{"version":3,"sources":["../../src/values/AbstractObjectValue.js"],"names":["t","AbstractObjectValue","constructor","realm","types","values","hashValue","args","buildNode","optionalArgs","isTop","element","getElements","getTemplate","isPartialObject","reportIntrospectionError","temporalAlias","temporalValue","hasStringOrSymbolProperties","isSimpleObject","cachedIsSimpleObject","undefined","_elementsAreSimpleObjects","result","mightBeFinalObject","mightNotBeFinalObject","mightBeFalse","mightNotBeFalse","makeNotPartial","makePartial","makeSimple","option","getType","obj","$Realm","intrinsics","ObjectPrototype","intrinsicName","intrinsicNameGenerated","_templateFor","getSnapshot","options","isIntrinsic","kind","c","l","r","ls","rs","absVal","createFromConditionalOp","expressionLocation","makeFinal","throwIfNotObject","usesOrdinaryObjectInternalPrototypeMethods","$GetPrototypeOf","error","currentLocation","handleError","elements","size","cv","cond","ob1","ob2","p1","p2","joinedObject","primitiveValue","isTypeCompatibleWith","createFromBuildFunction","p","preludeGenerator","getPrototypeOf","memoizeReference","isCompatibleWith","MOBILE_JSC_VERSION","memberExpression","callExpression","createFromBinaryOp","$IsExtensible","$GetOwnProperty","_P","P","value","d1","d2","desc","d1Value","d2Value","widenValues","hasProp","doesNotHaveProp","d","dval","$DefineOwnProperty","Desc","writable","enumerable","configurable","new_val","sawTrue","sawFalse","empty","$HasProperty","$Get","Receiver","generateAbstractGet","ob","type","createTemporalFromBuildFunction","o","skipInvariant","isPure","isInPureScope","evaluateWithPossibleThrowCompletion","topVal","$GetHelper","isIntrinsicAndHasWidenedNumericProperty","object","key","proto","d1val","d2val","cvVal","$GetPartial","$Set","V","$SetPartial","oldVal1","oldVal2","newVal1","newVal2","result1","result2","oldVal","v","generator","emitStatement","objectNode","valueNode","expressionStatement","assignmentExpression","keyNode","$Delete","$OwnPropertyKeys"],"mappings":";;;;;;AAWA;;AAGA;;AAWA;;AAEA;;AACA;;AAMA;;AAEA;;;;AACA;;IAAYA,C;;;;;;AArCZ;;;;;;;;;AAuCe,MAAMC,mBAAN,8BAAgD;AAC7DC,cACEC,KADF,EAEEC,KAFF,EAGEC,MAHF,EAIEC,SAJF,EAKEC,IALF,EAMEC,SANF,EAOEC,YAPF,EAQE;AACA,UAAMN,KAAN,EAAaC,KAAb,EAAoBC,MAApB,EAA4BC,SAA5B,EAAuCC,IAAvC,EAA6CC,SAA7C,EAAwDC,YAAxD;AACA,QAAI,CAACJ,OAAOK,KAAP,EAAL,EAAqB;AACnB,WAAK,IAAIC,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C,yBAAUD,qCAAV;AAChD;AACF;;AAKDE,gBAA2B;AACzB,SAAK,IAAIF,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACA,UAAIA,QAAQG,eAAR,EAAJ,EAA+B;AAC7B,eAAOH,OAAP;AACD,OAFD,MAEO;AACL;AACD;AACF;AACD,yBAAcI,wBAAd,CAAuC,IAAvC;AACA,UAAM,wBAAN;AACD;;AAED,MAAIC,aAAJ,CAAkBC,aAAlB,EAAsD;AACpD,QAAI,KAAKZ,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACD,SAAK,IAAIJ,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACAA,cAAQK,aAAR,GAAwBC,aAAxB;AACD;AACF;;AAEDC,gCAAuC;AACrC,QAAI,KAAKb,MAAL,CAAYK,KAAZ,EAAJ,EAAyB,OAAO,KAAP;AACzB,SAAK,IAAIC,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACA,UAAIA,QAAQO,2BAAR,EAAJ,EAA2C,OAAO,IAAP;AAC5C;AACD,WAAO,KAAP;AACD;;AAEDJ,oBAA2B;AACzB;AACA,WAAO,IAAP;AACD;;AAEDK,mBAA0B;AACxB,QAAI,KAAKC,oBAAL,KAA8BC,SAAlC,EAA6C,KAAKD,oBAAL,GAA4B,KAAKE,yBAAL,EAA5B;AAC7C,WAAO,KAAKF,oBAAZ;AACD;;AAEDE,8BAAqC;AACnC,QAAI,KAAKjB,MAAL,CAAYK,KAAZ,EAAJ,EAAyB,OAAO,KAAP;AACzB,QAAIa,MAAJ;AACA,SAAK,IAAIZ,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACA,UAAIY,WAAWF,SAAf,EAA0B;AACxBE,iBAASZ,QAAQQ,cAAR,EAAT;AACD,OAFD,MAEO,IAAII,WAAWZ,QAAQQ,cAAR,EAAf,EAAyC;AAC9C,6BAAcJ,wBAAd,CAAuC,IAAvC;AACA,cAAM,wBAAN;AACD;AACF;AACD,QAAIQ,WAAWF,SAAf,EAA0B;AACxB,2BAAcN,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACD,WAAOQ,MAAP;AACD;;AAEDC,uBAA8B;AAC5B,QAAI,KAAKnB,MAAL,CAAYK,KAAZ,EAAJ,EAAyB,OAAO,KAAP;AACzB,SAAK,IAAIC,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACA,UAAIA,QAAQa,kBAAR,EAAJ,EAAkC,OAAO,IAAP;AACnC;AACD,WAAO,KAAP;AACD;;AAEDC,0BAAiC;AAC/B,QAAI,KAAKpB,MAAL,CAAYK,KAAZ,EAAJ,EAAyB,OAAO,KAAP;AACzB,SAAK,IAAIC,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACA,UAAIA,QAAQc,qBAAR,EAAJ,EAAqC,OAAO,IAAP;AACtC;AACD,WAAO,KAAP;AACD;;AAEDC,iBAAwB;AACtB,WAAO,KAAP;AACD;;AAEDC,oBAA2B;AACzB,WAAO,IAAP;AACD;;AAEDC,mBAAuB;AACrB,QAAI,KAAKvB,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACD,SAAK,IAAIJ,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACAA,cAAQiB,cAAR;AACD;AACF;;AAEDC,gBAAoB;AAClB,QAAI,KAAKxB,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACD,SAAK,IAAIJ,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACAA,cAAQkB,WAAR;AACD;AACF;;AAEDC,aAAWC,MAAX,EAA0C;AACxC,QAAI,KAAK1B,MAAL,CAAYK,KAAZ,MAAuB,KAAKsB,OAAL,yBAA3B,EAA2D;AACzD,UAAIC,MAAM,uBAAgB,KAAKC,MAArB,EAA6B,KAAKA,MAAL,CAAYC,UAAZ,CAAuBC,eAApD,CAAV;AACAH,UAAII,aAAJ,GAAoB,KAAKA,aAAzB;AACAJ,UAAIK,sBAAJ,GAA6B,IAA7B;AACAL,UAAIJ,WAAJ;AACAI,UAAIM,YAAJ,GAAmB,IAAnB;AACA,WAAKlC,MAAL,GAAc,yBAAiB4B,GAAjB,CAAd;AACD;AACD,QAAI,CAAC,KAAK5B,MAAL,CAAYK,KAAZ,EAAL,EAA0B;AACxB,WAAK,IAAIC,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,iCAAUD,qCAAV;AACAA,gBAAQmB,UAAR,CAAmBC,MAAnB;AACD;AACF;AACD,SAAKX,oBAAL,GAA4B,IAA5B;AACD;;AAED;AACAoB,cAAYC,OAAZ,EAA0E;AACxE,QAAI,KAAKC,WAAL,EAAJ,EAAwB,OAAO,IAAP,CADgD,CACnC;AACrC,QAAI,KAAKrC,MAAL,CAAYK,KAAZ,EAAJ,EAAyB,OAAO,IAAP,CAF+C,CAElC;AACtC,QAAI,KAAKiC,IAAL,KAAc,aAAlB,EAAiC;AAC/B,UAAI,CAACC,CAAD,EAAIC,CAAJ,EAAOC,CAAP,IAAY,KAAKvC,IAArB;AACA,+BAAUsC,mCAA4BA,aAAa5C,mBAAnD;AACA,UAAI8C,KAAKF,EAAEL,WAAF,CAAcC,OAAd,CAAT;AACA,+BAAUK,mCAA4BA,aAAa7C,mBAAnD;AACA,UAAI+C,KAAKF,EAAEN,WAAF,CAAcC,OAAd,CAAT;AACA,+BAAUG,iCAAV;AACA,UAAIK,SAAS,qBAAcC,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmDU,CAAnD,EAAsDG,EAAtD,EAA0DC,EAA1D,EAA8D,KAAKG,kBAAnE,CAAb;AACA,+BAAUF,kBAAkBhD,mBAA5B;AACA,aAAOgD,MAAP;AACD;AACD;AACA,SAAKG,SAAL;AACA,WAAO,IAAP;AACD;;AAEDA,cAAkB;AAChB,QAAI,KAAK/C,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACD,SAAK,IAAIJ,OAAT,IAAoB,KAAKN,MAAL,CAAYO,WAAZ,EAApB,EAA+C;AAC7C,+BAAUD,qCAAV;AACAA,cAAQyC,SAAR;AACD;AACF;;AAEDC,qBAAwC;AACtC,WAAO,IAAP;AACD;;AAEDC,+CAAsD;AACpD,WAAO,IAAP;AACD;;AAED;AACAC,oBAAiE;AAC/D,QAAIpD,QAAQ,KAAK+B,MAAjB;AACA,QAAI,KAAK7B,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,UAAI8C,QAAQ,+BACV,oCADU,EAEV,KAAKtB,MAAL,CAAYuB,eAFF,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,WAAKvB,MAAL,CAAYwB,WAAZ,CAAwBF,KAAxB;AACA,YAAM,wBAAN;AACD;AACD,6BAAU,KAAKb,IAAL,KAAc,SAAxB,EAAmC,+CAAnC;AACA,QAAIgB,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGN,eAAH,EAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO,IAAI,KAAKZ,IAAL,KAAc,aAAlB,EAAiC;AACtC;AAEA,UAAI,CAACmB,IAAD,EAAOC,GAAP,EAAYC,GAAZ,IAAmB,KAAKzD,IAA5B;AACA,+BAAUuD,oCAAV;AACA,+BAAUC,qCAA8BA,eAAe9D,mBAAvD;AACA,+BAAU+D,qCAA8BA,eAAe/D,mBAAvD;AACA,UAAIgE,KAAKF,IAAIR,eAAJ,EAAT;AACA,UAAIW,KAAKF,IAAIT,eAAJ,EAAT;AACA,UAAIY,eAAe,qBAAcjB,uBAAd,CAAsC/C,KAAtC,EAA6C2D,IAA7C,EAAmDG,EAAnD,EAAuDC,EAAvD,CAAnB;AACA,+BAAUC,wBAAwBlE,mBAAlC;AACA,aAAOkE,YAAP;AACD,KAZM,MAYA,IAAI,KAAKxB,IAAL,KAAc,+BAAlB,EAAmD;AACxD,UAAIyB,iBAAiB,KAAK7D,IAAL,CAAU,CAAV,CAArB;AACA,+BAAU,CAAC,aAAM8D,oBAAN,CAA2BD,eAAepC,OAAf,EAA3B,wBAAX;AACA,UAAIT,SAAS,qBAAc+C,uBAAd,CAAsCnE,KAAtC,sBAA0D,CAACiE,cAAD,CAA1D,EAA4E,CAAC,CAACG,CAAD,CAAD,KAAS;AAChG,iCAAUpE,MAAMqE,gBAAN,KAA2BnD,SAArC;AACA,YAAIoD,iBAAiBtE,MAAMqE,gBAAN,CAAuBE,gBAAvB,CAAwC,uBAAxC,CAArB;AACA,eAAOvE,MAAMwE,gBAAN,CAAuBxE,MAAMyE,kBAA7B,KAAoDzE,MAAMwE,gBAAN,CAAuB,QAAvB,CAApD,GACH3E,EAAE6E,gBAAF,CAAmBN,CAAnB,gCADG,GAEHvE,EAAE8E,cAAF,CAAiBL,cAAjB,EAAiC,CAACF,CAAD,CAAjC,CAFJ;AAGD,OANY,CAAb;AAOA,+BAAUhD,kBAAkBtB,mBAA5B;AACA,aAAOsB,MAAP;AACD,KAZM,MAYA;AACL,UAAI4C,YAAJ;AACA,WAAK,IAAIN,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIU,IAAIV,GAAGN,eAAH,EAAR;AACA,YAAIY,iBAAiB9C,SAArB,EAAgC;AAC9B8C,yBAAeI,CAAf;AACD,SAFD,MAEO;AACL,cAAIT,OAAO,qBAAciB,kBAAd,CAAiC5E,KAAjC,EAAwC,KAAxC,EAA+C,IAA/C,EAAqD0D,EAArD,EAAyD,KAAKV,kBAA9D,CAAX;AACAgB,yBAAe,qBAAcjB,uBAAd,CAAsC/C,KAAtC,EAA6C2D,IAA7C,EAAmDS,CAAnD,EAAsDJ,YAAtD,CAAf;AACD;AACF;AACD,+BAAUA,wBAAwBlE,mBAAlC;AACA,aAAOkE,YAAP;AACD;AACF;;AAED;AACAa,kBAAyB;AACvB,WAAO,KAAP;AACD;;AAED;AACAC,kBAAgBC,EAAhB,EAAyD;AACvD,QAAIC,IAAID,EAAR;AACA,QAAIC,+BAAJ,EAA8BA,IAAIA,EAAEC,KAAN;;AAE9B,QAAI,KAAK/E,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,UAAI8C,QAAQ,+BACV,mCADU,EAEV,KAAKtB,MAAL,CAAYuB,eAFF,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,WAAKvB,MAAL,CAAYwB,WAAZ,CAAwBF,KAAxB;AACA,YAAM,wBAAN;AACD;;AAED,QAAIG,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGoB,eAAH,CAAmBE,CAAnB,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO,IAAI,KAAKxC,IAAL,KAAc,aAAlB,EAAiC;AACtC;AAEA,UAAI,CAACmB,IAAD,EAAOC,GAAP,EAAYC,GAAZ,IAAmB,KAAKzD,IAA5B;AACA,+BAAUuD,oCAAV;AACA,+BAAUC,qCAA8BA,eAAe9D,mBAAvD;AACA,+BAAU+D,qCAA8BA,eAAe/D,mBAAvD;AACA,UAAIoF,KAAKtB,IAAIkB,eAAJ,CAAoBE,CAApB,CAAT;AACA,UAAIG,KAAKtB,IAAIiB,eAAJ,CAAoBE,CAApB,CAAT;AACA,UAAIE,OAAOhE,SAAP,IAAoBiE,OAAOjE,SAA3B,IAAwC,CAAC,8BAAiBgE,EAAjB,EAAqBC,EAArB,CAA7C,EAAuE;AACrE,6BAAcvE,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,UAAII,OAAO,6BAAgBF,EAAhB,CAAX;AACA,+BAAUE,SAASlE,SAAnB;AACA,UAAI,8BAAiB,KAAKa,MAAtB,EAA8BqD,IAA9B,CAAJ,EAAyC;AACvC,YAAIC,UAAUH,GAAGD,KAAjB;AACA,iCAAUI,YAAYnE,SAAZ,IAAyBmE,+BAAnC;AACA,YAAIC,UAAUH,GAAGF,KAAjB;AACA,iCAAUK,YAAYpE,SAAZ,IAAyBoE,+BAAnC;AACAF,aAAKH,KAAL,GAAa,qBAAclC,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyD0B,OAAzD,EAAkEC,OAAlE,CAAb;AACD;AACD,aAAOF,IAAP;AACD,KAvBM,MAuBA,IAAI,KAAK5C,IAAL,KAAc,SAAlB,EAA6B;AAClC;AACA,UAAI,CAACoB,GAAD,EAAMC,GAAN,IAAa,KAAKzD,IAAtB,CAFkC,CAEN;AAC5B,+BAAUwD,iCAAV;AACA,+BAAUC,iCAAV;AACA,UAAIqB,KAAKtB,IAAIkB,eAAJ,CAAoBE,CAApB,CAAT;AACA,UAAIG,KAAKtB,IAAIiB,eAAJ,CAAoBE,CAApB,CAAT;AACA,UAAIE,OAAOhE,SAAP,IAAoBiE,OAAOjE,SAA3B,IAAwC,CAAC,8BAAiBgE,EAAjB,EAAqBC,EAArB,CAA7C,EAAuE;AACrE;AACA,6BAAcvE,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,UAAII,OAAO,6BAAgBF,EAAhB,CAAX;AACA,+BAAUE,SAASlE,SAAnB;AACA,UAAI,8BAAiB,KAAKa,MAAtB,EAA8BqD,IAA9B,CAAJ,EAAyC;AACvC;AACA;AACA,YAAIC,UAAUH,GAAGD,KAAjB;AACA,iCAAUI,+BAAV;AACA,YAAIC,UAAUH,GAAGF,KAAjB;AACA,iCAAUK,+BAAV;AACAF,aAAKH,KAAL,GAAa,kBAAMM,WAAN,CAAkB,KAAKxD,MAAvB,EAA+BsD,OAA/B,EAAwCC,OAAxC,CAAb;AACD,OARD,MAQO;AACL;AACA;AACD;AACD,aAAOF,IAAP;AACD,KA3BM,MA2BA;AACL,UAAII,UAAU,KAAd;AACA,UAAIC,kBAAkB,KAAtB;AACA,UAAIL,IAAJ;AACA,WAAK,IAAI1B,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIgC,IAAIhC,GAAGoB,eAAH,CAAmBE,CAAnB,CAAR;AACA,YAAIU,MAAMxE,SAAV,EAAqBuE,kBAAkB,IAAlB,CAArB,KACK;AACHD,oBAAU,IAAV;AACA,cAAIJ,SAASlE,SAAb,EAAwB;AACtBkE,mBAAO,6BAAgBM,CAAhB,CAAP;AACA,qCAAUN,SAASlE,SAAnB;AACA,gBAAI,CAAC,8BAAiB,KAAKa,MAAtB,EAA8B2D,CAA9B,CAAL,EAAuC;AACxC,WAJD,MAIO;AACL,gBAAI,CAAC,8BAAiBA,CAAjB,EAAoBN,IAApB,CAAL,EAAgC;AAC9B,mCAAcxE,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,oBAAM,wBAAN;AACD;AACD,gBAAI,CAAC,8BAAiB,KAAKjD,MAAtB,EAA8BqD,IAA9B,CAAL,EAA0C;AAC1C;AACA,gBAAIzB,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACA,gBAAI2C,OAAOD,EAAET,KAAb;AACA,qCAAUU,4BAAV;AACAP,iBAAKH,KAAL,GAAa,qBAAclC,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyDgC,IAAzD,EAA+DP,KAAKH,KAApE,CAAb;AACD;AACF;AACF;AACD,UAAIO,WAAWC,eAAf,EAAgC;AAC9B,6BAAc7E,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,aAAOI,IAAP;AACD;AACF;;AAED;AACAQ,qBAAmBb,EAAnB,EAAyCc,IAAzC,EAAoE;AAClE,QAAIb,IAAID,EAAR;AACA,QAAIC,+BAAJ,EAA8BA,IAAIA,EAAEC,KAAN;AAC9B,QAAI,KAAK/E,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,YAAM,wBAAN;AACD;;AAED,QAAIxB,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGkC,kBAAH,CAAsBZ,CAAtB,EAAyBa,IAAzB,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO;AACL,UAAI,CAAC,8BAAiB,KAAK9D,MAAtB,EAA8B8D,IAA9B,CAAL,EAA0C;AACxC,6BAAcjF,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,UAAII,OAAO;AACTH,eAAO,WAAWY,IAAX,GAAkBA,KAAKZ,KAAvB,GAA+B,KAAKlD,MAAL,CAAYC,UAAZ,CAAuBd,SADpD;AAET4E,kBAAU,cAAcD,IAAd,GAAqBA,KAAKC,QAA1B,GAAqC,KAFtC;AAGTC,oBAAY,gBAAgBF,IAAhB,GAAuBA,KAAKE,UAA5B,GAAyC,KAH5C;AAITC,sBAAc,kBAAkBH,IAAlB,GAAyBA,KAAKG,YAA9B,GAA6C;AAJlD,OAAX;AAMA,UAAIC,UAAUb,KAAKH,KAAnB;AACA,+BAAUgB,+BAAV;AACA,UAAIC,UAAU,KAAd;AACA,UAAIC,WAAW,KAAf;AACA,WAAK,IAAIzC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIgC,IAAIhC,GAAGoB,eAAH,CAAmBE,CAAnB,CAAR;AACA,YAAIU,MAAMxE,SAAN,IAAmB,CAAC,8BAAiBwE,CAAjB,EAAoBN,IAApB,CAAxB,EAAmD;AACjD,+BAAcxE,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,gBAAM,wBAAN;AACD;AACD,YAAIW,OAAOD,MAAMxE,SAAN,IAAmBwE,EAAET,KAAF,KAAY/D,SAA/B,GAA2C,KAAKa,MAAL,CAAYC,UAAZ,CAAuBoE,KAAlE,GAA0EV,EAAET,KAAvF;AACA,iCAAUU,4BAAV;AACA,YAAIhC,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACAoC,aAAKH,KAAL,GAAa,qBAAclC,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyDsC,OAAzD,EAAkEN,IAAlE,CAAb;AACA,YAAIjC,GAAGkC,kBAAH,CAAsBZ,CAAtB,EAAyBI,IAAzB,CAAJ,EAAoC;AAClCc,oBAAU,IAAV;AACD,SAFD,MAEOC,WAAW,IAAX;AACR;AACD,UAAID,WAAWC,QAAf,EAAyB;AACvB,6BAAcvF,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,aAAOkB,OAAP;AACD;AACF;;AAED;AACAG,eAAatB,EAAb,EAA4C;AAC1C,QAAIC,IAAID,EAAR;AACA,QAAIC,+BAAJ,EAA8BA,IAAIA,EAAEC,KAAN;AAC9B,QAAI,KAAK/E,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,UAAI8C,QAAQ,+BACV,mCADU,EAEV,KAAKtB,MAAL,CAAYuB,eAFF,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,WAAKvB,MAAL,CAAYwB,WAAZ,CAAwBF,KAAxB;AACA,YAAM,wBAAN;AACD;;AAED,QAAIG,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAG2C,YAAH,CAAgBrB,CAAhB,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO;AACL,UAAIQ,UAAU,KAAd;AACA,UAAIC,kBAAkB,KAAtB;AACA,WAAK,IAAI/B,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIA,GAAG2C,YAAH,CAAgBrB,CAAhB,CAAJ,EAAwBQ,UAAU,IAAV,CAAxB,KACKC,kBAAkB,IAAlB;AACN;AACD,UAAID,WAAWC,eAAf,EAAgC;AAC9B,6BAAc7E,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,aAAOQ,OAAP;AACD;AACF;;AAED;AACAc,OAAKvB,EAAL,EAA2BwB,QAA3B,EAAmD;AACjD,QAAIvB,IAAID,EAAR;AACA,QAAIC,+BAAJ,EAA8BA,IAAIA,EAAEC,KAAN;;AAE9B,QAAI,KAAK/E,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,UAAIiG,sBAAsB,MAAM;AAC9B,YAAIC,KAAK,IAAT;AACA,YAAI,KAAKjE,IAAL,KAAc,+BAAlB,EAAmDiE,KAAK,KAAKrG,IAAL,CAAU,CAAV,CAAL;AACnD,YAAIsG,mBAAJ;AACA,YAAI1B,MAAM,QAAN,IAAkB,aAAMd,oBAAN,CAA2B,KAAKrC,OAAL,EAA3B,oBAAtB,EAA8E6E;AAC9E,eAAO,qBAAcC,+BAAd,CACL,KAAK5E,MADA,EAEL2E,IAFK,EAGL,CAACD,EAAD,CAHK,EAIL,CAAC,CAACG,CAAD,CAAD,KAAS;AACP,mCAAU,OAAO5B,CAAP,KAAa,QAAvB;AACA,iBAAO,0CAAuB4B,CAAvB,EAA0B5B,CAA1B,CAAP;AACD,SAPI,EAQL;AACE6B,yBAAe,IADjB;AAEEC,kBAAQ;AAFV,SARK,CAAP;AAaD,OAlBD;AAmBA,UAAI,KAAK9F,cAAL,MAAyB,KAAKuB,WAAL,EAA7B,EAAiD;AAC/C,eAAOiE,qBAAP;AACD,OAFD,MAEO,IAAI,KAAKzE,MAAL,CAAYgF,aAAZ,EAAJ,EAAiC;AACtC;AACA,0BAAM9B,KAAN,CAAY,KAAKlD,MAAjB,EAAyB,IAAzB;AACA;AACA,eAAO,KAAKA,MAAL,CAAYiF,mCAAZ,CACLR,mBADK,EAEL,oBAAYS,MAFP,EAGL,qBAAaA,MAHR,CAAP;AAKD;AACD,UAAI5D,QAAQ,+BACV,mCADU,EAEV,KAAKtB,MAAL,CAAYuB,eAFF,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,WAAKvB,MAAL,CAAYwB,WAAZ,CAAwBF,KAAxB;AACA,YAAM,wBAAN;AACD;;AAED,QAAI6D,aAAaT,MAAM;AACrB,UAAIA,mCAA4B,kBAAWU,uCAAX,CAAmDV,EAAnD,CAA5B,IAAsF,OAAOzB,CAAP,KAAa,QAAvG,EAAiH;AAC/G,eAAO;AACLoC,kBAAQX,EADH;AAELY,eAAKrC,CAFA;AAGLC,iBAAO,oDAAuC,KAAKlD,MAA5C,EAAoD0E,EAApD,EAAwDzB,CAAxD;AAHF,SAAP;AAKD;AACD,UAAIU,IAAIe,GAAG3B,eAAH,CAAmBE,CAAnB,CAAR;AACA,UAAIU,MAAMxE,SAAV,EAAqB,OAAOwE,CAAP;AACrB,UAAI4B,QAAQb,GAAGrD,eAAH,EAAZ;AACA,aAAOkE,oCAA6BpG,SAA7B,GAAyCgG,WAAWI,KAAX,CAAhD;AACD,KAZD;;AAcA,QAAI9D,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAG4C,IAAH,CAAQtB,CAAR,EAAWuB,QAAX,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO,IAAI,KAAK/D,IAAL,KAAc,aAAlB,EAAiC;AACtC;AAEA,UAAI,CAACmB,IAAD,EAAOC,GAAP,EAAYC,GAAZ,IAAmB,KAAKzD,IAA5B;AACA,+BAAUuD,oCAAV;AACA,+BAAUC,qCAA8BA,eAAe9D,mBAAvD;AACA,+BAAU+D,qCAA8BA,eAAe/D,mBAAvD;AACA,UAAIoF,KAAKgC,WAAWtD,GAAX,CAAT;AACA,UAAI2D,QACFrC,OAAOhE,SAAP,GAAmB,KAAKa,MAAL,CAAYC,UAAZ,CAAuBd,SAA1C,GAAsD,8BAAiB,KAAKa,MAAtB,EAA8BmD,EAA9B,IAAoCA,GAAGD,KAAvC,GAA+C/D,SADvG;AAEA,UAAIiE,KAAK+B,WAAWrD,GAAX,CAAT;AACA,UAAI2D,QACFrC,OAAOjE,SAAP,GAAmB,KAAKa,MAAL,CAAYC,UAAZ,CAAuBd,SAA1C,GAAsD,8BAAiB,KAAKa,MAAtB,EAA8BoD,EAA9B,IAAoCA,GAAGF,KAAvC,GAA+C/D,SADvG;AAEA;AACA,UAAIqG,UAAUrG,SAAV,IAAuBsG,UAAUtG,SAArC,EAAgD;AAC9C,6BAAcN,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,+BAAUuC,6BAAV;AACA,+BAAUC,6BAAV;AACA,aAAO,qBAAczE,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyD4D,KAAzD,EAAgEC,KAAhE,CAAP;AACD,KArBM,MAqBA;AACL,UAAIpG,MAAJ;AACA,WAAK,IAAIsC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIgC,IAAIwB,WAAWxD,EAAX,CAAR;AACA;AACA,YAAIgC,MAAMxE,SAAN,IAAmB,CAAC,8BAAiB,KAAKa,MAAtB,EAA8B2D,CAA9B,CAAxB,EAA0D;AACxD,+BAAc9E,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,gBAAM,wBAAN;AACD;AACD,YAAIyC,QAAQ/B,MAAMxE,SAAN,GAAkB,KAAKa,MAAL,CAAYC,UAAZ,CAAuBd,SAAzC,GAAqDwE,EAAET,KAAnE;AACA,iCAAUwC,6BAAV;AACA,YAAIrG,WAAWF,SAAf,EAA0BE,SAASqG,KAAT,CAA1B,KACK;AACH,cAAI9D,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACA5B,mBAAS,qBAAc2B,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyD8D,KAAzD,EAAgErG,MAAhE,CAAT;AACD;AACF;AACD,+BAAUA,WAAWF,SAArB;AACA,aAAOE,MAAP;AACD;AACF;;AAEDsG,cAAY1C,CAAZ,EAAiDuB,QAAjD,EAAyE;AACvE,QAAI,EAAEvB,iCAAF,CAAJ,EAAmC,OAAO,KAAKsB,IAAL,CAAUtB,CAAV,EAAauB,QAAb,CAAP;AACnC,QAAI,KAAKrG,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,UAAI,KAAKS,cAAL,MAAyB,KAAKuB,WAAL,EAA7B,EAAiD;AAC/C,eAAO,qBAAcoE,+BAAd,CACL,KAAK5E,MADA,gBAGL,CAAC,IAAD,EAAOiD,CAAP,CAHK,EAIL,CAAC,CAAC4B,CAAD,EAAIxC,CAAJ,CAAD,KAAY,0CAAuBwC,CAAvB,EAA0BxC,CAA1B,CAJP,EAKL,EAAEyC,eAAe,IAAjB,EAAuBC,QAAQ,IAA/B,EALK,CAAP;AAOD;AACD,UAAI,KAAK/E,MAAL,CAAYgF,aAAZ,EAAJ,EAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAM9B,KAAN,CAAY,KAAKlD,MAAjB,EAAyBwE,QAAzB;AACA;AACA,0BAAMtB,KAAN,CAAY,KAAKlD,MAAjB,EAAyBiD,CAAzB;AACA,eAAO,qBAAc2B,+BAAd,CACL,KAAK5E,MADA,gBAGL,CAACwE,QAAD,EAAWvB,CAAX,CAHK,EAIL,CAAC,CAAC4B,CAAD,EAAIxC,CAAJ,CAAD,KAAY,0CAAuBwC,CAAvB,EAA0BxC,CAA1B,CAJP,EAKL,EAAEyC,eAAe,IAAjB,EAAuBC,QAAQ,IAA/B,EALK,CAAP;AAOD;AACD,UAAIzD,QAAQ,+BACV,mCADU,EAEV,KAAKtB,MAAL,CAAYuB,eAFF,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,WAAKvB,MAAL,CAAYwB,WAAZ,CAAwBF,KAAxB;AACA,YAAM,wBAAN;AACD;;AAED,QAAIG,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGgE,WAAH,CAAe1C,CAAf,EAAkBuB,aAAa,IAAb,GAAoB7C,EAApB,GAAyB6C,QAA3C,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO;AACL,UAAInF,MAAJ;AACA,WAAK,IAAIsC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAI+D,QAAQ/D,GAAGgE,WAAH,CAAe1C,CAAf,EAAkBuB,aAAa,IAAb,GAAoB7C,EAApB,GAAyB6C,QAA3C,CAAZ;AACA,YAAInF,WAAWF,SAAf,EAA0BE,SAASqG,KAAT,CAA1B,KACK;AACH,cAAI9D,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACA5B,mBAAS,qBAAc2B,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyD8D,KAAzD,EAAgErG,MAAhE,CAAT;AACD;AACF;AACD,+BAAUA,WAAWF,SAArB;AACA,aAAOE,MAAP;AACD;AACF;;AAED;AACAuG,OAAK3C,CAAL,EAA0B4C,CAA1B,EAAoCrB,QAApC,EAA8D;AAC5D,QAAI,KAAKrG,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,aAAO,KAAKsH,WAAL,CAAiB7C,CAAjB,EAAoB4C,CAApB,EAAuBrB,QAAvB,CAAP;AACD;;AAED,QAAI/C,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGiE,IAAH,CAAQ3C,CAAR,EAAW4C,CAAX,EAAcrB,aAAa,IAAb,GAAoB7C,EAApB,GAAyB6C,QAAvC,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO,IAAI,KAAK/D,IAAL,KAAc,aAAlB,EAAiC;AACtC;AAEA,UAAI,CAACmB,IAAD,EAAOC,GAAP,EAAYC,GAAZ,IAAmB,KAAKzD,IAA5B;AACA,+BAAUuD,oCAAV;AACA,+BAAUC,qCAA8BA,eAAe9D,mBAAvD;AACA,+BAAU+D,qCAA8BA,eAAe/D,mBAAvD;AACA,UAAIoF,KAAKtB,IAAIkB,eAAJ,CAAoBE,CAApB,CAAT;AACA,UAAIG,KAAKtB,IAAIiB,eAAJ,CAAoBE,CAApB,CAAT;AACA,UAAI8C,UACF5C,OAAOhE,SAAP,GAAmB,KAAKa,MAAL,CAAYC,UAAZ,CAAuBoE,KAA1C,GAAkD,8BAAiB,KAAKrE,MAAtB,EAA8BmD,EAA9B,IAAoCA,GAAGD,KAAvC,GAA+C/D,SADnG;AAEA,UAAI6G,UACF5C,OAAOjE,SAAP,GAAmB,KAAKa,MAAL,CAAYC,UAAZ,CAAuBoE,KAA1C,GAAkD,8BAAiB,KAAKrE,MAAtB,EAA8BoD,EAA9B,IAAoCA,GAAGF,KAAvC,GAA+C/D,SADnG;AAEA,UAAI4G,YAAY5G,SAAZ,IAAyB6G,YAAY7G,SAAzC,EAAoD;AAClD,6BAAcN,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,+BAAU8C,+BAAV;AACA,+BAAUC,+BAAV;AACA,UAAIC,UAAU,qBAAcjF,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyDiE,CAAzD,EAA4DE,OAA5D,CAAd;AACA,UAAIG,UAAU,qBAAclF,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyDoE,OAAzD,EAAkEH,CAAlE,CAAd;AACA,UAAIM,UAAUtE,IAAI+D,IAAJ,CAAS3C,CAAT,EAAYgD,OAAZ,EAAqBpE,GAArB,CAAd;AACA,UAAIuE,UAAUtE,IAAI8D,IAAJ,CAAS3C,CAAT,EAAYiD,OAAZ,EAAqBpE,GAArB,CAAd;AACA,UAAIqE,YAAYC,OAAhB,EAAyB;AACvB,6BAAcvH,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,aAAOkD,OAAP;AACD,KA5BM,MA4BA;AACL,UAAIhC,UAAU,KAAd;AACA,UAAIC,WAAW,KAAf;AACA,WAAK,IAAIzC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIgC,IAAIhC,GAAGoB,eAAH,CAAmBE,CAAnB,CAAR;AACA,YAAIU,MAAMxE,SAAN,IAAmB,CAAC,8BAAiB,KAAKa,MAAtB,EAA8B2D,CAA9B,CAAxB,EAA0D;AACxD,+BAAc9E,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,gBAAM,wBAAN;AACD;AACD,YAAIoD,SAAS1C,MAAMxE,SAAN,GAAkB,KAAKa,MAAL,CAAYC,UAAZ,CAAuBoE,KAAzC,GAAiDV,EAAET,KAAhE;AACA,iCAAUmD,8BAAV;AACA,YAAIzE,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACA,YAAIqF,IAAI,qBAActF,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyDiE,CAAzD,EAA4DQ,MAA5D,CAAR;AACA,YAAI1E,GAAGiE,IAAH,CAAQ3C,CAAR,EAAWqD,CAAX,EAAc3E,EAAd,CAAJ,EAAuBwC,UAAU,IAAV,CAAvB,KACKC,WAAW,IAAX;AACN;AACD,UAAID,WAAWC,QAAf,EAAyB;AACvB,6BAAcvF,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,aAAOkB,OAAP;AACD;AACF;;AAED2B,cAAY9C,EAAZ,EAAkD6C,CAAlD,EAA4DrB,QAA5D,EAAsF;AACpF,QAAIvB,IAAID,EAAR;AACA,QAAI,KAAK7E,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,UAAI,KAAKwB,MAAL,CAAYgF,aAAZ,EAAJ,EAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAM9B,KAAN,CAAY,KAAKlD,MAAjB,EAAyBwE,QAAzB;AACA;AACA,0BAAMtB,KAAN,CAAY,KAAKlD,MAAjB,EAAyB6F,CAAzB;AACA,aAAK7F,MAAL,CAAYiF,mCAAZ,CACE,MAAM;AACJ,cAAIsB,YAAY,KAAKvG,MAAL,CAAYuG,SAA5B;AACA,mCAAUA,SAAV;;AAEA,cAAItD,+BAAJ,EAA8B;AAC5BA,gBAAIA,EAAEC,KAAN;AACD;AACD,cAAI,OAAOD,CAAP,KAAa,QAAjB,EAA2B;AACzBsD,sBAAUC,aAAV,CAAwB,CAAChC,QAAD,EAAWqB,CAAX,CAAxB,EAAuC,CAAC,CAACY,UAAD,EAAaC,SAAb,CAAD,KAA6B;AAClE,uCAAU,OAAOzD,CAAP,KAAa,QAAvB;AACA,qBAAOnF,EAAE6I,mBAAF,CACL7I,EAAE8I,oBAAF,CAAuB,GAAvB,EAA4B,0CAAuBH,UAAvB,EAAmCxD,CAAnC,CAA5B,EAAmEyD,SAAnE,CADK,CAAP;AAGD,aALD;AAMD,WAPD,MAOO;AACL;AACA,8BAAMxD,KAAN,CAAY,KAAKlD,MAAjB,EAAyBiD,CAAzB;AACAsD,sBAAUC,aAAV,CAAwB,CAAChC,QAAD,EAAWvB,CAAX,EAAc4C,CAAd,CAAxB,EAA0C,CAAC,CAACY,UAAD,EAAaI,OAAb,EAAsBH,SAAtB,CAAD,KACxC5I,EAAE6I,mBAAF,CACE7I,EAAE8I,oBAAF,CAAuB,GAAvB,EAA4B,0CAAuBH,UAAvB,EAAmCI,OAAnC,CAA5B,EAAyEH,SAAzE,CADF,CADF;AAKD;AACD,iBAAO,KAAK1G,MAAL,CAAYC,UAAZ,CAAuBd,SAA9B;AACD,SAzBH,EA0BE,oBAAY+F,MA1Bd,EA2BE,qBAAaA,MA3Bf;AA6BA;AACA;AACA;AACA;AACA,eAAO,IAAP;AACD;AACD,UAAI5D,QAAQ,+BACV,mCADU,EAEV,KAAKtB,MAAL,CAAYuB,eAFF,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,WAAKvB,MAAL,CAAYwB,WAAZ,CAAwBF,KAAxB;AACA,YAAM,wBAAN;AACD;;AAED,QAAI,EAAE2B,iCAAF,CAAJ,EAAmC,OAAO,KAAK2C,IAAL,CAAU3C,CAAV,EAAa4C,CAAb,EAAgBrB,QAAhB,CAAP;;AAEnC,QAAI/C,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGmE,WAAH,CAAe7C,CAAf,EAAkB4C,CAAlB,EAAqBrB,aAAa,IAAb,GAAoB7C,EAApB,GAAyB6C,QAA9C,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO;AACL,WAAK,IAAI7C,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAI0E,SAAS,KAAKV,WAAL,CAAiB1C,CAAjB,EAAoBuB,aAAa,IAAb,GAAoB7C,EAApB,GAAyB6C,QAA7C,CAAb;AACA,YAAI5C,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACA,YAAIqF,IAAI,qBAActF,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyDiE,CAAzD,EAA4DQ,MAA5D,CAAR;AACA1E,WAAGmE,WAAH,CAAe7C,CAAf,EAAkBqD,CAAlB,EAAqB9B,aAAa,IAAb,GAAoB7C,EAApB,GAAyB6C,QAA9C;AACD;AACD,aAAO,IAAP;AACD;AACF;;AAED;AACAsC,UAAQ9D,EAAR,EAAuC;AACrC,QAAIC,IAAID,EAAR;AACA,QAAIC,+BAAJ,EAA8BA,IAAIA,EAAEC,KAAN;AAC9B,QAAI,KAAK/E,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,YAAM,wBAAN;AACD;;AAED,QAAIxB,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGmF,OAAH,CAAW7D,CAAX,CAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO;AACL,UAAIkB,UAAU,KAAd;AACA,UAAIC,WAAW,KAAf;AACA,WAAK,IAAIzC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,YAAIgC,IAAIhC,GAAGoB,eAAH,CAAmBE,CAAnB,CAAR;AACA,YAAIU,MAAMxE,SAAV,EAAqB;AACrB,YAAI,CAAC,8BAAiB,KAAKa,MAAtB,EAA8B2D,CAA9B,CAAL,EAAuC;AACrC,+BAAc9E,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,gBAAM,wBAAN;AACD;AACD,YAAIrB,OAAO,qBAAciB,kBAAd,CAAiC,KAAK7C,MAAtC,EAA8C,KAA9C,EAAqD,IAArD,EAA2D2B,EAA3D,EAA+D,KAAKV,kBAApE,CAAX;AACA,YAAI2C,OAAOD,EAAET,KAAb;AACA,iCAAUU,4BAAV;AACA,YAAI0C,IAAI,qBAActF,uBAAd,CAAsC,KAAKhB,MAA3C,EAAmD4B,IAAnD,EAAyD,KAAK5B,MAAL,CAAYC,UAAZ,CAAuBoE,KAAhF,EAAuFT,IAAvF,CAAR;AACA,YAAIjC,GAAGiE,IAAH,CAAQ3C,CAAR,EAAWqD,CAAX,EAAc3E,EAAd,CAAJ,EAAuBwC,UAAU,IAAV,CAAvB,KACKC,WAAW,IAAX;AACN;AACD,UAAID,WAAWC,QAAf,EAAyB;AACvB,6BAAcvF,wBAAd,CAAuC,IAAvC,EAA6CoE,CAA7C;AACA,cAAM,wBAAN;AACD;AACD,aAAOkB,OAAP;AACD;AACF;;AAED4C,qBAA4C;AAC1C,QAAI,KAAK5I,MAAL,CAAYK,KAAZ,EAAJ,EAAyB;AACvB,2BAAcK,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACD,QAAI4C,WAAW,KAAKtD,MAAL,CAAYO,WAAZ,EAAf;AACA,QAAI+C,SAASC,IAAT,KAAkB,CAAtB,EAAyB;AACvB,WAAK,IAAIC,EAAT,IAAeF,QAAf,EAAyB;AACvB,iCAAUE,gCAAV;AACA,eAAOA,GAAGoF,gBAAH,EAAP;AACD;AACD,+BAAU,KAAV;AACD,KAND,MAMO;AACL,2BAAclI,wBAAd,CAAuC,IAAvC;AACA,YAAM,wBAAN;AACD;AACF;AAp0B4D;kBAA1Cd,mB","file":"AbstractObjectValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractValue,\n  type AbstractValueKind,\n  ArrayValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  Value,\n} from \"./index.js\";\nimport { protoExpression, memberExpressionHelper } from \"../utils/babelhelpers.js\";\nimport type { AbstractValueBuildNodeFunction } from \"./AbstractValue.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport {\n  GetFromArrayWithWidenedNumericProperty,\n  IsDataDescriptor,\n  cloneDescriptor,\n  equalDescriptors,\n} from \"../methods/index.js\";\nimport { Havoc, Widen } from \"../singletons.js\";\nimport type { BabelNodeExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\nexport default class AbstractObjectValue extends AbstractValue {\n  constructor(\n    realm: Realm,\n    types: TypesDomain,\n    values: ValuesDomain,\n    hashValue: number,\n    args: Array<Value>,\n    buildNode?: AbstractValueBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| kind?: AbstractValueKind, intrinsicName?: string |}\n  ) {\n    super(realm, types, values, hashValue, args, buildNode, optionalArgs);\n    if (!values.isTop()) {\n      for (let element of this.values.getElements()) invariant(element instanceof ObjectValue);\n    }\n  }\n\n  cachedIsSimpleObject: void | boolean;\n  functionResultType: void | typeof Value;\n\n  getTemplate(): ObjectValue {\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.isPartialObject()) {\n        return element;\n      } else {\n        break;\n      }\n    }\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  set temporalAlias(temporalValue: AbstractObjectValue) {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.temporalAlias = temporalValue;\n    }\n  }\n\n  hasStringOrSymbolProperties(): boolean {\n    if (this.values.isTop()) return false;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.hasStringOrSymbolProperties()) return true;\n    }\n    return false;\n  }\n\n  isPartialObject(): boolean {\n    // At the very least, the identity of the object is unknown\n    return true;\n  }\n\n  isSimpleObject(): boolean {\n    if (this.cachedIsSimpleObject === undefined) this.cachedIsSimpleObject = this._elementsAreSimpleObjects();\n    return this.cachedIsSimpleObject;\n  }\n\n  _elementsAreSimpleObjects(): boolean {\n    if (this.values.isTop()) return false;\n    let result;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (result === undefined) {\n        result = element.isSimpleObject();\n      } else if (result !== element.isSimpleObject()) {\n        AbstractValue.reportIntrospectionError(this);\n        throw new FatalError();\n      }\n    }\n    if (result === undefined) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    return result;\n  }\n\n  mightBeFinalObject(): boolean {\n    if (this.values.isTop()) return false;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.mightBeFinalObject()) return true;\n    }\n    return false;\n  }\n\n  mightNotBeFinalObject(): boolean {\n    if (this.values.isTop()) return false;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.mightNotBeFinalObject()) return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    return false;\n  }\n\n  mightNotBeFalse(): boolean {\n    return true;\n  }\n\n  makeNotPartial(): void {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.makeNotPartial();\n    }\n  }\n\n  makePartial(): void {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.makePartial();\n    }\n  }\n\n  makeSimple(option?: string | Value): void {\n    if (this.values.isTop() && this.getType() === ObjectValue) {\n      let obj = new ObjectValue(this.$Realm, this.$Realm.intrinsics.ObjectPrototype);\n      obj.intrinsicName = this.intrinsicName;\n      obj.intrinsicNameGenerated = true;\n      obj.makePartial();\n      obj._templateFor = this;\n      this.values = new ValuesDomain(obj);\n    }\n    if (!this.values.isTop()) {\n      for (let element of this.values.getElements()) {\n        invariant(element instanceof ObjectValue);\n        element.makeSimple(option);\n      }\n    }\n    this.cachedIsSimpleObject = true;\n  }\n\n  // Use this only if it is known that only the string properties of the snapshot will be accessed.\n  getSnapshot(options?: { removeProperties: boolean }): AbstractObjectValue {\n    if (this.isIntrinsic()) return this; // already temporal\n    if (this.values.isTop()) return this; // always the same\n    if (this.kind === \"conditional\") {\n      let [c, l, r] = this.args;\n      invariant(l instanceof ObjectValue || l instanceof AbstractObjectValue);\n      let ls = l.getSnapshot(options);\n      invariant(r instanceof ObjectValue || r instanceof AbstractObjectValue);\n      let rs = r.getSnapshot(options);\n      invariant(c instanceof AbstractValue);\n      let absVal = AbstractValue.createFromConditionalOp(this.$Realm, c, ls, rs, this.expressionLocation);\n      invariant(absVal instanceof AbstractObjectValue);\n      return absVal;\n    }\n    // If this is some other kind of abstract object we don't know how to make a copy, so just make this final\n    this.makeFinal();\n    return this;\n  }\n\n  makeFinal(): void {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.makeFinal();\n    }\n  }\n\n  throwIfNotObject(): AbstractObjectValue {\n    return this;\n  }\n\n  usesOrdinaryObjectInternalPrototypeMethods(): boolean {\n    return true;\n  }\n\n  // ECMA262 9.1.1\n  $GetPrototypeOf(): ObjectValue | AbstractObjectValue | NullValue {\n    let realm = this.$Realm;\n    if (this.values.isTop()) {\n      let error = new CompilerDiagnostic(\n        \"prototype access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0032\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n    invariant(this.kind !== \"widened\", \"widening currently always leads to top values\");\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$GetPrototypeOf();\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let p1 = ob1.$GetPrototypeOf();\n      let p2 = ob2.$GetPrototypeOf();\n      let joinedObject = AbstractValue.createFromConditionalOp(realm, cond, p1, p2);\n      invariant(joinedObject instanceof AbstractObjectValue);\n      return joinedObject;\n    } else if (this.kind === \"explicit conversion to object\") {\n      let primitiveValue = this.args[0];\n      invariant(!Value.isTypeCompatibleWith(primitiveValue.getType(), PrimitiveValue));\n      let result = AbstractValue.createFromBuildFunction(realm, ObjectValue, [primitiveValue], ([p]) => {\n        invariant(realm.preludeGenerator !== undefined);\n        let getPrototypeOf = realm.preludeGenerator.memoizeReference(\"Object.getPrototypeOf\");\n        return realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) || realm.isCompatibleWith(\"mobile\")\n          ? t.memberExpression(p, protoExpression)\n          : t.callExpression(getPrototypeOf, [p]);\n      });\n      invariant(result instanceof AbstractObjectValue);\n      return result;\n    } else {\n      let joinedObject;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let p = cv.$GetPrototypeOf();\n        if (joinedObject === undefined) {\n          joinedObject = p;\n        } else {\n          let cond = AbstractValue.createFromBinaryOp(realm, \"===\", this, cv, this.expressionLocation);\n          joinedObject = AbstractValue.createFromConditionalOp(realm, cond, p, joinedObject);\n        }\n      }\n      invariant(joinedObject instanceof AbstractObjectValue);\n      return joinedObject;\n    }\n  }\n\n  // ECMA262 9.1.3\n  $IsExtensible(): boolean {\n    return false;\n  }\n\n  // ECMA262 9.1.5\n  $GetOwnProperty(_P: PropertyKeyValue): Descriptor | void {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n\n    if (this.values.isTop()) {\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$GetOwnProperty(P);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let d1 = ob1.$GetOwnProperty(P);\n      let d2 = ob2.$GetOwnProperty(P);\n      if (d1 === undefined || d2 === undefined || !equalDescriptors(d1, d2)) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      let desc = cloneDescriptor(d1);\n      invariant(desc !== undefined);\n      if (IsDataDescriptor(this.$Realm, desc)) {\n        let d1Value = d1.value;\n        invariant(d1Value === undefined || d1Value instanceof Value);\n        let d2Value = d2.value;\n        invariant(d2Value === undefined || d2Value instanceof Value);\n        desc.value = AbstractValue.createFromConditionalOp(this.$Realm, cond, d1Value, d2Value);\n      }\n      return desc;\n    } else if (this.kind === \"widened\") {\n      // This abstract object was created by repeated assignments of freshly allocated objects to the same binding inside a loop\n      let [ob1, ob2] = this.args; // ob1: summary of iterations 1...n, ob2: summary of iteration n+1\n      invariant(ob1 instanceof ObjectValue);\n      invariant(ob2 instanceof ObjectValue);\n      let d1 = ob1.$GetOwnProperty(P);\n      let d2 = ob2.$GetOwnProperty(P);\n      if (d1 === undefined || d2 === undefined || !equalDescriptors(d1, d2)) {\n        // We do not handle the case where different loop iterations result in different kinds of propperties\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      let desc = cloneDescriptor(d1);\n      invariant(desc !== undefined);\n      if (IsDataDescriptor(this.$Realm, desc)) {\n        // Values may be different, i.e. values may be loop variant, so the widened value summarizes the entire loop\n        // equalDescriptors guarantees that both have value props and if you have a value prop is value is defined.\n        let d1Value = d1.value;\n        invariant(d1Value instanceof Value);\n        let d2Value = d2.value;\n        invariant(d2Value instanceof Value);\n        desc.value = Widen.widenValues(this.$Realm, d1Value, d2Value);\n      } else {\n        // In this case equalDescriptors guarantees exact equality betwee d1 and d2.\n        // Inlining the accessors will eventually bring in data properties if the accessors have loop variant behavior\n      }\n      return desc;\n    } else {\n      let hasProp = false;\n      let doesNotHaveProp = false;\n      let desc;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let d = cv.$GetOwnProperty(P);\n        if (d === undefined) doesNotHaveProp = true;\n        else {\n          hasProp = true;\n          if (desc === undefined) {\n            desc = cloneDescriptor(d);\n            invariant(desc !== undefined);\n            if (!IsDataDescriptor(this.$Realm, d)) continue;\n          } else {\n            if (!equalDescriptors(d, desc)) {\n              AbstractValue.reportIntrospectionError(this, P);\n              throw new FatalError();\n            }\n            if (!IsDataDescriptor(this.$Realm, desc)) continue;\n            // values may be different\n            let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n            let dval = d.value;\n            invariant(dval instanceof Value);\n            desc.value = AbstractValue.createFromConditionalOp(this.$Realm, cond, dval, desc.value);\n          }\n        }\n      }\n      if (hasProp && doesNotHaveProp) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return desc;\n    }\n  }\n\n  // ECMA262 9.1.6\n  $DefineOwnProperty(_P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this, P);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$DefineOwnProperty(P, Desc);\n      }\n      invariant(false);\n    } else {\n      if (!IsDataDescriptor(this.$Realm, Desc)) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      let desc = {\n        value: \"value\" in Desc ? Desc.value : this.$Realm.intrinsics.undefined,\n        writable: \"writable\" in Desc ? Desc.writable : false,\n        enumerable: \"enumerable\" in Desc ? Desc.enumerable : false,\n        configurable: \"configurable\" in Desc ? Desc.configurable : false,\n      };\n      let new_val = desc.value;\n      invariant(new_val instanceof Value);\n      let sawTrue = false;\n      let sawFalse = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let d = cv.$GetOwnProperty(P);\n        if (d !== undefined && !equalDescriptors(d, desc)) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        let dval = d === undefined || d.value === undefined ? this.$Realm.intrinsics.empty : d.value;\n        invariant(dval instanceof Value);\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        desc.value = AbstractValue.createFromConditionalOp(this.$Realm, cond, new_val, dval);\n        if (cv.$DefineOwnProperty(P, desc)) {\n          sawTrue = true;\n        } else sawFalse = true;\n      }\n      if (sawTrue && sawFalse) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return sawTrue;\n    }\n  }\n\n  // ECMA262 9.1.7\n  $HasProperty(_P: PropertyKeyValue): boolean {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n    if (this.values.isTop()) {\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$HasProperty(P);\n      }\n      invariant(false);\n    } else {\n      let hasProp = false;\n      let doesNotHaveProp = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        if (cv.$HasProperty(P)) hasProp = true;\n        else doesNotHaveProp = true;\n      }\n      if (hasProp && doesNotHaveProp) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return hasProp;\n    }\n  }\n\n  // ECMA262 9.1.8\n  $Get(_P: PropertyKeyValue, Receiver: Value): Value {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n\n    if (this.values.isTop()) {\n      let generateAbstractGet = () => {\n        let ob = this;\n        if (this.kind === \"explicit conversion to object\") ob = this.args[0];\n        let type = Value;\n        if (P === \"length\" && Value.isTypeCompatibleWith(this.getType(), ArrayValue)) type = NumberValue;\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          type,\n          [ob],\n          ([o]) => {\n            invariant(typeof P === \"string\");\n            return memberExpressionHelper(o, P);\n          },\n          {\n            skipInvariant: true,\n            isPure: true,\n          }\n        );\n      };\n      if (this.isSimpleObject() && this.isIntrinsic()) {\n        return generateAbstractGet();\n      } else if (this.$Realm.isInPureScope()) {\n        // This object might have leaked to a getter.\n        Havoc.value(this.$Realm, this);\n        // The getter might throw anything.\n        return this.$Realm.evaluateWithPossibleThrowCompletion(\n          generateAbstractGet,\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n      }\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let $GetHelper = ob => {\n      if (ob instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(ob) && typeof P === \"string\") {\n        return {\n          object: ob,\n          key: P,\n          value: GetFromArrayWithWidenedNumericProperty(this.$Realm, ob, P),\n        };\n      }\n      let d = ob.$GetOwnProperty(P);\n      if (d !== undefined) return d;\n      let proto = ob.$GetPrototypeOf();\n      return proto instanceof NullValue ? undefined : $GetHelper(proto);\n    };\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$Get(P, Receiver);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let d1 = $GetHelper(ob1);\n      let d1val =\n        d1 === undefined ? this.$Realm.intrinsics.undefined : IsDataDescriptor(this.$Realm, d1) ? d1.value : undefined;\n      let d2 = $GetHelper(ob2);\n      let d2val =\n        d2 === undefined ? this.$Realm.intrinsics.undefined : IsDataDescriptor(this.$Realm, d2) ? d2.value : undefined;\n      // We do not currently join property getters\n      if (d1val === undefined || d2val === undefined) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      invariant(d1val instanceof Value);\n      invariant(d2val instanceof Value);\n      return AbstractValue.createFromConditionalOp(this.$Realm, cond, d1val, d2val);\n    } else {\n      let result;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let d = $GetHelper(cv);\n        // We do not currently join property getters\n        if (d !== undefined && !IsDataDescriptor(this.$Realm, d)) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        let cvVal = d === undefined ? this.$Realm.intrinsics.undefined : d.value;\n        invariant(cvVal instanceof Value);\n        if (result === undefined) result = cvVal;\n        else {\n          let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n          result = AbstractValue.createFromConditionalOp(this.$Realm, cond, cvVal, result);\n        }\n      }\n      invariant(result !== undefined);\n      return result;\n    }\n  }\n\n  $GetPartial(P: AbstractValue | PropertyKeyValue, Receiver: Value): Value {\n    if (!(P instanceof AbstractValue)) return this.$Get(P, Receiver);\n    if (this.values.isTop()) {\n      if (this.isSimpleObject() && this.isIntrinsic()) {\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          Value,\n          [this, P],\n          ([o, p]) => memberExpressionHelper(o, p),\n          { skipInvariant: true, isPure: true }\n        );\n      }\n      if (this.$Realm.isInPureScope()) {\n        // If we're in a pure scope, we can havoc the key and the instance,\n        // and leave the residual property access in place.\n        // We assume that if the receiver is different than this object,\n        // then we only got here because there can be no other keys with\n        // this name on earlier parts of the prototype chain.\n        // We have to havoc since the property may be a getter or setter,\n        // which can run unknown code that has access to Receiver and\n        // (even in pure mode) can modify it in unknown ways.\n        Havoc.value(this.$Realm, Receiver);\n        // Coercion can only have effects on anything reachable from the key.\n        Havoc.value(this.$Realm, P);\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          Value,\n          [Receiver, P],\n          ([o, p]) => memberExpressionHelper(o, p),\n          { skipInvariant: true, isPure: true }\n        );\n      }\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$GetPartial(P, Receiver === this ? cv : Receiver);\n      }\n      invariant(false);\n    } else {\n      let result;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let cvVal = cv.$GetPartial(P, Receiver === this ? cv : Receiver);\n        if (result === undefined) result = cvVal;\n        else {\n          let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n          result = AbstractValue.createFromConditionalOp(this.$Realm, cond, cvVal, result);\n        }\n      }\n      invariant(result !== undefined);\n      return result;\n    }\n  }\n\n  // ECMA262 9.1.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    if (this.values.isTop()) {\n      return this.$SetPartial(P, V, Receiver);\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$Set(P, V, Receiver === this ? cv : Receiver);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let d1 = ob1.$GetOwnProperty(P);\n      let d2 = ob2.$GetOwnProperty(P);\n      let oldVal1 =\n        d1 === undefined ? this.$Realm.intrinsics.empty : IsDataDescriptor(this.$Realm, d1) ? d1.value : undefined;\n      let oldVal2 =\n        d2 === undefined ? this.$Realm.intrinsics.empty : IsDataDescriptor(this.$Realm, d2) ? d2.value : undefined;\n      if (oldVal1 === undefined || oldVal2 === undefined) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      invariant(oldVal1 instanceof Value);\n      invariant(oldVal2 instanceof Value);\n      let newVal1 = AbstractValue.createFromConditionalOp(this.$Realm, cond, V, oldVal1);\n      let newVal2 = AbstractValue.createFromConditionalOp(this.$Realm, cond, oldVal2, V);\n      let result1 = ob1.$Set(P, newVal1, ob1);\n      let result2 = ob2.$Set(P, newVal2, ob2);\n      if (result1 !== result2) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return result1;\n    } else {\n      let sawTrue = false;\n      let sawFalse = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let d = cv.$GetOwnProperty(P);\n        if (d !== undefined && !IsDataDescriptor(this.$Realm, d)) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        let oldVal = d === undefined ? this.$Realm.intrinsics.empty : d.value;\n        invariant(oldVal instanceof Value);\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        let v = AbstractValue.createFromConditionalOp(this.$Realm, cond, V, oldVal);\n        if (cv.$Set(P, v, cv)) sawTrue = true;\n        else sawFalse = true;\n      }\n      if (sawTrue && sawFalse) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return sawTrue;\n    }\n  }\n\n  $SetPartial(_P: AbstractValue | PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let P = _P;\n    if (this.values.isTop()) {\n      if (this.$Realm.isInPureScope()) {\n        // If we're in a pure scope, we can havoc the key and the instance,\n        // and leave the residual property assignment in place.\n        // We assume that if the receiver is different than this object,\n        // then we only got here because there can be no other keys with\n        // this name on earlier parts of the prototype chain.\n        // We have to havoc since the property may be a getter or setter,\n        // which can run unknown code that has access to Receiver and\n        // (even in pure mode) can modify it in unknown ways.\n        Havoc.value(this.$Realm, Receiver);\n        // We also need to havoc the value since it might leak to a setter.\n        Havoc.value(this.$Realm, V);\n        this.$Realm.evaluateWithPossibleThrowCompletion(\n          () => {\n            let generator = this.$Realm.generator;\n            invariant(generator);\n\n            if (P instanceof StringValue) {\n              P = P.value;\n            }\n            if (typeof P === \"string\") {\n              generator.emitStatement([Receiver, V], ([objectNode, valueNode]) => {\n                invariant(typeof P === \"string\");\n                return t.expressionStatement(\n                  t.assignmentExpression(\"=\", memberExpressionHelper(objectNode, P), valueNode)\n                );\n              });\n            } else {\n              // Coercion can only have effects on anything reachable from the key.\n              Havoc.value(this.$Realm, P);\n              generator.emitStatement([Receiver, P, V], ([objectNode, keyNode, valueNode]) =>\n                t.expressionStatement(\n                  t.assignmentExpression(\"=\", memberExpressionHelper(objectNode, keyNode), valueNode)\n                )\n              );\n            }\n            return this.$Realm.intrinsics.undefined;\n          },\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n        // The emitted assignment might throw at runtime but if it does, that\n        // is handled by evaluateWithPossibleThrowCompletion. Anything that\n        // happens after this, can assume we didn't throw and therefore,\n        // we return true here.\n        return true;\n      }\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    if (!(P instanceof AbstractValue)) return this.$Set(P, V, Receiver);\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$SetPartial(P, V, Receiver === this ? cv : Receiver);\n      }\n      invariant(false);\n    } else {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let oldVal = this.$GetPartial(P, Receiver === this ? cv : Receiver);\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        let v = AbstractValue.createFromConditionalOp(this.$Realm, cond, V, oldVal);\n        cv.$SetPartial(P, v, Receiver === this ? cv : Receiver);\n      }\n      return true;\n    }\n  }\n\n  // ECMA262 9.1.10\n  $Delete(_P: PropertyKeyValue): boolean {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this, P);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$Delete(P);\n      }\n      invariant(false);\n    } else {\n      let sawTrue = false;\n      let sawFalse = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let d = cv.$GetOwnProperty(P);\n        if (d === undefined) continue;\n        if (!IsDataDescriptor(this.$Realm, d)) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        let dval = d.value;\n        invariant(dval instanceof Value);\n        let v = AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.empty, dval);\n        if (cv.$Set(P, v, cv)) sawTrue = true;\n        else sawFalse = true;\n      }\n      if (sawTrue && sawFalse) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return sawTrue;\n    }\n  }\n\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$OwnPropertyKeys();\n      }\n      invariant(false);\n    } else {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n  }\n}\n"]}