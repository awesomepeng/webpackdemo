{"version":3,"sources":["../../src/values/ProxyValue.js"],"names":["FindPropertyKey","realm","keys","key","i","length","ProxyValue","constructor","getTrackedPropertyNames","trackedPropertyNames","isSimpleObject","usesOrdinaryObjectInternalPrototypeMethods","$GetPrototypeOf","$Realm","handler","$ProxyHandler","createErrorThrowCompletion","intrinsics","TypeError","target","$ProxyTarget","trap","handlerProto","extensibleTarget","targetProto","$SetPrototypeOf","V","booleanTrapResult","ToBooleanPartial","$IsExtensible","targetResult","$PreventExtensions","targetIsExtensible","$GetOwnProperty","P","trapResultObj","targetDesc","undefined","ThrowIfMightHaveBeenDeleted","value","configurable","resultDesc","ToPropertyDescriptor","CompletePropertyDescriptor","valid","IsCompatiblePropertyDescriptor","$DefineOwnProperty","Desc","descObj","FromPropertyDescriptor","settingConfigFalse","$HasProperty","$Get","Receiver","trapResult","writable","targetValue","get","$Set","set","$Delete","$OwnPropertyKeys","trapResultArray","CreateListFromArrayLike","targetKeys","targetConfigurableKeys","targetNonconfigurableKeys","desc","push","uncheckedResultKeys","slice","index","splice","concat"],"mappings":"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","file":"ProxyValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  Value,\n  AbstractObjectValue,\n  SymbolValue,\n  NullValue,\n  ObjectValue,\n  UndefinedValue,\n  StringValue,\n} from \"./index.js\";\nimport type { Descriptor, PropertyKeyValue } from \"../types.js\";\nimport invariant from \"../invariant.js\";\nimport { SameValuePartial, SamePropertyKey } from \"../methods/abstract.js\";\nimport { GetMethod } from \"../methods/get.js\";\nimport { IsExtensible, IsPropertyKey, IsDataDescriptor, IsAccessorDescriptor } from \"../methods/is.js\";\nimport { Create, Properties, To } from \"../singletons.js\";\nimport { Call } from \"../methods/call.js\";\n\nfunction FindPropertyKey(realm: Realm, keys: Array<PropertyKeyValue>, key: PropertyKeyValue): number {\n  for (let i = 0; i < keys.length; ++i) {\n    if (SamePropertyKey(realm, key, keys[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport default class ProxyValue extends ObjectValue {\n  $ProxyTarget: NullValue | ObjectValue;\n  $ProxyHandler: NullValue | ObjectValue;\n\n  constructor(realm: Realm) {\n    super(realm);\n  }\n\n  static trackedPropertyNames = ObjectValue.trackedPropertyNames.concat([\"$ProxyTarget\", \"$ProxyHandler\"]);\n\n  getTrackedPropertyNames(): Array<string> {\n    return ProxyValue.trackedPropertyNames;\n  }\n\n  isSimpleObject(): boolean {\n    return false;\n  }\n\n  usesOrdinaryObjectInternalPrototypeMethods(): boolean {\n    return false;\n  }\n\n  // ECMA262 9.5.1\n  $GetPrototypeOf(): NullValue | AbstractObjectValue | ObjectValue {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected an object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"getPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"getPrototypeOf\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetPrototypeOf]]().\n      return target.$GetPrototypeOf();\n    }\n\n    // 7. Let handlerProto be ? Call(trap, handler, « target »).\n    let handlerProto = Call(realm, trap, handler, [target]);\n\n    // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.\n    if (!(handlerProto instanceof ObjectValue) && !(handlerProto instanceof NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. If extensibleTarget is true, return handlerProto.\n    if (extensibleTarget) return handlerProto;\n\n    // 11. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.\n    if (!SameValuePartial(realm, handlerProto, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return handlerProto.\n    return handlerProto;\n  }\n\n  // ECMA262 9.5.2\n  $SetPrototypeOf(V: ObjectValue | NullValue): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    invariant(V instanceof ObjectValue || V instanceof NullValue, \"expected object or null\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"setPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"setPrototypeOf\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[SetPrototypeOf]](V).\n      return target.$SetPrototypeOf(V);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).\n    let booleanTrapResult = To.ToBooleanPartial(realm, Call(realm, trap, handler, [target, V]));\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 11. If extensibleTarget is true, return true.\n    if (extensibleTarget) return true;\n\n    // 12. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.\n    if (!SameValuePartial(realm, V, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 14. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.3\n  $IsExtensible(): boolean {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"isExtensible\").\n    let trap = GetMethod(realm, handler, \"isExtensible\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      return target.$IsExtensible();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = To.ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. Let targetResult be ? target.[[IsExtensible]]().\n    invariant(target instanceof ObjectValue);\n    let targetResult = target.$IsExtensible();\n\n    // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.\n    if (booleanTrapResult !== targetResult) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.4\n  $PreventExtensions(): boolean {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"preventExtensions\").\n    let trap = GetMethod(realm, handler, \"preventExtensions\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[PreventExtensions]]().\n      invariant(target instanceof ObjectValue);\n      return target.$PreventExtensions();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = To.ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. If booleanTrapResult is true, then\n    if (booleanTrapResult) {\n      // a. Let targetIsExtensible be ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      let targetIsExtensible = target.$IsExtensible();\n\n      // b. If targetIsExtensible is true, throw a TypeError exception.\n      if (targetIsExtensible) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 9. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.5\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"getOwnPropertyDescriptor\").\n    let trap = GetMethod(realm, handler, \"getOwnPropertyDescriptor\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetOwnProperty]](P).\n      return target.$GetOwnProperty(P);\n    }\n\n    // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).\n    let trapResultObj = Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P]);\n\n    // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.\n    if (!(trapResultObj instanceof ObjectValue) && !(trapResultObj instanceof UndefinedValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If trapResultObj is undefined, then\n    if (trapResultObj instanceof UndefinedValue) {\n      // a. If targetDesc is undefined, return undefined.\n      if (!targetDesc) return undefined;\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n      if (!targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // c. Let extensibleTarget be ? IsExtensible(target).\n      let extensibleTarget = IsExtensible(realm, target);\n\n      // d. Assert: Type(extensibleTarget) is Boolean.\n      invariant(typeof extensibleTarget === \"boolean\", \"expected boolean\");\n\n      // e. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // f. Return undefined.\n      return undefined;\n    }\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).\n    let resultDesc = To.ToPropertyDescriptor(realm, trapResultObj);\n\n    // 14. Call CompletePropertyDescriptor(resultDesc).\n    Properties.CompletePropertyDescriptor(realm, resultDesc);\n\n    // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).\n    let valid = Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, resultDesc, targetDesc);\n\n    // 16. If valid is false, throw a TypeError exception.\n    if (!valid) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 17. If resultDesc.[[Configurable]] is false, then\n    if (!resultDesc.configurable) {\n      // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then\n      if (!targetDesc || targetDesc.configurable) {\n        // i. Throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 18. Return resultDesc.\n    return resultDesc;\n  }\n\n  // ECMA262 9.5.6\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"defineProperty\").\n    let trap = GetMethod(realm, handler, \"defineProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[DefineOwnProperty]](P, Desc).\n      return target.$DefineOwnProperty(P, Desc);\n    }\n\n    // 8. Let descObj be FromPropertyDescriptor(Desc).\n    let descObj = Properties.FromPropertyDescriptor(realm, Desc);\n\n    // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, descObj])\n    );\n\n    // 10. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then\n    let settingConfigFalse;\n    if (\"configurable\" in Desc && !Desc.configurable) {\n      // a. Let settingConfigFalse be true.\n      settingConfigFalse = true;\n    } else {\n      // 14. Else let settingConfigFalse be false.\n      settingConfigFalse = false;\n    }\n\n    // 15. If targetDesc is undefined, then\n    if (!targetDesc) {\n      // a. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true, throw a TypeError exception.\n      if (settingConfigFalse) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    } else {\n      // 16. Else targetDesc is not undefined,\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.\n      if (!Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, Desc, targetDesc)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.\n      if (settingConfigFalse && targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 17. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.7\n  $HasProperty(P: PropertyKeyValue): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"has\").\n    let trap = GetMethod(realm, handler, \"has\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[HasProperty]](P).\n      return target.$HasProperty(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P])\n    );\n\n    // 9. If booleanTrapResult is false, then\n    if (!booleanTrapResult) {\n      // a. Let targetDesc be ? target.[[GetOwnProperty]](P).\n      let targetDesc = target.$GetOwnProperty(P);\n\n      // b. If targetDesc is not undefined, then\n      if (targetDesc) {\n        Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n        // i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n        if (!targetDesc.configurable) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n\n        // ii. Let extensibleTarget be ? IsExtensible(target).\n        let extensibleTarget = IsExtensible(realm, target);\n\n        // iii. If extensibleTarget is false, throw a TypeError exception.\n        if (!extensibleTarget) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.8\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"get\").\n    let trap = GetMethod(realm, handler, \"get\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Get]](P, Receiver).\n      return target.$Get(P, Receiver);\n    }\n\n    // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).\n    let trapResult = Call(realm, trap, handler, [\n      target,\n      typeof P === \"string\" ? new StringValue(realm, P) : P,\n      Receiver,\n    ]);\n\n    // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 10. If targetDesc is not undefined, then\n    if (targetDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {\n        // i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        let targetValue = targetDesc.value || realm.intrinsics.undefined;\n        invariant(targetValue instanceof Value);\n        if (!SameValuePartial(realm, trapResult, targetValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then\n      if (\n        IsAccessorDescriptor(realm, targetDesc) &&\n        targetDesc.configurable === false &&\n        (!targetDesc.get || targetDesc.get instanceof UndefinedValue)\n      ) {\n        // i. If trapResult is not undefined, throw a TypeError exception.\n        if (!(trapResult instanceof UndefinedValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 11. Return trapResult.\n    return trapResult;\n  }\n\n  // ECMA262 9.5.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"set\").\n    let trap = GetMethod(realm, handler, \"set\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Set]](P, V, Receiver).\n      invariant(target instanceof ObjectValue);\n      return target.$Set(P, V, Receiver);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, V, Receiver])\n    );\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is not undefined, then\n    if (targetDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && !targetDesc.configurable && !targetDesc.writable) {\n        // i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        let targetValue = targetDesc.value || realm.intrinsics.undefined;\n        invariant(targetValue instanceof Value);\n        if (!SameValuePartial(realm, V, targetValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, then\n      if (IsAccessorDescriptor(realm, targetDesc) && !targetDesc.configurable) {\n        // i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.\n        if (!targetDesc.set || targetDesc.set instanceof UndefinedValue) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 12. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.10\n  $Delete(P: PropertyKeyValue): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"deleteProperty\").\n    let trap = GetMethod(realm, handler, \"deleteProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Delete]](P).\n      invariant(target instanceof ObjectValue);\n      return target.$Delete(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P])\n    );\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is undefined, return true.\n    if (!targetDesc) return true;\n    Properties.ThrowIfMightHaveBeenDeleted(targetDesc.value);\n\n    // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n    if (!targetDesc.configurable) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.11\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"ownKeys\").\n    let trap = GetMethod(realm, handler, \"ownKeys\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[OwnPropertyKeys]]().\n      return target.$OwnPropertyKeys();\n    }\n\n    // 7. Let trapResultArray be ? Call(trap, handler, « target »).\n    let trapResultArray = Call(realm, trap, handler, [target]);\n\n    // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).\n    let trapResult: Array<PropertyKeyValue> = ((Create.CreateListFromArrayLike(realm, trapResultArray, [\n      \"String\",\n      \"Symbol\",\n    ]): any): Array<PropertyKeyValue>);\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. Let targetKeys be ? target.[[OwnPropertyKeys]]().\n    let targetKeys = target.$OwnPropertyKeys();\n\n    // 11. Assert: targetKeys is a List containing only String and Symbol values.\n    for (let key of targetKeys) {\n      invariant(key instanceof SymbolValue || key instanceof StringValue, \"expected string or symbol\");\n    }\n\n    // 12. Let targetConfigurableKeys be a new empty List.\n    let targetConfigurableKeys = [];\n\n    // 13. Let targetNonconfigurableKeys be a new empty List.\n    let targetNonconfigurableKeys = [];\n\n    // 14. Repeat, for each element key of targetKeys,\n    for (let key of targetKeys) {\n      // a. Let desc be ? target.[[GetOwnProperty]](key).\n      let desc = target.$GetOwnProperty(key);\n      if (desc) Properties.ThrowIfMightHaveBeenDeleted(desc.value);\n\n      // b. If desc is not undefined and desc.[[Configurable]] is false, then\n      if (desc && desc.configurable === false) {\n        // i. Append key as an element of targetNonconfigurableKeys.\n        targetNonconfigurableKeys.push(key);\n      } else {\n        // c. Else,\n        // i. Append key as an element of targetConfigurableKeys.\n        targetConfigurableKeys.push(key);\n      }\n    }\n\n    // 15. If extensibleTarget is true and targetNonconfigurableKeys is empty, then\n    if (extensibleTarget && !targetNonconfigurableKeys.length) {\n      // a. Return trapResult.\n      return trapResult;\n    }\n\n    // 16. Let uncheckedResultKeys be a new List which is a copy of trapResult.\n    let uncheckedResultKeys = trapResult.slice();\n\n    // 17. Repeat, for each key that is an element of targetNonconfigurableKeys,\n    for (let key of targetNonconfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"key is not an element of uncheckedResultKeys\"\n        );\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 18. If extensibleTarget is true, return trapResult.\n    if (extensibleTarget) return trapResult;\n\n    // 19. Repeat, for each key that is an element of targetConfigurableKeys,\n    for (let key of targetConfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"key is not an element of uncheckedResultKeys\"\n        );\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 20. If uncheckedResultKeys is not empty, throw a TypeError exception.\n    if (uncheckedResultKeys.length) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 21. Return trapResult.\n    return trapResult;\n  }\n}\n"]}