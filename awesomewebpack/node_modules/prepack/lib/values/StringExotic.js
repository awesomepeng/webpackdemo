"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../values/index.js");

var _is = require("../methods/is.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

class StringExotic extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.StringPrototype, intrinsicName);
  }

  // ECMA262 9.4.3.1
  $GetOwnProperty(P) {
    // 1. Assert: IsPropertyKey(P) is true.

    // 2. Let desc be OrdinaryGetOwnProperty(S, P).
    let desc = _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, this, P);

    // 3. If desc is not undefined, return desc.
    if (desc !== undefined) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc.value);
      return desc;
    }

    // 4. If Type(P) is not String, return undefined.
    if (typeof P !== "string" && !(P instanceof _index.StringValue)) return undefined;

    // 5. Let index be ! CanonicalNumericIndexString(P).
    let index = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

    // 6. If index is undefined, return undefined.
    if (index === undefined || index === null) return undefined;

    // 7. If IsInteger(index) is false, return undefined.
    if ((0, _is.IsInteger)(this.$Realm, index) === false) return undefined;

    // 8. If index = -0, return undefined.
    if (1.0 / index === -Infinity) return undefined;

    // 9. Let str be the String value of S.[[StringData]].
    let str = this.$StringData;
    (0, _invariant2.default)(str);
    str = str.throwIfNotConcreteString();

    // 10. Let len be the number of elements in str.
    let len = str.value.length;

    // 11. If index < 0 or len ≤ index, return undefined.
    if (index < 0 || len <= index) return undefined;

    // 12. Let resultStr be a String value of length 1, containing one code unit from str, specifically the code unit at index index.
    let resultStr = new _index.StringValue(this.$Realm, str.value.charAt(index));

    // 13. Return a PropertyDescriptor{[[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}.
    return {
      value: resultStr,
      writable: false,
      enumerable: true,
      configurable: false
    };
  }

  // ECMA262 9.4.3.2
  $OwnPropertyKeys() {
    // 1. Let keys be a new empty List.
    let keys = [];

    // 2. Let str be the String value of O.[[StringData]].
    let str = this.$StringData;
    (0, _invariant2.default)(str);
    str = str.throwIfNotConcreteString();

    // 3. Let len be the number of elements in str.
    let len = str.value.length;

    // 4. For each integer i starting with 0 such that i < len, in ascending order,
    for (let i = 0; i < len; ++i) {
      // a. Add ! ToString(i) as the last element of keys.
      keys.push(new _index.StringValue(this.$Realm, _singletons.To.ToString(this.$Realm, new _index.NumberValue(this.$Realm, i))));
    }

    // 5. For each own property key P of O such that P is an integer index and ToInteger(P) ≥ len, in ascending numeric index order,
    let properties = this.getOwnPropertyKeysArray();
    for (let key of properties.filter(x => (0, _is.IsArrayIndex)(this.$Realm, x)).map(x => parseInt(x, 10)).filter(x => _singletons.To.ToInteger(this.$Realm, x) >= len).sort((x, y) => x - y)) {
      // i. Add P as the last element of keys.
      keys.push(new _index.StringValue(this.$Realm, key + ""));
    }

    // 6. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation,
    for (let key of properties.filter(x => !(0, _is.IsArrayIndex)(this.$Realm, x))) {
      // i. Add P as the last element of keys.
      keys.push(new _index.StringValue(this.$Realm, key));
    }

    // 7. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation,
    for (let key of this.symbols.keys()) {
      // i. Add P as the last element of keys.
      keys.push(key);
    }

    // 12. Return keys.
    return keys;
  }
}
exports.default = StringExotic;
//# sourceMappingURL=StringExotic.js.map