"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _is = require("../methods/is.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

class ArrayValue extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.ArrayPrototype, intrinsicName);
  }

  getKind() {
    return "Array";
  }

  isSimpleObject() {
    return this.$TypedArrayName === undefined;
  }

  // ECMA262 9.4.2.1
  $DefineOwnProperty(P, Desc) {
    let A = this;

    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "expected a property key");

    // 2. If P is "length", then
    if (P === "length" || P instanceof _index.StringValue && P.value === "length") {
      // a. Return ? ArraySetLength(A, Desc).
      return _singletons.Properties.ArraySetLength(this.$Realm, A, Desc);
    } else if ((0, _is.IsArrayIndex)(this.$Realm, P)) {
      // 3. Else if P is an array index, then

      // a. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").
      let oldLenDesc = _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, A, "length");

      // b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are
      //    created with a length data property that cannot be deleted or reconfigured.
      (0, _invariant2.default)(oldLenDesc !== undefined && !(0, _is.IsAccessorDescriptor)(this.$Realm, oldLenDesc), "cannot be undefined or an accessor descriptor");
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(oldLenDesc.value);

      // c. Let oldLen be oldLenDesc.[[Value]].
      let oldLen = oldLenDesc.value;
      (0, _invariant2.default)(oldLen instanceof _index.Value);
      oldLen = oldLen.throwIfNotConcrete();
      (0, _invariant2.default)(oldLen instanceof _index.NumberValue, "expected number value");
      oldLen = oldLen.value;

      // d. Let index be ! ToUint32(P).
      let index = _singletons.To.ToUint32(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

      // e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.
      if (index >= oldLen && oldLenDesc.writable === false) return false;

      // f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).
      let succeeded = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);

      // g. If succeeded is false, return false.
      if (succeeded === false) return false;

      // h. If index ≥ oldLen, then
      if (index >= oldLen) {
        // i. Set oldLenDesc.[[Value]] to index + 1.
        oldLenDesc.value = new _index.NumberValue(this.$Realm, index + 1);

        // ii. Let succeeded be OrdinaryDefineOwnProperty(A, "length", oldLenDesc).
        succeeded = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, "length", oldLenDesc);

        // iii. Assert: succeeded is true.
        (0, _invariant2.default)(succeeded, "expected length definition to succeed");
      }

      // i. Return true.
      return true;
    }

    // 1. Return OrdinaryDefineOwnProperty(A, P, Desc).
    return _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);
  }

  static createTemporalWithWidenedNumericProperty(realm, args, buildFunction, reactArrayHint) {
    (0, _invariant2.default)(realm.generator !== undefined);

    let value = realm.generator.deriveConcreteObject(intrinsicName => new ArrayValue(realm, intrinsicName), args, buildFunction, { isPure: true });

    (0, _invariant2.default)(value instanceof ArrayValue);
    // Add unknownProperty so we manually handle this object property access
    value.unknownProperty = {
      key: undefined,
      descriptor: {
        value: _index.AbstractValue.createFromType(realm, _index.Value, "widened numeric property")
      },
      object: value
    };
    if (realm.react.enabled && reactArrayHint !== undefined) {
      realm.react.arrayHints.set(value, reactArrayHint);
    }
    return value;
  }

  static isIntrinsicAndHasWidenedNumericProperty(obj) {
    if (obj instanceof ArrayValue && obj.intrinsicName) {
      const prop = obj.unknownProperty;
      if (prop !== undefined && prop.descriptor !== undefined) {
        const desc = prop.descriptor;

        return desc.value instanceof _index.AbstractValue && desc.value.kind === "widened numeric property";
      }
    }
    return false;
  }
}
exports.default = ArrayValue;
//# sourceMappingURL=ArrayValue.js.map