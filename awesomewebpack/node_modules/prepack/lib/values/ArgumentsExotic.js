"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../values/index.js");

var _is = require("../methods/is.js");

var _has = require("../methods/has.js");

var _abstract = require("../methods/abstract.js");

var _get = require("../methods/get.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ArgumentsExotic extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);
  }

  // ECMA262 9.4.4.1
  $GetOwnProperty(P) {
    // 1. Let args be the arguments object.
    let args = this;

    // 2. Let desc be OrdinaryGetOwnProperty(args, P).
    let desc = _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, args, P);

    // 3. If desc is undefined, return desc.
    if (desc === undefined) return undefined;
    _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc.value);

    // 4. Let map be args.[[ParameterMap]].
    let map = args.$ParameterMap;
    (0, _invariant2.default)(map);

    // 5. Let isMapped be ! HasOwnProperty(map, P).
    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P);

    // 6. If isMapped is true, then
    if (isMapped === true) {
      // a. Set desc.[[Value]] to Get(map, P).
      desc.value = (0, _get.Get)(this.$Realm, map, P);
    }

    // 7. Return desc.
    return desc;
  }

  // ECMA262 9.4.4.2
  $DefineOwnProperty(P, Desc) {
    // 1. Let args be the arguments object.
    let args = this;

    // 2. Let map be args.[[ParameterMap]].
    let map = args.$ParameterMap;
    (0, _invariant2.default)(map);

    // 3. Let isMapped be HasOwnProperty(map, P).
    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P);

    // 4. Let newArgDesc be Desc.
    let newArgDesc = Desc;

    // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then
    if (isMapped === true && (0, _is.IsDataDescriptor)(this.$Realm, Desc) === true) {
      // a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then
      if (Desc.value === undefined && Desc.writable === false) {
        // i. Let newArgDesc be a copy of Desc.
        newArgDesc = Object.assign({}, Desc);

        // ii. Set newArgDesc.[[Value]] to Get(map, P).
        newArgDesc.value = (0, _get.Get)(this.$Realm, map, P);
      }
    }

    // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).
    let allowed = _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, args, P, newArgDesc);

    // 7. If allowed is false, return false.
    if (allowed === false) return false;

    // 8. If isMapped is true, then
    if (isMapped === true) {
      // a. If IsAccessorDescriptor(Desc) is true, then
      if ((0, _is.IsAccessorDescriptor)(this.$Realm, Desc) === true) {
        // i. Call map.[[Delete]](P).
        map.$Delete(P);
      } else {
        // b. Else,
        // i. If Desc.[[Value]] is present, then
        if (Desc.value !== undefined) {
          // 1. Let setStatus be Set(map, P, Desc.[[Value]], false).
          (0, _invariant2.default)(Desc.value instanceof _index.Value);
          let setStatus = _singletons.Properties.Set(this.$Realm, map, P, Desc.value, false);

          // 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.
          (0, _invariant2.default)(setStatus === true);
        }

        // ii. If Desc.[[Writable]] is present and its value is false, then
        if (Desc.writable === false) {
          // 1. Call map.[[Delete]](P).
          map.$Delete(P);
        }
      }
    }

    // 9. Return true.
    return true;
  }

  // ECMA262 9.4.4.3
  $Get(P, Receiver) {
    // 1. Let args be the arguments object.
    let args = this;

    // 2. Let map be args.[[ParameterMap]].
    let map = args.$ParameterMap;
    (0, _invariant2.default)(map);

    // 3. Let isMapped be ! HasOwnProperty(map, P).
    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P);

    // 4. If isMapped is false, then
    if (isMapped === false) {
      // a. Return ? OrdinaryGet(args, P, Receiver).
      return (0, _get.OrdinaryGet)(this.$Realm, args, P, Receiver);
    } else {
      // 5. Else map contains a formal parameter mapping for P,
      // b. Return Get(map, P).
      return (0, _get.Get)(this.$Realm, map, P);
    }
  }

  // ECMA262 9.4.4.4
  $Set(P, V, Receiver) {
    // 1. Let args be the arguments object.
    let args = this;

    let isMapped, map;
    // 2. If SameValue(args, Receiver) is false, then
    if ((0, _abstract.SameValuePartial)(this.$Realm, args, Receiver) === false) {
      // a. Let isMapped be false.
      isMapped = false;
    } else {
      // 3. Else,
      // a. Let map be args.[[ParameterMap]].
      map = args.$ParameterMap;
      (0, _invariant2.default)(map);

      // b. Let isMapped be ! HasOwnProperty(map, P).
      isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P);
    }

    // 4. If isMapped is true, then
    if (isMapped === true) {
      (0, _invariant2.default)(map);
      // a. Let setStatus be Set(map, P, V, false).
      let setStatus = _singletons.Properties.Set(this.$Realm, map, P, V, false);

      // b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.
      (0, _invariant2.default)(setStatus === true);
    }

    // 5. Return ? OrdinarySet(args, P, V, Receiver).
    return _singletons.Properties.OrdinarySet(this.$Realm, args, P, V, Receiver);
  }

  // ECMA262 9.4.4.5
  $Delete(P) {
    // 1. Let args be the arguments object.
    let args = this;

    // 2. Let map be args.[[ParameterMap]].
    let map = args.$ParameterMap;
    (0, _invariant2.default)(map);

    // 3. Let isMapped be ! HasOwnProperty(map, P).
    let isMapped = (0, _has.HasOwnProperty)(this.$Realm, map, P);

    // 4. Let result be ? OrdinaryDelete(args, P).
    let result = _singletons.Properties.OrdinaryDelete(this.$Realm, args, P);

    // 5. If result is true and isMapped is true, then
    if (result === true && isMapped === true) {
      // a. Call map.[[Delete]](P).
      map.$Delete(P);
    }

    // 6. Return result.
    return result;
  }
}
exports.default = ArgumentsExotic; /**
                                    * Copyright (c) 2017-present, Facebook, Inc.
                                    * All rights reserved.
                                    *
                                    * This source code is licensed under the BSD-style license found in the
                                    * LICENSE file in the root directory of this source tree. An additional grant
                                    * of patent rights can be found in the PATENTS file in the same directory.
                                    */

/*  strict-local */
//# sourceMappingURL=ArgumentsExotic.js.map