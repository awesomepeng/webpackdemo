"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../values/index.js");

var _is = require("../methods/is.js");

var _get = require("../methods/get.js");

var _has = require("../methods/has.js");

var _typedarray = require("../methods/typedarray.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class IntegerIndexedExotic extends _index.ObjectValue {
  constructor(realm, intrinsicName) {
    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);
  }

  // ECMA262 9.4.5.1
  $GetOwnProperty(P) {
    let O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer);

    // 3. If Type(P) is String, then
    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

      // b. If numericIndex is not undefined, then
      if (numericIndex !== undefined) {
        // i. Let value be ? IntegerIndexedElementGet(O, numericIndex).
        let value = (0, _typedarray.IntegerIndexedElementGet)(this.$Realm, O, numericIndex);

        // ii. If value is undefined, return undefined.
        if (value instanceof _index.UndefinedValue) return undefined;

        // iii. Return a PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false}.
        return {
          value: value,
          writable: true,
          enumerable: true,
          configurable: false
        };
      }
    }
    // 4. Return OrdinaryGetOwnProperty(O, P).
    return _singletons.Properties.OrdinaryGetOwnProperty(this.$Realm, O, P);
  }

  // ECMA262 9.4.5.2
  $HasProperty(P) {
    let O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer);

    // 3. If Type(P) is String, then
    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

      // b. If numericIndex is not undefined, then
      if (numericIndex !== undefined) {
        // i. Let buffer be O.[[ViewedArrayBuffer]].
        let buffer = O.$ViewedArrayBuffer;
        (0, _invariant2.default)(buffer);

        // ii. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
        if ((0, _is.IsDetachedBuffer)(this.$Realm, buffer) === true) {
          throw this.$Realm.createErrorThrowCompletion(this.$Realm.intrinsics.TypeError, "IsDetachedBuffer(buffer) is true");
        }

        // iii. If IsInteger(numericIndex) is false, return false.
        if ((0, _is.IsInteger)(this.$Realm, numericIndex) === false) return false;

        // iv. If numericIndex = -0, return false.
        if (Object.is(numericIndex, -0)) return false;

        // v. If numericIndex < 0, return false.
        if (numericIndex < 0) return false;

        // vi. If numericIndex ≥ O.[[ArrayLength]], return false.
        (0, _invariant2.default)(O.$ArrayLength);
        if (numericIndex >= O.$ArrayLength) return false;

        // vii. Return true.
        return true;
      }
    }

    // 4. Return ? OrdinaryHasProperty(O, P).
    return (0, _has.OrdinaryHasProperty)(this.$Realm, O, P);
  }

  // ECMA262 9.4.5.3
  $DefineOwnProperty(P, Desc) {
    let O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.
    (0, _invariant2.default)(O instanceof _index.ObjectValue && this.$ViewedArrayBuffer);

    // 3. If Type(P) is String, then
    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

      // b. If numericIndex is not undefined, then
      if (numericIndex !== undefined) {
        // i. If IsInteger(numericIndex) is false, return false.
        if ((0, _is.IsInteger)(this.$Realm, numericIndex) === false) return false;

        // ii. If numericIndex = -0, return false.
        if (Object.is(numericIndex, -0)) return false;

        // iii. If numericIndex < 0, return false.
        if (numericIndex < 0) return false;

        // iv. Let length be O.[[ArrayLength]].
        let length = this.$ArrayLength;
        (0, _invariant2.default)(typeof length === "number");

        // v. If numericIndex ≥ length, return false.
        if (numericIndex >= length) return false;

        // vi. If IsAccessorDescriptor(Desc) is true, return false.
        if ((0, _is.IsAccessorDescriptor)(this.$Realm, Desc) === true) return false;

        // vii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.
        if (Desc.configurable === true) return false;

        // viii. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.
        if (Desc.enumerable === false) return false;

        // ix. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.
        if (Desc.writable === false) return false;

        // x. If Desc has a [[Value]] field, then
        if (Desc.value) {
          // 1. Let value be Desc.[[Value]].
          let value = Desc.value;
          (0, _invariant2.default)(value === undefined || value instanceof _index.Value);

          // 2. Return ? IntegerIndexedElementSet(O, numericIndex, value).
          return (0, _typedarray.IntegerIndexedElementSet)(this.$Realm, O, numericIndex, value);
        }

        // xi. Return true.
        return true;
      }
    }

    // 4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).
    return _singletons.Properties.OrdinaryDefineOwnProperty(this.$Realm, O, P, Desc);
  }

  // ECMA262 9.4.5.4
  $Get(P, Receiver) {
    let O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

    // 2. If Type(P) is String, then
    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

      // b. If numericIndex is not undefined, then
      if (numericIndex !== undefined) {
        // i. Return ? IntegerIndexedElementGet(O, numericIndex).
        return (0, _typedarray.IntegerIndexedElementGet)(this.$Realm, O, numericIndex);
      }
    }

    // 3. Return ? OrdinaryGet(O, P, Receiver).
    return (0, _get.OrdinaryGet)(this.$Realm, O, P, Receiver);
  }

  // ECMA262 9.4.5.5
  $Set(P, V, Receiver) {
    let O = this;

    // 1. Assert: IsPropertyKey(P) is true.
    (0, _invariant2.default)((0, _is.IsPropertyKey)(this.$Realm, P), "IsPropertyKey(P) is true");

    // 2. If Type(P) is String, then
    if (typeof P === "string" || P instanceof _index.StringValue) {
      // a. Let numericIndex be ! CanonicalNumericIndexString(P).
      let numericIndex = _singletons.To.CanonicalNumericIndexString(this.$Realm, typeof P === "string" ? new _index.StringValue(this.$Realm, P) : P);

      // b. If numericIndex is not undefined, then
      if (numericIndex !== undefined) {
        // i. Return ? IntegerIndexedElementSet(O, numericIndex, V).
        return (0, _typedarray.IntegerIndexedElementSet)(this.$Realm, O, numericIndex, V);
      }
    }

    // 3. Return ? OrdinarySet(O, P, V, Receiver).
    return _singletons.Properties.OrdinarySet(this.$Realm, O, P, V, Receiver);
  }

  // ECMA262 9.4.5.6
  $OwnPropertyKeys() {
    let O = this;

    // 1. Let keys be a new empty List.
    let keys = [];

    // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
    (0, _invariant2.default)(O instanceof _index.ObjectValue && O.$ViewedArrayBuffer && O.$ArrayLength !== undefined && O.$ByteOffset !== undefined && O.$TypedArrayName);

    // 3. Let len be O.[[ArrayLength]].
    let len = O.$ArrayLength;
    (0, _invariant2.default)(typeof len === "number");

    // 4. For each integer i starting with 0 such that i < len, in ascending order,
    for (let i = 0; i < len; ++i) {
      // a. Add ! ToString(i) as the last element of keys.
      keys.push(new _index.StringValue(this.$Realm, _singletons.To.ToString(this.$Realm, new _index.NumberValue(this.$Realm, i))));
    }

    // 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation
    let properties = O.getOwnPropertyKeysArray();
    for (let key of properties.filter(x => !(0, _is.IsArrayIndex)(this.$Realm, x))) {
      // i. Add P as the last element of keys.
      keys.push(new _index.StringValue(this.$Realm, key));
    }

    // 6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation
    for (let key of O.symbols.keys()) {
      // a. Add P as the last element of keys.
      keys.push(key);
    }

    // 7. Return keys.
    return keys;
  }
}
exports.default = IntegerIndexedExotic; /**
                                         * Copyright (c) 2017-present, Facebook, Inc.
                                         * All rights reserved.
                                         *
                                         * This source code is licensed under the BSD-style license found in the
                                         * LICENSE file in the root directory of this source tree. An additional grant
                                         * of patent rights can be found in the PATENTS file in the same directory.
                                         */

/*  strict-local */
//# sourceMappingURL=IntegerIndexedExotic.js.map