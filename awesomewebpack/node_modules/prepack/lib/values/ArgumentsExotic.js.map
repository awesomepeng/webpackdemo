{"version":3,"sources":["../../src/values/ArgumentsExotic.js"],"names":["ArgumentsExotic","constructor","realm","intrinsicName","intrinsics","ObjectPrototype","$GetOwnProperty","P","args","desc","OrdinaryGetOwnProperty","$Realm","undefined","ThrowIfMightHaveBeenDeleted","value","map","$ParameterMap","isMapped","$DefineOwnProperty","Desc","newArgDesc","writable","Object","assign","allowed","OrdinaryDefineOwnProperty","$Delete","setStatus","Set","$Get","Receiver","$Set","V","OrdinarySet","result","OrdinaryDelete"],"mappings":"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","file":"ArgumentsExotic.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor } from \"../types.js\";\nimport { ObjectValue, Value } from \"../values/index.js\";\nimport { IsDataDescriptor, IsAccessorDescriptor } from \"../methods/is.js\";\nimport { HasOwnProperty } from \"../methods/has.js\";\nimport { SameValuePartial } from \"../methods/abstract.js\";\nimport { Get, OrdinaryGet } from \"../methods/get.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant\";\n\nexport default class ArgumentsExotic extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);\n  }\n\n  $ParameterMap: void | ObjectValue;\n\n  // ECMA262 9.4.4.1\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let desc be OrdinaryGetOwnProperty(args, P).\n    let desc = Properties.OrdinaryGetOwnProperty(this.$Realm, args, P);\n\n    // 3. If desc is undefined, return desc.\n    if (desc === undefined) return undefined;\n    Properties.ThrowIfMightHaveBeenDeleted(desc.value);\n\n    // 4. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 5. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 6. If isMapped is true, then\n    if (isMapped === true) {\n      // a. Set desc.[[Value]] to Get(map, P).\n      desc.value = Get(this.$Realm, map, P);\n    }\n\n    // 7. Return desc.\n    return desc;\n  }\n\n  // ECMA262 9.4.4.2\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 3. Let isMapped be HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. Let newArgDesc be Desc.\n    let newArgDesc = Desc;\n\n    // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then\n    if (isMapped === true && IsDataDescriptor(this.$Realm, Desc) === true) {\n      // a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then\n      if (Desc.value === undefined && Desc.writable === false) {\n        // i. Let newArgDesc be a copy of Desc.\n        newArgDesc = Object.assign({}, Desc);\n\n        // ii. Set newArgDesc.[[Value]] to Get(map, P).\n        newArgDesc.value = Get(this.$Realm, map, P);\n      }\n    }\n\n    // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).\n    let allowed = Properties.OrdinaryDefineOwnProperty(this.$Realm, args, P, newArgDesc);\n\n    // 7. If allowed is false, return false.\n    if (allowed === false) return false;\n\n    // 8. If isMapped is true, then\n    if (isMapped === true) {\n      // a. If IsAccessorDescriptor(Desc) is true, then\n      if (IsAccessorDescriptor(this.$Realm, Desc) === true) {\n        // i. Call map.[[Delete]](P).\n        map.$Delete(P);\n      } else {\n        // b. Else,\n        // i. If Desc.[[Value]] is present, then\n        if (Desc.value !== undefined) {\n          // 1. Let setStatus be Set(map, P, Desc.[[Value]], false).\n          invariant(Desc.value instanceof Value);\n          let setStatus = Properties.Set(this.$Realm, map, P, Desc.value, false);\n\n          // 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n          invariant(setStatus === true);\n        }\n\n        // ii. If Desc.[[Writable]] is present and its value is false, then\n        if (Desc.writable === false) {\n          // 1. Call map.[[Delete]](P).\n          map.$Delete(P);\n        }\n      }\n    }\n\n    // 9. Return true.\n    return true;\n  }\n\n  // ECMA262 9.4.4.3\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. If isMapped is false, then\n    if (isMapped === false) {\n      // a. Return ? OrdinaryGet(args, P, Receiver).\n      return OrdinaryGet(this.$Realm, args, P, Receiver);\n    } else {\n      // 5. Else map contains a formal parameter mapping for P,\n      // b. Return Get(map, P).\n      return Get(this.$Realm, map, P);\n    }\n  }\n\n  // ECMA262 9.4.4.4\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    let isMapped, map;\n    // 2. If SameValue(args, Receiver) is false, then\n    if (SameValuePartial(this.$Realm, args, Receiver) === false) {\n      // a. Let isMapped be false.\n      isMapped = false;\n    } else {\n      // 3. Else,\n      // a. Let map be args.[[ParameterMap]].\n      map = args.$ParameterMap;\n      invariant(map);\n\n      // b. Let isMapped be ! HasOwnProperty(map, P).\n      isMapped = HasOwnProperty(this.$Realm, map, P);\n    }\n\n    // 4. If isMapped is true, then\n    if (isMapped === true) {\n      invariant(map);\n      // a. Let setStatus be Set(map, P, V, false).\n      let setStatus = Properties.Set(this.$Realm, map, P, V, false);\n\n      // b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n      invariant(setStatus === true);\n    }\n\n    // 5. Return ? OrdinarySet(args, P, V, Receiver).\n    return Properties.OrdinarySet(this.$Realm, args, P, V, Receiver);\n  }\n\n  // ECMA262 9.4.4.5\n  $Delete(P: PropertyKeyValue): boolean {\n    // 1. Let args be the arguments object.\n    let args = this;\n\n    // 2. Let map be args.[[ParameterMap]].\n    let map = args.$ParameterMap;\n    invariant(map);\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    let isMapped = HasOwnProperty(this.$Realm, map, P);\n\n    // 4. Let result be ? OrdinaryDelete(args, P).\n    let result = Properties.OrdinaryDelete(this.$Realm, args, P);\n\n    // 5. If result is true and isMapped is true, then\n    if (result === true && isMapped === true) {\n      // a. Call map.[[Delete]](P).\n      map.$Delete(P);\n    }\n\n    // 6. Return result.\n    return result;\n  }\n}\n"]}