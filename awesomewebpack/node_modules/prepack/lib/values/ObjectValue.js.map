{"version":3,"sources":["../../src/values/ObjectValue.js"],"names":["t","isWidenedValue","v","kind","a","args","lengthTemplateSrc","lengthTemplate","ObjectValue","constructor","realm","proto","intrinsicName","refuseSerialization","recordNewObject","useAbstractInterpretation","setupBindings","getTrackedPropertyNames","$Prototype","intrinsics","null","$Extensible","true","_isPartial","false","_isHavoced","_isSimple","_simplicityIsTransitive","_isFinal","properties","Map","symbols","$IsClassPrototype","trackedPropertyNames","propertyNames","propName","propBindingName","trackedPropertyBindingNames","get","undefined","setupTrackedPropertyAccessors","set","Object","defineProperty","prototype","configurable","binding","descriptor","value","mightNotBeHavocedObject","desc","writeable","object","key","internalSlot","$Realm","recordModifiedProperty","equals","x","getHash","hashValue","objectCount","temporalAlias","_temporalAlias","hasStringOrSymbolProperties","prop","values","mightBeFalse","mightNotBeObject","throwIfNotObject","makeNotPartial","makePartial","makeSimple","option","makeFinal","makeNotFinal","isPartialObject","mightBeTrue","mightBeFinalObject","mightNotBeFinalObject","mightNotBeTrue","havoc","mightBeHavocedObject","isSimpleObject","size","propertyBinding","writable","ObjectPrototype","isTransitivelySimple","getExtensible","throwIfNotConcreteBoolean","setExtensible","getKind","$SymbolData","$StringData","$NumberData","$BooleanData","$DateValue","$RegExpMatcher","$SetData","$MapData","$DataView","$ArrayBufferData","$WeakMapData","$WeakSetData","react","enabled","$TypedArrayName","defineNativeMethod","name","length","callback","fnValue","defineNativeProperty","$DefineOwnProperty","enumerable","defineNativeGetter","funcName","$Description","throwIfNotConcreteString","func","defineNativeConstant","getOwnPropertyKeysArray","allowAbstractKeys","unknownProperty","reportIntrospectionError","keyArray","Array","from","keys","filter","pb","pv","mightHaveBeenDeleted","callReportObjectGetOwnProperties","getSnapshot","options","template","copyKeys","$OwnPropertyKeys","reactProps","has","add","result","createTemporalFromBuildFunction","skipInvariant","isPure","removeProperties","to","nextKey","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","propValue","Set","_serialize","stack","obj","serializedDesc","serialize","usesOrdinaryObjectInternalPrototypeMethods","$GetPrototypeOf","$SetPrototypeOf","V","OrdinarySetPrototypeOf","$IsExtensible","$PreventExtensions","P","OrdinaryGetOwnProperty","Desc","OrdinaryDefineOwnProperty","$HasProperty","$Get","Receiver","val","isIntrinsicAndHasWidenedNumericProperty","specializeJoin","_SafeGetDataPropertyValue","savedInvariantLevel","invariantLevel","$GetPartial","getType","createFromTemplate","mightNotBeString","mightNotBeNumber","isInPureScope","error","currentLocation","handleError","o","p","ToStringAbstract","createFromType","cond","createFromBinaryOp","createFromConditionalOp","absVal","ob","pName","pNumber","generic_cond","specializeCond","arg1","arg2","expressionLocation","$Set","OrdinarySet","$SetPartial","pIsLoopVar","pIsNumeric","isTypeCompatibleWith","evaluateWithPossibleThrowCompletion","generator","emitStatement","objectNode","keyNode","valueNode","expressionStatement","assignmentExpression","topVal","createTemplate","newVal","sentinel","oldVal","savedUnknownProperty","delete","empty","$Delete","OrdinaryDelete"],"mappings":"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","file":"ObjectValue.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm, ExecutionContext } from \"../realm.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type {\n  DataBlock,\n  Descriptor,\n  IterationKind,\n  ObjectKind,\n  PromiseReaction,\n  PropertyBinding,\n  PropertyKeyValue,\n  TypedArrayKind,\n} from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ConcreteValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n  PrimitiveValue,\n} from \"./index.js\";\nimport { isReactElement } from \"../react/utils.js\";\nimport buildExpressionTemplate from \"../utils/builder.js\";\nimport { ECMAScriptSourceFunctionValue, type NativeFunctionCallback } from \"./index.js\";\nimport {\n  Get,\n  GetFromArrayWithWidenedNumericProperty,\n  IsDataDescriptor,\n  OrdinaryOwnPropertyKeys,\n  OrdinaryGet,\n  OrdinaryHasProperty,\n  OrdinaryIsExtensible,\n  OrdinaryPreventExtensions,\n  HasCompatibleType,\n} from \"../methods/index.js\";\nimport { Havoc, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { typeAnnotation } from \"babel-types\";\nimport * as t from \"babel-types\";\nimport { memberExpressionHelper } from \"../utils/babelhelpers.js\";\n\nfunction isWidenedValue(v: void | Value) {\n  if (!(v instanceof AbstractValue)) return false;\n  if (v.kind === \"widened\" || v.kind === \"widened property\") return true;\n  for (let a of v.args) {\n    if (isWidenedValue(a)) return true;\n  }\n  return false;\n}\n\nconst lengthTemplateSrc = \"(A).length\";\nconst lengthTemplate = buildExpressionTemplate(lengthTemplateSrc);\n\nexport default class ObjectValue extends ConcreteValue {\n  constructor(\n    realm: Realm,\n    proto?: ObjectValue | NullValue,\n    intrinsicName?: string,\n    refuseSerialization: boolean = false\n  ) {\n    super(realm, intrinsicName);\n    realm.recordNewObject(this);\n    if (realm.useAbstractInterpretation) this.setupBindings(this.getTrackedPropertyNames());\n    this.$Prototype = proto || realm.intrinsics.null;\n    this.$Extensible = realm.intrinsics.true;\n    this._isPartial = realm.intrinsics.false;\n    this._isHavoced = realm.intrinsics.false;\n    this._isSimple = realm.intrinsics.false;\n    this._simplicityIsTransitive = realm.intrinsics.false;\n    this._isFinal = realm.intrinsics.false;\n    this.properties = new Map();\n    this.symbols = new Map();\n    this.refuseSerialization = refuseSerialization;\n\n    // this.$IsClassPrototype should be the last thing that gets initialized,\n    // as other code checks whether this.$IsClassPrototype === undefined\n    // as a proxy for whether initialization is still ongoing.\n    this.$IsClassPrototype = false;\n  }\n\n  static trackedPropertyNames = [\n    \"_isPartial\",\n    \"_isHavoced\",\n    \"_isSimple\",\n    \"_isFinal\",\n    \"_simplicityIsTransitive\",\n    \"_temporalAlias\",\n    \"$ArrayIteratorNextIndex\",\n    \"$DateValue\",\n    \"$Extensible\",\n    \"$IteratedList\",\n    \"$IteratedObject\",\n    \"$IteratedSet\",\n    \"$IteratedString\",\n    \"$Map\",\n    \"$MapData\",\n    \"$MapNextIndex\",\n    \"$Prototype\",\n    \"$SetData\",\n    \"$SetNextIndex\",\n    \"$StringIteratorNextIndex\",\n    \"$WeakMapData\",\n    \"$WeakSetData\",\n  ];\n  static trackedPropertyBindingNames = new Map();\n\n  getTrackedPropertyNames(): Array<string> {\n    return ObjectValue.trackedPropertyNames;\n  }\n\n  setupBindings(propertyNames: Array<string>): void {\n    for (let propName of propertyNames) {\n      let propBindingName = ObjectValue.trackedPropertyBindingNames.get(propName);\n      invariant(propBindingName !== undefined);\n      (this: any)[propBindingName] = undefined;\n    }\n  }\n\n  static setupTrackedPropertyAccessors(propertyNames: Array<string>): void {\n    for (let propName of propertyNames) {\n      let propBindingName = ObjectValue.trackedPropertyBindingNames.get(propName);\n      if (propBindingName === undefined)\n        ObjectValue.trackedPropertyBindingNames.set(propName, (propBindingName = propName + \"_binding\"));\n      Object.defineProperty(ObjectValue.prototype, propName, {\n        configurable: true,\n        get: function() {\n          let binding = this[propBindingName];\n          return binding === undefined ? undefined : binding.descriptor.value;\n        },\n        set: function(v) {\n          // Let's make sure that the object is not havoced.\n          // To that end, we'd like to call this.isHavocedObject().\n          // However, while the object is still being initialized,\n          // properties may be set, but this.isHavocedObject() may not be called yet.\n          // To check if we are still initializing, guard the call by looking at\n          // whether this.$IsClassPrototype has been initialized as a proxy for\n          // object initialization in general.\n          invariant(\n            // We're still initializing so we can set a property.\n            this.$IsClassPrototype === undefined ||\n              // It's not havoced so we can set a property.\n              this.mightNotBeHavocedObject() ||\n              // Object.assign() implementation needs to temporarily\n              // make potentially havoced objects non-partial and back.\n              // We don't gain anything from checking whether it's havoced\n              // before calling makePartial() so we'll whitelist this property.\n              propBindingName === \"_isPartial_binding\",\n            \"cannot mutate a havoced object\"\n          );\n          let binding = this[propBindingName];\n          if (binding === undefined) {\n            let desc = { writeable: true, value: undefined };\n            this[propBindingName] = binding = {\n              descriptor: desc,\n              object: this,\n              key: propName,\n              internalSlot: true,\n            };\n          }\n          this.$Realm.recordModifiedProperty(binding);\n          binding.descriptor.value = v;\n        },\n      });\n    }\n  }\n\n  $Prototype: ObjectValue | AbstractObjectValue | NullValue;\n  $Extensible: BooleanValue | AbstractValue;\n\n  $ParameterMap: void | ObjectValue; // undefined when the property is \"missing\"\n  $SymbolData: void | SymbolValue | AbstractValue;\n  $StringData: void | StringValue | AbstractValue;\n  $NumberData: void | NumberValue | AbstractValue;\n  $BooleanData: void | BooleanValue | AbstractValue;\n\n  // error\n  $ErrorData: void | {\n    // undefined when the property is \"missing\"\n    contextStack: Array<ExecutionContext>,\n    locationData: void | {\n      filename: string,\n      sourceCode: string,\n      loc: { line: number, column: number },\n      stackDecorated: boolean,\n    },\n  };\n\n  // function\n  $Call: void | ((thisArgument: Value, argumentsList: Array<Value>) => Value);\n  $Construct: void | ((argumentsList: Array<Value>, newTarget: ObjectValue) => ObjectValue);\n\n  // promise\n  $PromiseState: void | \"pending\" | \"fulfilled\" | \"rejected\";\n  $PromiseResult: void | Value;\n  $PromiseFulfillReactions: void | Array<PromiseReaction>;\n  $PromiseRejectReactions: void | Array<PromiseReaction>;\n  $PromiseIsHandled: void | boolean;\n\n  // iterator\n  $IteratedList: void | Array<Value>;\n  $ListIteratorNextIndex: void | number;\n  $IteratorNext: void | NativeFunctionValue;\n\n  // set\n  $SetIterationKind: void | IterationKind;\n  $SetNextIndex: void | number;\n  $IteratedSet: void | ObjectValue | UndefinedValue;\n  $SetData: void | Array<void | Value>;\n\n  // react\n  $SuperTypeParameters: void | typeAnnotation;\n\n  // map\n  $MapIterationKind: void | IterationKind;\n  $MapNextIndex: void | NumberValue;\n  $MapData: void | Array<{ $Key: void | Value, $Value: void | Value }>;\n  $Map: void | ObjectValue | UndefinedValue;\n\n  // weak map\n  $WeakMapData: void | Array<{ $Key: void | Value, $Value: void | Value }>;\n\n  // weak set\n  $WeakSetData: void | Array<void | Value>;\n\n  // date\n  $DateValue: void | NumberValue | AbstractValue; // of type number\n\n  // array\n  $ArrayIterationKind: void | IterationKind;\n  $ArrayIteratorNextIndex: void | NumberValue;\n  $IteratedObject: void | UndefinedValue | ObjectValue;\n\n  // regex\n  $OriginalSource: void | string;\n  $OriginalFlags: void | string;\n  $RegExpMatcher: void | ((S: string, lastIndex: number) => ?{ endIndex: number, captures: Array<any> });\n\n  // string\n  $StringIteratorNextIndex: void | number;\n  $IteratedString: void | StringValue;\n\n  // data view\n  $DataView: void | true;\n  $ViewedArrayBuffer: void | ObjectValue;\n  $ByteLength: void | number;\n  $ByteOffset: void | number;\n\n  // array buffer\n  $ArrayBufferData: void | null | DataBlock;\n  $ArrayBufferByteLength: void | number;\n\n  // generator\n  $GeneratorState: void | \"suspendedStart\" | \"executing\";\n  $GeneratorContext: void | ExecutionContext;\n\n  // typed array\n  $TypedArrayName: void | TypedArrayKind;\n  $ViewedArrayBuffer: void | ObjectValue;\n  $ArrayLength: void | number;\n\n  // backpointer to the constructor if this object was created its prototype object\n  originalConstructor: void | ECMAScriptSourceFunctionValue;\n\n  // partial objects\n  _isPartial: AbstractValue | BooleanValue;\n\n  // tainted objects\n  _isHavoced: AbstractValue | BooleanValue;\n\n  // If true, the object has no property getters or setters and it is safe\n  // to return AbstractValue for unknown properties.\n  _isSimple: AbstractValue | BooleanValue;\n\n  // If true, it is not safe to perform any more mutations that would change\n  // the object's serialized form.\n  _isFinal: AbstractValue | BooleanValue;\n\n  // Specifies whether the object is a template that needs to be created in a scope\n  // If set, this happened during object initialization and the value is never changed again, so not tracked.\n  _isScopedTemplate: void | true;\n\n  // If true, then unknown properties should return transitively simple abstract object values\n  _simplicityIsTransitive: AbstractValue | BooleanValue;\n\n  // The abstract object for which this object is the template.\n  // Use this instead of the object itself when deriving temporal values for object properties.\n  _templateFor: void | AbstractObjectValue;\n\n  properties: Map<string, PropertyBinding>;\n  symbols: Map<SymbolValue, PropertyBinding>;\n  unknownProperty: void | PropertyBinding;\n  _temporalAlias: void | AbstractObjectValue;\n\n  // An object value with an intrinsic name can either exist from the beginning of time,\n  // or it can be associated with a particular point in time by being used as a template\n  // when deriving an abstract value via a generator.\n  intrinsicNameGenerated: void | true;\n  hashValue: void | number;\n\n  // ReactElement\n  $BailOutReason: void | string;\n\n  // ES2015 classes\n  $IsClassPrototype: boolean;\n\n  // We track some internal state as properties on the global object, these should\n  // never be serialized.\n  refuseSerialization: boolean;\n\n  equals(x: Value): boolean {\n    return this === x;\n  }\n\n  getHash(): number {\n    if (!this.hashValue) {\n      this.hashValue = ++this.$Realm.objectCount;\n    }\n    return this.hashValue;\n  }\n\n  get temporalAlias(): void | AbstractObjectValue {\n    return this._temporalAlias;\n  }\n\n  set temporalAlias(value: AbstractObjectValue) {\n    this._temporalAlias = value;\n  }\n\n  hasStringOrSymbolProperties(): boolean {\n    for (let prop of this.properties.values()) {\n      if (prop.descriptor === undefined) continue;\n      return true;\n    }\n    for (let prop of this.symbols.values()) {\n      if (prop.descriptor === undefined) continue;\n      return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    return false;\n  }\n\n  mightNotBeObject(): boolean {\n    return false;\n  }\n\n  throwIfNotObject(): ObjectValue {\n    return this;\n  }\n\n  makeNotPartial(): void {\n    this._isPartial = this.$Realm.intrinsics.false;\n  }\n\n  makePartial(): void {\n    this._isPartial = this.$Realm.intrinsics.true;\n  }\n\n  makeSimple(option?: string | Value): void {\n    this._isSimple = this.$Realm.intrinsics.true;\n    this._simplicityIsTransitive = new BooleanValue(\n      this.$Realm,\n      option === \"transitive\" || (option instanceof StringValue && option.value === \"transitive\")\n    );\n  }\n\n  makeFinal(): void {\n    this._isFinal = this.$Realm.intrinsics.true;\n  }\n\n  makeNotFinal(): void {\n    this._isFinal = this.$Realm.intrinsics.false;\n  }\n\n  isPartialObject(): boolean {\n    return this._isPartial.mightBeTrue();\n  }\n\n  mightBeFinalObject(): boolean {\n    return this._isFinal.mightBeTrue();\n  }\n\n  mightNotBeFinalObject(): boolean {\n    return this._isFinal.mightNotBeTrue();\n  }\n\n  havoc(): void {\n    this._isHavoced = this.$Realm.intrinsics.true;\n  }\n\n  mightBeHavocedObject(): boolean {\n    return this._isHavoced.mightBeTrue();\n  }\n\n  mightNotBeHavocedObject(): boolean {\n    return this._isHavoced.mightNotBeTrue();\n  }\n\n  isSimpleObject(): boolean {\n    if (!this._isSimple.mightNotBeTrue()) return true;\n    if (this.isPartialObject()) return false;\n    if (this.symbols.size > 0) return false;\n    for (let propertyBinding of this.properties.values()) {\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; // deleted\n      if (!IsDataDescriptor(this.$Realm, desc)) return false;\n      if (!desc.writable) return false;\n    }\n    if (this.$Prototype instanceof NullValue) return true;\n    if (this.$Prototype === this.$Realm.intrinsics.ObjectPrototype) return true;\n    invariant(this.$Prototype);\n    return this.$Prototype.isSimpleObject();\n  }\n\n  isTransitivelySimple(): boolean {\n    return !this._simplicityIsTransitive.mightNotBeTrue();\n  }\n\n  getExtensible(): boolean {\n    return this.$Extensible.throwIfNotConcreteBoolean().value;\n  }\n\n  setExtensible(v: boolean) {\n    this.$Extensible = v ? this.$Realm.intrinsics.true : this.$Realm.intrinsics.false;\n  }\n\n  getKind(): ObjectKind {\n    // we can deduce the natural prototype by checking whether the following internal slots are present\n    if (this.$SymbolData !== undefined) return \"Symbol\";\n    if (this.$StringData !== undefined) return \"String\";\n    if (this.$NumberData !== undefined) return \"Number\";\n    if (this.$BooleanData !== undefined) return \"Boolean\";\n    if (this.$DateValue !== undefined) return \"Date\";\n    if (this.$RegExpMatcher !== undefined) return \"RegExp\";\n    if (this.$SetData !== undefined) return \"Set\";\n    if (this.$MapData !== undefined) return \"Map\";\n    if (this.$DataView !== undefined) return \"DataView\";\n    if (this.$ArrayBufferData !== undefined) return \"ArrayBuffer\";\n    if (this.$WeakMapData !== undefined) return \"WeakMap\";\n    if (this.$WeakSetData !== undefined) return \"WeakSet\";\n    if (isReactElement(this) && this.$Realm.react.enabled) return \"ReactElement\";\n    if (this.$TypedArrayName !== undefined) return this.$TypedArrayName;\n    // TODO #26 #712: Promises. All kinds of iterators. Generators.\n    return \"Object\";\n  }\n\n  defineNativeMethod(\n    name: SymbolValue | string,\n    length: number,\n    callback: NativeFunctionCallback,\n    desc?: Descriptor = {}\n  ): Value {\n    let intrinsicName;\n    if (typeof name === \"string\") {\n      if (this.intrinsicName) intrinsicName = `${this.intrinsicName}.${name}`;\n    } else if (name instanceof SymbolValue) {\n      if (this.intrinsicName && name.intrinsicName) intrinsicName = `${this.intrinsicName}[${name.intrinsicName}]`;\n    } else {\n      invariant(false);\n    }\n    let fnValue = new NativeFunctionValue(this.$Realm, intrinsicName, name, length, callback, false);\n    this.defineNativeProperty(name, fnValue, desc);\n    return fnValue;\n  }\n\n  defineNativeProperty(name: SymbolValue | string, value?: Value | Array<Value>, desc?: Descriptor = {}): void {\n    invariant(!value || value instanceof Value);\n    this.$DefineOwnProperty(name, {\n      value,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      ...desc,\n    });\n  }\n\n  defineNativeGetter(name: SymbolValue | string, callback: NativeFunctionCallback, desc?: Descriptor = {}): void {\n    let intrinsicName, funcName;\n    if (typeof name === \"string\") {\n      funcName = `get ${name}`;\n      if (this.intrinsicName) intrinsicName = `${this.intrinsicName}.${name}`;\n    } else if (name instanceof SymbolValue) {\n      funcName =\n        name.$Description instanceof Value\n          ? `get [${name.$Description.throwIfNotConcreteString().value}]`\n          : `get [${\"?\"}]`;\n      if (this.intrinsicName && name.intrinsicName) intrinsicName = `${this.intrinsicName}[${name.intrinsicName}]`;\n    } else {\n      invariant(false);\n    }\n\n    let func = new NativeFunctionValue(this.$Realm, intrinsicName, funcName, 0, callback);\n    this.$DefineOwnProperty(name, {\n      get: func,\n      set: this.$Realm.intrinsics.undefined,\n      enumerable: false,\n      configurable: true,\n      ...desc,\n    });\n  }\n\n  defineNativeConstant(name: SymbolValue | string, value?: Value | Array<Value>, desc?: Descriptor = {}): void {\n    invariant(!value || value instanceof Value);\n    this.$DefineOwnProperty(name, {\n      value,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n      ...desc,\n    });\n  }\n\n  getOwnPropertyKeysArray(allowAbstractKeys: boolean = false): Array<string> {\n    if (this.isPartialObject() || this.mightBeHavocedObject() || this.unknownProperty !== undefined) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n\n    let keyArray = Array.from(this.properties.keys());\n    keyArray = keyArray.filter(x => {\n      let pb = this.properties.get(x);\n      if (!pb || pb.descriptor === undefined) return false;\n      let pv = pb.descriptor.value;\n      if (pv === undefined) return true;\n      invariant(pv instanceof Value);\n      if (!pv.mightHaveBeenDeleted()) return true;\n      // The property may or may not be there at runtime.\n      // We can at best return an abstract keys array.\n      // For now, unless the caller has told us that is okay,\n      // just terminate.\n      invariant(pv instanceof AbstractValue);\n      if (allowAbstractKeys) return true;\n      AbstractValue.reportIntrospectionError(pv);\n      throw new FatalError();\n    });\n    this.$Realm.callReportObjectGetOwnProperties(this);\n    return keyArray;\n  }\n\n  // Note that internal properties will not be copied to the snapshot, nor will they be removed.\n  getSnapshot(options?: { removeProperties: boolean }): AbstractObjectValue {\n    try {\n      if (this.temporalAlias !== undefined) return this.temporalAlias;\n      invariant(!this.isPartialObject());\n      let template = new ObjectValue(this.$Realm, this.$Realm.intrinsics.ObjectPrototype);\n      this.copyKeys(this.$OwnPropertyKeys(), this, template);\n      let realm = this.$Realm;\n      // The snapshot is an immutable object snapshot\n      template.makeFinal();\n      // The original object might be a React props object, thus\n      // if it is, we need to ensure we mark it with the same rules\n      if (realm.react.enabled && realm.react.reactProps.has(this)) {\n        realm.react.reactProps.add(template);\n      }\n      let result = AbstractValue.createTemporalFromBuildFunction(this.$Realm, ObjectValue, [template], ([x]) => x, {\n        skipInvariant: true,\n        isPure: true,\n      });\n      invariant(result instanceof AbstractObjectValue);\n      result.values = new ValuesDomain(template);\n      return result;\n    } finally {\n      if (options && options.removeProperties) {\n        this.properties = new Map();\n        this.symbols = new Map();\n        this.unknownProperty = undefined;\n      }\n    }\n  }\n\n  copyKeys(keys: Array<PropertyKeyValue>, from: ObjectValue, to: ObjectValue): void {\n    // c. Repeat for each element nextKey of keys in List order,\n    for (let nextKey of keys) {\n      // i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n      let desc = from.$GetOwnProperty(nextKey);\n\n      // ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n      if (desc && desc.enumerable) {\n        Properties.ThrowIfMightHaveBeenDeleted(desc.value);\n\n        // 1. Let propValue be ? Get(from, nextKey).\n        let propValue = Get(this.$Realm, from, nextKey);\n\n        // 2. Perform ? Set(to, nextKey, propValue, true).\n        Properties.Set(this.$Realm, to, nextKey, propValue, true);\n      }\n    }\n  }\n\n  _serialize(set: Function, stack: Map<Value, any>): any {\n    let obj = set({});\n\n    for (let [key, propertyBinding] of this.properties) {\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; // deleted\n      Properties.ThrowIfMightHaveBeenDeleted(desc.value);\n      let serializedDesc: any = { enumerable: desc.enumerable, configurable: desc.configurable };\n      if (desc.value) {\n        serializedDesc.writable = desc.writable;\n        invariant(desc.value instanceof Value);\n        serializedDesc.value = desc.value.serialize(stack);\n      } else {\n        invariant(desc.get !== undefined);\n        serializedDesc.get = desc.get.serialize(stack);\n        invariant(desc.set !== undefined);\n        serializedDesc.set = desc.set.serialize(stack);\n      }\n      Object.defineProperty(obj, key, serializedDesc);\n    }\n    return obj;\n  }\n\n  // Whether [[{Get,Set}PrototypeOf]] delegate to Ordinary{Get,Set}PrototypeOf.\n  // E.g. ProxyValue overrides this to return false.\n  // See ECMA262 9.1.2.1 for an algorithm where this is relevant\n  usesOrdinaryObjectInternalPrototypeMethods(): boolean {\n    return true;\n  }\n\n  // ECMA262 9.1.1\n  $GetPrototypeOf(): ObjectValue | AbstractObjectValue | NullValue {\n    return this.$Prototype;\n  }\n\n  // ECMA262 9.1.2\n  $SetPrototypeOf(V: ObjectValue | NullValue): boolean {\n    // 1. Return ! OrdinarySetPrototypeOf(O, V).\n    return Properties.OrdinarySetPrototypeOf(this.$Realm, this, V);\n  }\n\n  // ECMA262 9.1.3\n  $IsExtensible(): boolean {\n    // 1. Return ! OrdinaryIsExtensible(O).\n    return OrdinaryIsExtensible(this.$Realm, this);\n  }\n\n  // ECMA262 9.1.4\n  $PreventExtensions(): boolean {\n    // 1. Return ! OrdinaryPreventExtensions(O).\n    return OrdinaryPreventExtensions(this.$Realm, this);\n  }\n\n  // ECMA262 9.1.5\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    // 1. Return ! OrdinaryGetOwnProperty(O, P).\n    return Properties.OrdinaryGetOwnProperty(this.$Realm, this, P);\n  }\n\n  // ECMA262 9.1.6\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    // 1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).\n    return Properties.OrdinaryDefineOwnProperty(this.$Realm, this, P, Desc);\n  }\n\n  // ECMA262 9.1.7\n  $HasProperty(P: PropertyKeyValue): boolean {\n    if (this.unknownProperty !== undefined && this.$GetOwnProperty(P) === undefined) {\n      AbstractValue.reportIntrospectionError(this, P);\n      throw new FatalError();\n    }\n\n    return OrdinaryHasProperty(this.$Realm, this, P);\n  }\n\n  // ECMA262 9.1.8\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let prop = this.unknownProperty;\n    if (prop !== undefined && prop.descriptor !== undefined && this.$GetOwnProperty(P) === undefined) {\n      let desc = prop.descriptor;\n      invariant(desc !== undefined);\n      let val = desc.value;\n      invariant(val instanceof AbstractValue);\n      let propValue;\n      if (P instanceof StringValue) {\n        propValue = P;\n      } else if (typeof P === \"string\") {\n        propValue = new StringValue(this.$Realm, P);\n      }\n\n      if (val.kind === \"widened numeric property\") {\n        invariant(Receiver instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(Receiver));\n        let propName;\n        if (P instanceof StringValue) {\n          propName = P.value;\n        } else {\n          propName = P;\n        }\n        return GetFromArrayWithWidenedNumericProperty(this.$Realm, Receiver, propName);\n      } else if (!propValue) {\n        AbstractValue.reportIntrospectionError(val, \"abstract computed property name\");\n        throw new FatalError();\n      }\n      return this.specializeJoin(val, propValue);\n    }\n\n    // 1. Return ? OrdinaryGet(O, P, Receiver).\n    return OrdinaryGet(this.$Realm, this, P, Receiver);\n  }\n\n  _SafeGetDataPropertyValue(P: PropertyKeyValue): Value {\n    let savedInvariantLevel = this.$Realm.invariantLevel;\n    try {\n      this.$Realm.invariantLevel = 0;\n      let desc = this.$GetOwnProperty(P);\n      return desc !== undefined && desc.value instanceof Value ? desc.value : this.$Realm.intrinsics.undefined;\n    } finally {\n      this.$Realm.invariantLevel = savedInvariantLevel;\n    }\n  }\n\n  $GetPartial(P: AbstractValue | PropertyKeyValue, Receiver: Value): Value {\n    if (Receiver instanceof AbstractValue && Receiver.getType() === StringValue && P === \"length\") {\n      return AbstractValue.createFromTemplate(this.$Realm, lengthTemplate, NumberValue, [Receiver], lengthTemplateSrc);\n    }\n\n    if (!(P instanceof AbstractValue)) return this.$Get(P, Receiver);\n\n    // A string coercion might have side-effects.\n    // TODO #1682: We assume that simple objects mean that they don't have a\n    // side-effectful valueOf and toString but that's not enforced.\n    if (P.mightNotBeString() && P.mightNotBeNumber() && !P.isSimpleObject()) {\n      if (this.$Realm.isInPureScope()) {\n        // If we're in pure scope, we can havoc the key and keep going.\n        // Coercion can only have effects on anything reachable from the key.\n        Havoc.value(this.$Realm, P);\n      } else {\n        let error = new CompilerDiagnostic(\n          \"property key might not have a well behaved toString or be a symbol\",\n          this.$Realm.currentLocation,\n          \"PP0002\",\n          \"RecoverableError\"\n        );\n        if (this.$Realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    // We assume that simple objects have no getter/setter properties.\n    if (!this.isSimpleObject()) {\n      if (this.$Realm.isInPureScope()) {\n        // If we're in pure scope, we can havoc the object. Coercion\n        // can only have effects on anything reachable from this object.\n        // We assume that if the receiver is different than this object,\n        // then we only got here because there were no other keys with\n        // this name on other parts of the prototype chain.\n        // TODO #1675: A fix to 1675 needs to take this into account.\n        Havoc.value(this.$Realm, Receiver);\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          Value,\n          [Receiver, P],\n          ([o, p]) => memberExpressionHelper(o, p),\n          { skipInvariant: true, isPure: true }\n        );\n      } else {\n        let error = new CompilerDiagnostic(\n          \"unknown property access might need to invoke a getter\",\n          this.$Realm.currentLocation,\n          \"PP0030\",\n          \"RecoverableError\"\n        );\n        if (this.$Realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    P = To.ToStringAbstract(this.$Realm, P);\n\n    // If all else fails, use this expression\n    // TODO #1675: Check the prototype chain for known properties too.\n    let result;\n    if (this.isPartialObject()) {\n      if (isWidenedValue(P)) {\n        // TODO #1678: Use a snapshot or havoc this object.\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          Value,\n          [this, P],\n          ([o, p]) => memberExpressionHelper(o, p),\n          { skipInvariant: true, isPure: true }\n        );\n      }\n      result = AbstractValue.createFromType(this.$Realm, Value, \"sentinel member expression\", [this, P]);\n    } else {\n      result = AbstractValue.createTemporalFromBuildFunction(\n        this.$Realm,\n        Value,\n        [this, P],\n        ([o, p]) => memberExpressionHelper(o, p),\n        { skipInvariant: true, isPure: true }\n      );\n    }\n\n    // Get a specialization of the join of all values written to the object\n    // with abstract property names.\n    let prop = this.unknownProperty;\n    if (prop !== undefined) {\n      let desc = prop.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        if (val.kind === \"widened numeric property\") {\n          invariant(Receiver instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(Receiver));\n          return GetFromArrayWithWidenedNumericProperty(this.$Realm, Receiver, P instanceof StringValue ? P.value : P);\n        }\n        result = this.specializeJoin(val, P);\n      }\n    }\n    // Join in all of the other values that were written to the object with\n    // concrete property names.\n    for (let [key, propertyBinding] of this.properties) {\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; // deleted\n      invariant(desc.value !== undefined); // otherwise this is not simple\n      let val = desc.value;\n      invariant(val instanceof Value);\n      let cond = AbstractValue.createFromBinaryOp(\n        this.$Realm,\n        \"===\",\n        P,\n        new StringValue(this.$Realm, key),\n        undefined,\n        \"check for known property\"\n      );\n      result = AbstractValue.createFromConditionalOp(this.$Realm, cond, val, result);\n    }\n    return result;\n  }\n\n  specializeJoin(absVal: AbstractValue, propName: Value): Value {\n    if (absVal.kind === \"widened property\") {\n      let ob = absVal.args[0];\n      if (propName instanceof StringValue) {\n        let pName = propName.value;\n        let pNumber = +pName;\n        if (pName === pNumber + \"\") propName = new NumberValue(this.$Realm, pNumber);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(\n        this.$Realm,\n        absVal.getType(),\n        [ob, propName],\n        ([o, p]) => memberExpressionHelper(o, p),\n        { skipInvariant: true, isPure: true }\n      );\n    }\n    invariant(absVal.args.length === 3 && absVal.kind === \"conditional\");\n    let generic_cond = absVal.args[0];\n    invariant(generic_cond instanceof AbstractValue);\n    let cond = this.specializeCond(generic_cond, propName);\n    let arg1 = absVal.args[1];\n    if (arg1 instanceof AbstractValue && arg1.args.length === 3) arg1 = this.specializeJoin(arg1, propName);\n    let arg2 = absVal.args[2];\n    if (arg2 instanceof AbstractValue) {\n      if (arg2.kind === \"template for prototype member expression\") {\n        let ob = arg2.args[0];\n        arg2 = AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          absVal.getType(),\n          [ob, propName],\n          ([o, p]) => memberExpressionHelper(o, p),\n          { skipInvariant: true, isPure: true }\n        );\n      } else if (arg2.args.length === 3) {\n        arg2 = this.specializeJoin(arg2, propName);\n      }\n    }\n    return AbstractValue.createFromConditionalOp(this.$Realm, cond, arg1, arg2, absVal.expressionLocation);\n  }\n\n  specializeCond(absVal: AbstractValue, propName: Value): Value {\n    if (absVal.kind === \"template for property name condition\")\n      return AbstractValue.createFromBinaryOp(this.$Realm, \"===\", absVal.args[0], propName);\n    return absVal;\n  }\n\n  // ECMA262 9.1.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    // 1. Return ? OrdinarySet(O, P, V, Receiver).\n    return Properties.OrdinarySet(this.$Realm, this, P, V, Receiver);\n  }\n\n  $SetPartial(P: AbstractValue | PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    if (!(P instanceof AbstractValue)) return this.$Set(P, V, Receiver);\n    let pIsLoopVar = isWidenedValue(P);\n    let pIsNumeric = Value.isTypeCompatibleWith(P.getType(), NumberValue);\n\n    // A string coercion might have side-effects.\n    // TODO #1682: We assume that simple objects mean that they don't have a\n    // side-effectful valueOf and toString but that's not enforced.\n    if (P.mightNotBeString() && P.mightNotBeNumber() && !P.isSimpleObject()) {\n      if (this.$Realm.isInPureScope()) {\n        // If we're in pure scope, we can havoc the key and keep going.\n        // Coercion can only have effects on anything reachable from the key.\n        Havoc.value(this.$Realm, P);\n      } else {\n        let error = new CompilerDiagnostic(\n          \"property key might not have a well behaved toString or be a symbol\",\n          this.$Realm.currentLocation,\n          \"PP0002\",\n          \"RecoverableError\"\n        );\n        if (this.$Realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    // We assume that simple objects have no getter/setter properties and\n    // that all properties are writable.\n    if (!this.isSimpleObject()) {\n      if (this.$Realm.isInPureScope()) {\n        // If we're in pure scope, we can havoc the object and leave an\n        // assignment in place.\n        Havoc.value(this.$Realm, Receiver);\n        // We also need to havoc the value since it might leak to a setter.\n        Havoc.value(this.$Realm, V);\n        this.$Realm.evaluateWithPossibleThrowCompletion(\n          () => {\n            let generator = this.$Realm.generator;\n            invariant(generator);\n            invariant(P instanceof AbstractValue);\n            generator.emitStatement([Receiver, P, V], ([objectNode, keyNode, valueNode]) =>\n              t.expressionStatement(t.assignmentExpression(\"=\", memberExpressionHelper(objectNode, keyNode), valueNode))\n            );\n            return this.$Realm.intrinsics.undefined;\n          },\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n        // The emitted assignment might throw at runtime but if it does, that\n        // is handled by evaluateWithPossibleThrowCompletion. Anything that\n        // happens after this, can assume we didn't throw and therefore,\n        // we return true here.\n        return true;\n      } else {\n        let error = new CompilerDiagnostic(\n          \"unknown property access might need to invoke a setter\",\n          this.$Realm.currentLocation,\n          \"PP0030\",\n          \"RecoverableError\"\n        );\n        if (this.$Realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    // We should never consult the prototype chain for unknown properties.\n    // If it was simple, it would've been an assignment to the receiver.\n    // The only case the Receiver isn't this, if this was a ToObject\n    // coercion from a PrimitiveValue.\n    invariant(this === Receiver || HasCompatibleType(Receiver, PrimitiveValue));\n\n    P = To.ToStringAbstract(this.$Realm, P);\n\n    function createTemplate(realm: Realm, propName: AbstractValue) {\n      return AbstractValue.createFromBinaryOp(\n        realm,\n        \"===\",\n        propName,\n        new StringValue(realm, \"\"),\n        undefined,\n        \"template for property name condition\"\n      );\n    }\n\n    let prop;\n    if (this.unknownProperty === undefined) {\n      prop = {\n        descriptor: undefined,\n        object: this,\n        key: P,\n      };\n      this.unknownProperty = prop;\n    } else {\n      prop = this.unknownProperty;\n    }\n    this.$Realm.recordModifiedProperty(prop);\n    let desc = prop.descriptor;\n    if (desc === undefined) {\n      let newVal = V;\n      if (!(V instanceof UndefinedValue) && !isWidenedValue(P)) {\n        // join V with sentinel, using a property name test as the condition\n        let cond = createTemplate(this.$Realm, P);\n        let sentinel = AbstractValue.createFromType(this.$Realm, Value, \"template for prototype member expression\", [\n          Receiver,\n          P,\n        ]);\n        newVal = AbstractValue.createFromConditionalOp(this.$Realm, cond, V, sentinel);\n      }\n      prop.descriptor = {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: newVal,\n      };\n    } else {\n      // join V with current value of this.unknownProperty. I.e. weak update.\n      let oldVal = desc.value;\n      invariant(oldVal instanceof Value);\n      let newVal = oldVal;\n      if (!(V instanceof UndefinedValue)) {\n        if (isWidenedValue(P)) {\n          newVal = V; // It will be widened later on\n        } else {\n          let cond = createTemplate(this.$Realm, P);\n          newVal = AbstractValue.createFromConditionalOp(this.$Realm, cond, V, oldVal);\n        }\n      }\n      desc.value = newVal;\n    }\n\n    // Since we don't know the name of the property we are writing to, we also need\n    // to perform weak updates of all of the known properties.\n    // First clear out this.unknownProperty so that helper routines know its OK to update the properties\n    let savedUnknownProperty = this.unknownProperty;\n    this.unknownProperty = undefined;\n    for (let [key, propertyBinding] of this.properties) {\n      if (pIsLoopVar && pIsNumeric) {\n        // Delete numeric properties and don't do weak updates on other properties.\n        if (key !== +key + \"\") continue;\n        this.properties.delete(key);\n        continue;\n      }\n      let oldVal = this.$Realm.intrinsics.empty;\n      if (propertyBinding.descriptor && propertyBinding.descriptor.value) {\n        oldVal = propertyBinding.descriptor.value;\n        invariant(oldVal instanceof Value); // otherwise this is not simple\n      }\n      let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", P, new StringValue(this.$Realm, key));\n      let newVal = AbstractValue.createFromConditionalOp(this.$Realm, cond, V, oldVal);\n      Properties.OrdinarySet(this.$Realm, this, key, newVal, Receiver);\n    }\n    this.unknownProperty = savedUnknownProperty;\n\n    return true;\n  }\n\n  // ECMA262 9.1.10\n  $Delete(P: PropertyKeyValue): boolean {\n    if (this.unknownProperty !== undefined) {\n      // TODO #946: generate a delete from the object\n      AbstractValue.reportIntrospectionError(this, P);\n      throw new FatalError();\n    }\n\n    // 1. Return ? OrdinaryDelete(O, P).\n    return Properties.OrdinaryDelete(this.$Realm, this, P);\n  }\n\n  // ECMA262 9.1.11\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    return OrdinaryOwnPropertyKeys(this.$Realm, this);\n  }\n}\n"]}