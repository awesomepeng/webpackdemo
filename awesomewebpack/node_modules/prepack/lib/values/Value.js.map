{"version":3,"sources":["../../src/values/Value.js"],"names":["Value","constructor","realm","intrinsicName","$Realm","expressionLocation","currentLocation","toDisplayString","name","__originalName","equals","x","getHash","getType","isTypeCompatibleWith","type","Constructor","prototype","implies","val","mightNotBeFalse","mightNotBeTrue","isIntrinsic","isPartialObject","isSimpleObject","mightBeFalse","mightBeNull","mightNotBeNull","mightBeNumber","mightNotBeNumber","mightNotBeObject","mightBeObject","mightBeString","mightNotBeString","mightBeTrue","mightBeUndefined","mightNotBeUndefined","mightHaveBeenDeleted","promoteEmptyToUndefined","throwIfNotConcrete","throwIfNotConcreteNumber","throwIfNotConcreteString","Error","throwIfNotConcreteBoolean","throwIfNotConcreteSymbol","throwIfNotConcreteObject","throwIfNotConcretePrimitive","throwIfNotObject","serialize","stack","Map","has","get","set","_serialize"],"mappings":"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","file":"Value.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport {\n  AbstractObjectValue,\n  BooleanValue,\n  ConcreteValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n} from \"./index.js\";\nimport invariant from \"../invariant.js\";\n\nexport default class Value {\n  constructor(realm: Realm, intrinsicName?: string) {\n    invariant(realm, \"realm required\");\n\n    this.$Realm = realm;\n    this.intrinsicName = intrinsicName;\n    this.expressionLocation = realm.currentLocation;\n  }\n  // Name from original source if existant\n  __originalName: void | string;\n\n  toDisplayString(): string {\n    return (\n      \"[\" + this.constructor.name + \" originally; \" + (this.__originalName ? this.__originalName : \"undefined\") + \"]\"\n    );\n  }\n\n  equals(x: Value): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  getHash(): number {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  getType(): typeof Value {\n    return this.constructor;\n  }\n\n  static isTypeCompatibleWith(type: typeof Value, Constructor: typeof Value): boolean {\n    return (type: any).prototype instanceof Constructor || (type: any).prototype === Constructor.prototype;\n  }\n\n  intrinsicName: void | string;\n\n  // The source location of the expression that first produced this value.\n  expressionLocation: ?BabelNodeSourceLocation;\n  $Realm: Realm;\n\n  implies(val: Value): boolean {\n    if (this.equals(val)) return true;\n    if (!this.mightNotBeFalse()) return true;\n    if (!val.mightNotBeTrue()) return true;\n    return false;\n  }\n\n  isIntrinsic(): boolean {\n    return !!this.intrinsicName;\n  }\n\n  isPartialObject(): boolean {\n    return false;\n  }\n\n  isSimpleObject(): boolean {\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeFalse(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeNull(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeNull(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeNumber(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeNumber(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeObject(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeObject(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeString(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeString(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightBeTrue(): boolean {\n    return this.mightNotBeFalse();\n  }\n\n  mightNotBeTrue(): boolean {\n    return this.mightBeFalse();\n  }\n\n  mightBeUndefined(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightNotBeUndefined(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  mightHaveBeenDeleted(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  promoteEmptyToUndefined(): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcrete(): ConcreteValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcreteNumber(): NumberValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcreteString(): StringValue {\n    throw new Error(\"abstract method; please override\");\n  }\n\n  throwIfNotConcreteBoolean(): BooleanValue {\n    throw new Error(\"abstract method; please override\");\n  }\n\n  throwIfNotConcreteSymbol(): SymbolValue {\n    throw new Error(\"abstract method; please override\");\n  }\n\n  throwIfNotConcreteObject(): ObjectValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotConcretePrimitive(): PrimitiveValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  throwIfNotObject(): ObjectValue | AbstractObjectValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  serialize(stack: Map<Value, any> = new Map()): any {\n    if (stack.has(this)) {\n      return stack.get(this);\n    } else {\n      let set = val => {\n        stack.set(this, val);\n        return val;\n      };\n\n      return set(this._serialize(set, stack));\n    }\n  }\n\n  _serialize(set: Function, stack: Map<Value, any>): any {\n    invariant(false, \"abstract method; please override\");\n  }\n}\n"]}