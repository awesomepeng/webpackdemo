{"version":3,"sources":["../../src/values/IntegerIndexedExotic.js"],"names":["IntegerIndexedExotic","constructor","realm","intrinsicName","intrinsics","ObjectPrototype","$GetOwnProperty","P","O","$Realm","$ViewedArrayBuffer","numericIndex","CanonicalNumericIndexString","undefined","value","writable","enumerable","configurable","OrdinaryGetOwnProperty","$HasProperty","buffer","createErrorThrowCompletion","TypeError","Object","is","$ArrayLength","$DefineOwnProperty","Desc","length","OrdinaryDefineOwnProperty","$Get","Receiver","$Set","V","OrdinarySet","$OwnPropertyKeys","keys","$ByteOffset","$TypedArrayName","len","i","push","ToString","properties","getOwnPropertyKeysArray","key","filter","x","symbols"],"mappings":"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","file":"IntegerIndexedExotic.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue, Descriptor } from \"../types.js\";\nimport { ObjectValue, NumberValue, StringValue, Value, UndefinedValue } from \"../values/index.js\";\nimport { IsInteger, IsArrayIndex, IsAccessorDescriptor, IsDetachedBuffer, IsPropertyKey } from \"../methods/is.js\";\nimport { OrdinaryGet } from \"../methods/get.js\";\nimport { OrdinaryHasProperty } from \"../methods/has.js\";\nimport { IntegerIndexedElementSet, IntegerIndexedElementGet } from \"../methods/typedarray.js\";\nimport { Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant\";\n\nexport default class IntegerIndexedExotic extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ObjectPrototype, intrinsicName);\n  }\n\n  // ECMA262 9.4.5.1\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O instanceof ObjectValue && O.$ViewedArrayBuffer);\n\n    // 3. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = To.CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Let value be ? IntegerIndexedElementGet(O, numericIndex).\n        let value = IntegerIndexedElementGet(this.$Realm, O, numericIndex);\n\n        // ii. If value is undefined, return undefined.\n        if (value instanceof UndefinedValue) return undefined;\n\n        // iii. Return a PropertyDescriptor{[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false}.\n        return {\n          value: value,\n          writable: true,\n          enumerable: true,\n          configurable: false,\n        };\n      }\n    }\n    // 4. Return OrdinaryGetOwnProperty(O, P).\n    return Properties.OrdinaryGetOwnProperty(this.$Realm, O, P);\n  }\n\n  // ECMA262 9.4.5.2\n  $HasProperty(P: PropertyKeyValue): boolean {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O instanceof ObjectValue && O.$ViewedArrayBuffer);\n\n    // 3. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = To.CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Let buffer be O.[[ViewedArrayBuffer]].\n        let buffer = O.$ViewedArrayBuffer;\n        invariant(buffer);\n\n        // ii. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(this.$Realm, buffer) === true) {\n          throw this.$Realm.createErrorThrowCompletion(\n            this.$Realm.intrinsics.TypeError,\n            \"IsDetachedBuffer(buffer) is true\"\n          );\n        }\n\n        // iii. If IsInteger(numericIndex) is false, return false.\n        if (IsInteger(this.$Realm, numericIndex) === false) return false;\n\n        // iv. If numericIndex = -0, return false.\n        if (Object.is(numericIndex, -0)) return false;\n\n        // v. If numericIndex < 0, return false.\n        if (numericIndex < 0) return false;\n\n        // vi. If numericIndex ≥ O.[[ArrayLength]], return false.\n        invariant(O.$ArrayLength);\n        if (numericIndex >= O.$ArrayLength) return false;\n\n        // vii. Return true.\n        return true;\n      }\n    }\n\n    // 4. Return ? OrdinaryHasProperty(O, P).\n    return OrdinaryHasProperty(this.$Realm, O, P);\n  }\n\n  // ECMA262 9.4.5.3\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. Assert: O is an Object that has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O instanceof ObjectValue && this.$ViewedArrayBuffer);\n\n    // 3. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = To.CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. If IsInteger(numericIndex) is false, return false.\n        if (IsInteger(this.$Realm, numericIndex) === false) return false;\n\n        // ii. If numericIndex = -0, return false.\n        if (Object.is(numericIndex, -0)) return false;\n\n        // iii. If numericIndex < 0, return false.\n        if (numericIndex < 0) return false;\n\n        // iv. Let length be O.[[ArrayLength]].\n        let length = this.$ArrayLength;\n        invariant(typeof length === \"number\");\n\n        // v. If numericIndex ≥ length, return false.\n        if (numericIndex >= length) return false;\n\n        // vi. If IsAccessorDescriptor(Desc) is true, return false.\n        if (IsAccessorDescriptor(this.$Realm, Desc) === true) return false;\n\n        // vii. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is true, return false.\n        if (Desc.configurable === true) return false;\n\n        // viii. If Desc has an [[Enumerable]] field and if Desc.[[Enumerable]] is false, return false.\n        if (Desc.enumerable === false) return false;\n\n        // ix. If Desc has a [[Writable]] field and if Desc.[[Writable]] is false, return false.\n        if (Desc.writable === false) return false;\n\n        // x. If Desc has a [[Value]] field, then\n        if (Desc.value) {\n          // 1. Let value be Desc.[[Value]].\n          let value = Desc.value;\n          invariant(value === undefined || value instanceof Value);\n\n          // 2. Return ? IntegerIndexedElementSet(O, numericIndex, value).\n          return IntegerIndexedElementSet(this.$Realm, O, numericIndex, value);\n        }\n\n        // xi. Return true.\n        return true;\n      }\n    }\n\n    // 4. Return ! OrdinaryDefineOwnProperty(O, P, Desc).\n    return Properties.OrdinaryDefineOwnProperty(this.$Realm, O, P, Desc);\n  }\n\n  // ECMA262 9.4.5.4\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = To.CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Return ? IntegerIndexedElementGet(O, numericIndex).\n        return IntegerIndexedElementGet(this.$Realm, O, numericIndex);\n      }\n    }\n\n    // 3. Return ? OrdinaryGet(O, P, Receiver).\n    return OrdinaryGet(this.$Realm, O, P, Receiver);\n  }\n\n  // ECMA262 9.4.5.5\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"IsPropertyKey(P) is true\");\n\n    // 2. If Type(P) is String, then\n    if (typeof P === \"string\" || P instanceof StringValue) {\n      // a. Let numericIndex be ! CanonicalNumericIndexString(P).\n      let numericIndex = To.CanonicalNumericIndexString(\n        this.$Realm,\n        typeof P === \"string\" ? new StringValue(this.$Realm, P) : P\n      );\n\n      // b. If numericIndex is not undefined, then\n      if (numericIndex !== undefined) {\n        // i. Return ? IntegerIndexedElementSet(O, numericIndex, V).\n        return IntegerIndexedElementSet(this.$Realm, O, numericIndex, V);\n      }\n    }\n\n    // 3. Return ? OrdinarySet(O, P, V, Receiver).\n    return Properties.OrdinarySet(this.$Realm, O, P, V, Receiver);\n  }\n\n  // ECMA262 9.4.5.6\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    let O = this;\n\n    // 1. Let keys be a new empty List.\n    let keys = [];\n\n    // 2. Assert: O is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.\n    invariant(\n      O instanceof ObjectValue &&\n        O.$ViewedArrayBuffer &&\n        O.$ArrayLength !== undefined &&\n        O.$ByteOffset !== undefined &&\n        O.$TypedArrayName\n    );\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. For each integer i starting with 0 such that i < len, in ascending order,\n    for (let i = 0; i < len; ++i) {\n      // a. Add ! ToString(i) as the last element of keys.\n      keys.push(new StringValue(this.$Realm, To.ToString(this.$Realm, new NumberValue(this.$Realm, i))));\n    }\n\n    // 5. For each own property key P of O such that Type(P) is String and P is not an integer index, in ascending chronological order of property creation\n    let properties = O.getOwnPropertyKeysArray();\n    for (let key of properties.filter(x => !IsArrayIndex(this.$Realm, x))) {\n      // i. Add P as the last element of keys.\n      keys.push(new StringValue(this.$Realm, key));\n    }\n\n    // 6. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation\n    for (let key of O.symbols.keys()) {\n      // a. Add P as the last element of keys.\n      keys.push(key);\n    }\n\n    // 7. Return keys.\n    return keys;\n  }\n}\n"]}