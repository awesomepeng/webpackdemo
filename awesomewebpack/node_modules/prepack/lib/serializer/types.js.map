{"version":3,"sources":["../../src/serializer/types.js"],"names":["AreSameResidualBinding","realm","x","y","serializedValue","value","BodyReference","constructor","body","index","isNotEarlierThan","other","ReactStatistics","optimizedTrees","inlinedComponents","evaluatedRootNodes","componentsEvaluated","optimizedNestedClosures"],"mappings":";;;;;;QAwIgBA,sB,GAAAA,sB;;AA7HhB;;AACA;;AAGA;;AACA;;AACA;;;;AAEA;;;;AAIA;;;AA8CA;AACA;AACA;AAvEA;;;;;;;;;AASA;;AA+HO,SAASA,sBAAT,CAAgCC,KAAhC,EAA8CC,CAA9C,EAA0EC,CAA1E,EAA+G;AACpH,MAAID,EAAEE,eAAF,KAAsBD,EAAEC,eAA5B,EAA6C,OAAO,IAAP;AAC7C,MAAIF,EAAEG,KAAF,IAAWH,EAAEG,KAAF,KAAYF,EAAEE,KAA7B,EAAoC,OAAO,IAAP;AACpC,MAAIH,EAAEG,KAAF,oCAAoCF,EAAEE,KAAF,gCAAxC,EAA0E;AACxE,WAAO,yBAAUJ,KAAV,EAAiBC,EAAEG,KAAnB,EAA0BF,EAAEE,KAA5B,CAAP;AACD;AACD,SAAO,KAAP;AACD;;AAEM,MAAMC,aAAN,CAAoB;AACzBC,cAAYC,IAAZ,EAAkCC,KAAlC,EAAiD;AAC/C,6BAAUA,SAAS,CAAnB;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACD;AACDC,mBAAiBC,KAAjB,EAAgD;AAC9C,WAAO,KAAKH,IAAL,KAAcG,MAAMH,IAApB,IAA4B,KAAKC,KAAL,IAAcE,MAAMF,KAAvD;AACD;AARwB;;QAAdH,a,GAAAA,a;AA6BN,MAAMM,eAAN,CAAsB;AAC3BL,gBAAc;AACZ,SAAKM,cAAL,GAAsB,CAAtB;AACA,SAAKC,iBAAL,GAAyB,CAAzB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,mBAAL,GAA2B,CAA3B;AACA,SAAKC,uBAAL,GAA+B,CAA/B;AACD;AAP0B;;QAAhBL,e,GAAAA,e","file":"types.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { DeclarativeEnvironmentRecord, type Binding } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, ObjectValue, Value } from \"../values/index.js\";\nimport type { ECMAScriptSourceFunctionValue, FunctionValue } from \"../values/index.js\";\nimport type { BabelNodeExpression, BabelNodeStatement, BabelNodeMemberExpression } from \"babel-types\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Realm, type Effects } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\nimport type { Generator } from \"../utils/generator.js\";\nimport { type SerializerStatistics } from \"./statistics.js\";\n\nexport type TryQuery<T> = (f: () => T, defaultValue: T) => T;\n\n// TODO: add type for additional functions.\nexport type SerializedBodyType =\n  | \"MainGenerator\"\n  | \"Generator\"\n  | \"AdditionalFunction\"\n  | \"DelayInitializations\"\n  | \"ConditionalAssignmentBranch\"\n  | \"LazyObjectInitializer\";\n\nexport type SerializedBody = {\n  type: SerializedBodyType,\n  entries: Array<BabelNodeStatement>,\n  done: boolean,\n  declaredValues?: Map<AbstractValue | ObjectValue, SerializedBody>,\n  parentBody?: SerializedBody,\n  nestingLevel?: number,\n  processing?: boolean,\n};\n\nexport type AdditionalFunctionEffects = {\n  // All of these effects must be applied for this additional function\n  // to be properly setup\n  parentAdditionalFunction: FunctionValue | void,\n  effects: Effects,\n  generator: Generator,\n  transforms: Array<(body: Array<BabelNodeStatement>) => void>,\n  additionalRoots: Set<ObjectValue>,\n};\n\nexport type WriteEffects = Map<FunctionValue, AdditionalFunctionEffects>;\n\nexport type AdditionalFunctionInfo = {\n  functionValue: FunctionValue,\n  modifiedBindings: Map<Binding, ResidualFunctionBinding>,\n  instance: FunctionInstance,\n};\n\nexport type ClassMethodInstance = {|\n  classPrototype: ObjectValue,\n  methodType: \"constructor\" | \"method\" | \"get\" | \"set\",\n  classSuperNode: void | BabelNodeIdentifier,\n  classMethodIsStatic: boolean,\n  classMethodKeyNode: void | BabelNodeExpression,\n  classMethodComputed: boolean,\n|};\n\n// Each of these will correspond to a different preludeGenerator and thus will\n// have different values available for initialization. FunctionValues should\n// only be additional functions.\nexport type ReferentializationScope = FunctionValue | \"GLOBAL\";\n\nexport type FunctionInstance = {\n  residualFunctionBindings: Map<string, ResidualFunctionBinding>,\n  functionValue: ECMAScriptSourceFunctionValue,\n  insertionPoint?: BodyReference,\n  // Additional function that the function instance was declared inside of (if any)\n  containingAdditionalFunction?: FunctionValue,\n  scopeInstances: Map<string, ScopeBinding>,\n  initializationStatements: Array<BabelNodeStatement>,\n};\n\nexport type FunctionInfo = {\n  depth: number,\n  lexicalDepth: number,\n  unbound: Map<string, Array<BabelNodeIdentifier>>,\n  requireCalls: Map<BabelNode, number | string>,\n  modified: Set<string>,\n  usesArguments: boolean,\n  usesThis: boolean,\n};\n\nexport type LazilyHoistedNodes = {|\n  id: BabelNodeIdentifier,\n  createElementIdentifier: null | BabelNodeIdentifier,\n  nodes: Array<{ id: BabelNodeIdentifier, astNode: BabelNode }>,\n|};\n\nexport type FactoryFunctionInfo = {\n  factoryId: BabelNodeIdentifier,\n  functionInfo: FunctionInfo,\n  anyContainingAdditionalFunction: boolean,\n};\n\nexport type ResidualFunctionBinding = {\n  name: string,\n  value: void | Value,\n  modified: boolean,\n  hasLeaked: boolean,\n  // null means a global binding\n  declarativeEnvironmentRecord: null | DeclarativeEnvironmentRecord,\n  // The serializedValue is only not yet present during the initialization of a binding that involves recursive dependencies.\n  serializedValue?: void | BabelNodeExpression,\n  serializedUnscopedLocation?: void | BabelNodeIdentifier | BabelNodeMemberExpression,\n  referentialized?: boolean,\n  scope?: ScopeBinding,\n  // Which additional functions a binding is accessed by. (Determines what initializer\n  // to put the binding in -- global or additional function)\n  potentialReferentializationScopes: Set<ReferentializationScope>,\n  // If the binding is overwritten by an additional function, these contain the\n  // new values\n  // TODO #1087: make this a map and support arbitrary binding modifications\n  additionalFunctionOverridesValue?: FunctionValue,\n};\n\nexport type ScopeBinding = {\n  name: string,\n  id: number,\n  initializationValues: Array<BabelNodeExpression>,\n  leakedIds: Array<BabelNodeIdentifier>,\n  capturedScope?: string,\n  referentializationScope: ReferentializationScope,\n};\n\nexport function AreSameResidualBinding(realm: Realm, x: ResidualFunctionBinding, y: ResidualFunctionBinding): boolean {\n  if (x.serializedValue === y.serializedValue) return true;\n  if (x.value && x.value === y.value) return true;\n  if (x.value instanceof ConcreteValue && y.value instanceof ConcreteValue) {\n    return SameValue(realm, x.value, y.value);\n  }\n  return false;\n}\n\nexport class BodyReference {\n  constructor(body: SerializedBody, index: number) {\n    invariant(index >= 0);\n    this.body = body;\n    this.index = index;\n  }\n  isNotEarlierThan(other: BodyReference): boolean {\n    return this.body === other.body && this.index >= other.index;\n  }\n  body: SerializedBody;\n  index: number;\n}\n\nexport type ReactEvaluatedNode = {\n  children: Array<ReactEvaluatedNode>,\n  message: string,\n  name: string,\n  status:\n    | \"ROOT\"\n    | \"NEW_TREE\"\n    | \"INLINED\"\n    | \"BAIL-OUT\"\n    | \"FATAL\"\n    | \"UNKNOWN_TYPE\"\n    | \"RENDER_PROPS\"\n    | \"FORWARD_REF\"\n    | \"NORMAL\",\n};\n\nexport class ReactStatistics {\n  constructor() {\n    this.optimizedTrees = 0;\n    this.inlinedComponents = 0;\n    this.evaluatedRootNodes = [];\n    this.componentsEvaluated = 0;\n    this.optimizedNestedClosures = 0;\n  }\n  optimizedTrees: number;\n  inlinedComponents: number;\n  evaluatedRootNodes: Array<ReactEvaluatedNode>;\n  componentsEvaluated: number;\n  optimizedNestedClosures: number;\n}\n\nexport type LocationService = {\n  getContainingAdditionalFunction: FunctionValue => void | FunctionValue,\n  getLocation: Value => BabelNodeIdentifier,\n  createLocation: (void | FunctionValue) => BabelNodeIdentifier,\n  createFunction: (void | FunctionValue, Array<BabelNodeStatement>) => BabelNodeIdentifier,\n};\n\nexport type ObjectRefCount = {\n  inComing: number, // The number of objects that references this object.\n  outGoing: number, // The number of objects that are referenced by this object.\n};\n\nexport type SerializedResult = {\n  code: string,\n  map: void | SourceMap,\n  statistics?: SerializerStatistics,\n  reactStatistics?: ReactStatistics,\n  heapGraph?: string,\n};\n"]}