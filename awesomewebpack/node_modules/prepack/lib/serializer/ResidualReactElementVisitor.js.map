{"version":3,"sources":["../../src/serializer/ResidualReactElementVisitor.js"],"names":["ResidualReactElementVisitor","constructor","realm","residualHeapVisitor","reactOutput","react","output","reactEquivalenceSet","reactElementEquivalenceSet","reactPropsEquivalenceSet","visitReactElement","reactElement","reactElementData","reactElements","get","undefined","firstRenderOnly","isReactFragment","visitType","typeValue","reactElementStringTypeReferences","has","value","reference","visitValue","visitKey","keyValue","visitRef","refValue","visitAbstractOrPartialProps","propsValue","visitConcreteProps","propName","binding","properties","descriptor","propValue","visitChildNode","childValue","reactLibraryObject","_getReactLibraryValue","createElement","reactCreateElement","_visitInUnrelatedScope","globalGenerator","withCleanEquivalenceSet","func","wasTemporalAliasDeclaredInCurrentScope","temporalAlias","scope","values","i","_entries","length","entry","declared","fbLibraries"],"mappings":"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","file":"ResidualReactElementVisitor.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  FunctionValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  Value,\n} from \"../values/index.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\nimport { determineIfReactElementCanBeHoisted } from \"../react/hoisting.js\";\nimport { traverseReactElement } from \"../react/elements.js\";\nimport {\n  canExcludeReactElementObjectProperty,\n  getProperty,\n  getReactSymbol,\n  hardModifyReactObjectPropertyBinding,\n} from \"../react/utils.js\";\nimport invariant from \"../invariant.js\";\nimport { TemporalBuildNodeEntry } from \"../utils/generator.js\";\nimport { ReactEquivalenceSet } from \"../react/ReactEquivalenceSet.js\";\nimport { ReactElementSet } from \"../react/ReactElementSet.js\";\nimport { ReactPropsSet } from \"../react/ReactPropsSet.js\";\nimport type { ReactOutputTypes } from \"../options.js\";\nimport { Get } from \"../methods/index.js\";\n\nexport class ResidualReactElementVisitor {\n  constructor(realm: Realm, residualHeapVisitor: ResidualHeapVisitor) {\n    this.realm = realm;\n    this.residualHeapVisitor = residualHeapVisitor;\n    this.reactOutput = realm.react.output || \"create-element\";\n    this.reactEquivalenceSet = new ReactEquivalenceSet(realm, this);\n    this.reactElementEquivalenceSet = new ReactElementSet(realm, this.reactEquivalenceSet);\n    this.reactPropsEquivalenceSet = new ReactPropsSet(realm, this.reactEquivalenceSet);\n  }\n\n  realm: Realm;\n  residualHeapVisitor: ResidualHeapVisitor;\n  reactOutput: ReactOutputTypes;\n  reactEquivalenceSet: ReactEquivalenceSet;\n  reactElementEquivalenceSet: ReactElementSet;\n  reactPropsEquivalenceSet: ReactPropsSet;\n\n  visitReactElement(reactElement: ObjectValue): void {\n    let reactElementData = this.realm.react.reactElements.get(reactElement);\n    invariant(reactElementData !== undefined);\n    let { firstRenderOnly } = reactElementData;\n    let isReactFragment = false;\n\n    traverseReactElement(this.realm, reactElement, {\n      visitType: (typeValue: Value) => {\n        let reactElementStringTypeReferences = this.realm.react.reactElementStringTypeReferences;\n\n        // If the type is a text value, and we have a derived reference for it\n        // then use that derived reference instead of the string value. This is\n        // primarily designed around RCTView and RCTText, which are string values\n        // for RN apps, but are treated as special host components.\n        if (typeValue instanceof StringValue && reactElementStringTypeReferences.has(typeValue.value)) {\n          let reference = reactElementStringTypeReferences.get(typeValue.value);\n          invariant(reference instanceof AbstractValue);\n          hardModifyReactObjectPropertyBinding(this.realm, reactElement, \"type\", reference);\n          this.residualHeapVisitor.visitValue(reference);\n          return;\n        }\n        isReactFragment =\n          typeValue instanceof SymbolValue && typeValue === getReactSymbol(\"react.fragment\", this.realm);\n        // we don't want to visit fragments as they are internal values\n        if (!isReactFragment) {\n          this.residualHeapVisitor.visitValue(typeValue);\n        }\n      },\n      visitKey: (keyValue: Value) => {\n        this.residualHeapVisitor.visitValue(keyValue);\n      },\n      visitRef: (refValue: Value) => {\n        if (!firstRenderOnly) {\n          this.residualHeapVisitor.visitValue(refValue);\n        }\n      },\n      visitAbstractOrPartialProps: (propsValue: AbstractValue | ObjectValue) => {\n        this.residualHeapVisitor.visitValue(propsValue);\n      },\n      visitConcreteProps: (propsValue: ObjectValue) => {\n        for (let [propName, binding] of propsValue.properties) {\n          invariant(propName !== \"key\" && propName !== \"ref\", `\"${propName}\" is a reserved prop name`);\n          if (binding.descriptor === undefined || propName === \"children\") {\n            continue;\n          }\n          let propValue = getProperty(this.realm, propsValue, propName);\n          if (canExcludeReactElementObjectProperty(this.realm, reactElement, propName, propValue)) {\n            continue;\n          }\n          this.residualHeapVisitor.visitValue(propValue);\n        }\n      },\n      visitChildNode: (childValue: Value) => {\n        this.residualHeapVisitor.visitValue(childValue);\n      },\n    });\n\n    // Our serializer requires that every value we serialize must first be visited in every scope where it appears. In\n    // our React element serializer we serialize some values (namely `React.createElement` and `React.Fragment`) that do\n    // not necessarily appear in our source code. We must manually visit these values in our visitor pass for the values\n    // to be serializable.\n    if (this.realm.react.output === \"create-element\") {\n      const reactLibraryObject = this._getReactLibraryValue();\n      invariant(reactLibraryObject instanceof ObjectValue);\n      const createElement = reactLibraryObject.properties.get(\"createElement\");\n      invariant(createElement !== undefined);\n      const reactCreateElement = Get(this.realm, reactLibraryObject, \"createElement\");\n      // Our `createElement` value will be used in the prelude of the optimized function we serialize to initialize\n      // our hoisted React elements. So we need to ensure that we visit our value in a scope above our own to allow\n      // the function to be used in our optimized function prelude. We use our global scope to accomplish this. We are\n      // a \"friend\" class of `ResidualHeapVisitor` so we call one of its private methods.\n      this.residualHeapVisitor._visitInUnrelatedScope(this.residualHeapVisitor.globalGenerator, reactCreateElement);\n    }\n    if (isReactFragment) {\n      const reactLibraryObject = this._getReactLibraryValue();\n      // Our `React.Fragment` value will be used in the function to lazily initialize hoisted JSX elements. So we need\n      // to visit the library in our global generator so that it is available when creating the hoisted elements.\n      this.residualHeapVisitor._visitInUnrelatedScope(this.residualHeapVisitor.globalGenerator, reactLibraryObject);\n    }\n\n    // determine if this ReactElement node tree is going to be hoistable\n    determineIfReactElementCanBeHoisted(this.realm, reactElement, this.residualHeapVisitor);\n  }\n\n  withCleanEquivalenceSet(func: () => void): void {\n    let reactEquivalenceSet = this.reactEquivalenceSet;\n    let reactElementEquivalenceSet = this.reactElementEquivalenceSet;\n    let reactPropsEquivalenceSet = this.reactPropsEquivalenceSet;\n    this.reactEquivalenceSet = new ReactEquivalenceSet(this.realm, this);\n    this.reactElementEquivalenceSet = new ReactElementSet(this.realm, this.reactEquivalenceSet);\n    this.reactPropsEquivalenceSet = new ReactPropsSet(this.realm, this.reactEquivalenceSet);\n    func();\n    // Cleanup\n    this.reactEquivalenceSet = reactEquivalenceSet;\n    this.reactElementEquivalenceSet = reactElementEquivalenceSet;\n    this.reactPropsEquivalenceSet = reactPropsEquivalenceSet;\n  }\n\n  wasTemporalAliasDeclaredInCurrentScope(temporalAlias: AbstractObjectValue): boolean {\n    let scope = this.residualHeapVisitor.scope;\n    if (scope instanceof FunctionValue) {\n      return false;\n    }\n    // If the temporal has already been visited, then we know the temporal\n    // value was used and thus declared in another scope\n    if (this.residualHeapVisitor.values.has(temporalAlias)) {\n      return false;\n    }\n    // Otherwise, we check the current scope and see if the\n    // temporal value was declared in one of the entries\n    for (let i = 0; i < scope._entries.length; i++) {\n      let entry = scope._entries[i];\n      if (entry instanceof TemporalBuildNodeEntry) {\n        if (entry.declared === temporalAlias) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  _getReactLibraryValue() {\n    const reactLibraryObject = this.realm.fbLibraries.react;\n    invariant(reactLibraryObject, \"Unable to find React library reference in scope.\");\n    return reactLibraryObject;\n  }\n}\n"]}