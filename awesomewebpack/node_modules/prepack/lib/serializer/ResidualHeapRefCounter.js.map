{"version":3,"sources":["../../src/serializer/ResidualHeapRefCounter.js"],"names":["ResidualHeapRefCounter","constructor","realm","logger","modules","additionalFunctionValuesAndEffects","referentializer","_valueToEdgeRecord","Map","_path","getResult","_shouldIgnore","val","isIntrinsic","isLeaf","preProcessValue","length","_updateParentOutgoingEdgeCount","push","_updateValueIncomingEdgeCount","parent","edgeRecord","get","outGoing","undefined","set","inComing","postProcessValue","pop","visitRoots"],"mappings":";;;;;;;AAiBA;;;;AACA;;AACA;;AACA;;;;AAEA;;;AAGO,MAAMA,sBAAN,kDAAyD;AAC9DC,cACEC,KADF,EAEEC,MAFF,EAGEC,OAHF,EAIEC,kCAJF,EAKEC,eALF,EAME;AACA,UAAMJ,KAAN,EAAaC,MAAb,EAAqBC,OAArB,EAA8BC,kCAA9B,EAAkEC,eAAlE;AACA,SAAKC,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B;AACA,SAAKC,KAAL,GAAa,EAAb;AACD;;AAGoB;;AAErBC,cAAwC;AACtC,WAAO,KAAKH,kBAAZ;AACD;;AAEDI,gBAAcC,GAAd,EAAmC;AACjC,WAAOA,oCAA6BA,IAAIC,WAAJ,EAA7B,IAAkD,6BAAcC,MAAd,CAAqBF,GAArB,CAAzD;AACD;;AAEDG,kBAAgBH,GAAhB,EAAqC;AACnC,QAAI,KAAKD,aAAL,CAAmBC,GAAnB,CAAJ,EAA6B;AAC3B,aAAO,KAAP;AACD;;AAED,QAAI,KAAKH,KAAL,CAAWO,MAAX,GAAoB,CAAxB,EAA2B;AACzB,WAAKC,8BAAL;AACD;AACD,SAAKR,KAAL,CAAWS,IAAX,CAAgBN,GAAhB;;AAEA,WAAO,KAAKO,6BAAL,CAAmCP,GAAnC,CAAP;AACD;;AAEDK,mCAAuC;AACrC,UAAMG,SAAS,KAAKX,KAAL,CAAW,KAAKA,KAAL,CAAWO,MAAX,GAAoB,CAA/B,CAAf;AACA,UAAMK,aAAa,KAAKd,kBAAL,CAAwBe,GAAxB,CAA4BF,MAA5B,CAAnB;AACA,6BAAUC,UAAV;AACA,MAAEA,WAAWE,QAAb;AACD;;AAEDJ,gCAA8BP,GAA9B,EAAmD;AACjD,QAAIS,aAAa,KAAKd,kBAAL,CAAwBe,GAAxB,CAA4BV,GAA5B,CAAjB;AACA,QAAIS,eAAeG,SAAnB,EAA8B;AAC5B,WAAKjB,kBAAL,CAAwBkB,GAAxB,CAA4Bb,GAA5B,EAAiC;AAC/Bc,kBAAU,CADqB;AAE/BH,kBAAU;AAFqB,OAAjC;AAIA,aAAO,IAAP;AACD,KAND,MAMO;AACL,QAAEF,WAAWK,QAAb;AACA,aAAO,KAAP,CAFK,CAES;AACf;AACF;;AAED;AACAC,mBAAiBf,GAAjB,EAAmC;AACjC,QAAI,KAAKD,aAAL,CAAmBC,GAAnB,CAAJ,EAA6B;AAC3B;AACD;AACD,6BAAU,KAAKH,KAAL,CAAWO,MAAX,GAAoB,CAA9B;AACA,SAAKP,KAAL,CAAWmB,GAAX;AACD;;AAED;AACAC,eAAmB;AACjB,UAAMA,UAAN;AACA,6BAAU,KAAKpB,KAAL,CAAWO,MAAX,KAAsB,CAAhC,EAAmC,gDAAnC;AACD;AAvE6D;QAAnDhB,sB,GAAAA,sB,EAzBb;;;;;;;;;AASA","file":"ResidualHeapRefCounter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Logger } from \"../utils/logger.js\";\nimport type { Modules } from \"../utils/modules.js\";\nimport type { Referentializer } from \"./Referentializer.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ObjectRefCount, AdditionalFunctionEffects } from \"./types.js\";\n\nimport invariant from \"../invariant.js\";\nimport { Value, EmptyValue, FunctionValue } from \"../values/index.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\n\n/**\n * Record residual heap object's incoming and outgoing reference counts.\n */\nexport class ResidualHeapRefCounter extends ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    referentializer: Referentializer\n  ) {\n    super(realm, logger, modules, additionalFunctionValuesAndEffects, referentializer);\n    this._valueToEdgeRecord = new Map();\n    this._path = [];\n  }\n\n  _valueToEdgeRecord: Map<Value, ObjectRefCount>;\n  _path: Array<Value>; // Contains the path of nodes from root to current visiting node.\n\n  getResult(): Map<Value, ObjectRefCount> {\n    return this._valueToEdgeRecord;\n  }\n\n  _shouldIgnore(val: Value): boolean {\n    return val instanceof EmptyValue || val.isIntrinsic() || HeapInspector.isLeaf(val);\n  }\n\n  preProcessValue(val: Value): boolean {\n    if (this._shouldIgnore(val)) {\n      return false;\n    }\n\n    if (this._path.length > 0) {\n      this._updateParentOutgoingEdgeCount();\n    }\n    this._path.push(val);\n\n    return this._updateValueIncomingEdgeCount(val);\n  }\n\n  _updateParentOutgoingEdgeCount(): void {\n    const parent = this._path[this._path.length - 1];\n    const edgeRecord = this._valueToEdgeRecord.get(parent);\n    invariant(edgeRecord);\n    ++edgeRecord.outGoing;\n  }\n\n  _updateValueIncomingEdgeCount(val: Value): boolean {\n    let edgeRecord = this._valueToEdgeRecord.get(val);\n    if (edgeRecord === undefined) {\n      this._valueToEdgeRecord.set(val, {\n        inComing: 1,\n        outGoing: 0,\n      });\n      return true;\n    } else {\n      ++edgeRecord.inComing;\n      return false; // visited node, skip its children.\n    }\n  }\n\n  // Override.\n  postProcessValue(val: Value): void {\n    if (this._shouldIgnore(val)) {\n      return;\n    }\n    invariant(this._path.length > 0);\n    this._path.pop();\n  }\n\n  // Override.\n  visitRoots(): void {\n    super.visitRoots();\n    invariant(this._path.length === 0, \"Path should be balanced empty after traversal.\");\n  }\n}\n"]}