{"version":3,"sources":["../../src/serializer/Emitter.js"],"names":["Emitter","constructor","residualFunctions","referencedDeclaredValues","conditionalFeasibility","derivedIds","_mainBody","type","parentBody","undefined","entries","done","_waitingForValues","Map","_waitingForBodies","_body","_residualFunctions","_activeStack","_activeValues","Set","_activeGeneratorStack","_finalized","_getReasonToWaitForDependenciesCallbacks","onActive","val","onFunction","addFunctionUsage","getBodyReference","onAbstractValueWithIdentifier","has","getIdentifier","name","cannotDeclare","hasBeenDeclared","emittingToAdditionalFunction","get","onArrayWithWidenedNumericProperty","_conditionalFeasibility","beginEmitting","dependency","targetBody","isChild","push","add","includes","nestingLevel","oldBody","emit","statement","_processCurrentBody","finalizeCurrentBody","endEmitting","valuesToProcess","lastDependency","pop","delete","_processValue","_isEmittingActiveGenerator","lastBody","declaredValues","anyPropagated","b","parentDeclaredValues","key","value","set","processValues","finalize","length","size","_isGeneratorBody","body","processing","a","dependencies","func","shift","emitNowOrAfterWaitingForDependencies","currentBody","_emitAfterWaitingForGeneratorBody","_getFirstAncestorGeneratorWithActiveBody","bodyStack","activeBody","slice","reverse","find","getReasonToWaitForDependencies","dependenciesVisitor","callbacks","result","recurse","Array","isArray","values","$BoundTargetFunction","$BoundThis","$BoundArguments","hasIdentifier","argsToRecurse","kind","cf","t","f","args","$ProxyTarget","$ProxyHandler","$Description","isIntrinsicAndHasWidenedNumericProperty","getKind","proto","$Prototype","usesOrdinaryObjectInternalPrototypeMethods","$DateValue","realm","$Realm","props","ref","getReasonToWaitForActiveValue","condition","emitAfterWaiting","delayReason","_emitAfterWaitingForValue","reason","declare","getDeclarationBody","declaredCount","getBody","isCurrentBodyOffspringOf"],"mappings":"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","file":"Emitter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbstractValue,\n  ArrayValue,\n  BoundFunctionValue,\n  FunctionValue,\n  ObjectValue,\n  ProxyValue,\n  SymbolValue,\n  Value,\n} from \"../values/index.js\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport type { SerializedBody } from \"./types.js\";\nimport { Generator, type TemporalBuildNodeEntry } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { BodyReference } from \"./types.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport { getProperty } from \"../react/utils.js\";\n\n// Type used to configure callbacks from the dependenciesVisitor of the Emitter.\ntype EmitterDependenciesVisitorCallbacks<T> = {\n  // Callback invoked whenever an \"active\" dependency is visited, i.e. a dependency which is in the process of being emitted.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onActive?: Value => void | T,\n  // Callback invoked whenever a dependency is visited that is a FunctionValue.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onFunction?: FunctionValue => void | T,\n  // Callback invoked whenever a dependency is visited that is an abstract value with an identifier.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onAbstractValueWithIdentifier?: AbstractValue => void | T,\n  // Callback invoked whenever a dependency is visited that is an unknown array value with a widened numeric property.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onArrayWithWidenedNumericProperty?: ArrayValue => void | T,\n};\n\n// The emitter keeps track of a stack of what's currently being emitted.\n// There are two kinds of interesting dependencies the emitter is dealing with:\n// 1. Value dependencies:\n//    If an emission task depends on the result of another emission task which\n//    is still currently being emitted, then the emission task must be performed later,\n//    once the dependency is available.\n//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.\n// 2. Generator dependencies:\n//    For each generator, there's a corresponding \"body\", i.e. a stream of babel statements\n//    that the emitter is appending to.\n//    There's always a \"current\" body that is currently being emitted to.\n//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.\n//    If there are multiple generators/bodies involved, then they form a stack.\n//    Nested bodies are usually composed into an instruction emitted to the outer body.\n//    For example, two nested generators may yield the then and else-branch of an `if` statement.\n//    When an emission is supposed to target a body that is the current body, i.e. when it sits\n//    lower on the stack, then the emission task gets delayed until the next emission task on\n//    the lower body entry is finished.\n//    To this end, the emitter maintains the `_activeGeneratorStack` and `_waitingForBodies` datastructures.\nexport class Emitter {\n  constructor(\n    residualFunctions: ResidualFunctions,\n    referencedDeclaredValues: Map<Value, void | FunctionValue>,\n    conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>,\n    derivedIds: Map<string, TemporalBuildNodeEntry>\n  ) {\n    this._mainBody = { type: \"MainGenerator\", parentBody: undefined, entries: [], done: false };\n    this._waitingForValues = new Map();\n    this._waitingForBodies = new Map();\n    this._body = this._mainBody;\n    this._residualFunctions = residualFunctions;\n    this._activeStack = [];\n    this._activeValues = new Set();\n    this._activeGeneratorStack = [this._mainBody];\n    this._finalized = false;\n    this._getReasonToWaitForDependenciesCallbacks = {\n      onActive: val => val, // cyclic dependency; we need to wait until this value has finished emitting\n      onFunction: val => {\n        // Functions are currently handled in a special way --- they are all defined ahead of time. Thus, we never have to wait for functions.\n        this._residualFunctions.addFunctionUsage(val, this.getBodyReference());\n        return undefined;\n      },\n      onAbstractValueWithIdentifier: val => {\n        // If the value hasn't been declared yet, then we should wait for it.\n        if (\n          derivedIds.has(val.getIdentifier().name) &&\n          !this.cannotDeclare() &&\n          !this.hasBeenDeclared(val) &&\n          (!this.emittingToAdditionalFunction() || referencedDeclaredValues.get(val) !== undefined)\n        ) {\n          return val;\n        }\n        return undefined;\n      },\n      onArrayWithWidenedNumericProperty: val => {\n        // If the value hasn't been declared yet, then we should wait for it.\n        if (\n          !this.cannotDeclare() &&\n          !this.hasBeenDeclared(val) &&\n          (!this.emittingToAdditionalFunction() || referencedDeclaredValues.get(val) !== undefined)\n        ) {\n          return val;\n        }\n        return undefined;\n      },\n    };\n    this._conditionalFeasibility = conditionalFeasibility;\n  }\n\n  _finalized: boolean;\n  _activeStack: Array<string | Generator | Value>;\n  _activeValues: Set<Value>;\n  _activeGeneratorStack: Array<SerializedBody>; // Contains all the active generator bodies in stack order.\n  _residualFunctions: ResidualFunctions;\n  _waitingForValues: Map<Value, Array<{ body: SerializedBody, dependencies: Array<Value>, func: () => void }>>;\n  _waitingForBodies: Map<SerializedBody, Array<{ dependencies: Array<Value>, func: () => void }>>;\n  _body: SerializedBody;\n  _mainBody: SerializedBody;\n  _getReasonToWaitForDependenciesCallbacks: EmitterDependenciesVisitorCallbacks<Value>;\n  _conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>;\n\n  // Begin to emit something. Such sessions can be nested.\n  // The dependency indicates what is being emitted; until this emission ends, other parties might have to wait for the dependency.\n  // The targetBody is a wrapper that holds the sequence of statements that are going to be emitted.\n  // If isChild, then we are starting a new emitting session as a branch off the previously active emitting session.\n  beginEmitting(\n    dependency: string | Generator | Value,\n    targetBody: SerializedBody,\n    isChild: boolean = false\n  ): SerializedBody {\n    invariant(!this._finalized);\n    this._activeStack.push(dependency);\n    if (dependency instanceof Value) {\n      invariant(!this._activeValues.has(dependency));\n      this._activeValues.add(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(!this._activeGeneratorStack.includes(targetBody));\n      this._activeGeneratorStack.push(targetBody);\n    }\n    if (isChild) {\n      targetBody.parentBody = this._body;\n      targetBody.nestingLevel = (this._body.nestingLevel || 0) + 1;\n    }\n    let oldBody = this._body;\n    this._body = targetBody;\n    return oldBody;\n  }\n  emit(statement: BabelNodeStatement): void {\n    invariant(!this._finalized);\n    this._body.entries.push(statement);\n    this._processCurrentBody();\n  }\n  finalizeCurrentBody(): void {\n    invariant(!this._finalized);\n    this._processCurrentBody();\n  }\n  // End to emit something. The parameters dependency and isChild must match a previous call to beginEmitting.\n  // oldBody should be the value returned by the previous matching beginEmitting call.\n  // valuesToProcess is filled with values that have been newly declared since the last corresponding beginEmitting call;\n  // other values not yet have been emitted as they might be waiting for valuesToProcess;\n  // processValues(valuesToProcess) should be called once the returned body has been embedded in the outer context.\n  endEmitting(\n    dependency: string | Generator | Value,\n    oldBody: SerializedBody,\n    valuesToProcess: void | Set<AbstractValue | ObjectValue>,\n    isChild: boolean = false\n  ): SerializedBody {\n    invariant(!this._finalized);\n    let lastDependency = this._activeStack.pop();\n    invariant(dependency === lastDependency);\n    if (dependency instanceof Value) {\n      invariant(this._activeValues.has(dependency));\n      this._activeValues.delete(dependency);\n      this._processValue(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(this._isEmittingActiveGenerator());\n      this._activeGeneratorStack.pop();\n    }\n    let lastBody = this._body;\n    this._body = oldBody;\n    if (isChild) {\n      invariant(lastBody.parentBody === oldBody);\n      invariant((lastBody.nestingLevel || 0) > 0);\n      invariant(!lastBody.done);\n      lastBody.done = true;\n      // When we are done processing a body, we can propogate all declared abstract values\n      // to its parent, possibly unlocking further processing...\n      if (lastBody.declaredValues) {\n        let anyPropagated = true;\n        for (let b = lastBody; b.done && b.parentBody !== undefined && anyPropagated; b = b.parentBody) {\n          anyPropagated = false;\n          let parentDeclaredValues = b.parentBody.declaredValues;\n          if (parentDeclaredValues === undefined) b.parentBody.declaredValues = parentDeclaredValues = new Map();\n          invariant(b.declaredValues);\n          for (let [key, value] of b.declaredValues) {\n            if (!parentDeclaredValues.has(key)) {\n              parentDeclaredValues.set(key, value);\n              if (valuesToProcess !== undefined) valuesToProcess.add(key);\n              anyPropagated = true;\n            }\n          }\n        }\n      }\n    }\n\n    return lastBody;\n  }\n  processValues(valuesToProcess: Set<AbstractValue | ObjectValue>): void {\n    for (let value of valuesToProcess) this._processValue(value);\n  }\n  finalize(): void {\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.length === 1);\n    invariant(this._activeGeneratorStack[0] === this._body);\n    invariant(this._body === this._mainBody);\n    this._processCurrentBody();\n    this._activeGeneratorStack.pop();\n    this._finalized = true;\n    invariant(this._waitingForBodies.size === 0);\n    invariant(this._waitingForValues.size === 0);\n    invariant(this._activeStack.length === 0);\n    invariant(this._activeValues.size === 0);\n    invariant(this._activeGeneratorStack.length === 0);\n  }\n  /**\n   * Emitter is emitting in two modes:\n   * 1. Emitting to entries in current active generator\n   * 2. Emitting to body of another scope(generator or residual function)\n   * This function checks the first condition above.\n   */\n  _isEmittingActiveGenerator(): boolean {\n    invariant(this._activeGeneratorStack.length > 0);\n    return this._activeGeneratorStack[this._activeGeneratorStack.length - 1] === this._body;\n  }\n  _isGeneratorBody(body: SerializedBody): boolean {\n    return body.type === \"MainGenerator\" || body.type === \"Generator\" || body.type === \"AdditionalFunction\";\n  }\n  _processCurrentBody(): void {\n    if (!this._isEmittingActiveGenerator() || this._body.processing) {\n      return;\n    }\n    let a = this._waitingForBodies.get(this._body);\n    if (a === undefined) return;\n    this._body.processing = true;\n    while (a.length > 0) {\n      let { dependencies, func } = a.shift();\n      this.emitNowOrAfterWaitingForDependencies(dependencies, func, this._body);\n    }\n    this._waitingForBodies.delete(this._body);\n    this._body.processing = false;\n  }\n  _processValue(value: Value): void {\n    let a = this._waitingForValues.get(value);\n    if (a === undefined) return;\n    let currentBody = this._body;\n    while (a.length > 0) {\n      let { body, dependencies, func } = a.shift();\n      // If body is not generator body no need to wait for it.\n      if (this._isGeneratorBody(body) && body !== currentBody) {\n        this._emitAfterWaitingForGeneratorBody(body, dependencies, func);\n      } else {\n        this.emitNowOrAfterWaitingForDependencies(dependencies, func, body);\n      }\n    }\n    this._waitingForValues.delete(value);\n  }\n\n  // Find the first ancestor in input generator body stack that is in current active stack.\n  // It can always find one because the bottom one in the stack is the main generator.\n  _getFirstAncestorGeneratorWithActiveBody(bodyStack: Array<SerializedBody>): SerializedBody {\n    const activeBody = bodyStack\n      .slice()\n      .reverse()\n      .find(body => this._activeGeneratorStack.includes(body));\n    invariant(activeBody);\n    return activeBody;\n  }\n\n  // Serialization of a statement related to a value MUST be delayed if\n  // the creation of the value's identity requires the availability of either:\n  // 1. a value that is also currently being serialized\n  //    (tracked by `_activeValues`).\n  // 2. a time-dependent value that is declared by some generator entry\n  //    that has not yet been processed\n  //    (tracked by `declaredValues` in bodies)\n  getReasonToWaitForDependencies(dependencies: Value | Array<Value>): void | Value {\n    return this.dependenciesVisitor(dependencies, this._getReasonToWaitForDependenciesCallbacks);\n  }\n\n  // Visitor of dependencies that require delaying serialization\n  dependenciesVisitor<T>(\n    dependencies: Value | Array<Value>,\n    callbacks: EmitterDependenciesVisitorCallbacks<T>\n  ): void | T {\n    invariant(!this._finalized);\n\n    let result;\n    let recurse = value => this.dependenciesVisitor(value, callbacks);\n\n    if (Array.isArray(dependencies)) {\n      let values = ((dependencies: any): Array<Value>);\n      for (let value of values) {\n        result = recurse(value);\n        if (result !== undefined) return result;\n      }\n      return undefined;\n    }\n\n    let val = ((dependencies: any): Value);\n    if (this._activeValues.has(val)) {\n      // If a value is active and it's a function, then we still shouldn't wait on it.\n      if (val instanceof FunctionValue && !(val instanceof BoundFunctionValue)) {\n        // We ran into a function value.\n        result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;\n        return result;\n      }\n      // We ran into a cyclic dependency, where the value we are dependending on is still in the process of being emitted.\n      result = callbacks.onActive ? callbacks.onActive(val) : undefined;\n      if (result !== undefined) return result;\n    }\n\n    if (val instanceof BoundFunctionValue) {\n      result = recurse(val.$BoundTargetFunction);\n      if (result !== undefined) return result;\n      result = recurse(val.$BoundThis);\n      if (result !== undefined) return result;\n      result = recurse(val.$BoundArguments);\n      if (result !== undefined) return result;\n    } else if (val instanceof FunctionValue) {\n      // We ran into a function value.\n      result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;\n      if (result !== undefined) return result;\n    } else if (val instanceof AbstractValue) {\n      if (val.hasIdentifier()) {\n        // We ran into an abstract value that might have to be declared.\n        result = callbacks.onAbstractValueWithIdentifier ? callbacks.onAbstractValueWithIdentifier(val) : undefined;\n        if (result !== undefined) return result;\n      }\n      let argsToRecurse;\n      if (val.kind === \"conditional\") {\n        let cf = this._conditionalFeasibility.get(val);\n        invariant(cf !== undefined);\n        argsToRecurse = [];\n        if (cf.t && cf.f) argsToRecurse.push(val.args[0]);\n        if (cf.t) argsToRecurse.push(val.args[1]);\n        if (cf.f) argsToRecurse.push(val.args[2]);\n      } else argsToRecurse = val.args;\n      result = recurse(argsToRecurse);\n      if (result !== undefined) return result;\n    } else if (val instanceof ProxyValue) {\n      result = recurse(val.$ProxyTarget);\n      if (result !== undefined) return result;\n      result = recurse(val.$ProxyHandler);\n      if (result !== undefined) return result;\n    } else if (val instanceof SymbolValue) {\n      if (val.$Description instanceof Value) {\n        result = recurse(val.$Description);\n        if (result !== undefined) return result;\n      }\n    } else if (val instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(val)) {\n      result = callbacks.onArrayWithWidenedNumericProperty\n        ? callbacks.onArrayWithWidenedNumericProperty(val)\n        : undefined;\n      if (result !== undefined) return result;\n    } else if (val instanceof ObjectValue) {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"Object\":\n          let proto = val.$Prototype;\n          if (\n            proto instanceof ObjectValue &&\n            // if this is falsy, prototype chain might be cyclic\n            proto.usesOrdinaryObjectInternalPrototypeMethods()\n          ) {\n            result = recurse(val.$Prototype);\n            if (result !== undefined) return result;\n          }\n          break;\n        case \"Date\":\n          invariant(val.$DateValue !== undefined);\n          result = recurse(val.$DateValue);\n          if (result !== undefined) return result;\n          break;\n        case \"ReactElement\":\n          let realm = val.$Realm;\n          let type = getProperty(realm, val, \"type\");\n          let props = getProperty(realm, val, \"props\");\n          let key = getProperty(realm, val, \"key\");\n          let ref = getProperty(realm, val, \"ref\");\n          result = recurse(type);\n          if (result !== undefined) return result;\n          result = recurse(props);\n          if (result !== undefined) return result;\n          result = recurse(key);\n          if (result !== undefined) return result;\n          result = recurse(ref);\n          if (result !== undefined) return result;\n          break;\n        default:\n          break;\n      }\n    }\n\n    return undefined;\n  }\n\n  // Wait for a known-to-be active value if a condition is met.\n  getReasonToWaitForActiveValue(value: Value, condition: boolean): void | Value {\n    invariant(!this._finalized);\n    invariant(this._activeValues.has(value));\n    return condition ? value : undefined;\n  }\n  emitAfterWaiting(\n    delayReason: void | Value | SerializedBody,\n    dependencies: Array<Value>,\n    func: () => void,\n    targetBody: SerializedBody\n  ): void {\n    if (delayReason === undefined && this._isGeneratorBody(targetBody)) {\n      delayReason = targetBody;\n    }\n\n    if (delayReason === undefined || delayReason === this._body) {\n      if (targetBody === this._body) {\n        // Emit into current body.\n        func();\n      } else {\n        invariant(!this._isGeneratorBody(targetBody));\n        // TODO: Check if effects really don't matter here,\n        // since we are going to emit something in an out-of-band body\n        // that might depend on applied effects.\n        const oldBody = this.beginEmitting(targetBody.type, targetBody);\n        func();\n        this.endEmitting(targetBody.type, oldBody);\n      }\n    } else {\n      invariant(delayReason !== undefined);\n      if (delayReason instanceof Value) {\n        this._emitAfterWaitingForValue(delayReason, dependencies, targetBody, func);\n      } else if (this._isGeneratorBody(delayReason)) {\n        // delayReason is a generator body.\n        this._emitAfterWaitingForGeneratorBody(delayReason, dependencies, func);\n      } else {\n        // Unknown delay reason.\n        invariant(false);\n      }\n    }\n  }\n  _emitAfterWaitingForValue(\n    reason: Value,\n    dependencies: Array<Value>,\n    targetBody: SerializedBody,\n    func: () => void\n  ): void {\n    invariant(!this._finalized);\n    invariant(!(reason instanceof AbstractValue && this.hasBeenDeclared(reason)) || this._activeValues.has(reason));\n    let a = this._waitingForValues.get(reason);\n    if (a === undefined) this._waitingForValues.set(reason, (a = []));\n    a.push({ body: targetBody, dependencies, func });\n  }\n  _emitAfterWaitingForGeneratorBody(reason: SerializedBody, dependencies: Array<Value>, func: () => void): void {\n    invariant(this._isGeneratorBody(reason));\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.includes(reason));\n    let b = this._waitingForBodies.get(reason);\n    if (b === undefined) {\n      this._waitingForBodies.set(reason, (b = []));\n    }\n    b.push({ dependencies, func });\n  }\n  emitNowOrAfterWaitingForDependencies(dependencies: Array<Value>, func: () => void, targetBody: SerializedBody): void {\n    this.emitAfterWaiting(this.getReasonToWaitForDependencies(dependencies), dependencies, func, targetBody);\n  }\n  declare(value: AbstractValue | ObjectValue): void {\n    invariant(!this._finalized);\n    invariant(!this._activeValues.has(value));\n    invariant(value instanceof ObjectValue || value.hasIdentifier());\n    invariant(this._isEmittingActiveGenerator());\n    invariant(!this.cannotDeclare());\n    invariant(!this._body.done);\n    if (this._body.declaredValues === undefined) this._body.declaredValues = new Map();\n    this._body.declaredValues.set(value, this._body);\n    this._processValue(value);\n  }\n  emittingToAdditionalFunction(): boolean {\n    // Whether we are directly or indirectly emitting to an additional function\n    for (let b = this._body; b !== undefined; b = b.parentBody) if (b.type === \"AdditionalFunction\") return true;\n    return false;\n  }\n  cannotDeclare(): boolean {\n    // Bodies of the following types will never contain any (temporal) abstract value declarations.\n    return this._body.type === \"DelayInitializations\" || this._body.type === \"LazyObjectInitializer\";\n  }\n  hasBeenDeclared(value: AbstractValue | ObjectValue): boolean {\n    return this.getDeclarationBody(value) !== undefined;\n  }\n  getDeclarationBody(value: AbstractValue | ObjectValue): void | SerializedBody {\n    for (let b = this._body; b !== undefined; b = b.parentBody) {\n      if (b.declaredValues !== undefined && b.declaredValues.has(value)) {\n        return b;\n      }\n    }\n    return undefined;\n  }\n  declaredCount(): number {\n    let declaredValues = this._body.declaredValues;\n    return declaredValues === undefined ? 0 : declaredValues.size;\n  }\n  getBody(): SerializedBody {\n    return this._body;\n  }\n  isCurrentBodyOffspringOf(targetBody: SerializedBody): boolean {\n    let currentBody = this._body;\n    while (currentBody !== undefined) {\n      if (currentBody === targetBody) {\n        return true;\n      }\n      currentBody = currentBody.parentBody;\n    }\n    return false;\n  }\n  getBodyReference(): BodyReference {\n    invariant(!this._finalized);\n    return new BodyReference(this._body, this._body.entries.length);\n  }\n}\n"]}