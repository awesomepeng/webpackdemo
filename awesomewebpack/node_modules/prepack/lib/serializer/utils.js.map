{"version":3,"sources":["../../src/serializer/utils.js"],"names":["getSuggestedArrayLiteralLength","commonAncestorOf","getOrDefault","withDescriptorValue","canIgnoreClassLengthProperty","getObjectPrototypeMetadata","createAdditionalEffects","handleReportedSideEffect","realm","val","minLength","maxLength","actualLength","key","properties","keys","Number","prevMax","elem","_SafeGetDataPropertyValue","mightHaveBeenDeleted","kind","maxLengthVal","c","x","y","args","prevActual","undefined","createFromConditionalOp","lengthVal","equals","node1","node2","getParent","n1","n2","count1","count2","p1","p2","map","defaultFn","value","get","set","propertyNameOrSymbol","descriptor","func","ClassPropertiesToIgnore","Set","desc","logger","logError","obj","proto","$Prototype","skipPrototype","constructor","$IsClassPrototype","_constructor","classFunc","effects","fatalOnAbrupt","name","environmentRecordIdAfterGlobalCode","parentAdditionalFunction","generator","fromEffects","retValue","transforms","additionalRoots","exceptionHandler","sideEffectType","binding","expressionLocation","object","intrinsicName","location"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  IntegralValue,\n  ObjectValue,\n  SymbolValue,\n} from \"../values/index.js\";\nimport type { Effects, Realm, SideEffectType } from \"../realm.js\";\n\nimport { FatalError } from \"../errors.js\";\nimport type { PropertyBinding, Descriptor } from \"../types.js\";\nimport invariant from \"../invariant.js\";\nimport { IsArray, IsArrayIndex } from \"../methods/index.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport type { AdditionalFunctionEffects } from \"./types\";\nimport type { Binding } from \"../environment.js\";\nimport { getLocationFromValue } from \"../react/utils\";\n\n/**\n * Get index property list length by searching array properties list for the max index key value plus 1.\n * If tail elements are conditional, return the minimum length if an assignment to the length property\n * can be avoided because of that. The boolean part of the result is a flag that indicates if the latter is true.\n */\nexport function getSuggestedArrayLiteralLength(realm: Realm, val: ObjectValue): [number, boolean] {\n  invariant(IsArray(realm, val));\n\n  let minLength = 0,\n    maxLength = 0;\n  let actualLength;\n  for (const key of val.properties.keys()) {\n    if (IsArrayIndex(realm, key) && Number(key) >= maxLength) {\n      let prevMax = maxLength;\n      maxLength = Number(key) + 1;\n      let elem = val._SafeGetDataPropertyValue(key);\n      if (!elem.mightHaveBeenDeleted()) minLength = maxLength;\n      else if (elem instanceof AbstractValue && elem.kind === \"conditional\") {\n        let maxLengthVal = new IntegralValue(realm, maxLength);\n        let [c, x, y] = elem.args;\n        if (x instanceof EmptyValue && !y.mightHaveBeenDeleted()) {\n          let prevActual = actualLength === undefined ? new IntegralValue(realm, prevMax) : actualLength;\n          actualLength = AbstractValue.createFromConditionalOp(realm, c, prevActual, maxLengthVal);\n        } else if (y instanceof EmptyValue && !x.mightHaveBeenDeleted()) {\n          let prevActual = actualLength === undefined ? new IntegralValue(realm, prevMax) : actualLength;\n          actualLength = AbstractValue.createFromConditionalOp(realm, c, maxLengthVal, prevActual);\n        } else {\n          actualLength = undefined;\n        }\n      }\n    }\n  }\n  if (maxLength > minLength && actualLength instanceof AbstractValue) {\n    let lengthVal = val._SafeGetDataPropertyValue(\"length\");\n    if (lengthVal.equals(actualLength)) return [minLength, true];\n  }\n  return [maxLength, false];\n}\n\nexport function commonAncestorOf<T>(node1: void | T, node2: void | T, getParent: T => void | T): void | T {\n  if (node1 === node2) return node1;\n  // First get the path length to the root node for both nodes while also checking if\n  // either node is the parent of the other.\n  let n1 = node1,\n    n2 = node2,\n    count1 = 0,\n    count2 = 0;\n  while (true) {\n    let p1 = n1 && getParent(n1);\n    let p2 = n2 && getParent(n2);\n    if (p1 === node2) return node2;\n    if (p2 === node1) return node1;\n    if (p1 !== undefined) count1++;\n    if (p2 !== undefined) count2++;\n    if (p1 === undefined && p2 === undefined) break;\n    n1 = p1;\n    n2 = p2;\n  }\n  // Now shorten the longest path to the same length as the shorter path\n  n1 = node1;\n  while (count1 > count2) {\n    invariant(n1 !== undefined);\n    n1 = getParent(n1);\n    count1--;\n  }\n  n2 = node2;\n  while (count1 < count2) {\n    invariant(n2 !== undefined);\n    n2 = getParent(n2);\n    count2--;\n  }\n  // Now run up both paths in tandem, stopping at the first common entry\n  while (n1 !== n2) {\n    invariant(n1 !== undefined);\n    n1 = getParent(n1);\n    invariant(n2 !== undefined);\n    n2 = getParent(n2);\n  }\n  return n1;\n}\n\n// Gets map[key] with default value provided by defaultFn\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultFn: () => V): V {\n  let value = map.get(key);\n  if (value === undefined) map.set(key, (value = defaultFn()));\n  invariant(value !== undefined);\n  return value;\n}\n\nexport function withDescriptorValue(\n  propertyNameOrSymbol: string | SymbolValue,\n  descriptor: void | Descriptor,\n  func: Function\n): void {\n  if (descriptor !== undefined) {\n    if (descriptor.value !== undefined) {\n      func(propertyNameOrSymbol, descriptor.value, \"value\");\n    } else {\n      if (descriptor.get !== undefined) {\n        func(propertyNameOrSymbol, descriptor.get, \"get\");\n      }\n      if (descriptor.set !== undefined) {\n        func(propertyNameOrSymbol, descriptor.set, \"set\");\n      }\n    }\n  }\n}\n\nexport const ClassPropertiesToIgnore: Set<string> = new Set([\"arguments\", \"name\", \"caller\"]);\n\nexport function canIgnoreClassLengthProperty(val: ObjectValue, desc: void | Descriptor, logger: Logger): boolean {\n  if (desc && desc.value === undefined) {\n    logger.logError(val, \"Functions with length accessor properties are not supported in residual heap.\");\n  }\n  return true;\n}\n\nexport function getObjectPrototypeMetadata(\n  realm: Realm,\n  obj: ObjectValue\n): { skipPrototype: boolean, constructor: void | ECMAScriptSourceFunctionValue } {\n  let proto = obj.$Prototype;\n  let skipPrototype = false;\n  let constructor;\n\n  if (obj.$IsClassPrototype) {\n    skipPrototype = true;\n  }\n  if (proto && proto.$IsClassPrototype) {\n    invariant(proto instanceof ObjectValue);\n    // we now need to check if the prototpe has a constructor\n    let _constructor = proto.properties.get(\"constructor\");\n    if (_constructor !== undefined) {\n      // if the contructor has been deleted then we have no way\n      // to serialize the original class AST as it won't have been\n      // evluated and thus visited\n      if (_constructor.descriptor === undefined) {\n        throw new FatalError(\"TODO #1024: implement object prototype serialization with deleted constructor\");\n      }\n      let classFunc = _constructor.descriptor.value;\n      if (classFunc instanceof ECMAScriptSourceFunctionValue) {\n        constructor = classFunc;\n        skipPrototype = true;\n      }\n    }\n  }\n\n  return {\n    skipPrototype,\n    constructor,\n  };\n}\n\nexport function createAdditionalEffects(\n  realm: Realm,\n  effects: Effects,\n  fatalOnAbrupt: boolean,\n  name: string,\n  environmentRecordIdAfterGlobalCode: number,\n  parentAdditionalFunction: FunctionValue | void = undefined\n): AdditionalFunctionEffects | null {\n  let generator = Generator.fromEffects(effects, realm, name, environmentRecordIdAfterGlobalCode);\n  let retValue: AdditionalFunctionEffects = {\n    parentAdditionalFunction,\n    effects,\n    transforms: [],\n    generator,\n    additionalRoots: new Set(),\n  };\n  return retValue;\n}\n\nexport function handleReportedSideEffect(\n  exceptionHandler: string => void,\n  sideEffectType: SideEffectType,\n  binding: void | Binding | PropertyBinding,\n  expressionLocation: any\n): void {\n  // This causes an infinite recursion because creating a callstack causes internal-only side effects\n  if (binding && binding.object && binding.object.intrinsicName === \"__checkedBindings\") return;\n  let location = getLocationFromValue(expressionLocation);\n\n  if (sideEffectType === \"MODIFIED_BINDING\") {\n    let name = binding ? `\"${((binding: any): Binding).name}\"` : \"unknown\";\n    exceptionHandler(`side-effects from mutating the binding ${name}${location}`);\n  } else if (sideEffectType === \"MODIFIED_PROPERTY\" || sideEffectType === \"MODIFIED_GLOBAL\") {\n    let name = \"\";\n    let key = ((binding: any): PropertyBinding).key;\n    if (typeof key === \"string\") {\n      name = `\"${key}\"`;\n    }\n    if (sideEffectType === \"MODIFIED_PROPERTY\") {\n      exceptionHandler(`side-effects from mutating a property ${name}${location}`);\n    } else {\n      exceptionHandler(`side-effects from mutating the global object property ${name}${location}`);\n    }\n  } else if (sideEffectType === \"EXCEPTION_THROWN\") {\n    exceptionHandler(`side-effects from throwing exception${location}`);\n  }\n}\n"]}