{"version":3,"sources":["../../src/serializer/ResidualReactElementSerializer.js"],"names":["t","ResidualReactElementSerializer","constructor","realm","residualHeapSerializer","logger","reactOutput","react","output","_lazilyHoistedNodes","undefined","_createReactElement","value","attributes","children","declared","type","_createReactElementAttribute","expr","key","_createReactElementChild","_emitHoistedReactElement","reactElement","id","reactElementAst","hoistedCreateElementIdentifier","originalCreateElementIdentifier","funcId","identifier","functionNameGenerator","generate","createElementIdentifier","nodes","statement","expressionStatement","logicalExpression","binaryExpression","unaryExpression","numericLiteral","callExpression","optimizedFunction","tryGetOptimizedFunctionRoot","getPrelude","push","Array","isArray","astNode","_getReactLibraryValue","reactLibraryObject","fbLibraries","_getReactCreateElementValue","_emitReactElement","typeValue","keyValue","refValue","propsValue","shouldHoist","getSerializeObjectIdentifier","reactElementAstNode","dependencies","createElement","emitter","emitNowOrAfterWaitingForDependencies","_serializeReactElementToJSXElement","serializeValue","intrinsicNameGenerator","_serializeReactElementToCreateElement","emit","assignmentExpression","variableDeclaration","variableDeclarator","getBody","_serializeNowOrAfterWaitingForDependencies","func","shouldSerialize","reason","getReasonToWaitForDependencies","serialize","emitAfterWaiting","_serializeReactFragmentType","memberExpression","serializeReactElement","val","reactElementData","reactElements","get","firstRenderOnly","visitType","residualHeapValueIdentifiers","incrementReferenceCount","visitKey","reactElementKey","visitRef","reactElementRef","visitAbstractOrPartialProps","reactElementSpread","visitConcreteProps","propName","binding","properties","descriptor","propValue","reactElementAttribute","visitChildNode","childValue","_serializeReactElementChild","_addSerializedValueToJSXAttriutes","prop","jSXSpreadAttribute","createElementArguments","length","astAttributes","attribute","spreadProperty","attributeKey","includes","stringLiteral","objectProperty","objectExpression","nullLiteral","astChildren","child","createElementCall","_addBailOutMessageToBabelNode","jsxTypeIdentifer","isStringLiteral","isNumericLiteral","jSXText","isJSXElement","jSXExpressionContainer","openingElement","jSXOpeningElement","closingElement","jSXClosingElement","jsxElement","jSXElement","node","$BailOutReason","leadingComments","reactElementChild","serializeLazyHoistedNodes","entries","functionExpression","blockStatement","map"],"mappings":"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","file":"ResidualReactElementSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport { ResidualHeapSerializer } from \"./ResidualHeapSerializer.js\";\nimport { canHoistReactElement } from \"../react/hoisting.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNode, BabelNodeExpression } from \"babel-types\";\nimport { AbstractValue, AbstractObjectValue, ObjectValue, SymbolValue, Value } from \"../values/index.js\";\nimport { convertExpressionToJSXIdentifier, convertKeyValueToJSXAttribute } from \"../react/jsx.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport invariant from \"../invariant.js\";\nimport { FatalError } from \"../errors\";\nimport { traverseReactElement } from \"../react/elements.js\";\nimport { canExcludeReactElementObjectProperty, getReactSymbol, getProperty } from \"../react/utils.js\";\nimport type { ReactOutputTypes } from \"../options.js\";\nimport type { LazilyHoistedNodes } from \"./types.js\";\n\ntype ReactElementAttributeType = \"SPREAD\" | \"PROPERTY\" | \"PENDING\";\ntype ReactElementChildType = \"NORMAL\" | \"PENDING\";\n\ntype ReactElementChild = {\n  expr: void | BabelNodeExpression,\n  type: ReactElementChildType,\n};\n\ntype ReactElementAttribute = {\n  expr: void | BabelNodeExpression,\n  key: void | string,\n  type: ReactElementAttributeType,\n};\n\ntype ReactElement = {\n  attributes: Array<ReactElementAttribute>,\n  children: Array<ReactElementChild>,\n  declared: boolean,\n  type: void | BabelNodeExpression,\n  value: ObjectValue,\n};\n\nexport class ResidualReactElementSerializer {\n  constructor(realm: Realm, residualHeapSerializer: ResidualHeapSerializer) {\n    this.realm = realm;\n    this.residualHeapSerializer = residualHeapSerializer;\n    this.logger = residualHeapSerializer.logger;\n    this.reactOutput = realm.react.output || \"create-element\";\n    this._lazilyHoistedNodes = undefined;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  reactOutput: ReactOutputTypes;\n  residualHeapSerializer: ResidualHeapSerializer;\n  _lazilyHoistedNodes: void | LazilyHoistedNodes;\n\n  _createReactElement(value: ObjectValue): ReactElement {\n    return { attributes: [], children: [], declared: false, type: undefined, value };\n  }\n\n  _createReactElementAttribute(): ReactElementAttribute {\n    return { expr: undefined, key: undefined, type: \"PENDING\" };\n  }\n\n  _createReactElementChild(): ReactElementChild {\n    return { expr: undefined, type: \"PENDING\" };\n  }\n\n  _emitHoistedReactElement(\n    reactElement: ObjectValue,\n    id: BabelNodeExpression,\n    reactElementAst: BabelNodeExpression,\n    hoistedCreateElementIdentifier: BabelNodeIdentifier,\n    originalCreateElementIdentifier: BabelNodeIdentifier\n  ): void {\n    // if the currentHoistedReactElements is not defined, we create it an emit the function call\n    // this should only occur once per additional function\n    if (this._lazilyHoistedNodes === undefined) {\n      let funcId = t.identifier(this.residualHeapSerializer.functionNameGenerator.generate());\n      this._lazilyHoistedNodes = {\n        id: funcId,\n        createElementIdentifier: hoistedCreateElementIdentifier,\n        nodes: [],\n      };\n      let statement = t.expressionStatement(\n        t.logicalExpression(\n          \"&&\",\n          t.binaryExpression(\"===\", id, t.unaryExpression(\"void\", t.numericLiteral(0), true)),\n          // pass the createElementIdentifier if it's not null\n          t.callExpression(funcId, originalCreateElementIdentifier ? [originalCreateElementIdentifier] : [])\n        )\n      );\n      let optimizedFunction = this.residualHeapSerializer.tryGetOptimizedFunctionRoot(reactElement);\n      this.residualHeapSerializer.getPrelude(optimizedFunction).push(statement);\n    }\n    // we then push the reactElement and its id into our list of elements to process after\n    // the current additional function has serialzied\n    invariant(this._lazilyHoistedNodes !== undefined);\n    invariant(Array.isArray(this._lazilyHoistedNodes.nodes));\n    this._lazilyHoistedNodes.nodes.push({ id, astNode: reactElementAst });\n  }\n\n  _getReactLibraryValue(): AbstractObjectValue | ObjectValue {\n    let reactLibraryObject = this.realm.fbLibraries.react;\n    // if there is no React library, then we should throw and error\n    if (reactLibraryObject === undefined) {\n      throw new FatalError(\"unable to find React library reference in scope\");\n    }\n    return reactLibraryObject;\n  }\n\n  _getReactCreateElementValue(): Value {\n    let reactLibraryObject = this._getReactLibraryValue();\n    return getProperty(this.realm, reactLibraryObject, \"createElement\");\n  }\n\n  _emitReactElement(reactElement: ReactElement): BabelNodeExpression {\n    let { value } = reactElement;\n    let typeValue = getProperty(this.realm, value, \"type\");\n    let keyValue = getProperty(this.realm, value, \"key\");\n    let refValue = getProperty(this.realm, value, \"ref\");\n    let propsValue = getProperty(this.realm, value, \"props\");\n\n    let shouldHoist =\n      this.residualHeapSerializer.tryGetOptimizedFunctionRoot(value) !== undefined &&\n      canHoistReactElement(this.realm, value);\n\n    let id = this.residualHeapSerializer.getSerializeObjectIdentifier(value);\n    // this identifier is used as the deafult, but also passed to the hoisted factory function\n    let originalCreateElementIdentifier = null;\n    // this name is used when hoisting, and is passed into the factory function, rather than the original\n    let hoistedCreateElementIdentifier = null;\n    let reactElementAstNode;\n    let dependencies = [typeValue, keyValue, refValue, propsValue, value];\n    let createElement;\n\n    if (this.reactOutput === \"create-element\") {\n      createElement = this._getReactCreateElementValue();\n      dependencies.push(createElement);\n    }\n\n    this.residualHeapSerializer.emitter.emitNowOrAfterWaitingForDependencies(\n      dependencies,\n      () => {\n        if (this.reactOutput === \"jsx\") {\n          reactElementAstNode = this._serializeReactElementToJSXElement(value, reactElement);\n        } else if (this.reactOutput === \"create-element\") {\n          originalCreateElementIdentifier = this.residualHeapSerializer.serializeValue(createElement);\n\n          if (shouldHoist) {\n            // if we haven't created a _lazilyHoistedNodes before, then this is the first time\n            // so we only create the hoisted identifier once\n            if (this._lazilyHoistedNodes === undefined) {\n              // create a new unique instance\n              hoistedCreateElementIdentifier = t.identifier(\n                this.residualHeapSerializer.intrinsicNameGenerator.generate()\n              );\n            } else {\n              hoistedCreateElementIdentifier = this._lazilyHoistedNodes.createElementIdentifier;\n            }\n          }\n\n          let createElementIdentifier = shouldHoist ? hoistedCreateElementIdentifier : originalCreateElementIdentifier;\n          reactElementAstNode = this._serializeReactElementToCreateElement(\n            value,\n            reactElement,\n            createElementIdentifier\n          );\n        } else {\n          invariant(false, \"Unknown reactOutput specified\");\n        }\n        // if we are hoisting this React element, put the assignment in the body\n        // also ensure we are in an additional function\n        if (shouldHoist) {\n          this._emitHoistedReactElement(\n            value,\n            id,\n            reactElementAstNode,\n            hoistedCreateElementIdentifier,\n            originalCreateElementIdentifier\n          );\n        } else {\n          // Note: it can be expected that we assign to the same variable multiple times\n          // this is due to fact ReactElements are immutable objects and the fact that\n          // when we inline/fold logic, the same ReactElements are referenced at different\n          // points with different attributes. Given we can't mutate an immutable object,\n          // we instead create new objects and assign to the same binding\n          if (reactElement.declared) {\n            this.residualHeapSerializer.emitter.emit(\n              t.expressionStatement(t.assignmentExpression(\"=\", id, reactElementAstNode))\n            );\n          } else {\n            reactElement.declared = true;\n            this.residualHeapSerializer.emitter.emit(\n              t.variableDeclaration(\"var\", [t.variableDeclarator(id, reactElementAstNode)])\n            );\n          }\n        }\n      },\n      this.residualHeapSerializer.emitter.getBody()\n    );\n    return id;\n  }\n\n  _serializeNowOrAfterWaitingForDependencies(\n    value: Value,\n    reactElement: ReactElement,\n    func: () => void | BabelNode,\n    shouldSerialize?: boolean = true\n  ): void {\n    let reason = this.residualHeapSerializer.emitter.getReasonToWaitForDependencies(value);\n\n    const serialize = () => {\n      func();\n    };\n\n    if (reason) {\n      this.residualHeapSerializer.emitter.emitAfterWaiting(\n        reason,\n        [value],\n        () => {\n          serialize();\n          this._emitReactElement(reactElement);\n        },\n        this.residualHeapSerializer.emitter.getBody()\n      );\n    } else {\n      serialize();\n    }\n  }\n\n  _serializeReactFragmentType(typeValue: SymbolValue): BabelNodeExpression {\n    let reactLibraryObject = this._getReactLibraryValue();\n    return t.memberExpression(this.residualHeapSerializer.serializeValue(reactLibraryObject), t.identifier(\"Fragment\"));\n  }\n\n  serializeReactElement(val: ObjectValue): BabelNodeExpression {\n    let reactElementData = this.realm.react.reactElements.get(val);\n    invariant(reactElementData !== undefined);\n    let { firstRenderOnly } = reactElementData;\n    let reactElement = this._createReactElement(val);\n\n    traverseReactElement(this.realm, reactElement.value, {\n      visitType: (typeValue: Value) => {\n        this._serializeNowOrAfterWaitingForDependencies(typeValue, reactElement, () => {\n          let expr;\n\n          if (typeValue instanceof SymbolValue && typeValue === getReactSymbol(\"react.fragment\", this.realm)) {\n            expr = this._serializeReactFragmentType(typeValue);\n          } else {\n            expr = this.residualHeapSerializer.serializeValue(typeValue);\n            // Increment ref count one more time to ensure that this object will be assigned a unique id.\n            // Abstract values that are emitted as first argument to JSX elements needs a proper id.\n            this.residualHeapSerializer.residualHeapValueIdentifiers.incrementReferenceCount(typeValue);\n          }\n          reactElement.type = expr;\n        });\n      },\n      visitKey: (keyValue: Value) => {\n        let reactElementKey = this._createReactElementAttribute();\n        this._serializeNowOrAfterWaitingForDependencies(keyValue, reactElement, () => {\n          let expr = this.residualHeapSerializer.serializeValue(keyValue);\n          reactElementKey.expr = expr;\n          reactElementKey.key = \"key\";\n          reactElementKey.type = \"PROPERTY\";\n        });\n        reactElement.attributes.push(reactElementKey);\n      },\n      visitRef: (refValue: Value) => {\n        if (!firstRenderOnly) {\n          let reactElementRef = this._createReactElementAttribute();\n          this._serializeNowOrAfterWaitingForDependencies(refValue, reactElement, () => {\n            let expr = this.residualHeapSerializer.serializeValue(refValue);\n            reactElementRef.expr = expr;\n            reactElementRef.key = \"ref\";\n            reactElementRef.type = \"PROPERTY\";\n          });\n          reactElement.attributes.push(reactElementRef);\n        }\n      },\n      visitAbstractOrPartialProps: (propsValue: AbstractValue | ObjectValue) => {\n        let reactElementSpread = this._createReactElementAttribute();\n        this._serializeNowOrAfterWaitingForDependencies(propsValue, reactElement, () => {\n          let expr = this.residualHeapSerializer.serializeValue(propsValue);\n          reactElementSpread.expr = expr;\n          reactElementSpread.type = \"SPREAD\";\n        });\n        reactElement.attributes.push(reactElementSpread);\n      },\n      visitConcreteProps: (propsValue: ObjectValue) => {\n        for (let [propName, binding] of propsValue.properties) {\n          if (binding.descriptor === undefined || propName === \"children\") {\n            continue;\n          }\n          let propValue = getProperty(this.realm, propsValue, propName);\n          if (canExcludeReactElementObjectProperty(this.realm, val, propName, propValue)) {\n            continue;\n          }\n          let reactElementAttribute = this._createReactElementAttribute();\n\n          this._serializeNowOrAfterWaitingForDependencies(propValue, reactElement, () => {\n            let expr = this.residualHeapSerializer.serializeValue(propValue);\n            reactElementAttribute.expr = expr;\n            reactElementAttribute.key = propName;\n            reactElementAttribute.type = \"PROPERTY\";\n          });\n          reactElement.attributes.push(reactElementAttribute);\n        }\n      },\n      visitChildNode: (childValue: Value) => {\n        reactElement.children.push(this._serializeReactElementChild(childValue, reactElement));\n      },\n    });\n    return this._emitReactElement(reactElement);\n  }\n\n  _addSerializedValueToJSXAttriutes(prop: string | null, expr: any, attributes: Array<BabelNode>): void {\n    if (prop === null) {\n      attributes.push(t.jSXSpreadAttribute(expr));\n    } else {\n      attributes.push(convertKeyValueToJSXAttribute(prop, expr));\n    }\n  }\n\n  _serializeReactElementToCreateElement(\n    val: ObjectValue,\n    reactElement: ReactElement,\n    createElementIdentifier: BabelNodeIdentifier\n  ): BabelNodeExpression {\n    let { type, attributes, children } = reactElement;\n\n    let createElementArguments = [type];\n    // check if we need to add attributes\n    if (attributes.length !== 0) {\n      let astAttributes = [];\n      for (let attribute of attributes) {\n        let expr = ((attribute.expr: any): BabelNodeExpression);\n\n        if (attribute.type === \"SPREAD\") {\n          astAttributes.push(t.spreadProperty(expr));\n        } else if (attribute.type === \"PROPERTY\") {\n          let attributeKey = attribute.key;\n          let key;\n\n          invariant(typeof attributeKey === \"string\");\n          if (attributeKey.includes(\"-\")) {\n            key = t.stringLiteral(attributeKey);\n          } else {\n            key = t.identifier(attributeKey);\n          }\n          astAttributes.push(t.objectProperty(key, expr));\n        }\n      }\n      createElementArguments.push(t.objectExpression(astAttributes));\n    }\n    if (children.length !== 0) {\n      if (attributes.length === 0) {\n        createElementArguments.push(t.nullLiteral());\n      }\n      let astChildren = [];\n      for (let child of children) {\n        let expr = ((child.expr: any): BabelNodeExpression);\n\n        if (child.type === \"NORMAL\") {\n          astChildren.push(expr);\n        }\n      }\n      createElementArguments.push(...astChildren);\n    }\n    // cast to any for createElementArguments as casting it to BabelNodeExpresion[] isn't working\n    let createElementCall = t.callExpression(createElementIdentifier, (createElementArguments: any));\n    this._addBailOutMessageToBabelNode(val, createElementCall);\n    return createElementCall;\n  }\n\n  _serializeReactElementToJSXElement(val: ObjectValue, reactElement: ReactElement): BabelNodeExpression {\n    let { type, attributes, children } = reactElement;\n\n    let jsxTypeIdentifer = convertExpressionToJSXIdentifier(((type: any): BabelNodeIdentifier), true);\n    let astAttributes = [];\n    for (let attribute of attributes) {\n      let expr = ((attribute.expr: any): BabelNodeExpression);\n\n      if (attribute.type === \"SPREAD\") {\n        astAttributes.push(t.jSXSpreadAttribute(expr));\n      } else if (attribute.type === \"PROPERTY\") {\n        let attributeKey = attribute.key;\n        invariant(typeof attributeKey === \"string\");\n        astAttributes.push(convertKeyValueToJSXAttribute(attributeKey, expr));\n      }\n    }\n\n    let astChildren = [];\n    for (let child of children) {\n      let expr = ((child.expr: any): BabelNodeExpression);\n\n      if (child.type === \"NORMAL\") {\n        if (t.isStringLiteral(expr) || t.isNumericLiteral(expr)) {\n          astChildren.push(t.jSXText(((expr: any).value: string) + \"\"));\n        } else if (t.isJSXElement(expr)) {\n          astChildren.push(expr);\n        } else {\n          astChildren.push(t.jSXExpressionContainer(expr));\n        }\n      }\n    }\n\n    let openingElement = t.jSXOpeningElement(jsxTypeIdentifer, (astAttributes: any), astChildren.length === 0);\n    let closingElement = t.jSXClosingElement(jsxTypeIdentifer);\n    let jsxElement = t.jSXElement(openingElement, closingElement, astChildren, astChildren.length === 0);\n    this._addBailOutMessageToBabelNode(val, jsxElement);\n    return jsxElement;\n  }\n\n  _addBailOutMessageToBabelNode(val: ObjectValue, node: BabelNode): void {\n    // if there has been a bail-out, we create an inline BlockComment node before the JSX element\n    if (val.$BailOutReason !== undefined) {\n      // $BailOutReason contains an optional string of what to print out in the comment\n      node.leadingComments = [({ type: \"BlockComment\", value: `${val.$BailOutReason}` }: any)];\n    }\n  }\n\n  _serializeReactElementChild(child: Value, reactElement: ReactElement): ReactElementChild {\n    let reactElementChild = this._createReactElementChild();\n    this._serializeNowOrAfterWaitingForDependencies(child, reactElement, () => {\n      let expr = this.residualHeapSerializer.serializeValue(child);\n\n      reactElementChild.expr = expr;\n      reactElementChild.type = \"NORMAL\";\n    });\n    return reactElementChild;\n  }\n\n  serializeLazyHoistedNodes(): Array<BabelNodeStatement> {\n    const entries = [];\n    if (this._lazilyHoistedNodes !== undefined) {\n      let { id, nodes, createElementIdentifier } = this._lazilyHoistedNodes;\n      // create a function that initializes all the hoisted nodes\n      let func = t.functionExpression(\n        null,\n        // use createElementIdentifier if it's not null\n        createElementIdentifier ? [createElementIdentifier] : [],\n        t.blockStatement(nodes.map(node => t.expressionStatement(t.assignmentExpression(\"=\", node.id, node.astNode))))\n      );\n      // push it to the mainBody of the module\n      entries.push(t.variableDeclaration(\"var\", [t.variableDeclarator(id, func)]));\n      // output all the empty variable declarations that will hold the nodes lazily\n      entries.push(...nodes.map(node => t.variableDeclaration(\"var\", [t.variableDeclarator(node.id)])));\n      // reset the _lazilyHoistedNodes so other additional functions work\n      this._lazilyHoistedNodes = undefined;\n    }\n    return entries;\n  }\n}\n"]}