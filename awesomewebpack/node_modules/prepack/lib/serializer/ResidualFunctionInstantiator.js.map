{"version":3,"sources":["../../src/serializer/ResidualFunctionInstantiator.js"],"names":["getReplacement","isPure","t","canShareFunctionBody","duplicateFunctionInfo","anyContainingAdditionalFunction","unbound","modified","usesThis","functionInfo","size","node","value","truthiness","undefined","mightNotBeFalse","mightNotBeTrue","type","unaryExpression","argument","binaryExpression","left","right","ResidualFunctionInstantiator","constructor","factoryFunctionInfos","identifierReplacements","callReplacements","root","instantiate","_replace","_getLiteralTruthiness","replacement","get","classExpression","superClass","body","length","objectExpression","properties","every","property","key","arrayExpression","elements","element","operator","_replaceIdentifier","_replaceJSXIdentifier","_replaceLabeledStatement","newBody","res","Object","assign","_replaceCallExpression","_replaceFallback","_replaceFunctionExpression","functionExpression","functionTag","uniqueOrderedTag","factoryId","callExpression","memberExpression","identifier","_replaceIfStatement","testTruthiness","test","consequent","alternate","emptyStatement","_replaceConditionalExpression","_replaceLogicalExpression","leftTruthiness","_replaceWhileStatement","newNode","subNode","newSubNode","Array","isArray","newArray","i","elementNode","newElementNode","slice"],"mappings":";;;;;;QAiEgBA,c,GAAAA,c;QAQAC,M,GAAAA,M;;AA9DhB;;IAAYC,C;;AACZ;;AA2BA;;;;AAEA,SAASC,oBAAT,CAA8BC,qBAA9B,EAAmF;AACjF,MAAIA,sBAAsBC,+BAA1B,EAA2D;AACzD;AACA;AACA;AACA;AACA;AACA,WAAO,KAAP;AACD;;AAED;AACA;AACA;AACA,QAAM,EAAEC,OAAF,EAAWC,QAAX,EAAqBC,QAArB,KAAkCJ,sBAAsBK,YAA9D;AACA,SAAOH,QAAQI,IAAR,KAAiB,CAAjB,IAAsBH,SAASG,IAAT,KAAkB,CAAxC,IAA6C,CAACF,QAArD;AACD,C,CAEwC;;AA1DzC;;;;;;;;;AAiEO,SAASR,cAAT,CAAwBW,IAAxB,EAAmDC,KAAnD,EAAqF;AAC1F,MAAIC,UAAJ;AACA,MAAID,UAAUE,SAAd,EACE,IAAI,CAACF,MAAMG,eAAN,EAAL,EAA8BF,aAAa,KAAb,CAA9B,KACK,IAAI,CAACD,MAAMI,cAAN,EAAL,EAA6BH,aAAa,IAAb;AACpC,SAAO,EAAEF,IAAF,EAAQE,UAAR,EAAP;AACD;;AAEM,SAASZ,MAAT,CAAgBU,IAAhB,EAA6E;AAClF,UAAQA,KAAKM,IAAb;AACE,SAAK,aAAL;AACA,SAAK,gBAAL;AACA,SAAK,eAAL;AACA,SAAK,gBAAL;AACE,aAAO,IAAP;AACF,SAAK,iBAAL;AACA,SAAK,eAAL;AACE,UAAIC,kBAAoBP,IAAxB;AACA,aAAOV,OAAOiB,gBAAgBC,QAAvB,CAAP;AACF,SAAK,kBAAL;AACA,SAAK,mBAAL;AACE,UAAIC,mBAAqBT,IAAzB;AACA,aAAOV,OAAOmB,iBAAiBC,IAAxB,KAAiCpB,OAAOmB,iBAAiBE,KAAxB,CAAxC;AACF;AACE,aAAO,KAAP;AAfJ;AAiBD;;AAED;AACA;AACA;AACA;AACO,MAAMC,4BAAN,CAEL;;AAMAC,cACEC,oBADF,EAEEC,sBAFF,EAGEC,gBAHF,EAIEC,IAJF,EAKE;AACA,SAAKH,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACD;;AAEDC,gBAAiB;AACf,WAAS,KAAKC,QAAL,CAAc,KAAKF,IAAnB,CAAT;AACD;;AAEDG,wBAAsBpB,IAAtB,EAA6D;AAC3D,YAAQA,KAAKM,IAAb;AACE,WAAK,gBAAL;AACA,WAAK,gBAAL;AACA,WAAK,eAAL;AACE,eAAO,CAAC,CAAGN,IAAF,CAA0FC,KAAnG;AACF,WAAK,YAAL;AAAmB;AACjB,cAAIoB,cAAc,KAAKN,sBAAL,CAA4BO,GAA5B,CAAgCtB,IAAhC,CAAlB;AACA,cAAIqB,gBAAgBlB,SAApB,EAA+B,OAAOkB,YAAYnB,UAAnB;AAC/B,iBAAOC,SAAP;AACD;AACD,WAAK,gBAAL;AAAuB;AACrB,cAAIkB,cAAc,KAAKL,gBAAL,CAAsBM,GAAtB,CAA0BtB,IAA1B,CAAlB;AACA,cAAIqB,gBAAgBlB,SAApB,EAA+B,OAAOkB,YAAYnB,UAAnB;AAC/B,iBAAOC,SAAP;AACD;AACD,WAAK,oBAAL;AACA,WAAK,yBAAL;AACA,WAAK,eAAL;AACE,eAAO,IAAP;AACF,WAAK,iBAAL;AACE,YAAIoB,kBAAoBvB,IAAxB;AACA,eAAOuB,gBAAgBC,UAAhB,KAA+B,IAA/B,IAAuCD,gBAAgBE,IAAhB,CAAqBA,IAArB,CAA0BC,MAA1B,KAAqC,CAA5E,GAAgF,IAAhF,GAAuFvB,SAA9F;AACF,WAAK,kBAAL;AACE,YAAIwB,mBAAqB3B,IAAzB;AACA,eAAO2B,iBAAiBC,UAAjB,CAA4BC,KAA5B,CAAkCC,YAAYxC,OAAOwC,SAASC,GAAhB,KAAwBzC,OAAOwC,SAAS7B,KAAhB,CAAtE,IACH,IADG,GAEHE,SAFJ;AAGF,WAAK,iBAAL;AACE,YAAI6B,kBAAoBhC,IAAxB;AACA,eAAOgC,gBAAgBC,QAAhB,CAAyBJ,KAAzB,CAA+BK,WAAWA,YAAY/B,SAAZ,IAAyBb,OAAO4C,OAAP,CAAnE,IAAsF,IAAtF,GAA6F/B,SAApG;AACF,WAAK,aAAL;AACE,eAAO,KAAP;AACF,WAAK,iBAAL;AACE,YAAII,kBAAoBP,IAAxB;AACA,eAAOO,gBAAgB4B,QAAhB,KAA6B,MAA7B,IAAuC7C,OAAOiB,gBAAgBC,QAAvB,CAAvC,GAA0E,KAA1E,GAAkFL,SAAzF;AACF;AACE,eAAOA,SAAP;AApCJ;AAsCD;;AAEDiC,qBAAmBpC,IAAnB,EAAyD;AACvD,QAAIqB,cAAc,KAAKN,sBAAL,CAA4BO,GAA5B,CAAgCtB,IAAhC,CAAlB;AACA,QAAIqB,gBAAgBlB,SAApB,EAA+B,OAAOkB,YAAYrB,IAAnB;AAC/B,WAAOA,IAAP,CAHuD,CAG1C;AACd;;AAEDqC,wBAAsBrC,IAAtB,EAA8F;AAC5F,QAAIqB,cAAc,KAAKN,sBAAL,CAA4BO,GAA5B,CAAgCtB,IAAhC,CAAlB;AACA,QAAIqB,gBAAgBlB,SAApB,EAA+B,OAAO,2CAAiCkB,YAAYrB,IAA7C,EAAmD,IAAnD,CAAP;AAC/B,WAAOA,IAAP,CAH4F,CAG/E;AACd;;AAEDsC,2BAAyBtC,IAAzB,EAAqE;AACnE;AACA,QAAIuC,UAAU,KAAKpB,QAAL,CAAcnB,KAAKyB,IAAnB,CAAd;AACA,QAAIc,YAAYvC,KAAKyB,IAArB,EAA2B;AACzB,UAAIe,MAAMC,OAAOC,MAAP,CAAc,EAAd,EAAkB1C,IAAlB,CAAV;AACAwC,UAAIf,IAAJ,GAAWc,OAAX;AACA,aAAOC,GAAP;AACD;AACD,WAAOxC,IAAP,CARmE,CAQtD;AACd;;AAED2C,yBAAuB3C,IAAvB,EAAiE;AAC/D,QAAIqB,cAAc,KAAKL,gBAAL,CAAsBM,GAAtB,CAA0BtB,IAA1B,CAAlB;AACA,QAAIqB,gBAAgBlB,SAApB,EAA+B,OAAOkB,YAAYrB,IAAnB;AAC/B,WAAO,KAAK4C,gBAAL,CAAsB5C,IAAtB,CAAP;AACD;;AAED6C,6BAA2B7C,IAA3B,EAAyE;AACvE;AACA,QAAI,KAAKiB,IAAL,KAAcjB,IAAlB,EAAwB;AACtB,YAAM8C,qBAAkD9C,IAAxD;AACA,YAAM+C,cAAgBD,mBAAmBrB,IAArB,CAAsDuB,gBAA1E;AACA;AACA,UAAID,gBAAgB5C,SAApB,EAA+B;AAC7B;;AAEA,cAAMV,wBAAwB,KAAKqB,oBAAL,CAA0BQ,GAA1B,CAA8ByB,WAA9B,CAA9B;AACA,YAAItD,yBAAyBD,qBAAqBC,qBAArB,CAA7B,EAA0E;AACxE,gBAAM,EAAEwD,SAAF,KAAgBxD,qBAAtB;AACA,iBAAOF,EAAE2D,cAAF,CAAiB3D,EAAE4D,gBAAF,CAAmBF,SAAnB,EAA8B1D,EAAE6D,UAAF,CAAa,MAAb,CAA9B,CAAjB,EAAsE,8BAAtE,CAAP;AACD;AACF;AACF;;AAED,WAAO,KAAKR,gBAAL,CAAsB5C,IAAtB,CAAP;AACD;;AAEDqD,sBAAoBrD,IAApB,EAA2D;AACzD,QAAIsD,iBAAiB,KAAKlC,qBAAL,CAA2BpB,KAAKuD,IAAhC,CAArB;AACA,QAAID,mBAAmB,IAAvB,EAA6B;AAC3B;AACA;AACA;AACA;AACA,aAAO,KAAKnC,QAAL,CAAcnB,KAAKwD,UAAnB,CAAP;AACD,KAND,MAMO,IAAIF,mBAAmB,KAAvB,EAA8B;AACnC,UAAItD,KAAKyD,SAAL,KAAmB,IAAvB,EAA6B;AAC3B,eAAO,KAAKtC,QAAL,CAAcnB,KAAKyD,SAAnB,CAAP;AACD,OAFD,MAEO;AACL,eAAOlE,EAAEmE,cAAF,EAAP;AACD;AACF;;AAED,WAAO,KAAKd,gBAAL,CAAsB5C,IAAtB,CAAP;AACD;;AAED2D,gCAA8B3D,IAA9B,EAA+E;AAC7E,QAAIsD,iBAAiB,KAAKlC,qBAAL,CAA2BpB,KAAKuD,IAAhC,CAArB;AACA,QAAID,mBAAmBnD,SAAvB,EAAkC;AAChC,aAAOmD,iBAAiB,KAAKnC,QAAL,CAAcnB,KAAKwD,UAAnB,CAAjB,GAAkD,KAAKrC,QAAL,CAAcnB,KAAKyD,SAAnB,CAAzD;AACD;;AAED,WAAO,KAAKb,gBAAL,CAAsB5C,IAAtB,CAAP;AACD;;AAED4D,4BAA0B5D,IAA1B,EAAuE;AACrE,QAAI6D,iBAAiB,KAAKzC,qBAAL,CAA2BpB,KAAKU,IAAhC,CAArB;AACA,QAAIV,KAAKmC,QAAL,KAAkB,IAAlB,IAA0B0B,mBAAmB1D,SAAjD,EAA4D;AAC1D,aAAO0D,iBAAiB,KAAK1C,QAAL,CAAcnB,KAAKW,KAAnB,CAAjB,GAA6C,KAAKQ,QAAL,CAAcnB,KAAKU,IAAnB,CAApD;AACD,KAFD,MAEO,IAAIV,KAAKmC,QAAL,KAAkB,IAAlB,IAA0B0B,mBAAmB1D,SAAjD,EAA4D;AACjE,aAAO0D,iBAAiB,KAAK1C,QAAL,CAAcnB,KAAKU,IAAnB,CAAjB,GAA4C,KAAKS,QAAL,CAAcnB,KAAKW,KAAnB,CAAnD;AACD;;AAED,WAAO,KAAKiC,gBAAL,CAAsB5C,IAAtB,CAAP;AACD;;AAED8D,yBAAuB9D,IAAvB,EAAiE;AAC/D,QAAIsD,iBAAiB,KAAKlC,qBAAL,CAA2BpB,KAAKuD,IAAhC,CAArB;AACA,QAAID,mBAAmB,KAAvB,EAA8B;AAC5B,aAAO/D,EAAEmE,cAAF,EAAP;AACD;;AAED,WAAO,KAAKd,gBAAL,CAAsB5C,IAAtB,CAAP;AACD;;AAED4C,mBAAiB5C,IAAjB,EAA6C;AAC3C,QAAI+D,OAAJ;AACA,SAAK,IAAIhC,GAAT,IAAgB/B,IAAhB,EAAsB;AACpB,UAAIgE,UAAWhE,IAAD,CAAY+B,GAAZ,CAAd;AACA,UAAI,CAACiC,OAAL,EAAc;AACd,UAAIC,UAAJ;AACA,UAAIC,MAAMC,OAAN,CAAcH,OAAd,CAAJ,EAA4B;AAC1B,YAAII,QAAJ;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIL,QAAQtC,MAA5B,EAAoC2C,GAApC,EAAyC;AACvC,cAAIC,cAAcN,QAAQK,CAAR,CAAlB;AACA,cAAI,CAACC,WAAL,EAAkB;AAClB,cAAIC,iBAAiB,KAAKpD,QAAL,CAAcmD,WAAd,CAArB;AACA,cAAIC,mBAAmBD,WAAvB,EAAoC;AAClC,gBAAIF,aAAajE,SAAjB,EAA4BiE,WAAWJ,QAAQQ,KAAR,CAAc,CAAd,CAAX;AAC5BJ,qBAASC,CAAT,IAAcE,cAAd;AACD;AACF;AACD,YAAIH,aAAajE,SAAjB,EAA4B;AAC5B8D,qBAAaG,QAAb;AACD,OAbD,MAaO,IAAIJ,QAAQ1D,IAAZ,EAAkB;AACvB2D,qBAAa,KAAK9C,QAAL,CAAc6C,OAAd,CAAb;AACA,YAAIC,eAAeD,OAAnB,EAA4B;AAC7B,OAHM,MAGA;;AAEP,UAAID,YAAY5D,SAAhB,EAA2B4D,UAAUtB,OAAOC,MAAP,CAAc,EAAd,EAAkB1C,IAAlB,CAAV;AAC3B+D,cAAQhC,GAAR,IAAekC,UAAf;AACD;AACD,WAAOF,WAAW/D,IAAlB;AACD;;AAEDmB,WAASnB,IAAT,EAAqC;AACnC,YAAQA,KAAKM,IAAb;AACE,WAAK,YAAL;AACE,eAAO,KAAK8B,kBAAL,CAAwBpC,IAAxB,CAAP;AACF,WAAK,kBAAL;AACE,eAAO,KAAKsC,wBAAL,CAA8BtC,IAA9B,CAAP;AACF,WAAK,gBAAL;AACA,WAAK,mBAAL;AACE,eAAOA,IAAP;AACF,WAAK,eAAL;AACA,WAAK,sBAAL;AACE,eAAO,KAAKqC,qBAAL,CAA2BrC,IAA3B,CAAP;AACF,WAAK,gBAAL;AACE,eAAO,KAAK2C,sBAAL,CAA4B3C,IAA5B,CAAP;AACF,WAAK,oBAAL;AACE,eAAO,KAAK6C,0BAAL,CAAgC7C,IAAhC,CAAP;AACF,WAAK,aAAL;AACE,eAAO,KAAKqD,mBAAL,CAAyBrD,IAAzB,CAAP;AACF,WAAK,uBAAL;AACE,eAAO,KAAK2D,6BAAL,CAAmC3D,IAAnC,CAAP;AACF,WAAK,mBAAL;AACE,eAAO,KAAK4D,yBAAL,CAA+B5D,IAA/B,CAAP;AACF,WAAK,gBAAL;AACE,eAAO,KAAK8D,sBAAL,CAA4B9D,IAA5B,CAAP;AACF;AACE,eAAO,KAAK4C,gBAAL,CAAsB5C,IAAtB,CAAP;AAxBJ;AA0BD;AAzND;QAFWY,4B,GAAAA,4B","file":"ResidualFunctionInstantiator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport * as t from \"babel-types\";\nimport { convertExpressionToJSXIdentifier } from \"../react/jsx\";\nimport type Value from \"../values/Value.js\";\nimport type {\n  BabelNodeBinaryExpression,\n  BabelNodeCallExpression,\n  BabelNodeFunctionExpression,\n  BabelNodeExpression,\n  BabelNodeClassMethod,\n  BabelNodeArrowFunctionExpression,\n  BabelNodeWhileStatement,\n  BabelNodeJSXIdentifier,\n  BabelNodeJSXMemberExpression,\n  BabelNodeConditionalExpression,\n  BabelNodeIfStatement,\n  BabelNodeLogicalExpression,\n  BabelNodeBooleanLiteral,\n  BabelNodeNumericLiteral,\n  BabelNodeStringLiteral,\n  BabelNodeUnaryExpression,\n  BabelNodeClassExpression,\n  BabelNodeObjectExpression,\n  BabelNodeArrayExpression,\n  BabelNodeSpreadElement,\n  BabelNodeLabeledStatement,\n} from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { FactoryFunctionInfo } from \"./types.js\";\nimport { nullExpression } from \"../utils/babelhelpers.js\";\n\nfunction canShareFunctionBody(duplicateFunctionInfo: FactoryFunctionInfo): boolean {\n  if (duplicateFunctionInfo.anyContainingAdditionalFunction) {\n    // If the function is referenced by an optimized function,\n    // it may get emitted within that optimized function,\n    // and then the function name is not generally available in arbitrary other code\n    // where we'd like to replace the body with a reference to the extracted function body.\n    // TODO: Revisit interplay of factory function concept, scope concept, and optimized functions.\n    return false;\n  }\n\n  // Only share function when:\n  // 1. it does not access any free variables.\n  // 2. it does not use \"this\".\n  const { unbound, modified, usesThis } = duplicateFunctionInfo.functionInfo;\n  return unbound.size === 0 && modified.size === 0 && !usesThis;\n}\n\nexport type Truthiness = void | boolean; // undefined means unknown\n\nexport type Replacement = {\n  node: BabelNodeExpression,\n  truthiness: Truthiness,\n};\n\nexport function getReplacement(node: BabelNodeExpression, value: void | Value): Replacement {\n  let truthiness;\n  if (value !== undefined)\n    if (!value.mightNotBeFalse()) truthiness = false;\n    else if (!value.mightNotBeTrue()) truthiness = true;\n  return { node, truthiness };\n}\n\nexport function isPure(node: BabelNodeExpression | BabelNodeSpreadElement): boolean {\n  switch (node.type) {\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n      return true;\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      let unaryExpression = ((node: any): BabelNodeUnaryExpression | BabelNodeSpreadElement);\n      return isPure(unaryExpression.argument);\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      let binaryExpression = ((node: any): BabelNodeLogicalExpression | BabelNodeBinaryExpression);\n      return isPure(binaryExpression.left) && isPure(binaryExpression.right);\n    default:\n      return false;\n  }\n}\n\n// This class instantiates residual functions by replacing certain nodes,\n// i.e. bindings to captured scopes that need to get renamed to variable ids.\n// The original nodes are never mutated; instead, nodes are cloned as needed.\n// Along the way, some trivial code optimizations are performed as well.\nexport class ResidualFunctionInstantiator<\n  T: BabelNodeClassMethod | BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression\n> {\n  factoryFunctionInfos: Map<number, FactoryFunctionInfo>;\n  identifierReplacements: Map<BabelNodeIdentifier, Replacement>;\n  callReplacements: Map<BabelNodeCallExpression, Replacement>;\n  root: T;\n\n  constructor(\n    factoryFunctionInfos: Map<number, FactoryFunctionInfo>,\n    identifierReplacements: Map<BabelNodeIdentifier, Replacement>,\n    callReplacements: Map<BabelNodeCallExpression, Replacement>,\n    root: T\n  ) {\n    this.factoryFunctionInfos = factoryFunctionInfos;\n    this.identifierReplacements = identifierReplacements;\n    this.callReplacements = callReplacements;\n    this.root = root;\n  }\n\n  instantiate(): T {\n    return ((this._replace(this.root): any): T);\n  }\n\n  _getLiteralTruthiness(node: BabelNodeExpression): Truthiness {\n    switch (node.type) {\n      case \"BooleanLiteral\":\n      case \"NumericLiteral\":\n      case \"StringLiteral\":\n        return !!((node: any): BabelNodeBooleanLiteral | BabelNodeNumericLiteral | BabelNodeStringLiteral).value;\n      case \"Identifier\": {\n        let replacement = this.identifierReplacements.get(node);\n        if (replacement !== undefined) return replacement.truthiness;\n        return undefined;\n      }\n      case \"CallExpression\": {\n        let replacement = this.callReplacements.get(node);\n        if (replacement !== undefined) return replacement.truthiness;\n        return undefined;\n      }\n      case \"FunctionExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"RegExpLiteral\":\n        return true;\n      case \"ClassExpression\":\n        let classExpression = ((node: any): BabelNodeClassExpression);\n        return classExpression.superClass === null && classExpression.body.body.length === 0 ? true : undefined;\n      case \"ObjectExpression\":\n        let objectExpression = ((node: any): BabelNodeObjectExpression);\n        return objectExpression.properties.every(property => isPure(property.key) && isPure(property.value))\n          ? true\n          : undefined;\n      case \"ArrayExpression\":\n        let arrayExpression = ((node: any): BabelNodeArrayExpression);\n        return arrayExpression.elements.every(element => element === undefined || isPure(element)) ? true : undefined;\n      case \"NullLiteral\":\n        return false;\n      case \"UnaryExpression\":\n        let unaryExpression = ((node: any): BabelNodeUnaryExpression);\n        return unaryExpression.operator === \"void\" && isPure(unaryExpression.argument) ? false : undefined;\n      default:\n        return undefined;\n    }\n  }\n\n  _replaceIdentifier(node: BabelNodeIdentifier): BabelNode {\n    let replacement = this.identifierReplacements.get(node);\n    if (replacement !== undefined) return replacement.node;\n    return node; // nothing else to replace in an identifier\n  }\n\n  _replaceJSXIdentifier(node: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression): BabelNode {\n    let replacement = this.identifierReplacements.get(node);\n    if (replacement !== undefined) return convertExpressionToJSXIdentifier(replacement.node, true);\n    return node; // nothing else to replace in an identifier\n  }\n\n  _replaceLabeledStatement(node: BabelNodeLabeledStatement): BabelNode {\n    // intentionally ignore embedded identifier\n    let newBody = this._replace(node.body);\n    if (newBody !== node.body) {\n      let res = Object.assign({}, node);\n      res.body = newBody;\n      return res;\n    }\n    return node; // nothing else to replace in a labeled statement\n  }\n\n  _replaceCallExpression(node: BabelNodeCallExpression): BabelNode {\n    let replacement = this.callReplacements.get(node);\n    if (replacement !== undefined) return replacement.node;\n    return this._replaceFallback(node);\n  }\n\n  _replaceFunctionExpression(node: BabelNodeFunctionExpression): BabelNode {\n    // Our goal is replacing duplicate nested function so skip root residual function itself.\n    if (this.root !== node) {\n      const functionExpression: BabelNodeFunctionExpression = node;\n      const functionTag = ((functionExpression.body: any): FunctionBodyAstNode).uniqueOrderedTag;\n      // Un-interpreted nested function?\n      if (functionTag !== undefined) {\n        // Un-interpreted nested function.\n\n        const duplicateFunctionInfo = this.factoryFunctionInfos.get(functionTag);\n        if (duplicateFunctionInfo && canShareFunctionBody(duplicateFunctionInfo)) {\n          const { factoryId } = duplicateFunctionInfo;\n          return t.callExpression(t.memberExpression(factoryId, t.identifier(\"bind\")), [nullExpression]);\n        }\n      }\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceIfStatement(node: BabelNodeIfStatement): BabelNode {\n    let testTruthiness = this._getLiteralTruthiness(node.test);\n    if (testTruthiness === true) {\n      // Strictly speaking this is not safe: Annex B.3.4 allows FunctionDeclarations as the body of IfStatements in sloppy mode,\n      // which have weird hoisting behavior: `console.log(typeof f); if (true) function f(){} console.log(typeof f)` will print 'undefined', 'function', but\n      // `console.log(typeof f); function f(){} console.log(typeof f)` will print 'function', 'function'.\n      // However, Babylon can't parse these, so it doesn't come up.\n      return this._replace(node.consequent);\n    } else if (testTruthiness === false) {\n      if (node.alternate !== null) {\n        return this._replace(node.alternate);\n      } else {\n        return t.emptyStatement();\n      }\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceConditionalExpression(node: BabelNodeConditionalExpression): BabelNode {\n    let testTruthiness = this._getLiteralTruthiness(node.test);\n    if (testTruthiness !== undefined) {\n      return testTruthiness ? this._replace(node.consequent) : this._replace(node.alternate);\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceLogicalExpression(node: BabelNodeLogicalExpression): BabelNode {\n    let leftTruthiness = this._getLiteralTruthiness(node.left);\n    if (node.operator === \"&&\" && leftTruthiness !== undefined) {\n      return leftTruthiness ? this._replace(node.right) : this._replace(node.left);\n    } else if (node.operator === \"||\" && leftTruthiness !== undefined) {\n      return leftTruthiness ? this._replace(node.left) : this._replace(node.right);\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceWhileStatement(node: BabelNodeWhileStatement): BabelNode {\n    let testTruthiness = this._getLiteralTruthiness(node.test);\n    if (testTruthiness === false) {\n      return t.emptyStatement();\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceFallback(node: BabelNode): BabelNode {\n    let newNode;\n    for (let key in node) {\n      let subNode = (node: any)[key];\n      if (!subNode) continue;\n      let newSubNode;\n      if (Array.isArray(subNode)) {\n        let newArray;\n        for (let i = 0; i < subNode.length; i++) {\n          let elementNode = subNode[i];\n          if (!elementNode) continue;\n          let newElementNode = this._replace(elementNode);\n          if (newElementNode !== elementNode) {\n            if (newArray === undefined) newArray = subNode.slice(0);\n            newArray[i] = newElementNode;\n          }\n        }\n        if (newArray === undefined) continue;\n        newSubNode = newArray;\n      } else if (subNode.type) {\n        newSubNode = this._replace(subNode);\n        if (newSubNode === subNode) continue;\n      } else continue;\n\n      if (newNode === undefined) newNode = Object.assign({}, node);\n      newNode[key] = newSubNode;\n    }\n    return newNode || node;\n  }\n\n  _replace(node: BabelNode): BabelNode {\n    switch (node.type) {\n      case \"Identifier\":\n        return this._replaceIdentifier(node);\n      case \"LabeledStatement\":\n        return this._replaceLabeledStatement(node);\n      case \"BreakStatement\":\n      case \"ContinueStatement\":\n        return node;\n      case \"JSXIdentifier\":\n      case \"JSXMemberExpressions\":\n        return this._replaceJSXIdentifier(node);\n      case \"CallExpression\":\n        return this._replaceCallExpression(node);\n      case \"FunctionExpression\":\n        return this._replaceFunctionExpression(node);\n      case \"IfStatement\":\n        return this._replaceIfStatement(node);\n      case \"ConditionalExpression\":\n        return this._replaceConditionalExpression(node);\n      case \"LogicalExpression\":\n        return this._replaceLogicalExpression(node);\n      case \"WhileStatement\":\n        return this._replaceWhileStatement(node);\n      default:\n        return this._replaceFallback(node);\n    }\n  }\n}\n"]}