{"version":3,"sources":["../../src/serializer/functions.js"],"names":["t","Functions","constructor","realm","moduleTracer","writeEffects","Map","functionExpressions","_noopFunction","undefined","__optimizedFunctionEntryOfValue","value","elements","values","getElements","possibleValues","filter","element","length","config","rootComponent","validConfig","intrinsics","validRootComponent","location","expressionLocation","start","line","column","end","handleError","currentLocation","__generateInitialAdditionalFunctions","globalKey","recordedAdditionalFunctions","globalRecordedAdditionalFunctionsMap","modules","logger","tryQuery","$GlobalObject","funcId","getOwnPropertyKeysArray","property","properties","get","descriptor","entry","push","optimizeReactComponentTreeRoots","statistics","environmentRecordIdAfterGlobalCode","recordedReactRootValues","react","verbose","logInformation","componentRoot","_callOfFunction","funcValue","call","$Call","numArgs","getLength","args","params","$FormalParameters","parameterId","isIdentifier","createAbstractArgument","name","thisArg","bind","checkThatFunctionsAreIndependent","additionalFunctionsToProcess","additionalFunctionStack","additionalFunctions","Set","map","optimizedFunctionsObject","getDeclaringAdditionalFunction","functionValue","additionalFunctionValue","additionalEffects","createdObjects","effects","has","optimizedFunctionId","getEffectsFromAdditionalFunctionAndNestedFunctions","currentOptimizedFunctionId","logCompilerDiagnostic","msg","error","t1","tracers","beginOptimizingFunction","evaluatePure","evaluateForEffectsInGlobalEnv","sideEffectType","binding","additionalFunctionEffects","set","modifiedProperties","withEffectsAppliedInGlobalEnv","propertyBinding","object","newValue","newEntry","add","pop","t2","endOptimizingFunction","shift","conflicts","fun1","fun1Name","intrinsicName","e1","result","fun2","reportFn","reportWriteConflicts","fun2Effects","parentAdditionalFunction","parentEffects","size","diagnostic","getAdditionalFunctionValuesToEffects","fname","pbs","call2","reportConflict","writtenObjects","forEach","val","key","m","oldReportObjectGetOwnProperties","reportObjectGetOwnProperties","ob","oldReportPropertyAccess","reportPropertyAccess","pb","refuseSerialization"],"mappings":"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","file":"functions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport { Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { type Effects, type PropertyBindings, Realm } from \"../realm.js\";\nimport type { PropertyBinding, ReactComponentTreeConfig } from \"../types.js\";\nimport { ignoreErrorsIn } from \"../utils/errors.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  ObjectValue,\n  UndefinedValue,\n  EmptyValue,\n  Value,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ModuleTracer } from \"../utils/modules.js\";\nimport { createAdditionalEffects } from \"./utils.js\";\nimport { ReactStatistics } from \"./types\";\nimport type { AdditionalFunctionEffects, WriteEffects } from \"./types\";\nimport { convertConfigObjectToReactComponentTreeConfig, valueIsKnownReactAbstraction } from \"../react/utils.js\";\nimport { applyOptimizedReactComponents, optimizeReactComponentTreeRoot } from \"../react/optimizing.js\";\nimport { handleReportedSideEffect } from \"./utils.js\";\nimport * as t from \"babel-types\";\n\ntype AdditionalFunctionEntry = {\n  value: ECMAScriptSourceFunctionValue | AbstractValue,\n  config?: ReactComponentTreeConfig,\n};\n\nexport class Functions {\n  constructor(realm: Realm, moduleTracer: ModuleTracer) {\n    this.realm = realm;\n    this.moduleTracer = moduleTracer;\n    this.writeEffects = new Map();\n    this.functionExpressions = new Map();\n    this._noopFunction = undefined;\n  }\n\n  realm: Realm;\n  // maps back from FunctionValue to the expression string\n  functionExpressions: Map<FunctionValue, string>;\n  moduleTracer: ModuleTracer;\n  writeEffects: WriteEffects;\n  _noopFunction: void | ECMAScriptSourceFunctionValue;\n\n  __optimizedFunctionEntryOfValue(value: Value): AdditionalFunctionEntry | void {\n    let realm = this.realm;\n\n    if (value instanceof AbstractValue) {\n      // if we conditionally called __optimize, we may have an AbstractValue that is the union of Empty or Undefined and\n      // a function/component to optimize\n      let elements = value.values.getElements();\n      if (elements) {\n        let possibleValues = [...elements].filter(\n          element => !(element instanceof EmptyValue || element instanceof UndefinedValue)\n        );\n        if (possibleValues.length === 1) {\n          value = possibleValues[0];\n        }\n      }\n    }\n    if (value instanceof ECMAScriptSourceFunctionValue) {\n      // additional function logic\n      return { value };\n    } else if (value instanceof ObjectValue) {\n      // React component tree logic\n      let config = Get(realm, value, \"config\");\n      let rootComponent = Get(realm, value, \"rootComponent\");\n      let validConfig = config instanceof ObjectValue || config === realm.intrinsics.undefined;\n      let validRootComponent =\n        rootComponent instanceof ECMAScriptSourceFunctionValue ||\n        (rootComponent instanceof AbstractValue && valueIsKnownReactAbstraction(this.realm, rootComponent));\n\n      if (validConfig && validRootComponent) {\n        return {\n          value: ((rootComponent: any): AbstractValue | ECMAScriptSourceFunctionValue),\n          config: convertConfigObjectToReactComponentTreeConfig(realm, ((config: any): ObjectValue | UndefinedValue)),\n        };\n      }\n    }\n\n    let location = value.expressionLocation\n      ? `${value.expressionLocation.start.line}:${value.expressionLocation.start.column} ` +\n        `${value.expressionLocation.end.line}:${value.expressionLocation.end.line}`\n      : \"location unknown\";\n    realm.handleError(\n      new CompilerDiagnostic(\n        `Optimized Function Value ${location} is an not a function or react element`,\n        realm.currentLocation,\n        \"PP0033\",\n        \"FatalError\"\n      )\n    );\n    throw new FatalError(\"Optimized Function Values must be functions or react elements\");\n  }\n\n  __generateInitialAdditionalFunctions(globalKey: string): Array<AdditionalFunctionEntry> {\n    let recordedAdditionalFunctions: Array<AdditionalFunctionEntry> = [];\n    let realm = this.realm;\n    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(realm, realm.$GlobalObject, globalKey),\n      realm.intrinsics.undefined\n    );\n    invariant(globalRecordedAdditionalFunctionsMap instanceof ObjectValue);\n    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray(true)) {\n      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);\n      if (property) {\n        let value = property.descriptor && property.descriptor.value;\n        invariant(value !== undefined);\n        invariant(value instanceof Value);\n        let entry = this.__optimizedFunctionEntryOfValue(value);\n        if (entry) recordedAdditionalFunctions.push(entry);\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  optimizeReactComponentTreeRoots(statistics: ReactStatistics, environmentRecordIdAfterGlobalCode: number): void {\n    let logger = this.moduleTracer.modules.logger;\n    let recordedReactRootValues = this.__generateInitialAdditionalFunctions(\"__reactComponentTrees\");\n    // Get write effects of the components\n    if (this.realm.react.verbose) {\n      logger.logInformation(`Evaluating ${recordedReactRootValues.length} React component tree roots...`);\n    }\n    for (let { value: componentRoot, config } of recordedReactRootValues) {\n      invariant(config);\n      optimizeReactComponentTreeRoot(\n        this.realm,\n        componentRoot,\n        config,\n        this.writeEffects,\n        environmentRecordIdAfterGlobalCode,\n        logger,\n        statistics\n      );\n    }\n    applyOptimizedReactComponents(this.realm, this.writeEffects, environmentRecordIdAfterGlobalCode);\n  }\n\n  _callOfFunction(funcValue: FunctionValue): void => Value {\n    let call = funcValue.$Call;\n    invariant(call);\n    let numArgs = funcValue.getLength();\n    let args = [];\n    invariant(funcValue instanceof ECMAScriptSourceFunctionValue);\n    let params = funcValue.$FormalParameters;\n    if (numArgs && numArgs > 0 && params) {\n      for (let parameterId of params) {\n        if (t.isIdentifier(parameterId)) {\n          // Create an AbstractValue similar to __abstract being called\n          args.push(\n            AbstractValue.createAbstractArgument(\n              this.realm,\n              ((parameterId: any): BabelNodeIdentifier).name,\n              funcValue.expressionLocation\n            )\n          );\n        } else {\n          this.realm.handleError(\n            new CompilerDiagnostic(\n              \"Non-identifier args to additional functions unsupported\",\n              funcValue.expressionLocation,\n              \"PP1005\",\n              \"FatalError\"\n            )\n          );\n          throw new FatalError(\"Non-identifier args to additional functions unsupported\");\n        }\n      }\n    }\n\n    let thisArg = AbstractValue.createAbstractArgument(this.realm, \"this\", funcValue.expressionLocation, ObjectValue);\n    return call.bind(this, thisArg, args);\n  }\n\n  checkThatFunctionsAreIndependent(environmentRecordIdAfterGlobalCode: number): void {\n    let additionalFunctionsToProcess = this.__generateInitialAdditionalFunctions(\"__optimizedFunctions\");\n    // When we find declarations of nested optimized functions, we need to apply the parent\n    // effects.\n    let additionalFunctionStack = [];\n    let additionalFunctions = new Set(additionalFunctionsToProcess.map(entry => entry.value));\n    let optimizedFunctionsObject = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(this.realm, this.realm.$GlobalObject, \"__optimizedFunctions\"),\n      this.realm.intrinsics.undefined\n    );\n    invariant(optimizedFunctionsObject instanceof ObjectValue);\n\n    // If there's an additional function that delcared functionValue, it must be\n    // have already been evaluated for the __optimize call to have happened, so\n    // this should always return either the defining additional function or void\n    let getDeclaringAdditionalFunction = functionValue => {\n      for (let [additionalFunctionValue, additionalEffects] of this.writeEffects) {\n        // CreatedObjects is all objects created by this additional function but not\n        // nested additional functions.\n        let createdObjects = additionalEffects.effects.createdObjects;\n        if (createdObjects.has(functionValue)) return additionalFunctionValue;\n      }\n    };\n\n    let optimizedFunctionId = 0;\n    let getEffectsFromAdditionalFunctionAndNestedFunctions = functionValue => {\n      let currentOptimizedFunctionId = optimizedFunctionId++;\n      additionalFunctionStack.push(functionValue);\n      invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n      let logCompilerDiagnostic = (msg: string) => {\n        let error = new CompilerDiagnostic(msg, undefined, \"PP1007\", \"Warning\");\n        realm.handleError(error);\n      };\n      for (let t1 of this.realm.tracers) t1.beginOptimizingFunction(currentOptimizedFunctionId, functionValue);\n      let call = this._callOfFunction(functionValue);\n      let realm = this.realm;\n      let effects: Effects = realm.evaluatePure(\n        () => realm.evaluateForEffectsInGlobalEnv(call, undefined, \"additional function\"),\n        (sideEffectType, binding, expressionLocation) =>\n          handleReportedSideEffect(logCompilerDiagnostic, sideEffectType, binding, expressionLocation)\n      );\n      invariant(effects);\n      let additionalFunctionEffects = createAdditionalEffects(\n        this.realm,\n        effects,\n        true,\n        \"AdditionalFunctionEffects\",\n        environmentRecordIdAfterGlobalCode,\n        getDeclaringAdditionalFunction(functionValue)\n      );\n      invariant(additionalFunctionEffects);\n      effects = additionalFunctionEffects.effects;\n      this.writeEffects.set(functionValue, additionalFunctionEffects);\n\n      // look for newly registered optimized functions\n      let modifiedProperties = additionalFunctionEffects.effects.modifiedProperties;\n      // Conceptually this will ensure that the nested additional function is defined\n      // although for later cases, we'll apply the effects of the parents only.\n      this.realm.withEffectsAppliedInGlobalEnv(() => {\n        for (let [propertyBinding] of modifiedProperties) {\n          let descriptor = propertyBinding.descriptor;\n          if (descriptor && propertyBinding.object === optimizedFunctionsObject) {\n            let newValue = descriptor.value;\n            invariant(newValue instanceof Value); //todo: this does not seem invariantly true\n            let newEntry = this.__optimizedFunctionEntryOfValue(newValue);\n            if (newEntry) {\n              additionalFunctions.add(newEntry.value);\n              getEffectsFromAdditionalFunctionAndNestedFunctions(newEntry.value);\n              // Now we have to rember the stack of effects that need to be applied to deal with\n              // this additional function.\n            }\n          }\n        }\n        return null;\n      }, additionalFunctionEffects.effects);\n      invariant(additionalFunctionStack.pop() === functionValue);\n      for (let t2 of this.realm.tracers) t2.endOptimizingFunction(currentOptimizedFunctionId);\n    };\n\n    while (additionalFunctionsToProcess.length > 0) {\n      let funcValue = additionalFunctionsToProcess.shift().value;\n      getEffectsFromAdditionalFunctionAndNestedFunctions(funcValue);\n    }\n    invariant(additionalFunctionStack.length === 0);\n\n    // check that functions are independent\n    let conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic> = new Map();\n    for (let fun1 of additionalFunctions) {\n      invariant(fun1 instanceof FunctionValue);\n      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || \"(unknown function)\";\n      // Also do argument validation here\n      let additionalFunctionEffects = this.writeEffects.get(fun1);\n      invariant(additionalFunctionEffects !== undefined);\n      let e1 = additionalFunctionEffects.effects;\n      invariant(e1 !== undefined);\n      if (e1.result instanceof Completion && !e1.result instanceof PossiblyNormalCompletion) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fun1Name} may terminate abruptly`,\n          e1.result.location,\n          \"PP1002\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n      for (let fun2 of additionalFunctions) {\n        if (fun1 === fun2) continue;\n        invariant(fun2 instanceof FunctionValue);\n        let reportFn = () => {\n          this.reportWriteConflicts(fun1Name, conflicts, e1.modifiedProperties, this._callOfFunction(fun2));\n          return null;\n        };\n        let fun2Effects = this.writeEffects.get(fun2);\n        invariant(fun2Effects);\n        if (fun2Effects.parentAdditionalFunction) {\n          let parentEffects = this.writeEffects.get(fun2Effects.parentAdditionalFunction);\n          invariant(parentEffects);\n          this.realm.withEffectsAppliedInGlobalEnv(reportFn, parentEffects.effects);\n        } else {\n          reportFn();\n        }\n      }\n    }\n    if (conflicts.size > 0) {\n      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n  }\n\n  getAdditionalFunctionValuesToEffects(): Map<FunctionValue, AdditionalFunctionEffects> {\n    return this.writeEffects;\n  }\n\n  reportWriteConflicts(\n    fname: string,\n    conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic>,\n    pbs: PropertyBindings,\n    call2: void => Value\n  ): void {\n    let reportConflict = (location: BabelNodeSourceLocation) => {\n      let error = new CompilerDiagnostic(\n        `Property access conflicts with write in optimized function ${fname}`,\n        location,\n        \"PP1003\",\n        \"FatalError\"\n      );\n      conflicts.set(location, error);\n    };\n    let writtenObjects: Set<ObjectValue | AbstractObjectValue> = new Set();\n    pbs.forEach((val, key, m) => {\n      writtenObjects.add(key.object);\n    });\n    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;\n    this.realm.reportObjectGetOwnProperties = (ob: ObjectValue) => {\n      let location = this.realm.currentLocation;\n      invariant(location);\n      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);\n    };\n    let oldReportPropertyAccess = this.realm.reportPropertyAccess;\n    this.realm.reportPropertyAccess = (pb: PropertyBinding) => {\n      if (pb.object.refuseSerialization) return;\n      let location = this.realm.currentLocation;\n      if (!location) return; // happens only when accessing an additional function property\n      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);\n    };\n    try {\n      ignoreErrorsIn(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));\n    } finally {\n      this.realm.reportPropertyAccess = oldReportPropertyAccess;\n      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;\n    }\n  }\n}\n"]}