{"version":3,"sources":["../../src/serializer/ResidualHeapGraphGenerator.js"],"names":["ResidualHeapGraphGenerator","constructor","realm","logger","modules","additionalFunctionValuesAndEffects","valueIdentifiers","valueToEdgeRecord","referentializer","_valueToEdgeRecord","_valueIdentifiers","_visitedValues","Set","_valueIds","Map","_idSeed","_path","_edges","preProcessValue","val","_shouldIgnore","_updateEdge","has","add","postProcessValue","length","pop","_getValueId","id","get","set","isIntrinsic","isLeaf","parent","push","fromId","toId","_getValueLabel","serializedId","getIdentifier","__originalName","name","_generateDotGraphData","nodes","edges","content","nodeId","_getValueShape","edge","_generateVisJSGraphData","nodesData","edgesData","node","nodeData","label","shape","color","_getValueColor","index","entries","edgeData","from","to","arrows","graphData","JSON","stringify","generateResult","heapGraphFormat"],"mappings":"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","file":"ResidualHeapGraphGenerator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Logger } from \"../utils/logger.js\";\nimport type { Modules } from \"../utils/modules.js\";\nimport type { Referentializer } from \"./Referentializer.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ObjectRefCount, AdditionalFunctionEffects } from \"./types.js\";\nimport type { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers\";\n\nimport invariant from \"../invariant.js\";\nimport {\n  Value,\n  EmptyValue,\n  FunctionValue,\n  AbstractValue,\n  SymbolValue,\n  ProxyValue,\n  ObjectValue,\n} from \"../values/index.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\n\ntype Edge = {\n  fromId: number,\n  toId: number,\n};\n\n/**\n * Generate a visualizable objects graph for Prepack heap.\n */\nexport class ResidualHeapGraphGenerator extends ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    valueIdentifiers: ResidualHeapValueIdentifiers,\n    valueToEdgeRecord: Map<Value, ObjectRefCount>,\n    referentializer: Referentializer\n  ) {\n    super(realm, logger, modules, additionalFunctionValuesAndEffects, referentializer);\n    this._valueToEdgeRecord = valueToEdgeRecord;\n    this._valueIdentifiers = valueIdentifiers;\n    this._visitedValues = new Set();\n    this._valueIds = new Map();\n    this._idSeed = 0;\n    this._path = [];\n    this._edges = [];\n  }\n\n  _valueIdentifiers: ResidualHeapValueIdentifiers;\n  _valueToEdgeRecord: Map<Value, ObjectRefCount>;\n  _valueIds: Map<Value, number>;\n  _idSeed: number;\n  _visitedValues: Set<Value>;\n  _path: Array<Value>; // Contains the path of nodes from root to current visiting node.\n  _edges: Array<Edge>;\n\n  // Override.\n  preProcessValue(val: Value): boolean {\n    if (this._shouldIgnore(val)) {\n      return true;\n    }\n    this._updateEdge(val);\n\n    if (this._visitedValues.has(val)) {\n      return false; // Already visited.\n    }\n    this._visitedValues.add(val);\n    return true;\n  }\n\n  // Override.\n  postProcessValue(val: Value): void {\n    if (this._shouldIgnore(val)) {\n      return;\n    }\n    invariant(this._path.length > 0);\n    this._path.pop();\n  }\n\n  _getValueId(val: Value): number {\n    let id = this._valueIds.get(val);\n    if (!id) {\n      this._valueIds.set(val, ++this._idSeed);\n      id = this._idSeed;\n    }\n    return id;\n  }\n\n  _shouldIgnore(val: Value): boolean {\n    return val instanceof EmptyValue || val.isIntrinsic() || HeapInspector.isLeaf(val);\n  }\n\n  _updateEdge(val: Value): void {\n    if (this._path.length > 0) {\n      const parent = this._path[this._path.length - 1];\n      this._edges.push({ fromId: this._getValueId(parent), toId: this._getValueId(val) });\n    }\n    this._path.push(val);\n  }\n\n  _getValueLabel(val: Value): string {\n    // TODO: does not use ref count yet, figure out how to best visualize it later.\n    const serializedId = this._valueIdentifiers.getIdentifier(val);\n    invariant(serializedId);\n    return val.__originalName ? `${serializedId.name}(${val.__originalName})` : serializedId.name;\n  }\n\n  _generateDotGraphData(nodes: Set<Value>, edges: Array<Edge>): string {\n    let content = \"digraph{\\n\";\n    for (const val of nodes) {\n      const nodeId = this._getValueId(val);\n      content += `  node${nodeId} [shape=${this._getValueShape(val)} label=${this._getValueLabel(val)}];\\n`;\n    }\n    for (const edge of edges) {\n      content += `  node${edge.fromId} -> node${edge.toId};\\n`;\n    }\n    content += \"}\";\n    return content;\n  }\n\n  _generateVisJSGraphData(nodes: Set<Value>, edges: Array<Edge>): string {\n    let nodesData = [];\n    let edgesData = [];\n\n    for (let node of nodes) {\n      const nodeId = this._getValueId(node);\n      let nodeData = {\n        id: `${nodeId}`,\n        label: this._getValueLabel(node),\n        shape: this._getValueShape(node),\n        color: this._getValueColor(node),\n      };\n      nodesData.push(nodeData);\n    }\n\n    for (let [index, edge] of edges.entries()) {\n      let edgeData = {\n        id: index,\n        from: `${edge.fromId}`,\n        to: `${edge.toId}`,\n        arrows: \"to\",\n      };\n      edgesData.push(edgeData);\n    }\n\n    let graphData = {\n      nodes: nodesData,\n      edges: edgesData,\n    };\n    return JSON.stringify(graphData);\n  }\n\n  // TODO: find a way to comment the meaning of shape => value mapping in final graph language.\n  _getValueShape(val: Value): string {\n    let shape = null;\n    if (val instanceof FunctionValue) {\n      shape = \"circle\";\n    } else if (val instanceof AbstractValue) {\n      shape = \"diamond\";\n    } else if (val instanceof ProxyValue) {\n      shape = \"triangle\";\n    } else if (val instanceof SymbolValue) {\n      shape = \"star\";\n    } else if (val instanceof ObjectValue) {\n      shape = \"box\";\n    } else {\n      shape = \"ellipse\";\n    }\n    return shape;\n  }\n\n  // TODO: find a way to comment the meaning of shape => value mapping in final graph language.\n  _getValueColor(val: Value): string {\n    let shape = null;\n    if (val instanceof FunctionValue) {\n      shape = \"red\";\n    } else if (val instanceof AbstractValue) {\n      shape = \"green\";\n    } else if (val instanceof ProxyValue) {\n      shape = \"orange\";\n    } else if (val instanceof SymbolValue) {\n      shape = \"yellow\";\n    } else if (val instanceof ObjectValue) {\n      shape = \"#3BB9FF\"; // light blue\n    } else {\n      shape = \"grey\";\n    }\n    return shape;\n  }\n\n  generateResult(heapGraphFormat: \"DotLanguage\" | \"VISJS\"): string {\n    return heapGraphFormat === \"DotLanguage\"\n      ? this._generateDotGraphData(this._visitedValues, this._edges)\n      : this._generateVisJSGraphData(this._visitedValues, this._edges);\n  }\n}\n"]}