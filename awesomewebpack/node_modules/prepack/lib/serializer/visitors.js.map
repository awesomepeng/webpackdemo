{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["t","visitName","path","state","node","modified","scope","hasBinding","name","nodes","functionInfo","unbound","get","undefined","set","push","add","ignorePath","parent","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","enter","depth","exit","ArrowFunctionExpression","lexicalDepth","CallExpression","getModuleIdIfNodeIsRequireFunction","moduleId","requireCalls","ReferencedIdentifier","innerName","usesArguments","ThisExpression","usesThis","ids","getBindingIdentifiers"],"mappings":";;;;;;;AAWA;;AACA;;IAAYA,C;;;;AAZZ;;;;;;;;;AASA;;AAkBA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,QAAtC,EAAgD;AAC9C;AACA,MAAIH,KAAKI,KAAL,CAAWC,UAAX,CAAsBH,KAAKI,IAA3B,EAAiC,aAAc,IAA/C,CAAJ,EAA0D;;AAE1D;AACA,MAAIC,QAAQN,MAAMO,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CAA+BR,KAAKI,IAApC,CAAZ;AACA,MAAIC,UAAUI,SAAd,EAAyBV,MAAMO,YAAN,CAAmBC,OAAnB,CAA2BG,GAA3B,CAA+BV,KAAKI,IAApC,EAA2CC,QAAQ,EAAnD;AACzBA,QAAMM,IAAN,CAAWX,IAAX;AACA,MAAIC,QAAJ,EAAcF,MAAMO,YAAN,CAAmBL,QAAnB,CAA4BW,GAA5B,CAAgCZ,KAAKI,IAArC;AACf;;AAED,SAASS,UAAT,CAAoBf,IAApB,EAA6C;AAC3C,MAAIgB,SAAShB,KAAKgB,MAAlB;AACA,SAAOlB,EAAEmB,kBAAF,CAAqBD,MAArB,KAAgClB,EAAEoB,gBAAF,CAAmBF,MAAnB,CAAhC,IAA8DlB,EAAEqB,mBAAF,CAAsBH,MAAtB,CAArE;AACD;;AAEM,IAAII,gDAAoB;AAC7B,oEAAkE;AAChEC,UAAMrB,IAAN,EAA+BC,KAA/B,EAA8D;AAC5DA,YAAMO,YAAN,CAAmBc,KAAnB;AACD,KAH+D;AAIhEC,SAAKvB,IAAL,EAA8BC,KAA9B,EAA6D;AAC3DA,YAAMO,YAAN,CAAmBc,KAAnB;AACD;AAN+D,GADrC;;AAU7BE,2BAAyB;AACvBH,UAAMrB,IAAN,EAA+BC,KAA/B,EAA8D;AAC5DA,YAAMO,YAAN,CAAmBc,KAAnB;AACArB,YAAMO,YAAN,CAAmBiB,YAAnB;AACD,KAJsB;AAKvBF,SAAKvB,IAAL,EAA8BC,KAA9B,EAA6D;AAC3DA,YAAMO,YAAN,CAAmBc,KAAnB;AACArB,YAAMO,YAAN,CAAmBiB,YAAnB;AACD;AARsB,GAVI;;AAqB7BC,iBAAe1B,IAAf,EAAwCC,KAAxC,EAAuE;AACrE;AACA;AACA,QAAIA,MAAM0B,kCAAN,KAA6ChB,SAAjD,EAA4D;AAC5D,QAAIiB,WAAW3B,MAAM0B,kCAAN,CAAyC3B,KAAKI,KAA9C,EAAqDJ,KAAKE,IAA1D,CAAf;AACA,QAAI0B,aAAajB,SAAjB,EAA4B;AAC5BV,UAAMO,YAAN,CAAmBqB,YAAnB,CAAgCjB,GAAhC,CAAoCZ,KAAKE,IAAzC,EAA+C0B,QAA/C;AACD,GA5B4B;;AA8B7BE,uBAAqB9B,IAArB,EAA8CC,KAA9C,EAA6E;AAC3E,QAAIc,WAAWf,IAAX,CAAJ,EAAsB;;AAEtB,QAAI+B,YAAY/B,KAAKE,IAAL,CAAUI,IAA1B;AACA,QAAIyB,cAAc,WAAlB,EAA+B;AAC7B,UAAI9B,MAAMO,YAAN,CAAmBc,KAAnB,KAA6B,CAAjC,EAAoC;AAClCrB,cAAMO,YAAN,CAAmBwB,aAAnB,GAAmC,IAAnC;AACD;AACD;AACA;AACD;AACDjC,cAAUC,IAAV,EAAgBC,KAAhB,EAAuBD,KAAKE,IAA5B,EAAkC,KAAlC;AACD,GA1C4B;;AA4C7B+B,iBAAejC,IAAf,EAAwCC,KAAxC,EAAuE;AACrE,QAAIA,MAAMO,YAAN,CAAmBc,KAAnB,GAA2BrB,MAAMO,YAAN,CAAmBiB,YAA9C,KAA+D,CAAnE,EAAsE;AACpExB,YAAMO,YAAN,CAAmB0B,QAAnB,GAA8B,IAA9B;AACD;AACF,GAhD4B;;AAkD7B,0CAAwClC,IAAxC,EAAiEC,KAAjE,EAAgG;AAC9F,QAAIkC,MAAMnC,KAAKoC,qBAAL,EAAV;AACA,SAAK,IAAI9B,IAAT,IAAiB6B,GAAjB,EAAsB;AACpBpC,gBAAUC,IAAV,EAAgBC,KAAhB,EAAuBkC,IAAI7B,IAAJ,CAAvB,EAAkC,IAAlC;AACD;AACF;AAvD4B,CAAxB","file":"visitors.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { Realm } from \"../realm.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeCallExpression } from \"babel-types\";\nimport type { BabelTraversePath, BabelTraverseScope } from \"babel-traverse\";\nimport type { FunctionInfo } from \"./types.js\";\n\ntype GetModuleIdIfNodeIsRequireFunction =\n  | void\n  | ((scope: BabelTraverseScope, node: BabelNodeCallExpression) => void | number | string);\n\nexport type ClosureRefVisitorState = {\n  functionInfo: FunctionInfo,\n  realm: Realm,\n  getModuleIdIfNodeIsRequireFunction: GetModuleIdIfNodeIsRequireFunction,\n};\n\nfunction visitName(path, state, node, modified) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(node.name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  let nodes = state.functionInfo.unbound.get(node.name);\n  if (nodes === undefined) state.functionInfo.unbound.set(node.name, (nodes = []));\n  nodes.push(node);\n  if (modified) state.functionInfo.modified.add(node.name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nexport let ClosureRefVisitor = {\n  \"FunctionDeclaration|ArrowFunctionExpression|FunctionExpression\": {\n    enter(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth++;\n    },\n    exit(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth--;\n    },\n  },\n\n  ArrowFunctionExpression: {\n    enter(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth++;\n      state.functionInfo.lexicalDepth++;\n    },\n    exit(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth--;\n      state.functionInfo.lexicalDepth--;\n    },\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    if (state.getModuleIdIfNodeIsRequireFunction === undefined) return;\n    let moduleId = state.getModuleIdIfNodeIsRequireFunction(path.scope, path.node);\n    if (moduleId === undefined) return;\n    state.functionInfo.requireCalls.set(path.node, moduleId);\n  },\n\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      if (state.functionInfo.depth === 1) {\n        state.functionInfo.usesArguments = true;\n      }\n      // \"arguments\" bound to local scope. therefore, there's no need to visit this identifier.\n      return;\n    }\n    visitName(path, state, path.node, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (state.functionInfo.depth - state.functionInfo.lexicalDepth === 1) {\n      state.functionInfo.usesThis = true;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    let ids = path.getBindingIdentifiers();\n    for (let name in ids) {\n      visitName(path, state, ids[name], true);\n    }\n  },\n};\n"]}