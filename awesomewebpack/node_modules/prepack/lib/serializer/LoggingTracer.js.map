{"version":3,"sources":["../../src/serializer/LoggingTracer.js"],"names":["describeValue","realm","v","value","toString","ToStringPartial","LoggingTracer","constructor","nesting","log","message","console","map","_","join","beginEvaluateForEffects","state","push","endEvaluateForEffects","effects","name","pop","beforeCall","F","thisArgument","argumentsList","newTarget","afterCall","result","beginOptimizingFunction","optimizedFunctionId","functionValue","intrinsicName","expressionLocation","endOptimizingFunction"],"mappings":";;;;;;;AAWA;;AACA;;AAEA;;AACA;;AACA;;AAWA;;AACA;;;;AACA;;;;AA7BA;;;;;;;;;AA+BA,SAASA,aAAT,CAAuBC,KAAvB,EAAqCC,CAArC,EAAuD;AACrD,MAAIA,oCAA4BA,iCAAhC,EAA2D,OAAOA,EAAEC,KAAF,CAAQC,QAAR,EAAP;AAC3D,MAAIF,mCAAJ,EAAiC,OAAO,WAAP;AACjC,MAAIA,8BAAJ,EAA4B,OAAO,MAAP;AAC5B,MAAIA,gCAAJ,EAA8B,OAAQ,IAAGA,EAAEC,KAAM,GAAnB,CAJuB,CAIA;AACrD,MAAID,kCAAJ,EAAgC,OAAO,eAAGG,eAAH,CAAmBJ,KAAnB,EAA0B,gBAAIA,KAAJ,EAAWC,CAAX,EAAc,MAAd,CAA1B,KAAoD,sBAA3D;AAChC,MAAIA,gCAAJ,EAA8B,OAAO,eAAP;AAC9B,MAAIA,kCAAJ,EAAgC,OAAO,uBAAP;AAChC,2BAAU,KAAV;AACD;;AAEM,MAAMI,aAAN,uBAAmC;AACxCC,cAAYN,KAAZ,EAA0B;AACxB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKO,OAAL,GAAe,EAAf;AACD;;AAKDC,MAAIC,OAAJ,EAA2B;AACzBC,YAAQF,GAAR,CAAa,WAAU,KAAKD,OAAL,CAAaI,GAAb,CAAiBC,KAAK,IAAtB,EAA4BC,IAA5B,CAAiC,EAAjC,CAAqC,GAAEJ,OAAQ,EAAtE;AACD;;AAEDK,0BAAwBC,KAAxB,EAA0C;AACxC,SAAKP,GAAL,CAAU,uBAAV;AACA,SAAKD,OAAL,CAAaS,IAAb,CAAkB,wBAAlB;AACD;;AAEDC,wBAAsBF,KAAtB,EAAkCG,OAAlC,EAAiE;AAC/D,QAAIC,OAAO,KAAKZ,OAAL,CAAaa,GAAb,EAAX;AACA,6BAAUD,SAAS,wBAAnB;AACA,SAAKX,GAAL,CAAU,uBAAV;AACD;;AAEDa,aACEC,CADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,SAJF,EAKQ;AACN,QAAIzB,QAAQ,KAAKA,KAAjB;AACA,QAAImB,OAAOpB,cAAcC,KAAd,EAAqBsB,CAArB,CAAX;AACA,SAAKd,GAAL,CAAU,IAAGW,IAAK,IAAGK,cAAcb,GAAd,CAAkBV,KAAKF,cAAcC,KAAd,EAAqBC,CAArB,CAAvB,EAAgDY,IAAhD,CAAqD,IAArD,CAA2D,GAAhF;AACA,SAAKN,OAAL,CAAaS,IAAb,CAAkBG,IAAlB;AACD;;AAEDO,YACEJ,CADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,SAJF,EAKEE,MALF,EAMQ;AACN,QAAIR,OAAO,KAAKZ,OAAL,CAAaa,GAAb,EAAX;AACA,SAAKZ,GAAL,CAAU,IAAGW,IAAK,GAAEQ,iDAAoC,SAApC,GAAgD,EAAG,EAAvE;AACD;;AAEDC,0BAAwBC,mBAAxB,EAAqDC,aAArD,EAAyF;AACvF,SAAKtB,GAAL,CACG,gCAA+BqB,mBAAoB,IAClDC,cAAcC,aAAd,GAA8BD,cAAcC,aAA5C,GAA4D,gBAC7D,IAAGD,cAAcE,kBAAd,GAAmC,oCAAiBF,cAAcE,kBAA/B,CAAnC,GAAwF,EAAG,EAHjG;AAKD;;AAEDC,wBAAsBJ,mBAAtB,EAAyD;AACvD,SAAKrB,GAAL,CAAU,8BAA6BqB,mBAAoB,EAA3D;AACD;AA1DuC;QAA7BxB,a,GAAAA,a","file":"LoggingTracer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Reference } from \"../environment.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ThrowCompletion, AbruptCompletion } from \"../completions.js\";\nimport {\n  FunctionValue,\n  Value,\n  NumberValue,\n  BooleanValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { stringOfLocation } from \"../utils/babelhelpers.js\";\n\nfunction describeValue(realm: Realm, v: Value): string {\n  if (v instanceof NumberValue || v instanceof BooleanValue) return v.value.toString();\n  if (v instanceof UndefinedValue) return \"undefined\";\n  if (v instanceof NullValue) return \"null\";\n  if (v instanceof StringValue) return `\"${v.value}\"`; // TODO: proper escaping\n  if (v instanceof FunctionValue) return To.ToStringPartial(realm, Get(realm, v, \"name\")) || \"(anonymous function)\";\n  if (v instanceof ObjectValue) return \"(some object)\";\n  if (v instanceof AbstractValue) return \"(some abstract value)\";\n  invariant(false);\n}\n\nexport class LoggingTracer extends Tracer {\n  constructor(realm: Realm) {\n    super();\n    this.realm = realm;\n    this.nesting = [];\n  }\n\n  realm: Realm;\n  nesting: Array<string>;\n\n  log(message: string): void {\n    console.log(`[calls] ${this.nesting.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any): void {\n    this.log(`>evaluate for effects`);\n    this.nesting.push(\"(evaluate for effects)\");\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects): void {\n    let name = this.nesting.pop();\n    invariant(name === \"(evaluate for effects)\");\n    this.log(`<evaluate for effects`);\n  }\n\n  beforeCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue\n  ): void {\n    let realm = this.realm;\n    let name = describeValue(realm, F);\n    this.log(`>${name}(${argumentsList.map(v => describeValue(realm, v)).join(\", \")})`);\n    this.nesting.push(name);\n  }\n\n  afterCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    result: void | Reference | Value | AbruptCompletion\n  ): void {\n    let name = this.nesting.pop();\n    this.log(`<${name}${result instanceof ThrowCompletion ? \": error\" : \"\"}`);\n  }\n\n  beginOptimizingFunction(optimizedFunctionId: number, functionValue: FunctionValue): void {\n    this.log(\n      `>Starting Optimized Function ${optimizedFunctionId} ${\n        functionValue.intrinsicName ? functionValue.intrinsicName : \"[unknown name]\"\n      } ${functionValue.expressionLocation ? stringOfLocation(functionValue.expressionLocation) : \"\"}`\n    );\n  }\n\n  endOptimizingFunction(optimizedFunctionId: number): void {\n    this.log(`<Ending Optimized Function ${optimizedFunctionId}`);\n  }\n}\n"]}