{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["t","ResidualFunctions","constructor","realm","options","modules","requireReturns","locationService","prelude","factoryNameGenerator","residualFunctionInfos","residualFunctionInstances","residualClassMethodInstances","additionalFunctionValueInfos","additionalFunctionValueNestedFunctions","referentializer","functionPrototypes","Map","firstFunctionUsages","functions","classes","functionInstances","residualFunctionInitializers","instance","values","undefined","has","functionValue","addFunctionInstance","additionalFunctionPreludes","keys","set","getStatistics","statistics","push","code","$ECMAScriptCode","setFunctionPrototype","prototypeId","addFunctionUsage","val","bodyReference","_shouldUseFactoryFunction","funcBody","instances","length","shouldInlineFunction","scopeInstances","size","shouldInline","start","end","bodySize","functionInfo","get","usesArguments","hasAnyLeakedIds","scope","leakedIds","_getIdentifierReplacements","residualFunctionBindings","unbound","res","name","nodes","residualFunctionBinding","declarativeEnvironmentRecord","value","serializedValue","replacement","referentialized","node","_getCallReplacements","requireCalls","modified","callNode","moduleId","callee","requireCallsReplaced","_hasRewrittenFunctionInstance","rewrittenAdditionalFunctions","find","_generateFactoryFunctionInfos","factoryFunctionInfos","functionBody","factoryId","suffix","__originalName","debugNames","identifier","generate","getLocation","functionUniqueTag","uniqueOrderedTag","anyContainingAdditionalFunction","every","containingAdditionalFunction","_sortFunctionByOriginalOrdering","functionEntries","sort","funcA","funcB","funcAUniqueTag","funcBUniqueTag","_createFunctionExpression","params","body","isLexical","Object","assign","arrowFunctionExpression","functionExpression","spliceFunctions","scrubFunctionInitializers","functionBodies","additionalFunctionModifiedBindingsSegment","getModifiedBindingsSegment","additionalFunction","getFunctionBody","getPrelude","b","Array","from","entries","unstrictFunctionBodies","strictFunctionBodies","registerFunctionStrictness","strict","isFunctionExpression","isArrowFunctionExpression","funcNodes","defineFunction","funcId","funcOrClassNode","initializationStatements","initializationBody","prototype","apply","isCallExpression","isClassExpression","variableDeclaration","variableDeclarator","id","memberExpression","funcValue","funcInfo","scopes","Set","residualBinding","modifiedBindings","add","bodySegment","referentializationScope","init","getReferentializedScopeInitialization","numericLiteral","additionalFunctionInfo","$FormalParameters","$ThisMode","rewrittenBody","blockStatement","classMethodInstance","methodType","classMethodKeyNode","classSuperNode","classMethodComputed","classPrototype","classMethodIsStatic","isConstructor","isExpression","isIdentifier","_getOrCreateClassNode","classMethod","unshift","superClass","$Strict","usesThis","normalInstances","additionalFunctionNestedInstances","naiveProcessInstances","instancesToSplice","functionClones","hasEmptyConstructor","$HasEmptyConstructor","methodParams","slice","instantiate","scopeInitialization","concat","funcOrClassNodeBody","isBlockStatement","factoryInfo","factoryNames","sameResidualBindings","isDifferent","lastBinding","firstBinding","factoryParams","key","scopeName","scopeNameId","factoryNode","factoryNodeBody","factoryDeclaration","insertionPoint","functionId","hasFunctionArg","flatArgs","map","funcNode","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","childBody","returnStatement","callExpression","referentializationState","createCapturedScopesPrelude","createLeakedIds","reverse","splice","index","initializerStatement","getInitializerStatement","classExpression","classBody"],"mappings":"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","file":"ResidualFunctions.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue, ECMAScriptSourceFunctionValue, ObjectValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeCallExpression,\n  BabelNodeClassMethod,\n  BabelNodeClassExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n  BabelNodeArrowFunctionExpression,\n} from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FactoryFunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n} from \"./types.js\";\nimport { BodyReference, AreSameResidualBinding } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { ResidualFunctionInstantiator, type Replacement, getReplacement } from \"./ResidualFunctionInstantiator.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/babelhelpers.js\";\nimport type { LocationService, ClassMethodInstance } from \"./types.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport { getOrDefault } from \"./utils.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression>,\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    modules: Modules,\n    requireReturns: Map<number | string, Replacement>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    factoryNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    additionalFunctionValueNestedFunctions: Set<FunctionValue>,\n    referentializer: Referentializer\n  ) {\n    this.realm = realm;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.classes = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(locationService);\n    this.residualFunctionInfos = residualFunctionInfos;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.referentializer = referentializer;\n    for (let instance of residualFunctionInstances.values()) {\n      invariant(instance !== undefined);\n      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);\n    }\n    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;\n    this.additionalFunctionPreludes = new Map();\n    for (let functionValue of additionalFunctionValueInfos.keys()) {\n      this.additionalFunctionPreludes.set(functionValue, []);\n    }\n  }\n\n  realm: Realm;\n  modules: Modules;\n  requireReturns: Map<number | string, Replacement>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  classes: Map<ObjectValue, BabelNodeClassExpression>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  referentializer: Referentializer;\n  additionalFunctionPreludes: Map<FunctionValue, Array<BabelNodeStatement>>;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  addFunctionInstance(instance: FunctionInstance): void {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    getOrDefault(this.functions, code, () => []).push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier): void {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference): void {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _shouldUseFactoryFunction(funcBody: BabelNodeBlockStatement, instances: Array<FunctionInstance>): boolean {\n    invariant(instances.length > 0);\n    function shouldInlineFunction(): boolean {\n      if (instances[0].scopeInstances.size > 0) return false;\n      let shouldInline = true;\n      if (funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n      return shouldInline;\n    }\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { usesArguments } = functionInfo;\n    let hasAnyLeakedIds = false;\n    for (const instance of instances)\n      for (const scope of instance.scopeInstances.values()) if (scope.leakedIds.length > 0) hasAnyLeakedIds = true;\n    return !shouldInlineFunction() && instances.length > 1 && !usesArguments && !hasAnyLeakedIds;\n  }\n\n  _getIdentifierReplacements(\n    funcBody: BabelNodeBlockStatement,\n    residualFunctionBindings: Map<string, ResidualFunctionBinding>\n  ): Map<BabelNodeIdentifier, Replacement> {\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { unbound } = functionInfo;\n    let res = new Map();\n    for (let [name, nodes] of unbound) {\n      let residualFunctionBinding = residualFunctionBindings.get(name);\n      if (residualFunctionBinding === undefined) continue;\n\n      // Let's skip bindings that are referring to\n      // 1) something global (without an environment record), and\n      // 2) have not been assigned a value (which would mean that they have a var/let binding and Prepack will take the liberty to rename them).\n      if (\n        residualFunctionBinding.declarativeEnvironmentRecord === null &&\n        residualFunctionBinding.value === undefined\n      ) {\n        continue;\n      }\n\n      let serializedValue = residualFunctionBinding.serializedValue;\n      invariant(serializedValue !== undefined);\n      let replacement = getReplacement(\n        serializedValue,\n        residualFunctionBinding.referentialized ? undefined : residualFunctionBinding.value\n      );\n      for (let node of nodes) res.set(node, replacement);\n    }\n    return res;\n  }\n\n  _getCallReplacements(funcBody: BabelNodeBlockStatement): Map<BabelNode, Replacement> {\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { requireCalls, modified } = functionInfo;\n    let res = new Map();\n    for (let [callNode, moduleId] of requireCalls) {\n      this.getStatistics().requireCalls++;\n      if (modified.has(callNode.callee.name)) continue;\n\n      let replacement = this.requireReturns.get(\"\" + moduleId);\n      if (replacement !== undefined) {\n        this.getStatistics().requireCallsReplaced++;\n        res.set(callNode, replacement);\n      }\n    }\n    return res;\n  }\n\n  // Note: this function takes linear time. Please do not call it inside loop.\n  _hasRewrittenFunctionInstance(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>,\n    instances: Array<FunctionInstance>\n  ): boolean {\n    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;\n  }\n\n  _generateFactoryFunctionInfos(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): Map<number, FactoryFunctionInfo> {\n    const factoryFunctionInfos = new Map();\n    for (const [functionBody, instances] of this.functions) {\n      invariant(instances.length > 0);\n\n      let factoryId;\n      const suffix = instances[0].functionValue.__originalName || this.realm.debugNames ? \"factoryFunction\" : \"\";\n      if (this._shouldUseFactoryFunction(functionBody, instances)) {\n        // Rewritten function should never use factory function.\n        invariant(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));\n        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n      } else {\n        // For inline function body case, use the first function as the factory function.\n        factoryId = this.locationService.getLocation(instances[0].functionValue);\n      }\n\n      const functionUniqueTag = ((functionBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(functionUniqueTag);\n\n      const functionInfo = this.residualFunctionInfos.get(functionBody);\n      invariant(functionInfo);\n      let anyContainingAdditionalFunction = !instances.every(\n        instance => instance.containingAdditionalFunction === undefined\n      );\n      factoryFunctionInfos.set(functionUniqueTag, { factoryId, functionInfo, anyContainingAdditionalFunction });\n    }\n    return factoryFunctionInfos;\n  }\n\n  // Preserve residual functions' ordering based on its ast dfs traversal order.\n  // This is necessary to prevent unexpected code locality issues.\n  _sortFunctionByOriginalOrdering(functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]>): void {\n    functionEntries.sort((funcA, funcB) => {\n      const funcAUniqueTag = ((funcA[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcAUniqueTag);\n\n      const funcBUniqueTag = ((funcB[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcBUniqueTag);\n      return funcAUniqueTag - funcBUniqueTag;\n    });\n  }\n\n  _createFunctionExpression(\n    params: Array<BabelNodeLVal>,\n    body: BabelNodeBlockStatement,\n    isLexical: boolean\n  ): BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression {\n    // Additional statements might be inserted at the beginning of the body, so we clone it.\n    body = ((Object.assign({}, body): any): BabelNodeBlockStatement);\n    return isLexical ? t.arrowFunctionExpression(params, body) : t.functionExpression(null, params, body);\n  }\n\n  spliceFunctions(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    // these need to get spliced in at the end\n    let additionalFunctionModifiedBindingsSegment: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let getModifiedBindingsSegment = additionalFunction =>\n      getOrDefault(additionalFunctionModifiedBindingsSegment, additionalFunction, () => []);\n    let getFunctionBody = (instance: FunctionInstance): Array<BabelNodeStatement> =>\n      getOrDefault(functionBodies, instance, () => []);\n    let getPrelude = (instance: FunctionInstance): Array<BabelNodeStatement> => {\n      let additionalFunction = instance.containingAdditionalFunction;\n      let b;\n      if (additionalFunction !== undefined) {\n        b = this.additionalFunctionPreludes.get(additionalFunction);\n        invariant(b !== undefined);\n      } else {\n        b = this.prelude;\n      }\n      return b;\n    };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this._sortFunctionByOriginalOrdering(functionEntries);\n    this.getStatistics().functions = functionEntries.length;\n    let unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression> = [];\n    let strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression> = [];\n    let registerFunctionStrictness = (\n      node:\n        | BabelNodeFunctionExpression\n        | BabelNodeArrowFunctionExpression\n        | BabelNodeClassMethod\n        | BabelNodeClassExpression,\n      strict: boolean\n    ) => {\n      if (t.isFunctionExpression(node) || t.isArrowFunctionExpression(node)) {\n        (strict ? strictFunctionBodies : unstrictFunctionBodies).push(\n          ((node: any): BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression)\n        );\n      }\n    };\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n    let defineFunction = (\n      instance: FunctionInstance,\n      funcId: BabelNodeIdentifier,\n      funcOrClassNode:\n        | BabelNodeCallExpression\n        | BabelNodeFunctionExpression\n        | BabelNodeArrowFunctionExpression\n        | BabelNodeClassExpression\n    ) => {\n      let { functionValue } = instance;\n\n      if (instance.initializationStatements.length > 0) {\n        // always add initialization statements to insertion point\n        let initializationBody = getFunctionBody(instance);\n        Array.prototype.push.apply(initializationBody, instance.initializationStatements);\n      }\n\n      let body;\n      if (t.isFunctionExpression(funcOrClassNode)) {\n        funcNodes.set(functionValue, ((funcOrClassNode: any): BabelNodeFunctionExpression));\n        body = getPrelude(instance);\n      } else {\n        invariant(\n          t.isCallExpression(funcOrClassNode) ||\n            t.isClassExpression(funcOrClassNode) ||\n            t.isArrowFunctionExpression(funcOrClassNode)\n        ); // .bind call\n        body = getFunctionBody(instance);\n      }\n      body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcOrClassNode)]));\n      let prototypeId = this.functionPrototypes.get(functionValue);\n      if (prototypeId !== undefined) {\n        let id = this.locationService.getLocation(functionValue);\n        invariant(id !== undefined);\n        body.push(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    // Emit code for ModifiedBindings for additional functions\n    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {\n      let scopes = new Set();\n      for (let [, residualBinding] of funcInfo.modifiedBindings) {\n        let scope = residualBinding.scope;\n        if (scope === undefined || scopes.has(scope)) continue;\n        scopes.add(scope);\n\n        invariant(residualBinding.referentialized);\n\n        // Find the proper prelude to emit to (global vs additional function's prelude)\n        let bodySegment = getModifiedBindingsSegment(funcValue);\n\n        // binding has been referentialized, so setup the scope to be able to\n        // access bindings from other __captured_scopes initializers\n        if (scope.referentializationScope !== funcValue) {\n          let init = this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id));\n          // flow forces me to do this\n          Array.prototype.push.apply(bodySegment, init);\n        }\n      }\n    }\n\n    // Process Additional Functions\n    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {\n      let { instance } = additionalFunctionInfo;\n      let functionValue = ((funcValue: any): ECMAScriptSourceFunctionValue);\n      let params = functionValue.$FormalParameters;\n      let isLexical = functionValue.$ThisMode === \"lexical\";\n      invariant(params !== undefined);\n\n      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);\n      invariant(rewrittenBody);\n\n      // rewritten functions shouldn't have references fixed up because the body,\n      // consists of serialized code. For simplicity we emit their instances in a naive way\n      let functionBody = t.blockStatement(rewrittenBody);\n      let funcOrClassNode;\n\n      if (this.residualClassMethodInstances.has(funcValue)) {\n        let classMethodInstance = this.residualClassMethodInstances.get(funcValue);\n        invariant(classMethodInstance);\n        let {\n          methodType,\n          classMethodKeyNode,\n          classSuperNode,\n          classMethodComputed,\n          classPrototype,\n          classMethodIsStatic,\n        } = classMethodInstance;\n\n        let isConstructor = methodType === \"constructor\";\n        invariant(classPrototype instanceof ObjectValue);\n        invariant(classMethodKeyNode && (t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode)));\n        // we use the classPrototype as the key to get the class expression ast node\n        funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n        let classMethod = t.classMethod(\n          methodType,\n          classMethodKeyNode,\n          params,\n          functionBody,\n          classMethodComputed,\n          classMethodIsStatic\n        );\n        // add the class method to the class expression node body\n        if (isConstructor) {\n          funcOrClassNode.body.body.unshift(classMethod);\n        } else {\n          funcOrClassNode.body.body.push(classMethod);\n        }\n        // we only return the funcOrClassNode if this is the constructor\n        if (!isConstructor) {\n          continue;\n        }\n        // handle the class super\n        if (classSuperNode !== undefined) {\n          funcOrClassNode.superClass = classSuperNode;\n        }\n      } else {\n        funcOrClassNode = isLexical\n          ? t.arrowFunctionExpression(params, functionBody)\n          : t.functionExpression(null, params, functionBody);\n      }\n      let id = this.locationService.getLocation(funcValue);\n      invariant(id !== undefined);\n\n      registerFunctionStrictness(\n        funcOrClassNode,\n        funcValue instanceof ECMAScriptSourceFunctionValue && funcValue.$Strict\n      );\n      defineFunction(instance, id, funcOrClassNode);\n    }\n\n    // Process normal functions\n    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, usesThis } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      // Split instances into normal or nested in an additional function\n      let normalInstances = [];\n      let additionalFunctionNestedInstances = [];\n      for (let instance of instances) {\n        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue))\n          additionalFunctionNestedInstances.push(instance);\n        else normalInstances.push(instance);\n      }\n\n      let naiveProcessInstances = instancesToSplice => {\n        this.getStatistics().functionClones += instancesToSplice.length;\n\n        for (let instance of instancesToSplice) {\n          let { functionValue, residualFunctionBindings, scopeInstances } = instance;\n          let funcOrClassNode;\n\n          if (this.residualClassMethodInstances.has(functionValue)) {\n            let classMethodInstance = this.residualClassMethodInstances.get(functionValue);\n            invariant(classMethodInstance);\n            let {\n              classSuperNode,\n              classMethodKeyNode,\n              methodType,\n              classMethodComputed,\n              classPrototype,\n              classMethodIsStatic,\n            } = classMethodInstance;\n\n            let isConstructor = methodType === \"constructor\";\n            invariant(classPrototype instanceof ObjectValue);\n            invariant(classMethodKeyNode);\n            invariant(t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode));\n            // we use the classPrototype as the key to get the class expression ast node\n            funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n            // if we are dealing with a constructor, don't serialize it if the original\n            // had an empty user-land constructor (because we create a constructor behind the scenes for them)\n            let hasEmptyConstructor = !!functionValue.$HasEmptyConstructor;\n            if (!isConstructor || (isConstructor && !hasEmptyConstructor)) {\n              let methodParams = params.slice();\n              let classMethod = new ResidualFunctionInstantiator(\n                factoryFunctionInfos,\n                this._getIdentifierReplacements(funcBody, residualFunctionBindings),\n                this._getCallReplacements(funcBody),\n                t.classMethod(\n                  methodType,\n                  classMethodKeyNode,\n                  methodParams,\n                  funcBody,\n                  classMethodComputed,\n                  classMethodIsStatic\n                )\n              ).instantiate();\n\n              // add the class method to the class expression node body\n              if (isConstructor) {\n                funcOrClassNode.body.body.unshift(classMethod);\n              } else {\n                funcOrClassNode.body.body.push(classMethod);\n              }\n            }\n            // we only return the funcOrClassNode if this is the constructor\n            if (!isConstructor) {\n              continue;\n            }\n            // handle the class super\n            if (classSuperNode !== undefined) {\n              funcOrClassNode.superClass = classSuperNode;\n            }\n          } else {\n            let isLexical = instance.functionValue.$ThisMode === \"lexical\";\n            funcOrClassNode = new ResidualFunctionInstantiator(\n              factoryFunctionInfos,\n              this._getIdentifierReplacements(funcBody, residualFunctionBindings),\n              this._getCallReplacements(funcBody),\n              this._createFunctionExpression(params, funcBody, isLexical)\n            ).instantiate();\n\n            let scopeInitialization = [];\n            for (let scope of scopeInstances.values()) {\n              scopeInitialization = scopeInitialization.concat(\n                this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id))\n              );\n            }\n\n            if (scopeInitialization.length > 0) {\n              let funcOrClassNodeBody = ((funcOrClassNode.body: any): BabelNodeBlockStatement);\n              invariant(t.isBlockStatement(funcOrClassNodeBody));\n              funcOrClassNodeBody.body = scopeInitialization.concat(funcOrClassNodeBody.body);\n            }\n          }\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n\n          registerFunctionStrictness(funcOrClassNode, functionValue.$Strict);\n          invariant(id !== undefined);\n          invariant(funcOrClassNode !== undefined);\n          defineFunction(instance, id, funcOrClassNode);\n        }\n      };\n\n      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);\n      if (normalInstances.length > 0 && !this._shouldUseFactoryFunction(funcBody, normalInstances)) {\n        naiveProcessInstances(normalInstances);\n        this.getStatistics().functionClones--;\n      } else if (normalInstances.length > 0) {\n        const functionUniqueTag = ((funcBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n        invariant(functionUniqueTag);\n        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);\n        invariant(factoryInfo);\n        const { factoryId } = factoryInfo;\n\n        // filter included variables to only include those that are different\n        let factoryNames: Array<string> = [];\n        let sameResidualBindings = new Map();\n        for (let name of unbound.keys()) {\n          let isDifferent = false;\n          let lastBinding;\n\n          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);\n          invariant(firstBinding);\n          if (firstBinding.modified) {\n            // Must modify for traversal\n            sameResidualBindings.set(name, firstBinding);\n            continue;\n          }\n\n          for (let { residualFunctionBindings } of normalInstances) {\n            let residualBinding = residualFunctionBindings.get(name);\n\n            invariant(residualBinding);\n            invariant(!residualBinding.modified);\n            if (!lastBinding) {\n              lastBinding = residualBinding;\n            } else if (!AreSameResidualBinding(this.realm, residualBinding, lastBinding)) {\n              isDifferent = true;\n              break;\n            }\n          }\n\n          if (isDifferent) {\n            factoryNames.push(name);\n          } else {\n            invariant(lastBinding);\n            sameResidualBindings.set(name, lastBinding);\n          }\n        }\n\n        let factoryParams: Array<BabelNodeLVal> = [];\n        for (let key of factoryNames) {\n          factoryParams.push(t.identifier(key));\n        }\n\n        let scopeInitialization = [];\n        for (let [scopeName, scope] of normalInstances[0].scopeInstances) {\n          let scopeNameId = t.identifier(scopeName);\n          factoryParams.push(scopeNameId);\n          scopeInitialization = scopeInitialization.concat(\n            this.referentializer.getReferentializedScopeInitialization(scope, scopeNameId)\n          );\n        }\n\n        factoryParams = factoryParams.concat(params).slice();\n        let factoryNode = new ResidualFunctionInstantiator(\n          factoryFunctionInfos,\n          this._getIdentifierReplacements(funcBody, sameResidualBindings),\n          this._getCallReplacements(funcBody),\n          this._createFunctionExpression(factoryParams, funcBody, false)\n        ).instantiate();\n\n        if (scopeInitialization.length > 0) {\n          let factoryNodeBody = ((factoryNode.body: any): BabelNodeBlockStatement);\n          invariant(t.isBlockStatement(factoryNodeBody));\n          factoryNodeBody.body = scopeInitialization.concat(factoryNodeBody.body);\n        }\n\n        // factory functions do not depend on any nested generator scope, so they go to the prelude\n        let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n        this.prelude.push(factoryDeclaration);\n\n        registerFunctionStrictness(factoryNode, normalInstances[0].functionValue.$Strict);\n\n        for (let instance of normalInstances) {\n          let { functionValue, residualFunctionBindings, insertionPoint } = instance;\n          let functionId = this.locationService.getLocation(functionValue);\n          invariant(functionId !== undefined);\n          let hasFunctionArg = false;\n          let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n            let residualBinding = residualFunctionBindings.get(name);\n            invariant(residualBinding);\n            let serializedValue = residualBinding.serializedValue;\n            hasFunctionArg =\n              hasFunctionArg || (residualBinding.value && residualBinding.value instanceof FunctionValue);\n            invariant(serializedValue);\n            return serializedValue;\n          });\n          let hasAnyLeakedIds = false;\n          for (const scope of instance.scopeInstances.values()) {\n            flatArgs.push(t.numericLiteral(scope.id));\n            if (scope.leakedIds.length > 0) hasAnyLeakedIds = true;\n          }\n          let funcNode;\n          let firstUsage = this.firstFunctionUsages.get(functionValue);\n          invariant(insertionPoint !== undefined);\n          if (\n            // The same free variables in shared instances may refer to objects with different initialization values\n            // so a stub forward function is needed during delay initializations.\n            this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n            usesThis ||\n            hasFunctionArg ||\n            (firstUsage !== undefined && !firstUsage.isNotEarlierThan(insertionPoint)) ||\n            this.functionPrototypes.get(functionValue) !== undefined ||\n            hasAnyLeakedIds\n          ) {\n            let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n            for (let flatArg of flatArgs) callArgs.push(flatArg);\n            for (let param of params) {\n              if (param.type !== \"Identifier\") {\n                throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n              }\n              callArgs.push(((param: any): BabelNodeIdentifier));\n            }\n\n            let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n            funcNode = t.functionExpression(null, params, childBody);\n            registerFunctionStrictness(funcNode, functionValue.$Strict);\n          } else {\n            funcNode = t.callExpression(\n              t.memberExpression(factoryId, t.identifier(\"bind\")),\n              [nullExpression].concat(flatArgs)\n            );\n          }\n\n          defineFunction(instance, functionId, funcNode);\n        }\n      }\n    }\n\n    for (let referentializationScope of this.referentializer.referentializationState.keys()) {\n      let prelude;\n      // Get the prelude for this additional function value\n      if (referentializationScope !== \"GLOBAL\") {\n        let additionalFunction = referentializationScope;\n        prelude = this.additionalFunctionPreludes.get(additionalFunction);\n        invariant(prelude !== undefined);\n      } else {\n        prelude = this.prelude;\n      }\n      prelude.unshift(\n        ...this.referentializer.createCapturedScopesPrelude(referentializationScope),\n        ...this.referentializer.createLeakedIds(referentializationScope)\n      );\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        insertionPoint.body.entries.splice(insertionPoint.index, 0, ...functionBody);\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions (for delay initializations)\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    for (let [additionalFunction, body] of Array.from(rewrittenAdditionalFunctions.entries()).reverse()) {\n      let additionalFunctionInfo = this.additionalFunctionValueInfos.get(additionalFunction);\n      invariant(additionalFunctionInfo);\n      // Modified bindings initializers of optimized function\n      let bodySegment = additionalFunctionModifiedBindingsSegment.get(additionalFunction);\n      // initializers from Referentialization\n      let initializationStatements = getFunctionBody(additionalFunctionInfo.instance);\n      let prelude = this.additionalFunctionPreludes.get(additionalFunction);\n      invariant(prelude !== undefined);\n      let insertionPoint = additionalFunctionInfo.instance.insertionPoint;\n      invariant(insertionPoint);\n      // TODO: I think this inserts things in the wrong place\n      insertionPoint.body.entries.splice(insertionPoint.index, 0, ...initializationStatements);\n      if (bodySegment) body.unshift(...bodySegment);\n      body.unshift(...prelude);\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies };\n  }\n  _getOrCreateClassNode(classPrototype: ObjectValue): BabelNodeClassExpression {\n    if (!this.classes.has(classPrototype)) {\n      let funcOrClassNode = t.classExpression(null, null, t.classBody([]), []);\n      this.classes.set(classPrototype, funcOrClassNode);\n      return funcOrClassNode;\n    } else {\n      let funcOrClassNode = this.classes.get(classPrototype);\n      invariant(funcOrClassNode && t.isClassExpression(funcOrClassNode));\n      return funcOrClassNode;\n    }\n  }\n}\n"]}