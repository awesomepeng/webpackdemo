{"version":3,"sources":["../../src/serializer/Referentializer.js"],"names":["t","Referentializer","constructor","realm","options","scopeNameGenerator","scopeBindingNameGenerator","leakedNameGenerator","_options","referentializationState","Map","_leakedNameGenerator","getStatistics","statistics","_createReferentializationState","capturedScopeInstanceIdx","capturedScopesArray","identifier","generate","capturedScopeAccessFunctionId","serializedScopes","_getReferentializationState","referentializationScope","bind","createLeakedIds","leakedIds","scopeBinding","values","push","length","variableDeclaration","map","id","variableDeclarator","createCapturedScopesPrelude","accessFunctionDeclaration","_createCaptureScopeAccessFunction","undefined","_createCapturedScopesArrayInitialization","cases","initializationCases","initializationValues","expr","arrayExpression","key","code","has","set","scopeIDs","value","ic","get","size","body","selectorParam","captured","selectorExpression","memberExpression","forEach","i","consequent","expressionStatement","assignmentExpression","breakStatement","switchCase","numericLiteral","invariantLevel","throwStatement","newExpression","stringLiteral","switchStatement","returnStatement","factoryFunction","functionExpression","blockStatement","accessFunctionId","_getReferentializationScope","residualBinding","potentialReferentializationScopes","scope","_getSerializedBindingScopeInstance","declarativeEnvironmentRecord","refState","name","getReferentializedScopeInitialization","scopeName","capturedScope","state","funcName","scopeArray","init","logicalExpression","callExpression","referentializeLeakedBinding","hasLeaked","serializedBindingId","serializedValue","serializedUnscopedLocation","referentialized","referentializeModifiedBinding","modified","variableIndexInScope","indexExpression","capturedScopeExpression","cleanInstance","instance","initializationStatements","b","residualFunctionBindings","binding","referentialize","residualBindings","scopeInstances"],"mappings":"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","file":"Referentializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"babel-types\";\nimport generate from \"babel-generator\";\nimport type { BabelNodeStatement, BabelNodeExpression, BabelNodeIdentifier } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type { ResidualFunctionBinding, ScopeBinding, FunctionInstance } from \"./types.js\";\nimport { type ReferentializationScope } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { getOrDefault } from \"./utils.js\";\nimport { Realm } from \"../realm.js\";\n\ntype ReferentializationState = {|\n  capturedScopeInstanceIdx: number,\n  capturedScopesArray: BabelNodeIdentifier,\n  capturedScopeAccessFunctionId: BabelNodeIdentifier,\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>,\n|};\n\n/*\n * This class helps fixup names in residual functions for variables that these\n * functions capture from parent scopes.\n * For each ReferentializationScope it creates a _get_scope_binding function\n * that contains the initialization for all of that scope's FunctionInstances\n * which will contain a switch statement with all the initializations.\n */\nexport class Referentializer {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    scopeNameGenerator: NameGenerator,\n    scopeBindingNameGenerator: NameGenerator,\n    leakedNameGenerator: NameGenerator\n  ) {\n    this._options = options;\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.scopeBindingNameGenerator = scopeBindingNameGenerator;\n\n    this.referentializationState = new Map();\n    this._leakedNameGenerator = leakedNameGenerator;\n    this.realm = realm;\n  }\n\n  _options: SerializerOptions;\n  scopeNameGenerator: NameGenerator;\n  scopeBindingNameGenerator: NameGenerator;\n  realm: Realm;\n\n  _newCapturedScopeInstanceIdx: number;\n  referentializationState: Map<ReferentializationScope, ReferentializationState>;\n  _leakedNameGenerator: NameGenerator;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  _createReferentializationState(): ReferentializationState {\n    return {\n      capturedScopeInstanceIdx: 0,\n      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate(\"main\")),\n      capturedScopeAccessFunctionId: t.identifier(this.scopeBindingNameGenerator.generate(\"get_scope_binding\")),\n      serializedScopes: new Map(),\n    };\n  }\n\n  _getReferentializationState(referentializationScope: ReferentializationScope): ReferentializationState {\n    return getOrDefault(\n      this.referentializationState,\n      referentializationScope,\n      this._createReferentializationState.bind(this)\n    );\n  }\n\n  createLeakedIds(referentializationScope: ReferentializationScope): Array<BabelNodeStatement> {\n    const leakedIds = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    for (const scopeBinding of serializedScopes.values()) leakedIds.push(...scopeBinding.leakedIds);\n    if (leakedIds.length === 0) return [];\n    return [t.variableDeclaration(\"var\", leakedIds.map(id => t.variableDeclarator(id)))];\n  }\n\n  createCapturedScopesPrelude(referentializationScope: ReferentializationScope): Array<BabelNodeStatement> {\n    let accessFunctionDeclaration = this._createCaptureScopeAccessFunction(referentializationScope);\n    if (accessFunctionDeclaration === undefined) return [];\n    return [accessFunctionDeclaration, this._createCapturedScopesArrayInitialization(referentializationScope)];\n  }\n\n  // Generate a shared function for accessing captured scope bindings.\n  // TODO: skip generating this function if the captured scope is not shared by multiple residual functions.\n  _createCaptureScopeAccessFunction(referentializationScope: ReferentializationScope): void | BabelNodeStatement {\n    // One switch case for one scope.\n    const cases = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    type InitializationCase = {|\n      scopeIDs: Array<number>,\n      value: BabelNodeExpression,\n    |};\n    const initializationCases: Map<string, InitializationCase> = new Map();\n    for (const scopeBinding of serializedScopes.values()) {\n      if (scopeBinding.initializationValues.length === 0) continue;\n      const expr = t.arrayExpression((scopeBinding.initializationValues: any));\n      const key = generate(expr, {}, \"\").code;\n      if (!initializationCases.has(key)) {\n        initializationCases.set(key, {\n          scopeIDs: [scopeBinding.id],\n          value: expr,\n        });\n      } else {\n        const ic = initializationCases.get(key);\n        invariant(ic);\n        ic.scopeIDs.push(scopeBinding.id);\n      }\n    }\n    if (initializationCases.size === 0) return undefined;\n\n    const body = [];\n    const selectorParam = t.identifier(\"__selector\");\n    const captured = t.identifier(\"__captured\");\n    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;\n    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam, /*Indexer syntax*/ true);\n    for (const ic of initializationCases.values()) {\n      ic.scopeIDs.forEach((id, i) => {\n        let consequent: Array<BabelNodeStatement> = [];\n        if (i === ic.scopeIDs.length - 1) {\n          consequent = [t.expressionStatement(t.assignmentExpression(\"=\", captured, ic.value)), t.breakStatement()];\n        }\n        cases.push(t.switchCase(t.numericLiteral(id), consequent));\n      });\n    }\n    // Default case.\n    if (this.realm.invariantLevel >= 1) {\n      cases.push(\n        t.switchCase(null, [\n          t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"Unknown scope selector\")])),\n        ])\n      );\n    }\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(captured)]));\n    body.push(t.switchStatement(selectorParam, cases));\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", selectorExpression, captured)));\n    body.push(t.returnStatement(captured));\n    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));\n    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(accessFunctionId, factoryFunction)]);\n  }\n\n  _getReferentializationScope(residualBinding: ResidualFunctionBinding): ReferentializationScope {\n    if (residualBinding.potentialReferentializationScopes.has(\"GLOBAL\")) return \"GLOBAL\";\n    if (residualBinding.potentialReferentializationScopes.size > 1) {\n      // TODO Revisit for nested optimized functions.\n      return \"GLOBAL\";\n    }\n    for (let scope of residualBinding.potentialReferentializationScopes) return scope;\n    invariant(false);\n  }\n\n  _getSerializedBindingScopeInstance(residualBinding: ResidualFunctionBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;\n    invariant(declarativeEnvironmentRecord);\n\n    let referentializationScope = this._getReferentializationScope(residualBinding);\n\n    // figure out if this is accessed only from additional functions\n    let refState: ReferentializationState = this._getReferentializationState(referentializationScope);\n    let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: refState.capturedScopeInstanceIdx++,\n        initializationValues: [],\n        leakedIds: [],\n        referentializationScope,\n      };\n      refState.serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    invariant(scope.referentializationScope === referentializationScope);\n    invariant(!residualBinding.scope || residualBinding.scope === scope);\n    residualBinding.scope = scope;\n    return scope;\n  }\n\n  getReferentializedScopeInitialization(\n    scope: ScopeBinding,\n    scopeName: BabelNodeExpression\n  ): Array<BabelNodeStatement> {\n    const capturedScope = scope.capturedScope;\n    invariant(capturedScope);\n    const state = this._getReferentializationState(scope.referentializationScope);\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const init = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    return [t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(capturedScope), init)])];\n  }\n\n  referentializeLeakedBinding(residualBinding: ResidualFunctionBinding): void {\n    invariant(residualBinding.hasLeaked);\n    // When simpleClosures is enabled, then space for captured mutable bindings is allocated upfront.\n    let serializedBindingId = t.identifier(this._leakedNameGenerator.generate(residualBinding.name));\n    let scope = this._getSerializedBindingScopeInstance(residualBinding);\n    scope.leakedIds.push(serializedBindingId);\n    residualBinding.serializedValue = residualBinding.serializedUnscopedLocation = serializedBindingId;\n\n    this.getStatistics().referentialized++;\n  }\n\n  referentializeModifiedBinding(residualBinding: ResidualFunctionBinding): void {\n    invariant(residualBinding.modified);\n\n    // Space for captured mutable bindings is allocated lazily.\n    let scope = this._getSerializedBindingScopeInstance(residualBinding);\n    let capturedScope = \"__captured\" + scope.name;\n    // Save the serialized value for initialization at the top of\n    // the factory.\n    // This can serialize more variables than are necessary to execute\n    // the function because every function serializes every\n    // modified variable of its parent scope. In some cases it could be\n    // an improvement to split these variables into multiple\n    // scopes.\n    const variableIndexInScope = scope.initializationValues.length;\n    const indexExpression = t.numericLiteral(variableIndexInScope);\n    invariant(residualBinding.serializedValue);\n    scope.initializationValues.push(residualBinding.serializedValue);\n    scope.capturedScope = capturedScope;\n\n    // Replace binding usage with scope references\n\n    // The rewritten .serializedValue refers to a local capturedScope variable\n    // which is only accessible from within residual functions where code\n    // to create this variable is emitted.\n    residualBinding.serializedValue = t.memberExpression(\n      t.identifier(capturedScope),\n      indexExpression,\n      true // Array style access.\n    );\n\n    // .serializedUnscopedLocation is initialized with a more general expressions\n    // that can be used outside of residual functions.\n    // TODO: Creating these expressions just in case looks expensive. Measure, and potentially only create lazily.\n    const state = this._getReferentializationState(scope.referentializationScope);\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const scopeName = t.numericLiteral(scope.id);\n    const capturedScopeExpression = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    residualBinding.serializedUnscopedLocation = t.memberExpression(\n      capturedScopeExpression,\n      indexExpression,\n      true // Array style access.\n    );\n\n    this.getStatistics().referentialized++;\n  }\n\n  // Cleans all scopes between passes of the serializer\n  cleanInstance(instance: FunctionInstance): void {\n    instance.initializationStatements = [];\n    for (let b of ((instance: any): FunctionInstance).residualFunctionBindings.values()) {\n      let binding = ((b: any): ResidualFunctionBinding);\n      if (binding.referentialized && binding.declarativeEnvironmentRecord) {\n        let declarativeEnvironmentRecord = binding.declarativeEnvironmentRecord;\n        let referentializationScope = this._getReferentializationScope(binding);\n\n        let refState = this.referentializationState.get(referentializationScope);\n        if (refState) {\n          let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n          if (scope) {\n            scope.initializationValues = [];\n            scope.leakedIds = [];\n          }\n        }\n      }\n      delete binding.serializedValue;\n    }\n  }\n\n  referentialize(instance: FunctionInstance): void {\n    let residualBindings = instance.residualFunctionBindings;\n\n    for (let residualBinding of residualBindings.values()) {\n      if (residualBinding === undefined) continue;\n      if (residualBinding.modified) {\n        // Initialize captured scope at function call instead of globally\n        if (!residualBinding.declarativeEnvironmentRecord) residualBinding.referentialized = true;\n        if (!residualBinding.referentialized) {\n          if (!residualBinding.hasLeaked) this._getSerializedBindingScopeInstance(residualBinding);\n          residualBinding.referentialized = true;\n        }\n\n        invariant(residualBinding.referentialized);\n        if (residualBinding.declarativeEnvironmentRecord && residualBinding.scope) {\n          instance.scopeInstances.set(residualBinding.scope.name, residualBinding.scope);\n        }\n      }\n    }\n  }\n\n  _createCapturedScopesArrayInitialization(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    return t.variableDeclaration(\"var\", [\n      t.variableDeclarator(\n        this._getReferentializationState(referentializationScope).capturedScopesArray,\n        t.newExpression(t.identifier(\"Array\"), [\n          t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx),\n        ])\n      ),\n    ]);\n  }\n}\n"]}