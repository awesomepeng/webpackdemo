{"version":3,"sources":["../../src/serializer/factorify.js"],"names":["factorifyObjects","t","isLiteral","node","type","operator","argument","isSameNode","left","right","name","Object","is","value","getObjectKeys","obj","keys","prop","properties","key","push","computed","indexOf","join","body","factoryNameGenerator","signatures","create","declar","declarations","init","initializerAstNodeName","declars","expr","expression","signatureKey","length","split","rootFactoryParams","rootFactoryProps","keyIndex","id","identifier","keyNode","isValidIdentifier","stringLiteral","objectProperty","rootFactoryId","generate","rootFactoryBody","blockStatement","returnStatement","objectExpression","rootFactory","functionDeclaration","unshift","args","callExpression","seen","Set","has","common","Map","mostSharedArgsLength","declar2","initializerAstNodeName2","sharedArgs","i","arguments","Math","max","set","sharedPairs","entries","pair","highestPairArgs","highestPairCount","pairArgs","undefined","declarsSub","concat","removeArgs","subFactoryArgs","subFactoryParams","arg","subFactoryId","subFactoryBody","subFactory","declarSub","add","call","callee","filter","val"],"mappings":"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","file":"factorify.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement, BabelNodeObjectExpression, BabelNodeLVal } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\n\nfunction isLiteral(node) {\n  switch (node.type) {\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n      return true;\n    case \"UnaryExpression\":\n      return node.operator === \"void\" && isLiteral(node.argument);\n    default:\n      return false;\n  }\n}\n\nfunction isSameNode(left, right) {\n  let type = left.type;\n\n  if (type !== right.type) {\n    return false;\n  }\n\n  if (type === \"Identifier\") {\n    return left.name === right.name;\n  }\n\n  if (type === \"NullLiteral\") {\n    return true;\n  }\n\n  if (type === \"BooleanLiteral\" || type === \"StringLiteral\" || type === \"NumericLiteral\") {\n    return Object.is(left.value, right.value);\n  }\n\n  if (type === \"UnaryExpression\") {\n    return (\n      left.operator === \"void\" && right.operator === \"void\" && isLiteral(left.argument) && isLiteral(right.argument)\n    );\n  }\n\n  return false;\n}\n\nfunction getObjectKeys(obj: BabelNodeObjectExpression): string | false {\n  let keys = [];\n\n  for (let prop of obj.properties) {\n    if (prop.type !== \"ObjectProperty\") return false;\n\n    let key = prop.key;\n    if (key.type === \"StringLiteral\") {\n      keys.push(key.value);\n    } else if (key.type === \"Identifier\") {\n      if (prop.computed) return false;\n      keys.push(key.name);\n    } else {\n      return false;\n    }\n  }\n\n  for (let key of keys) {\n    if (key.indexOf(\"|\") >= 0) return false;\n  }\n\n  return keys.join(\"|\");\n}\n\n// This function looks for recurring initialization patterns in the code of the form\n//   var x = { a: literal1, b: literal2 }\n//   var y = { a: literal1, b: literal3 }\n// and transforms them into something like\n//   function factory(b) { return { a: literal1, b } }\n//   var x = factory(literal2);\n//   var y = factory(literal3);\n// TODO #884: Right now, the visitor below only looks into top-level variable declaration\n// with a flat object literal initializer.\n// It should also look into conditional control flow, residual functions, and nested object literals.\nexport function factorifyObjects(body: Array<BabelNodeStatement>, factoryNameGenerator: NameGenerator): void {\n  let signatures = Object.create(null);\n\n  for (let node of body) {\n    switch (node.type) {\n      case \"VariableDeclaration\":\n        for (let declar of node.declarations) {\n          let { init } = declar;\n          if (!init) continue;\n          if (init.type !== \"ObjectExpression\") continue;\n\n          let keys = getObjectKeys(init);\n          if (!keys) continue;\n\n          let initializerAstNodeName = \"init\";\n          let declars = (signatures[keys] = signatures[keys] || []);\n          declars.push({ declar, initializerAstNodeName });\n        }\n        break;\n\n      case \"ExpressionStatement\":\n        const expr = node.expression;\n        if (expr.type !== \"AssignmentExpression\") {\n          break;\n        }\n        const { right } = expr;\n        if (right.type !== \"ObjectExpression\") {\n          break;\n        }\n\n        let keys = getObjectKeys(right);\n        if (!keys) continue;\n\n        let initializerAstNodeName = \"right\";\n        let declars = (signatures[keys] = signatures[keys] || []);\n        declars.push({ declar: node.expression, initializerAstNodeName });\n        break;\n\n      default:\n        // Continue to next node.\n        break;\n    }\n  }\n\n  for (let signatureKey in signatures) {\n    let declars = signatures[signatureKey];\n    if (declars.length < 5) continue;\n\n    let keys = signatureKey.split(\"|\");\n\n    //\n    let rootFactoryParams: Array<BabelNodeLVal> = [];\n    let rootFactoryProps = [];\n    for (let keyIndex = 0; keyIndex < keys.length; keyIndex++) {\n      let key = keys[keyIndex];\n      let id = t.identifier(`__${keyIndex}`);\n      rootFactoryParams.push(id);\n      let keyNode = t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key);\n      rootFactoryProps.push(t.objectProperty(keyNode, id));\n    }\n\n    let rootFactoryId = t.identifier(factoryNameGenerator.generate(\"root\"));\n    let rootFactoryBody = t.blockStatement([t.returnStatement(t.objectExpression(rootFactoryProps))]);\n    let rootFactory = t.functionDeclaration(rootFactoryId, rootFactoryParams, rootFactoryBody);\n    body.unshift(rootFactory);\n\n    //\n    for (let { declar, initializerAstNodeName } of declars) {\n      let args = [];\n      for (let prop of declar[initializerAstNodeName].properties) {\n        args.push(prop.value);\n      }\n\n      declar[initializerAstNodeName] = t.callExpression(rootFactoryId, args);\n    }\n\n    //\n    let seen = new Set();\n    for (let { declar, initializerAstNodeName } of declars) {\n      if (seen.has(declar)) continue;\n\n      // build up a map containing the arguments that are shared\n      let common = new Map();\n      let mostSharedArgsLength = 0;\n      for (let { declar: declar2, initializerAstNodeName: initializerAstNodeName2 } of declars) {\n        if (seen.has(declar2)) continue;\n        if (declar === declar2) continue;\n\n        let sharedArgs = [];\n        for (let i = 0; i < keys.length; i++) {\n          if (isSameNode(declar[initializerAstNodeName].arguments[i], declar2[initializerAstNodeName2].arguments[i])) {\n            sharedArgs.push(i);\n          }\n        }\n        if (!sharedArgs.length) continue;\n\n        mostSharedArgsLength = Math.max(mostSharedArgsLength, sharedArgs.length);\n        common.set(declar2, sharedArgs);\n      }\n\n      // build up a mapping of the argument positions that are shared so we can pick the top one\n      let sharedPairs = Object.create(null);\n      for (let [declar2, args] of common.entries()) {\n        if (args.length === mostSharedArgsLength) {\n          args = args.join(\",\");\n          let pair = (sharedPairs[args] = sharedPairs[args] || []);\n          pair.push(declar2);\n        }\n      }\n\n      // get the highest pair\n      let highestPairArgs;\n      let highestPairCount;\n      for (let pairArgs in sharedPairs) {\n        let pair = sharedPairs[pairArgs];\n        if (highestPairArgs === undefined || pair.length > highestPairCount) {\n          highestPairCount = pair.length;\n          highestPairArgs = pairArgs;\n        }\n      }\n      if (highestPairArgs === undefined) continue;\n\n      //\n      let declarsSub = sharedPairs[highestPairArgs].concat(declar);\n      let removeArgs = highestPairArgs.split(\",\");\n\n      let subFactoryArgs = [];\n      let subFactoryParams = [];\n      let sharedArgs = declarsSub[0][initializerAstNodeName].arguments;\n      for (let i = 0; i < sharedArgs.length; i++) {\n        let arg = sharedArgs[i];\n        if (removeArgs.indexOf(i + \"\") >= 0) {\n          subFactoryArgs.push(arg);\n        } else {\n          let id = t.identifier(`__${i}`);\n          subFactoryArgs.push(id);\n          subFactoryParams.push(id);\n        }\n      }\n\n      let subFactoryId = t.identifier(factoryNameGenerator.generate(\"sub\"));\n      let subFactoryBody = t.blockStatement([t.returnStatement(t.callExpression(rootFactoryId, subFactoryArgs))]);\n      let subFactory = t.functionDeclaration(subFactoryId, subFactoryParams, subFactoryBody);\n      body.unshift(subFactory);\n\n      for (let declarSub of declarsSub) {\n        seen.add(declarSub);\n\n        let call = declarSub[initializerAstNodeName];\n        call.callee = subFactoryId;\n        call.arguments = call.arguments.filter(function(val, i) {\n          return removeArgs.indexOf(i + \"\") < 0;\n        });\n      }\n    }\n  }\n}\n"]}