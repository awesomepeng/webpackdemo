{"version":3,"sources":["../../src/serializer/ResidualHeapVisitor.js"],"names":["t","ResidualHeapVisitor","constructor","realm","logger","modules","additionalFunctionValuesAndEffects","referentializer","useAbstractInterpretation","undefined","declarativeEnvironmentRecordsBindings","Map","globalBindings","functionInfos","classMethodInstances","functionInstances","values","conditionalFeasibility","generator","scope","globalGenerator","inspector","referencedDeclaredValues","delayedActions","equivalenceSet","additionalFunctionValueInfos","functionToCapturedScopes","environment","$GlobalEnv","environmentRecord","globalEnvironmentRecord","additionalGeneratorRoots","residualReactElementVisitor","generatorDAG","_getCommonScope","s","getParent","has","getCreator","_getAdditionalFunctionOfScope","_registerAdditionalRoot","value","creationGenerator","additionalFunction","targetAdditionalFunction","usageScope","additionalFVEffects","get","additionalRoots","add","_visitInUnrelatedScope","anyRelevantEffects","g","set","Set","effectsToApply","pb","modifiedProperties","keys","object","_withScope","f","oldScope","_enqueueWithUnrelatedScope","action","push","val","scopes","visitValue","visitObjectProperty","binding","desc","descriptor","obj","key","canIgnoreProperty","visitDescriptor","visitObjectProperties","kind","skipPrototype","temporalAlias","symbol","propertyBinding","symbols","propertyBindingKey","propertyBindingValue","properties","$FunctionKind","pathNode","unknownProperty","visitObjectPropertiesWithComputedNames","visitObjectPrototype","visitConstructorPrototype","proto","$Prototype","getKind","intrinsics","$IsClassPrototype","null","func","prototype","getPropertyValue","originalConstructor","isDefaultPrototype","absVal","cond","args","P","V","earlier_props","visitEquivalentValue","consequent","alternate","joinCondition","descriptor1","descriptor2","visitValueArray","lenProperty","mightBeHavocedObject","evaluateWithoutLeakLogic","initialLength","lengthAssignmentNotNeeded","ToLength","visitValueMap","entries","$MapData","len","length","i","entry","$Key","$Value","visitValueWeakMap","$WeakMapData","fixpoint_rerun","progress","visitValueSet","$SetData","visitValueWeakSet","$WeakSetData","visitValueFunction","isClass","homeObject","$HomeObject","$BoundTargetFunction","$BoundThis","boundArg","$BoundArguments","formalParameters","$FormalParameters","code","$ECMAScriptCode","functionInfo","residualFunctionBindings","initializationStatements","functionValue","scopeInstances","depth","lexicalDepth","unbound","requireCalls","modified","usesArguments","usesThis","state","getModuleIdIfNodeIsRequireFunction","getGetModuleIdIfNodeIsRequireFunction","file","program","expressionStatement","functionExpression","clearCache","isResidual","size","isUnsafeResidual","logError","loc","Object","join","additionalFunctionEffects","_visitAdditionalFunction","innerName","resolveBinding","residualBinding","getBinding","visitBinding","_visitClass","_visitBindingHelper","residualFunctionBinding","hasLeaked","declarativeEnvironmentRecord","bindings","name","deletable","initialized","refScope","potentialReferentializationScopes","funcToScopes","envRec","bindingState","capturedBindings","capturingFunctions","doesNotMatter","reference","tryQuery","ResolveBinding","$Environment","IsUnresolvableReference","base","$DeclarativeRecord","referencedBase","referencedName","getGlobalLetBinding","classFunc","classPrototype","visitClassMethod","propertyNameOrSymbol","methodFunc","methodType","isStatic","_visitClassMethod","propertyName","method","$HasEmptyConstructor","visitClassProperty","constructorFunc","classSuperNode","classMethodIsStatic","classMethodKeyNode","classMethodComputed","$HasComputedName","visitValueObject","visitReactElement","dateValue","$DateValue","buf","$ViewedArrayBuffer","react","enabled","fbLibraries","visitValueSymbol","$Description","visitValueProxy","$ProxyTarget","$ProxyHandler","_visitAbstractValueConditional","condition","cf","feasibleT","feasibleF","savedPath","pathConditions","impliesT","implies","impliesF","impliesNot","visitedT","visitedF","visitAbstractValue","n","preProcessValue","_mark","postProcessValue","equivalentValue","equivalentReactElementValue","reactElementEquivalenceSet","equivalentReactPropsValue","reactPropsEquivalenceSet","refuseSerialization","isIntrinsic","_isScopedTemplate","isLeaf","commonScope","createGeneratorVisitCallbacks","additionalFunctionInfo","callbacks","bind","visitGenerator","parent","isParent","canOmit","recordDeclaration","recordDelayedEntry","visit","visitModifiedObjectProperty","internalSlot","error","expressionLocation","handleError","visitModifiedBinding","modifiedBinding","funcInstance","instance","newValue","otherFunc","additionalFunctionOverridesValue","otherNameVal","_SafeGetDataPropertyValue","otherNameStr","funcNameVal","funNameStr","$Realm","modifiedBindings","visitBindingAssignment","additionalEffects","withCleanEquivalenceSet","prelude","effectsGenerator","visitRoots","moduleValue","initializedModules","_visitUntilFixpoint","referentialize","verbose","logInformation","actionsByGenerator","expected","a","effectsInfos","topEffectsRunners","actual","scopedActions","runGeneratorAction","visited","newNestedRunner","info","runner","withEffectsAppliedInGlobalEnv","nestedEffectsRunner","nestedEffectsRunners","topEffectsRunner"],"mappings":"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","file":"ResidualHeapVisitor.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord, EnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { type Effects, Realm } from \"../realm.js\";\nimport { Path } from \"../singletons.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport type { Binding } from \"../environment.js\";\nimport { HashSet, IsArray, Get } from \"../methods/index.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BoundFunctionValue,\n  ECMAScriptFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  SymbolValue,\n  Value,\n} from \"../values/index.js\";\nimport { describeLocation } from \"../intrinsics/ecma262/Error.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeBlockStatement } from \"babel-types\";\nimport { Generator } from \"../utils/generator.js\";\nimport type { GeneratorEntry, VisitEntryCallbacks } from \"../utils/generator.js\";\nimport traverse from \"babel-traverse\";\nimport invariant from \"../invariant.js\";\nimport type {\n  AdditionalFunctionEffects,\n  AdditionalFunctionInfo,\n  ClassMethodInstance,\n  FunctionInfo,\n  FunctionInstance,\n  ResidualFunctionBinding,\n  ReferentializationScope,\n} from \"./types.js\";\nimport { ClosureRefVisitor } from \"./visitors.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport {\n  canIgnoreClassLengthProperty,\n  ClassPropertiesToIgnore,\n  getObjectPrototypeMetadata,\n  getOrDefault,\n  getSuggestedArrayLiteralLength,\n  withDescriptorValue,\n} from \"./utils.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport { isReactElement, isReactPropsObject, valueIsReactLibraryObject } from \"../react/utils.js\";\nimport { ResidualReactElementVisitor } from \"./ResidualReactElementVisitor.js\";\nimport { GeneratorDAG } from \"./GeneratorDAG.js\";\n\nexport type Scope = FunctionValue | Generator;\ntype BindingState = {|\n  capturedBindings: Set<ResidualFunctionBinding>,\n  capturingFunctions: Set<FunctionValue>,\n|};\n\n/* This class visits all values that are reachable in the residual heap.\n   In particular, this \"filters out\" values that are:\n   - captured by a DeclarativeEnvironmentRecord, but not actually used by any closure.\n   - Unmodified prototype objects\n   TODO #680: Figure out minimal set of values that need to be kept alive for WeakSet and WeakMap instances.\n*/\nexport class ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    // Referentializer is null if we're just checking what values exist\n    referentializer: Referentializer | \"NO_REFERENTIALIZE\"\n  ) {\n    invariant(realm.useAbstractInterpretation);\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.referentializer = referentializer === \"NO_REFERENTIALIZE\" ? undefined : referentializer;\n\n    this.declarativeEnvironmentRecordsBindings = new Map();\n    this.globalBindings = new Map();\n    this.functionInfos = new Map();\n    this.classMethodInstances = new Map();\n    this.functionInstances = new Map();\n    this.values = new Map();\n    this.conditionalFeasibility = new Map();\n    let generator = this.realm.generator;\n    invariant(generator);\n    this.scope = this.globalGenerator = generator;\n    this.inspector = new HeapInspector(realm, logger);\n    this.referencedDeclaredValues = new Map();\n    this.delayedActions = [];\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.equivalenceSet = new HashSet();\n    this.additionalFunctionValueInfos = new Map();\n    this.functionToCapturedScopes = new Map();\n    let environment = realm.$GlobalEnv.environmentRecord;\n    invariant(environment instanceof GlobalEnvironmentRecord);\n    this.globalEnvironmentRecord = environment;\n    this.additionalGeneratorRoots = new Map();\n    this.residualReactElementVisitor = new ResidualReactElementVisitor(this.realm, this);\n    this.generatorDAG = new GeneratorDAG();\n  }\n\n  realm: Realm;\n  logger: Logger;\n  modules: Modules;\n  referentializer: Referentializer | void;\n  globalGenerator: Generator;\n\n  // Caches that ensure one ResidualFunctionBinding exists per (record, name) pair\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  globalBindings: Map<string, ResidualFunctionBinding>;\n\n  functionToCapturedScopes: Map<ReferentializationScope, Map<DeclarativeEnvironmentRecord, BindingState>>;\n  functionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  scope: Scope;\n  values: Map<Value, Set<Scope>>;\n\n  // For every abstract value of kind \"conditional\", this map keeps track of whether the consequent and/or alternate is feasible in any scope\n  conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>;\n  inspector: HeapInspector;\n  referencedDeclaredValues: Map<Value, void | FunctionValue>;\n  delayedActions: Array<{| scope: Scope, action: () => void | boolean |}>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>;\n  functionInstances: Map<FunctionValue, FunctionInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  equivalenceSet: HashSet<AbstractValue>;\n  classMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  // Parents will always be a generator, optimized function value or \"GLOBAL\"\n  additionalGeneratorRoots: Map<Generator, Set<ObjectValue>>;\n  generatorDAG: GeneratorDAG;\n  globalEnvironmentRecord: GlobalEnvironmentRecord;\n  residualReactElementVisitor: ResidualReactElementVisitor;\n\n  // Going backwards from the current scope, find either the containing\n  // additional function, or if there isn't one, return the global generator.\n  _getCommonScope(): FunctionValue | Generator {\n    let s = this.scope;\n    while (true) {\n      if (s instanceof Generator) s = this.generatorDAG.getParent(s);\n      else if (s instanceof FunctionValue) {\n        // Did we find an additional function?\n        if (this.additionalFunctionValuesAndEffects.has(s)) return s;\n\n        // Did the function itself get created by a generator we can chase?\n        s = this.generatorDAG.getCreator(s) || \"GLOBAL\";\n      } else {\n        invariant(s === \"GLOBAL\");\n        let generator = this.globalGenerator;\n        invariant(generator);\n        return generator;\n      }\n    }\n    invariant(false);\n  }\n\n  // If the current scope has a containing additional function, retrieve it.\n  _getAdditionalFunctionOfScope(): FunctionValue | void {\n    let s = this._getCommonScope();\n    return s instanceof FunctionValue ? s : undefined;\n  }\n\n  // When a value has been created by some generator that is unrelated\n  // to the current common scope, visit the value in the scope it was\n  // created --- this causes the value later to be serialized in its\n  // creation scope, ensuring that the value has the right creation / life time.\n  _registerAdditionalRoot(value: ObjectValue): void {\n    let creationGenerator = this.generatorDAG.getCreator(value) || this.globalGenerator;\n\n    let additionalFunction = this._getAdditionalFunctionOfScope() || \"GLOBAL\";\n    let targetAdditionalFunction;\n    if (creationGenerator === this.globalGenerator) {\n      targetAdditionalFunction = \"GLOBAL\";\n    } else {\n      let s = creationGenerator;\n      while (s instanceof Generator) {\n        s = this.generatorDAG.getParent(s);\n        invariant(s !== undefined);\n      }\n      invariant(s === \"GLOBAL\" || s instanceof FunctionValue);\n      targetAdditionalFunction = s;\n    }\n\n    let usageScope;\n    if (additionalFunction === targetAdditionalFunction) {\n      usageScope = this.scope;\n    } else {\n      // Object was created outside of current additional function scope\n      invariant(additionalFunction instanceof FunctionValue);\n      let additionalFVEffects = this.additionalFunctionValuesAndEffects.get(additionalFunction);\n      invariant(additionalFVEffects !== undefined);\n      additionalFVEffects.additionalRoots.add(value);\n\n      this._visitInUnrelatedScope(creationGenerator, value);\n      usageScope = this.generatorDAG.getCreator(value) || this.globalGenerator;\n    }\n\n    usageScope = this.scope;\n    if (usageScope instanceof Generator) {\n      // Also check if object is used in some nested generator scope that involved\n      // applying effects; if so, store additional information that the serializer\n      // can use to proactive serialize such objects from within the right generator\n      let anyRelevantEffects = false;\n      for (let g = usageScope; g instanceof Generator; g = this.generatorDAG.getParent(g)) {\n        if (g === creationGenerator) {\n          if (anyRelevantEffects) {\n            let s = this.additionalGeneratorRoots.get(g);\n            if (s === undefined) this.additionalGeneratorRoots.set(g, (s = new Set()));\n            if (!s.has(value)) {\n              s.add(value);\n              this._visitInUnrelatedScope(g, value);\n            }\n          }\n          break;\n        }\n        let effectsToApply = g.effectsToApply;\n        if (effectsToApply)\n          for (let pb of effectsToApply.modifiedProperties.keys())\n            if (pb.object === value) {\n              anyRelevantEffects = true;\n              break;\n            }\n      }\n    }\n  }\n\n  // Careful!\n  // Only use _withScope when you know that the currently applied effects makes sense for the given (nested) scope!\n  _withScope(scope: Scope, f: () => void): void {\n    let oldScope = this.scope;\n    this.scope = scope;\n    try {\n      f();\n    } finally {\n      this.scope = oldScope;\n    }\n  }\n\n  // Queues up an action to be later processed in some arbitrary scope.\n  _enqueueWithUnrelatedScope(scope: Scope, action: () => void | boolean): void {\n    this.delayedActions.push({ scope, action });\n  }\n\n  // Queues up visiting a value in some arbitrary scope.\n  _visitInUnrelatedScope(scope: Scope, val: Value): void {\n    let scopes = this.values.get(val);\n    if (scopes !== undefined && scopes.has(scope)) return;\n    this._enqueueWithUnrelatedScope(scope, () => this.visitValue(val));\n  }\n\n  visitObjectProperty(binding: PropertyBinding): void {\n    let desc = binding.descriptor;\n    let obj = binding.object;\n    invariant(binding.key !== undefined, \"Undefined keys should never make it here.\");\n    if (\n      obj instanceof AbstractObjectValue ||\n      !(typeof binding.key === \"string\" && this.inspector.canIgnoreProperty(obj, binding.key))\n    ) {\n      if (desc !== undefined) this.visitDescriptor(desc);\n    }\n    if (binding.key instanceof Value) this.visitValue(binding.key);\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    let { skipPrototype, constructor } = getObjectPrototypeMetadata(this.realm, obj);\n    if (obj.temporalAlias !== undefined) return;\n\n    // visit properties\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      this.visitDescriptor(desc);\n      this.visitValue(symbol);\n    }\n\n    // visit properties\n    for (let [propertyBindingKey, propertyBindingValue] of obj.properties) {\n      // we don't want to visit these as we handle the serialization ourselves\n      // via a different logic route for classes\n      let descriptor = propertyBindingValue.descriptor;\n      if (\n        obj instanceof ECMAScriptFunctionValue &&\n        obj.$FunctionKind === \"classConstructor\" &&\n        (ClassPropertiesToIgnore.has(propertyBindingKey) ||\n          (propertyBindingKey === \"length\" && canIgnoreClassLengthProperty(obj, descriptor, this.logger)))\n      ) {\n        continue;\n      }\n      if (propertyBindingValue.pathNode !== undefined) continue; // property is written to inside a loop\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      }\n    }\n\n    // prototype\n    if (!skipPrototype) {\n      this.visitObjectPrototype(obj);\n    }\n    if (obj instanceof FunctionValue) {\n      this.visitConstructorPrototype(constructor ? constructor : obj);\n    } else if (obj instanceof ObjectValue && skipPrototype && constructor) {\n      this.visitValue(constructor);\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue): void {\n    let proto = obj.$Prototype;\n\n    let kind = obj.getKind();\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    if (!obj.$IsClassPrototype || proto !== this.realm.intrinsics.null) {\n      this.visitValue(proto);\n    }\n  }\n\n  visitConstructorPrototype(func: Value): void {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    invariant(func instanceof FunctionValue);\n    let prototype = HeapInspector.getPropertyValue(func, \"prototype\");\n    if (\n      prototype instanceof ObjectValue &&\n      prototype.originalConstructor === func &&\n      !this.inspector.isDefaultPrototype(prototype)\n    ) {\n      this.visitValue(prototype);\n    }\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    if (absVal.kind === \"widened property\") return;\n    if (absVal.kind === \"template for prototype member expression\") return;\n    if (absVal.kind === \"conditional\") {\n      let cond = absVal.args[0];\n      invariant(cond instanceof AbstractValue);\n      if (cond.kind === \"template for property name condition\") {\n        let P = cond.args[0];\n        invariant(P instanceof AbstractValue);\n        let V = absVal.args[1];\n        let earlier_props = absVal.args[2];\n        if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n        this.visitValue(P);\n        this.visitValue(V);\n      } else {\n        // conditional assignment\n        absVal.args[0] = this.visitEquivalentValue(cond);\n        let consequent = absVal.args[1];\n        if (consequent instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(consequent);\n        }\n        let alternate = absVal.args[2];\n        if (alternate instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(alternate);\n        }\n      }\n    } else {\n      this.visitValue(absVal);\n    }\n  }\n\n  visitDescriptor(desc: Descriptor): void {\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.joinCondition !== undefined) {\n      desc.joinCondition = this.visitEquivalentValue(desc.joinCondition);\n      if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);\n      if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);\n      return;\n    }\n    if (desc.value !== undefined) desc.value = this.visitEquivalentValue(desc.value);\n    if (desc.get !== undefined) this.visitValue(desc.get);\n    if (desc.set !== undefined) this.visitValue(desc.set);\n  }\n\n  visitValueArray(val: ObjectValue): void {\n    this._registerAdditionalRoot(val);\n\n    this.visitObjectProperties(val);\n    const realm = this.realm;\n    let lenProperty;\n    if (val.mightBeHavocedObject()) {\n      lenProperty = this.realm.evaluateWithoutLeakLogic(() => Get(realm, val, \"length\"));\n    } else {\n      lenProperty = Get(realm, val, \"length\");\n    }\n    let [initialLength, lengthAssignmentNotNeeded] = getSuggestedArrayLiteralLength(realm, val);\n    if (lengthAssignmentNotNeeded) return;\n    if (\n      lenProperty instanceof AbstractValue\n        ? lenProperty.kind !== \"widened property\"\n        : To.ToLength(realm, lenProperty) !== initialLength\n    ) {\n      this.visitValue(lenProperty);\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    invariant(val.getKind() === \"Map\");\n    let entries = val.$MapData;\n\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueWeakMap(val: ObjectValue): void {\n    invariant(val.getKind() === \"WeakMap\");\n    let entries = val.$WeakMapData;\n\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n\n      if (key !== undefined && value !== undefined) {\n        let fixpoint_rerun = () => {\n          let progress;\n          if (this.values.has(key)) {\n            progress = true;\n            this.visitValue(key);\n            this.visitValue(value);\n          } else {\n            progress = false;\n            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n          }\n          return progress;\n        };\n        fixpoint_rerun();\n      }\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    invariant(val.getKind() === \"Set\");\n\n    let entries = val.$SetData;\n    invariant(entries !== undefined);\n\n    let len = entries.length;\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueWeakSet(val: ObjectValue): void {\n    invariant(val.getKind() === \"WeakSet\");\n\n    let entries = val.$WeakSetData;\n    invariant(entries !== undefined);\n\n    let len = entries.length;\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry !== undefined) {\n        let fixpoint_rerun = () => {\n          let progress;\n          if (this.values.has(entry)) {\n            progress = true;\n            this.visitValue(entry);\n          } else {\n            progress = false;\n            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n          }\n          return progress;\n        };\n        fixpoint_rerun();\n      }\n    }\n  }\n\n  visitValueFunction(val: FunctionValue): void {\n    let isClass = false;\n\n    this._registerAdditionalRoot(val);\n    if (val instanceof ECMAScriptFunctionValue && val.$FunctionKind === \"classConstructor\") {\n      invariant(val instanceof ECMAScriptSourceFunctionValue);\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        isClass = true;\n      }\n    }\n    this.visitObjectProperties(val);\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n    invariant(val.constructor === ECMAScriptSourceFunctionValue);\n    let formalParameters = val.$FormalParameters;\n    let code = val.$ECMAScriptCode;\n\n    let functionInfo = this.functionInfos.get(code);\n    let residualFunctionBindings = new Map();\n    this.functionInstances.set(val, {\n      residualFunctionBindings,\n      initializationStatements: [],\n      functionValue: val,\n      scopeInstances: new Map(),\n    });\n\n    if (!functionInfo) {\n      functionInfo = {\n        depth: 0,\n        lexicalDepth: 0,\n        unbound: new Map(),\n        requireCalls: new Map(),\n        modified: new Set(),\n        usesArguments: false,\n        usesThis: false,\n      };\n      let state = {\n        functionInfo,\n        realm: this.realm,\n        getModuleIdIfNodeIsRequireFunction: this.modules.getGetModuleIdIfNodeIsRequireFunction(formalParameters, [val]),\n      };\n\n      traverse(\n        t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n        ClosureRefVisitor,\n        null,\n        state\n      );\n      traverse.clearCache();\n      this.functionInfos.set(code, functionInfo);\n\n      if (val.isResidual && functionInfo.unbound.size) {\n        if (!val.isUnsafeResidual) {\n          this.logger.logError(\n            val,\n            `residual function ${describeLocation(this.realm, val, undefined, code.loc) ||\n              \"(unknown)\"} refers to the following identifiers defined outside of the local scope: ${Object.keys(\n              functionInfo.unbound\n            ).join(\", \")}`\n          );\n        }\n      }\n    }\n\n    let additionalFunctionEffects = this.additionalFunctionValuesAndEffects.get(val);\n    if (additionalFunctionEffects) {\n      this._visitAdditionalFunction(val, additionalFunctionEffects);\n    } else {\n      this._enqueueWithUnrelatedScope(val, () => {\n        invariant(this.scope === val);\n        invariant(functionInfo);\n        for (let innerName of functionInfo.unbound.keys()) {\n          let environment = this.resolveBinding(val, innerName);\n          let residualBinding = this.getBinding(environment, innerName);\n          this.visitBinding(val, residualBinding);\n          residualFunctionBindings.set(innerName, residualBinding);\n          if (functionInfo.modified.has(innerName)) residualBinding.modified = true;\n        }\n      });\n    }\n    if (isClass && val.$HomeObject instanceof ObjectValue) {\n      this._visitClass(val, val.$HomeObject);\n    }\n  }\n\n  _visitBindingHelper(residualFunctionBinding: ResidualFunctionBinding) {\n    if (residualFunctionBinding.hasLeaked) return;\n    let environment = residualFunctionBinding.declarativeEnvironmentRecord;\n    invariant(environment !== null);\n    if (residualFunctionBinding.value === undefined) {\n      // The first time we visit, we need to initialize the value to its equivalent value\n      invariant(environment instanceof DeclarativeEnvironmentRecord);\n      let binding = environment.bindings[residualFunctionBinding.name];\n      invariant(binding !== undefined);\n      invariant(!binding.deletable);\n      let value = (binding.initialized && binding.value) || this.realm.intrinsics.undefined;\n      residualFunctionBinding.value = this.visitEquivalentValue(value);\n    } else {\n      // Subsequently, we just need to visit the value.\n      this.visitValue(residualFunctionBinding.value);\n    }\n  }\n\n  // Addresses the case:\n  // let x = [];\n  // let y = [];\n  // function a() { x.push(\"hi\"); }\n  // function b() { y.push(\"bye\"); }\n  // function c() { return x.length + y.length; }\n  // Here we need to make sure that a and b both initialize x and y because x and y will be in the same\n  // captured scope because c captures both x and y.\n  visitBinding(val: FunctionValue, residualFunctionBinding: ResidualFunctionBinding): void {\n    let environment = residualFunctionBinding.declarativeEnvironmentRecord;\n    if (environment === null) return;\n    invariant(this.scope === val);\n\n    let refScope = this._getAdditionalFunctionOfScope() || \"GLOBAL\";\n    residualFunctionBinding.potentialReferentializationScopes.add(refScope);\n    invariant(!(refScope instanceof Generator));\n    let funcToScopes = getOrDefault(this.functionToCapturedScopes, refScope, () => new Map());\n    let envRec = residualFunctionBinding.declarativeEnvironmentRecord;\n    invariant(envRec !== null);\n    let bindingState = getOrDefault(funcToScopes, envRec, () => ({\n      capturedBindings: new Set(),\n      capturingFunctions: new Set(),\n    }));\n    // If the binding is new for this bindingState, have all functions capturing bindings from that scope visit it\n    if (!bindingState.capturedBindings.has(residualFunctionBinding)) {\n      for (let functionValue of bindingState.capturingFunctions) {\n        this._enqueueWithUnrelatedScope(functionValue, () => this._visitBindingHelper(residualFunctionBinding));\n      }\n      bindingState.capturedBindings.add(residualFunctionBinding);\n    }\n    // If the function is new for this bindingState, visit all existent bindings in this scope\n    if (!bindingState.capturingFunctions.has(val)) {\n      invariant(this.scope === val);\n      for (let residualBinding of bindingState.capturedBindings) this._visitBindingHelper(residualBinding);\n      bindingState.capturingFunctions.add(val);\n    }\n  }\n\n  resolveBinding(val: FunctionValue, name: string): EnvironmentRecord {\n    let doesNotMatter = true;\n    let reference = this.logger.tryQuery(\n      () => Environment.ResolveBinding(this.realm, name, doesNotMatter, val.$Environment),\n      undefined\n    );\n    if (\n      reference === undefined ||\n      Environment.IsUnresolvableReference(this.realm, reference) ||\n      reference.base === this.globalEnvironmentRecord ||\n      reference.base === this.globalEnvironmentRecord.$DeclarativeRecord\n    ) {\n      return this.globalEnvironmentRecord;\n    } else {\n      invariant(!Environment.IsUnresolvableReference(this.realm, reference));\n      let referencedBase = reference.base;\n      let referencedName: string = (reference.referencedName: any);\n      invariant(referencedName === name);\n      invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n      return referencedBase;\n    }\n  }\n\n  // Visits a binding, returns a ResidualFunctionBinding\n  getBinding(environment: EnvironmentRecord, name: string): ResidualFunctionBinding {\n    if (environment === this.globalEnvironmentRecord.$DeclarativeRecord) environment = this.globalEnvironmentRecord;\n\n    if (environment === this.globalEnvironmentRecord) {\n      // Global Binding\n      return getOrDefault(this.globalBindings, name, () => {\n        let residualFunctionBinding = {\n          name,\n          value: undefined,\n          modified: true,\n          hasLeaked: false,\n          declarativeEnvironmentRecord: null,\n          potentialReferentializationScopes: new Set(),\n        };\n        // Queue up visiting of global binding exactly once in the globalGenerator scope.\n        this._enqueueWithUnrelatedScope(this.globalGenerator, () => {\n          let value = this.realm.getGlobalLetBinding(name);\n          if (value !== undefined) residualFunctionBinding.value = this.visitEquivalentValue(value);\n        });\n        return residualFunctionBinding;\n      });\n    } else {\n      invariant(environment instanceof DeclarativeEnvironmentRecord);\n      // DeclarativeEnvironmentRecord binding\n      let residualFunctionBindings = getOrDefault(\n        this.declarativeEnvironmentRecordsBindings,\n        environment,\n        () => new Map()\n      );\n      return getOrDefault(\n        residualFunctionBindings,\n        name,\n        (): ResidualFunctionBinding => {\n          invariant(environment instanceof DeclarativeEnvironmentRecord);\n          return {\n            name,\n            value: undefined,\n            modified: false,\n            hasLeaked: false,\n            declarativeEnvironmentRecord: environment,\n            potentialReferentializationScopes: new Set(),\n          };\n        }\n      );\n      // Note that we don't yet visit the binding (and its value) here,\n      // as that should be done by a call to visitBinding, in the right scope,\n      // if the binding's incoming value is relevant.\n    }\n  }\n\n  _visitClass(classFunc: ECMAScriptSourceFunctionValue, classPrototype: ObjectValue): void {\n    let visitClassMethod = (propertyNameOrSymbol, methodFunc, methodType, isStatic) => {\n      if (methodFunc instanceof ECMAScriptSourceFunctionValue) {\n        // if the method does not have a $HomeObject, it's not a class method\n        if (methodFunc.$HomeObject !== undefined) {\n          if (methodFunc !== classFunc) {\n            this._visitClassMethod(methodFunc, methodType, classPrototype, !!isStatic);\n          }\n        }\n      }\n    };\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, visitClassMethod);\n    }\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, visitClassMethod);\n    }\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      this.visitValue(classFunc.$Prototype);\n    }\n\n    if (classPrototype.properties.has(\"constructor\")) {\n      let constructor = classPrototype.properties.get(\"constructor\");\n\n      invariant(constructor !== undefined);\n      // check if the constructor was deleted, as it can't really be deleted\n      // it just gets set to empty (the default again)\n      if (constructor.descriptor === undefined) {\n        classFunc.$HasEmptyConstructor = true;\n      } else {\n        let visitClassProperty = (propertyNameOrSymbol, methodFunc, methodType) => {\n          visitClassMethod(propertyNameOrSymbol, methodFunc, methodType, true);\n        };\n        // check if we have any static methods we need to include\n        let constructorFunc = Get(this.realm, classPrototype, \"constructor\");\n        invariant(constructorFunc instanceof ObjectValue);\n        for (let [propertyName, method] of constructorFunc.properties) {\n          if (\n            !ClassPropertiesToIgnore.has(propertyName) &&\n            method.descriptor !== undefined &&\n            !(\n              propertyName === \"length\" && canIgnoreClassLengthProperty(constructorFunc, method.descriptor, this.logger)\n            )\n          ) {\n            withDescriptorValue(propertyName, method.descriptor, visitClassProperty);\n          }\n        }\n      }\n    }\n    this.classMethodInstances.set(classFunc, {\n      classPrototype,\n      methodType: \"constructor\",\n      classSuperNode: undefined,\n      classMethodIsStatic: false,\n      classMethodKeyNode: undefined,\n      classMethodComputed: false,\n    });\n  }\n\n  _visitClassMethod(\n    methodFunc: ECMAScriptSourceFunctionValue,\n    methodType: \"get\" | \"set\" | \"value\",\n    classPrototype: ObjectValue,\n    isStatic: boolean\n  ): void {\n    this.classMethodInstances.set(methodFunc, {\n      classPrototype,\n      methodType: methodType === \"value\" ? \"method\" : methodType,\n      classSuperNode: undefined,\n      classMethodIsStatic: isStatic,\n      classMethodKeyNode: undefined,\n      classMethodComputed: !!methodFunc.$HasComputedName,\n    });\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    this._registerAdditionalRoot(val);\n    if (isReactElement(val)) {\n      this.residualReactElementVisitor.visitReactElement(val);\n      return;\n    }\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      this.visitValue(constructor);\n      return;\n    }\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ArrayBuffer\":\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n        this.visitValueMap(val);\n        return;\n      case \"WeakMap\":\n        this.visitValueWeakMap(val);\n        return;\n      case \"Set\":\n        this.visitValueSet(val);\n        return;\n      case \"WeakSet\":\n        this.visitValueWeakSet(val);\n        return;\n      default:\n        if (kind !== \"Object\") this.logger.logError(val, `Object of kind ${kind} is not supported in residual heap.`);\n        if (this.realm.react.enabled && valueIsReactLibraryObject(this.realm, val, this.logger)) {\n          this.realm.fbLibraries.react = val;\n        }\n        return;\n    }\n  }\n\n  visitValueSymbol(val: SymbolValue): void {\n    if (val.$Description) this.visitValue(val.$Description);\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this._registerAdditionalRoot(val);\n\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  _visitAbstractValueConditional(val: AbstractValue): void {\n    let condition = val.args[0];\n    invariant(condition instanceof AbstractValue);\n\n    let cf = this.conditionalFeasibility.get(val);\n    if (cf === undefined) this.conditionalFeasibility.set(val, (cf = { t: false, f: false }));\n\n    let feasibleT, feasibleF;\n    let savedPath = this.realm.pathConditions;\n    try {\n      this.realm.pathConditions = this.scope instanceof Generator ? this.scope.pathConditions : [];\n\n      let impliesT = Path.implies(condition);\n      let impliesF = Path.impliesNot(condition);\n      invariant(!(impliesT && impliesF));\n\n      if (!impliesT && !impliesF) {\n        feasibleT = feasibleF = true;\n      } else {\n        feasibleT = impliesT;\n        feasibleF = impliesF;\n      }\n    } finally {\n      this.realm.pathConditions = savedPath;\n    }\n\n    let visitedT = false,\n      visitedF = false;\n\n    if (!cf.t && feasibleT) {\n      val.args[1] = this.visitEquivalentValue(val.args[1]);\n      cf.t = true;\n      if (cf.f) val.args[0] = this.visitEquivalentValue(val.args[0]);\n      visitedT = true;\n    }\n\n    if (!cf.f && feasibleF) {\n      val.args[2] = this.visitEquivalentValue(val.args[2]);\n      cf.f = true;\n      if (cf.t) val.args[0] = this.visitEquivalentValue(val.args[0]);\n      visitedF = true;\n    }\n\n    if (!visitedT || !visitedF) {\n      let fixpoint_rerun = () => {\n        let progress = false;\n        invariant(cf !== undefined);\n        if (cf.f && cf.t) {\n          invariant(!visitedT || !visitedF);\n          this.visitValue(val.args[0]);\n        }\n\n        if (cf.t && !visitedT) {\n          this.visitValue(val.args[1]);\n          progress = visitedT = true;\n        }\n        invariant(cf.t === visitedT);\n\n        if (cf.f && !visitedF) {\n          this.visitValue(val.args[2]);\n          progress = visitedF = true;\n        }\n        invariant(cf.f === visitedF);\n\n        // When not all possible outcomes are assumed to be feasible yet after visiting some scopes,\n        // it might be that they do become assumed to be feasible when later visiting some other scopes.\n        // In that case, we should also re-visit the corresponding cases in this scope.\n        // To this end, calling _enqueueWithUnrelatedScope enqueues this function for later re-execution if\n        // any other visiting progress was made.\n        if (!visitedT || !visitedF) this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n\n        return progress;\n      };\n\n      fixpoint_rerun();\n    }\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    if (val.kind === \"sentinel member expression\") {\n      this.logger.logError(val, \"expressions of type o[p] are not yet supported for partially known o and unknown p\");\n    } else if (val.kind === \"conditional\") {\n      this._visitAbstractValueConditional(val);\n      return;\n    }\n    for (let i = 0, n = val.args.length; i < n; i++) {\n      val.args[i] = this.visitEquivalentValue(val.args[i]);\n    }\n  }\n\n  // Overridable hook for pre-visiting the value.\n  // Return false will tell visitor to skip visiting children of this node.\n  preProcessValue(val: Value): boolean {\n    return this._mark(val);\n  }\n\n  // Overridable hook for post-visiting the value.\n  postProcessValue(val: Value): void {}\n\n  _mark(val: Value): boolean {\n    let scopes = this.values.get(val);\n    if (scopes === undefined) this.values.set(val, (scopes = new Set()));\n    if (scopes.has(this.scope)) return false;\n    scopes.add(this.scope);\n    return true;\n  }\n\n  visitEquivalentValue<T: Value>(val: T): T {\n    if (val instanceof AbstractValue) {\n      let equivalentValue = this.equivalenceSet.add(val);\n      if (this.preProcessValue(equivalentValue)) this.visitAbstractValue(equivalentValue);\n      this.postProcessValue(equivalentValue);\n      return (equivalentValue: any);\n    }\n    if (val instanceof ObjectValue && isReactElement(val)) {\n      if (val.temporalAlias !== undefined) {\n        return this.visitEquivalentValue(val.temporalAlias);\n      }\n      let equivalentReactElementValue = this.residualReactElementVisitor.reactElementEquivalenceSet.add(val);\n      if (this._mark(equivalentReactElementValue)) this.visitValueObject(equivalentReactElementValue);\n      return (equivalentReactElementValue: any);\n    } else if (val instanceof ObjectValue && isReactPropsObject(val)) {\n      let equivalentReactPropsValue = this.residualReactElementVisitor.reactPropsEquivalenceSet.add(val);\n      if (this._mark(equivalentReactPropsValue)) this.visitValueObject(equivalentReactPropsValue);\n      return (equivalentReactPropsValue: any);\n    }\n    this.visitValue(val);\n    return val;\n  }\n\n  visitValue(val: Value): void {\n    invariant(val !== undefined);\n    invariant(!(val instanceof ObjectValue && val.refuseSerialization));\n    if (val instanceof AbstractValue) {\n      if (this.preProcessValue(val)) this.visitAbstractValue(val);\n      this.postProcessValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time...\n      // ...except for a few that come into existence as templates for abstract objects via executable code.\n      if (val instanceof ObjectValue && val._isScopedTemplate) {\n        this.preProcessValue(val);\n        this.postProcessValue(val);\n      } else\n        this._enqueueWithUnrelatedScope(this._getCommonScope(), () => {\n          this.preProcessValue(val);\n          this.postProcessValue(val);\n        });\n    } else if (val instanceof EmptyValue) {\n      this.preProcessValue(val);\n      this.postProcessValue(val);\n    } else if (HeapInspector.isLeaf(val)) {\n      this.preProcessValue(val);\n      this.postProcessValue(val);\n    } else if (IsArray(this.realm, val)) {\n      invariant(val instanceof ObjectValue);\n      if (this.preProcessValue(val)) this.visitValueArray(val);\n      this.postProcessValue(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.preProcessValue(val)) this.visitValueProxy(val);\n      this.postProcessValue(val);\n    } else if (val instanceof FunctionValue) {\n      let creationGenerator = this.generatorDAG.getCreator(val) || this.globalGenerator;\n\n      // 1. Visit function in its creation scope\n      this._enqueueWithUnrelatedScope(creationGenerator, () => {\n        invariant(val instanceof FunctionValue);\n        if (this.preProcessValue(val)) this.visitValueFunction(val);\n        this.postProcessValue(val);\n      });\n\n      // 2. If current scope is not related to creation scope,\n      //    and if this is not a recursive visit, mark the usage of this function\n      //    in the common scope as well.\n      let commonScope = this._getCommonScope();\n      if (commonScope !== creationGenerator && commonScope !== val) {\n        this._enqueueWithUnrelatedScope(commonScope, () => {\n          this.preProcessValue(val);\n          this.postProcessValue(val);\n        });\n      }\n    } else if (val instanceof SymbolValue) {\n      if (this.preProcessValue(val)) this.visitValueSymbol(val);\n      this.postProcessValue(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n\n      if (this.preProcessValue(val)) this.visitValueObject(val);\n      this.postProcessValue(val);\n    }\n  }\n\n  createGeneratorVisitCallbacks(additionalFunctionInfo?: AdditionalFunctionInfo): VisitEntryCallbacks {\n    let callbacks = {\n      visitEquivalentValue: this.visitEquivalentValue.bind(this),\n      visitGenerator: (generator, parent) => {\n        invariant(this.generatorDAG.isParent(parent, generator));\n        this.visitGenerator(generator, additionalFunctionInfo);\n      },\n      canOmit: (value: Value): boolean => {\n        let canOmit = !this.referencedDeclaredValues.has(value) && !this.values.has(value);\n        if (!canOmit) {\n          return false;\n        }\n        if (value instanceof ObjectValue && value.temporalAlias !== undefined) {\n          let temporalAlias = value.temporalAlias;\n          return !this.referencedDeclaredValues.has(temporalAlias) && !this.values.has(temporalAlias);\n        }\n        return canOmit;\n      },\n      recordDeclaration: (value: Value) => {\n        this.referencedDeclaredValues.set(value, this._getAdditionalFunctionOfScope());\n      },\n      recordDelayedEntry: (generator, entry: GeneratorEntry) => {\n        this.delayedActions.push({\n          scope: generator,\n          action: () => entry.visit(callbacks, generator),\n        });\n      },\n      visitModifiedObjectProperty: (binding: PropertyBinding) => {\n        let fixpoint_rerun = () => {\n          if (this.values.has(binding.object)) {\n            if (binding.internalSlot) {\n              invariant(typeof binding.key === \"string\");\n              let error = new CompilerDiagnostic(\n                `Internal slot ${binding.key} modified in a nested context. This is not yet supported.`,\n                binding.object.expressionLocation,\n                \"PP1006\",\n                \"FatalError\"\n              );\n              this.realm.handleError(error) === \"Fail\";\n              throw new FatalError();\n            }\n            this.visitValue(binding.object);\n            if (binding.key instanceof Value) this.visitValue(binding.key);\n            this.visitObjectProperty(binding);\n            return true;\n          } else {\n            this._enqueueWithUnrelatedScope(this.scope, fixpoint_rerun);\n            return false;\n          }\n        };\n        fixpoint_rerun();\n      },\n      visitModifiedBinding: (modifiedBinding: Binding) => {\n        invariant(additionalFunctionInfo);\n        let { functionValue } = additionalFunctionInfo;\n        invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n        let residualBinding = this.getBinding(modifiedBinding.environment, modifiedBinding.name);\n        let funcInstance = additionalFunctionInfo.instance;\n        invariant(funcInstance !== undefined);\n        funcInstance.residualFunctionBindings.set(modifiedBinding.name, residualBinding);\n        let newValue = modifiedBinding.value;\n        invariant(newValue);\n        newValue = this.visitEquivalentValue(newValue);\n        residualBinding.modified = true;\n        let otherFunc = residualBinding.additionalFunctionOverridesValue;\n        if (otherFunc !== undefined && otherFunc !== functionValue) {\n          let otherNameVal = otherFunc._SafeGetDataPropertyValue(\"name\");\n          let otherNameStr = otherNameVal instanceof StringValue ? otherNameVal.value : \"unknown function\";\n          let funcNameVal = functionValue._SafeGetDataPropertyValue(\"name\");\n          let funNameStr = funcNameVal instanceof StringValue ? funcNameVal.value : \"unknown function\";\n          let error = new CompilerDiagnostic(\n            `Variable ${\n              modifiedBinding.name\n            } written to in optimized function ${funNameStr} conflicts with write in another optimized function ${otherNameStr}`,\n            funcNameVal.expressionLocation,\n            \"PP1001\",\n            \"RecoverableError\"\n          );\n          if (functionValue.$Realm.handleError(error) === \"Fail\") throw new FatalError();\n        }\n        residualBinding.additionalFunctionOverridesValue = functionValue;\n        additionalFunctionInfo.modifiedBindings.set(modifiedBinding, residualBinding);\n        // TODO nested optimized functions: revisit adding GLOBAL as outer optimized function\n        residualBinding.potentialReferentializationScopes.add(\"GLOBAL\");\n        return [residualBinding, newValue];\n      },\n      visitBindingAssignment: (binding: Binding, value: Value) => {\n        let residualBinding = this.getBinding(binding.environment, binding.name);\n        residualBinding.modified = true;\n        residualBinding.hasLeaked = true;\n        return this.visitEquivalentValue(value);\n      },\n    };\n    return callbacks;\n  }\n\n  visitGenerator(generator: Generator, additionalFunctionInfo?: AdditionalFunctionInfo): void {\n    this._withScope(generator, () => {\n      generator.visit(this.createGeneratorVisitCallbacks(additionalFunctionInfo));\n    });\n\n    // We don't bother purging created objects\n  }\n\n  // result -- serialized as a return statement\n  // Generator -- visit all entries\n  // Bindings -- (modifications to named variables) only need to serialize bindings if they're\n  //             captured by a residual function\n  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n  //             we don't overwrite anything they capture\n  // PropertyBindings -- (property modifications) visit any property bindings to pre-existing objects\n  // CreatedObjects -- should take care of itself\n  _visitAdditionalFunction(functionValue: FunctionValue, additionalEffects: AdditionalFunctionEffects): void {\n    // Get Instance + Info\n    invariant(functionValue instanceof ECMAScriptSourceFunctionValue);\n    let code = functionValue.$ECMAScriptCode;\n    let functionInfo = this.functionInfos.get(code);\n    invariant(functionInfo !== undefined);\n    let funcInstance = this.functionInstances.get(functionValue);\n    invariant(funcInstance !== undefined);\n\n    // Set Visitor state\n    // Allows us to emit function declarations etc. inside of this additional\n    // function instead of adding them at global scope\n    this.residualReactElementVisitor.withCleanEquivalenceSet(() => {\n      invariant(funcInstance !== undefined);\n      invariant(functionInfo !== undefined);\n      let additionalFunctionInfo = {\n        modifiedBindings: new Map(),\n        functionValue,\n        instance: funcInstance,\n        prelude: [],\n      };\n      this.additionalFunctionValueInfos.set(functionValue, additionalFunctionInfo);\n\n      let effectsGenerator = additionalEffects.generator;\n      this.generatorDAG.add(functionValue, effectsGenerator);\n      this.visitGenerator(effectsGenerator, additionalFunctionInfo);\n    });\n  }\n\n  visitRoots(): void {\n    this.generatorDAG.add(\"GLOBAL\", this.globalGenerator);\n    this.visitGenerator(this.globalGenerator);\n    for (let moduleValue of this.modules.initializedModules.values()) this.visitValue(moduleValue);\n\n    this._visitUntilFixpoint();\n\n    let referentializer = this.referentializer;\n    if (referentializer !== undefined)\n      for (let instance of this.functionInstances.values()) referentializer.referentialize(instance);\n  }\n\n  _visitUntilFixpoint(): void {\n    if (this.realm.react.verbose) {\n      this.logger.logInformation(`Computing fixed point...`);\n    }\n    // Do a fixpoint over all pure generator entries to make sure that we visit\n    // arguments of only BodyEntries that are required by some other residual value\n    let progress = true;\n    while (progress) {\n      // Let's partition the actions by their generators,\n      // as applying effects is expensive, and so we don't want to do it\n      // more often than necessary.\n      let actionsByGenerator = new Map();\n      let expected = 0;\n      for (let { scope, action } of this.delayedActions) {\n        let generator;\n        if (scope instanceof FunctionValue) generator = this.generatorDAG.getCreator(scope) || this.globalGenerator;\n        else if (scope === \"GLOBAL\") generator = this.globalGenerator;\n        else {\n          invariant(scope instanceof Generator);\n          generator = scope;\n        }\n        let a = actionsByGenerator.get(generator);\n        if (a === undefined) actionsByGenerator.set(generator, (a = []));\n        a.push({ action, scope });\n        expected++;\n      }\n      this.delayedActions = [];\n      progress = false;\n      // We build up a tree of effects runner that mirror the nesting of Generator effects.\n      // This way, we only have to apply any given effects once, regardless of how many actions we have associated with whatever generators.\n      let effectsInfos: Map<Effects, { runner: () => void, nestedEffectsRunners: Array<() => void> }> = new Map();\n      let topEffectsRunners: Array<() => void> = [];\n      let actual = 0;\n      for (let [generator, scopedActions] of actionsByGenerator) {\n        let runGeneratorAction = () => {\n          for (let { action, scope } of scopedActions) {\n            actual++;\n            this._withScope(scope, () => {\n              if (action() !== false) progress = true;\n            });\n          }\n        };\n        let s = generator;\n        let visited = new Set();\n        let newNestedRunner;\n        while (s !== \"GLOBAL\") {\n          invariant(!visited.has(s));\n          visited.add(s);\n          if (s instanceof Generator) {\n            let effectsToApply = s.effectsToApply;\n            if (effectsToApply) {\n              let info = effectsInfos.get(effectsToApply);\n              let runner;\n              if (info === undefined) {\n                runner = () => {\n                  this.realm.withEffectsAppliedInGlobalEnv(() => {\n                    invariant(info !== undefined);\n                    for (let nestedEffectsRunner of info.nestedEffectsRunners) nestedEffectsRunner();\n                    return null;\n                  }, effectsToApply);\n                };\n                effectsInfos.set(effectsToApply, (info = { runner, nestedEffectsRunners: [] }));\n              }\n              if (newNestedRunner !== undefined) info.nestedEffectsRunners.push(newNestedRunner);\n              newNestedRunner = runner;\n              if (runGeneratorAction === undefined) break;\n              info.nestedEffectsRunners.push(runGeneratorAction);\n              runGeneratorAction = undefined;\n            }\n            s = this.generatorDAG.getParent(s);\n          } else if (s instanceof FunctionValue) {\n            invariant(this.additionalFunctionValuesAndEffects.has(s));\n            s = this.generatorDAG.getCreator(s) || \"GLOBAL\";\n          }\n          invariant(s instanceof Generator || s instanceof FunctionValue || s === \"GLOBAL\");\n        }\n        if (runGeneratorAction !== undefined) {\n          invariant(newNestedRunner === undefined);\n          runGeneratorAction();\n        } else if (newNestedRunner !== undefined) topEffectsRunners.push(newNestedRunner);\n      }\n      for (let topEffectsRunner of topEffectsRunners) topEffectsRunner();\n      invariant(expected === actual);\n      if (this.realm.react.verbose) {\n        this.logger.logInformation(`  (${actual} items processed)`);\n      }\n    }\n  }\n}\n"]}