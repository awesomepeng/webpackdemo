{"version":3,"sources":["../../src/serializer/ResidualFunctionInitializers.js"],"names":["t","ResidualFunctionInitializers","constructor","locationService","functionInitializerInfos","Map","initializers","sharedInitializers","registerValueOnlyReferencedByResidualFunctions","functionValues","val","length","infos","functionValue","info","get","undefined","set","ownId","size","toString","initializerIds","Set","push","id","map","sort","join","add","initializer","order","values","body","type","parentBody","entries","done","scrubFunctionInitializers","delete","_conditionalInitialization","containingAdditionalFunction","initializedValues","initializationStatements","isIfStatement","location","value","mightBeUndefined","getLocation","createLocation","unshift","expressionStatement","assignmentExpression","ifStatement","binaryExpression","blockStatement","hasInitializerStatement","factorifyInitializers","nameGenerator","getInitializerStatement","initializerInfo","getContainingAdditionalFunction","ownInitializer","initializerId","i","j","concat","ast","count","file","program","node","createFunction","callExpression"],"mappings":"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","file":"ResidualFunctionInitializers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { FunctionValue, Value } from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type { BabelNodeStatement } from \"babel-types\";\nimport { NameGenerator } from \"../utils/generator.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport { voidExpression, nullExpression } from \"../utils/babelhelpers.js\";\nimport type { LocationService, SerializedBody } from \"./types.js\";\nimport { factorifyObjects } from \"./factorify.js\";\n\n// This class manages information about values\n// which are only referenced by residual functions,\n// and it provides the ability to generate initialization code for those values that\n// can be placed into the residual functions.\nexport class ResidualFunctionInitializers {\n  constructor(locationService: LocationService) {\n    this.functionInitializerInfos = new Map();\n    this.initializers = new Map();\n    this.sharedInitializers = new Map();\n    this.locationService = locationService;\n  }\n\n  // ownId: uid of the FunctionValue, initializer ids are strings of sorted lists of FunctionValues referencing the value\n  functionInitializerInfos: Map<FunctionValue, { ownId: string, initializerIds: Set<string> }>;\n  initializers: Map<string, { id: string, order: number, body: SerializedBody, values: Array<Value> }>;\n  sharedInitializers: Map<string, BabelNodeStatement>;\n  locationService: LocationService;\n\n  registerValueOnlyReferencedByResidualFunctions(functionValues: Array<FunctionValue>, val: Value): SerializedBody {\n    invariant(functionValues.length >= 1);\n    let infos = [];\n    for (let functionValue of functionValues) {\n      let info = this.functionInitializerInfos.get(functionValue);\n      if (info === undefined)\n        this.functionInitializerInfos.set(\n          functionValue,\n          (info = { ownId: this.functionInitializerInfos.size.toString(), initializerIds: new Set() })\n        );\n      infos.push(info);\n    }\n    let id = infos\n      .map(info => info.ownId)\n      .sort()\n      .join();\n    for (let info of infos) info.initializerIds.add(id);\n    let initializer = this.initializers.get(id);\n    if (initializer === undefined)\n      this.initializers.set(\n        id,\n        (initializer = {\n          id,\n          order: infos.length,\n          values: [],\n          body: { type: \"DelayInitializations\", parentBody: undefined, entries: [], done: false },\n        })\n      );\n    initializer.values.push(val);\n    return initializer.body;\n  }\n\n  scrubFunctionInitializers(): void {\n    // Deleting trivial entries in order to avoid creating empty initialization functions that serve no purpose.\n    for (let initializer of this.initializers.values())\n      if (initializer.body.entries.length === 0) this.initializers.delete(initializer.id);\n    for (let [functionValue, info] of this.functionInitializerInfos) {\n      for (let id of info.initializerIds) {\n        let initializer = this.initializers.get(id);\n        if (initializer === undefined) {\n          info.initializerIds.delete(id);\n        }\n      }\n      if (info.initializerIds.size === 0) this.functionInitializerInfos.delete(functionValue);\n    }\n  }\n\n  _conditionalInitialization(\n    containingAdditionalFunction: void | FunctionValue,\n    initializedValues: Array<Value>,\n    initializationStatements: Array<BabelNodeStatement>\n  ): BabelNodeStatement {\n    if (initializationStatements.length === 1 && t.isIfStatement(initializationStatements[0])) {\n      return initializationStatements[0];\n    }\n\n    // We have some initialization code, and it should only get executed once,\n    // so we are going to guard it.\n    // First, let's see if one of the initialized values is guaranteed to not\n    // be undefined after initialization. In that case, we can use that state-change\n    // to figure out if initialization needs to run.\n    let location;\n    for (let value of initializedValues) {\n      // function declarations get hoisted, so let's not use their initialization state as a marker\n      if (!value.mightBeUndefined() && !(value instanceof FunctionValue)) {\n        location = this.locationService.getLocation(value);\n        if (location !== undefined) break;\n      }\n    }\n    if (location === undefined) {\n      // Second, if we didn't find a non-undefined value, let's make one up.\n      // It will transition from `undefined` to `null`.\n      location = this.locationService.createLocation(containingAdditionalFunction);\n      initializationStatements.unshift(t.expressionStatement(t.assignmentExpression(\"=\", location, nullExpression)));\n    }\n    return t.ifStatement(\n      t.binaryExpression(\"===\", location, voidExpression),\n      t.blockStatement(initializationStatements)\n    );\n  }\n\n  hasInitializerStatement(functionValue: FunctionValue): boolean {\n    return !!this.functionInitializerInfos.get(functionValue);\n  }\n\n  factorifyInitializers(nameGenerator: NameGenerator): void {\n    for (const initializer of this.initializers.values()) {\n      factorifyObjects(initializer.body.entries, nameGenerator);\n    }\n  }\n\n  getInitializerStatement(functionValue: FunctionValue): void | BabelNodeStatement {\n    let initializerInfo = this.functionInitializerInfos.get(functionValue);\n    if (initializerInfo === undefined) return undefined;\n    let containingAdditionalFunction = this.locationService.getContainingAdditionalFunction(functionValue);\n\n    invariant(initializerInfo.initializerIds.size > 0);\n    let ownInitializer = this.initializers.get(initializerInfo.ownId);\n    let initializedValues;\n    let initializationStatements = [];\n    let initializers = [];\n    for (let initializerId of initializerInfo.initializerIds) {\n      let initializer = this.initializers.get(initializerId);\n      invariant(initializer !== undefined);\n      invariant(initializer.body.entries.length > 0);\n      initializers.push(initializer);\n    }\n    // Sorting initializers by the number of scopes they are required by.\n    // Note that the scope sets form a lattice, and this sorting effectively\n    // ensures that value initializers that depend on other value initializers\n    // get called in the right order.\n    initializers.sort((i, j) => j.order - i.order);\n    for (let initializer of initializers) {\n      if (initializerInfo.initializerIds.size === 1 || initializer === ownInitializer) {\n        initializedValues = initializer.values;\n      }\n      if (initializer === ownInitializer) {\n        initializationStatements = initializationStatements.concat(initializer.body.entries);\n      } else {\n        let ast = this.sharedInitializers.get(initializer.id);\n        if (ast === undefined) {\n          ast = this._conditionalInitialization(\n            containingAdditionalFunction,\n            initializer.values,\n            initializer.body.entries\n          );\n          // We inline compact initializers, as calling a function would introduce too much\n          // overhead. To determine if an initializer is compact, we count the number of\n          // nodes in the AST, and check if it exceeds a certain threshold.\n          // TODO #885: Study in more detail which threshold is the best compromise in terms of\n          // code size and performance.\n          let count = 0;\n          traverseFast(t.file(t.program([ast])), node => {\n            count++;\n            return false;\n          });\n          if (count > 24) {\n            let id = this.locationService.createFunction(containingAdditionalFunction, [ast]);\n            ast = t.expressionStatement(t.callExpression(id, []));\n          }\n          this.sharedInitializers.set(initializer.id, ast);\n        }\n        initializationStatements.push(ast);\n      }\n    }\n\n    return this._conditionalInitialization(\n      containingAdditionalFunction,\n      initializedValues || [],\n      initializationStatements\n    );\n  }\n}\n"]}