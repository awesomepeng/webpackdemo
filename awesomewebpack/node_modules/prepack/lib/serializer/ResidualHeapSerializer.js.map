{"version":3,"sources":["../../src/serializer/ResidualHeapSerializer.js"],"names":["t","commentStatement","text","s","emptyStatement","leadingComments","type","value","CountingSemaphore","constructor","action","initialCount","count","acquireOne","releaseOne","ResidualHeapSerializer","realm","logger","modules","residualHeapValueIdentifiers","residualHeapInspector","residualValues","residualFunctionInstances","residualClassMethodInstances","residualFunctionInfos","options","referencedDeclaredValues","additionalFunctionValuesAndEffects","additionalFunctionValueInfos","declarativeEnvironmentRecordsBindings","referentializer","generatorDAG","conditionalFeasibility","additionalGeneratorRoots","realmGenerator","generator","realmPreludeGenerator","preludeGenerator","prelude","_descriptors","Map","needsEmptyVar","needsAuxiliaryConstructor","descriptorNameGenerator","createNameGenerator","factoryNameGenerator","intrinsicNameGenerator","functionNameGenerator","initializeConditionNameGenerator","initializerNameGenerator","requireReturns","serializedValues","Set","_serializedValueWithIdentifiers","additionalFunctionValueNestedFunctions","residualReactElementSerializer","residualFunctions","getContainingAdditionalFunction","functionValue","instance","get","undefined","containingAdditionalFunction","getLocation","getSerializeObjectIdentifier","createLocation","location","identifier","generate","declar","variableDeclaration","variableDeclarator","getPrelude","push","createFunction","statements","id","functionDeclaration","blockStatement","emitter","derivedIds","mainBody","getBody","_options","activeGeneratorBodies","rewrittenAdditionalFunctions","additionalFunctionGenerators","declaredGlobalLets","_objectSemaphores","getStatistics","statistics","_acquireOneObjectSemaphore","object","semaphore","_emitObjectProperties","obj","properties","objectPrototypeAlreadyEstablished","cleanupDummyProperties","skipPrototype","symbol","propertyBinding","symbols","desc","descriptor","emitNowOrAfterWaitingForDependencies","_getDescriptorValues","concat","_emitProperty","key","pathNode","canIgnoreProperty","body","has","unknownProperty","val","_getNestedValuesFromAbstract","_emitPropertiesWithComputedNames","_emitObjectPrototype","_emitConstructorPrototype","objects","objectProperties","size","kind","getKind","proto","$Prototype","invariantLevel","serializedProto","serializeValue","uid","fetchedPrototype","isCompatibleWith","MOBILE_JSC_VERSION","memberExpression","callExpression","memoizeReference","condition","binaryExpression","consequent","getErrorStatement","stringLiteral","emit","ifStatement","intrinsics","expressionStatement","assignmentExpression","func","prototype","getPropertyValue","absVal","values","args","length","cond","P","V","W","alternate","earlier_props","serializedP","serializedV","serializedCond","valuesToProcess","consequentStatement","alternateStatement","oldBody","beginEmitting","parentBody","entries","done","consequentBody","endEmitting","alternateBody","unaryExpression","processValues","getIdentifierAndIncrementReferenceCount","deleteIfMightHaveBeenDeleted","locationFunction","serializedKey","computed","isIdentifier","_deleteProperty","emitDefinePropertyBody","joinCondition","trueBody","falseBody","descriptor1","descriptor2","_canEmbedProperty","descValue","getReasonToWaitForDependencies","mightHaveBeenDeleted","_getPropertyAssignmentStatement","descProps","boolKeys","valKeys","set","descriptorsKey","boolKey","b","objectProperty","booleanLiteral","toString","join","descriptorId","objectExpression","descKey","sequenceExpression","_serializeDeclarativeEnvironmentRecordBinding","residualFunctionBinding","serializedValue","declarativeEnvironmentRecord","hasLeaked","referentializeLeakedBinding","modified","referentializeModifiedBinding","mightBeObject","incrementReferenceCount","_getReferencingGenerators","initialGenerators","functionValues","referencingOnlyOptimizedFunction","result","activeFunctions","slice","visitedFunctions","f","pop","add","g","scopes","scope","Array","from","isDefinedInsideFunction","childFunction","maybeParentFunctions","maybeParentFunction","env","$Environment","parent","envRecord","environmentRecord","$FunctionObject","tryGetOptimizedFunctionRoot","getParent","additionalFunction","_getActiveBodyOfGenerator","_getTarget","trace","_logScopes","generators","delayInitializations","includes","residualFunctionInitializers","registerValueOnlyReferencedByResidualFunctions","usedOnlyByResidualFunctions","description","console","log","filter","getGeneratorParent","commonAncestor","reduce","x","y","getName","notYetDoneBodies","dependenciesVisitor","onArrayWithWidenedNumericProperty","dependency","intrinsicName","emittingToAdditionalFunction","declarationBody","getDeclarationBody","onAbstractValueWithIdentifier","scopeBody","nestingLevel","_getValueDebugName","name","getIdentifier","serializeBinding","binding","record","environment","residualFunctionBindings","residualBinding","serializedUnscopedLocation","additionalFunctionPreludes","_declare","emittingToResidualFunction","bindingType","init","assignment","referenceOnly","refuseSerialization","_serializeAbstractValueHelper","classMethodInstance","methodType","error","$ECMAScriptCode","loc","handleError","isLeaf","res","_serializeValue","target","debugIdentifiers","needsIdentifier","debugScopes","scopeList","map","comment","valueIds","delayedValues","deleteIdentifier","valuesInlined","_serializeValueIntrinsic","intrinsicNameGenerated","convertStringToMember","_assignProperty","c","_serializeEmptyValue","deletion","_serializeArrayIndexProperties","array","indexPropertyLength","remainingProperties","elems","i","elem","elemVal","delayReason","getReasonToWaitForActiveValue","delete","_serializeArrayLengthIfNeeded","numberOfIndexProperties","lenProperty","mightBeHavocedObject","evaluateWithoutLeakLogic","ToLength","_serializeValueArray","unconditionalLength","assignmentNotNeeded","initProperties","arrayExpression","_serializeValueMap","omitDeadEntries","$MapData","$WeakMapData","len","mapConstructorDoesntTakeArguments","entry","$Key","$Value","emitAfterWaiting","newExpression","_serializeValueSet","$SetData","$WeakSetData","setConstructorDoesntTakeArguments","_serializeValueTypedArrayOrDataView","buf","$ViewedArrayBuffer","outlinedArrayBuffer","_serializeValueArrayBuffer","$ArrayBufferByteLength","db","$ArrayBufferData","allzero","numericLiteral","arrayValue","consExpr","_serializeValueFunction","$BoundTargetFunction","$BoundThis","$BoundArguments","boundArg","residualBindings","inOptimizedFunction","bindingsEmittedSemaphore","insertionPoint","getBodyReference","boundName","referencedValues","serializeBindingFunc","_serializeGlobalBinding","$FunctionKind","homeObject","$HomeObject","$IsClassPrototype","_serializeClass","additionalFVEffects","additionalEffects","_serializeAdditionalFunction","classFunc","classPrototype","classProtoId","hasSerializedClassProtoId","propertiesToSerialize","classSuperNode","serializeClassPrototypeId","classId","serializeClassMethodOrProperty","propertyNameOrSymbol","methodFuncOrProperty","serializeNameAndId","methodFuncOrPropertyId","_serializeClassMethod","prototypeId","serializeClassProperty","propertyValue","prop","propertyName","method","classMethodKeyNode","methodFunc","classMethodComputed","targetDescriptor","getTargetIntegrityDescriptor","writable","configurable","enumerable","_findLastObjectPrototype","_serializeValueRegExpObject","source","$OriginalSource","flags","$OriginalFlags","RegExp","regExpLiteral","serializeValueRawObject","emitIntegrityCommand","dummyProperties","props","temporalAlias","propValue","_serializeValueObjectViaConstructor","classConstructor","serializeValueObject","originalConstructor","setFunctionPrototype","numberData","$NumberData","throwIfNotConcreteNumber","stringData","$StringData","throwIfNotConcreteString","booleanData","$BooleanData","throwIfNotConcreteBoolean","dateValue","$DateValue","serializedDateValue","serializeReactElement","_constructor","createViaAuxiliaryConstructor","ObjectPrototype","_serializeValueSymbol","$Description","serializedArg","globalReg","globalSymbolRegistry","find","e","$Symbol","_serializeValueProxy","$ProxyTarget","$ProxyHandler","serializedArgs","abstractArg","abstractIndex","findIndex","v","ob","buildNode","cannotDeclare","hasBeenDeclared","_serializeAbstractValue","cf","hasIdentifier","reason","isIntrinsic","valueToNode","serialize","_serializeValueObjectBase","objectSemaphore","targetCommand","getTargetIntegrityCommand","referentialized","_annotateGeneratorStatements","beginComments","effects","effectsToApply","valueToString","keyToString","createdObjects","modifiedBindings","modifiedProperties","keys","unshift","_withGeneratorScope","callback","isChildOverride","newBody","isChild","_getContext","context","bind","serializeGenerator","initGenerator","activeGeneratorBody","finalizeGenerator","finalizeCurrentBody","statement","getPropertyAssignmentStatement","canOmit","declare","emitPropertyModification","dependencies","_shouldBeWrapped","item","_serializeAdditionalFunctionGeneratorAndEffects","inAdditionalFunction","effectsGenerator","withEffectsAppliedInGlobalEnv","lazyHoistedReactNodes","serializeLazyHoistedNodes","additionalFunctionValue","transforms","additionalRoots","additionalRoot","nestedFunctions","forEach","transform","prepareAdditionalFunctionValues","postGeneratorSerialization","declaredCount","moduleId","moduleValue","initializedModules","apply","finalize","factorifyInitializers","unstrictFunctionBodies","strictFunctionBodies","spliceFunctions","strictDirective","directive","directiveLiteral","globalDirectives","isStrict","funcLoop","node","isFunctionExpression","directives","functionExpression","ast_body","declaredGlobals","globalExpression","thisExpression","usesThis","every","_logSerializedResidualMismatches","cleanInstance","program_directives","file","program","__originalName","JSON","stringify","expressionLocation","logValue"],"mappings":"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","file":"ResidualHeapSerializer.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\nimport { IsArray, Get } from \"../methods/index.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NumberValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  SymbolValue,\n  Value,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeMemberExpression,\n  BabelNodeSpreadElement,\n  BabelVariableKind,\n  BabelNodeFile,\n  BabelNodeFunctionExpression,\n} from \"babel-types\";\nimport { Generator, PreludeGenerator, NameGenerator } from \"../utils/generator.js\";\nimport type { SerializationContext } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n  SerializedBody,\n  ClassMethodInstance,\n  AdditionalFunctionEffects,\n} from \"./types.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport { BodyReference } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport type { Scope } from \"./ResidualHeapVisitor.js\";\nimport { factorifyObjects } from \"./factorify.js\";\nimport { voidExpression, emptyExpression, constructorExpression, protoExpression } from \"../utils/babelhelpers.js\";\nimport { Emitter } from \"./Emitter.js\";\nimport { ResidualHeapValueIdentifiers } from \"./ResidualHeapValueIdentifiers.js\";\nimport {\n  commonAncestorOf,\n  getSuggestedArrayLiteralLength,\n  withDescriptorValue,\n  ClassPropertiesToIgnore,\n  canIgnoreClassLengthProperty,\n  getObjectPrototypeMetadata,\n} from \"./utils.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { canHoistFunction } from \"../react/hoisting.js\";\nimport { To } from \"../singletons.js\";\nimport { ResidualReactElementSerializer } from \"./ResidualReactElementSerializer.js\";\nimport type { Binding } from \"../environment.js\";\nimport { DeclarativeEnvironmentRecord, FunctionEnvironmentRecord } from \"../environment.js\";\nimport type { Referentializer } from \"./Referentializer.js\";\nimport { GeneratorDAG } from \"./GeneratorDAG.js\";\nimport { type Replacement, getReplacement } from \"./ResidualFunctionInstantiator\";\nimport { describeValue } from \"../utils.js\";\nimport { getAsPropertyNameExpression } from \"../utils/babelhelpers.js\";\n\nfunction commentStatement(text: string) {\n  let s = t.emptyStatement();\n  s.leadingComments = [({ type: \"BlockComment\", value: text }: any)];\n  return s;\n}\n\nclass CountingSemaphore {\n  count: number;\n  action: () => void;\n  constructor(action: () => void, initialCount: number = 1) {\n    invariant(initialCount >= 1);\n    this.count = initialCount;\n    this.action = action;\n  }\n  acquireOne() {\n    this.count++;\n  }\n  releaseOne() {\n    invariant(this.count > 0);\n    if (--this.count === 0) this.action();\n  }\n}\n\nexport class ResidualHeapSerializer {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    residualHeapValueIdentifiers: ResidualHeapValueIdentifiers,\n    residualHeapInspector: HeapInspector,\n    residualValues: Map<Value, Set<Scope>>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    options: SerializerOptions,\n    referencedDeclaredValues: Map<Value, void | FunctionValue>,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>,\n    referentializer: Referentializer,\n    generatorDAG: GeneratorDAG,\n    conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>,\n    additionalGeneratorRoots: Map<Generator, Set<ObjectValue>>\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this.modules = modules;\n    this.residualHeapValueIdentifiers = residualHeapValueIdentifiers;\n    this.referentializer = referentializer;\n\n    let realmGenerator = this.realm.generator;\n    invariant(realmGenerator);\n    this.generator = realmGenerator;\n    let realmPreludeGenerator = this.realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n\n    this.prelude = [];\n    this._descriptors = new Map();\n    this.needsEmptyVar = false;\n    this.needsAuxiliaryConstructor = false;\n    this.descriptorNameGenerator = this.preludeGenerator.createNameGenerator(\"$$\");\n    this.factoryNameGenerator = this.preludeGenerator.createNameGenerator(\"$_\");\n    this.intrinsicNameGenerator = this.preludeGenerator.createNameGenerator(\"$i_\");\n    this.functionNameGenerator = this.preludeGenerator.createNameGenerator(\"$f_\");\n    this.initializeConditionNameGenerator = this.preludeGenerator.createNameGenerator(\"_initialized\");\n    this.initializerNameGenerator = this.preludeGenerator.createNameGenerator(\"__init_\");\n    this.requireReturns = new Map();\n    this.serializedValues = new Set();\n    this._serializedValueWithIdentifiers = new Set();\n    this.additionalFunctionValueNestedFunctions = new Set();\n    this.residualReactElementSerializer = new ResidualReactElementSerializer(this.realm, this);\n    this.residualFunctions = new ResidualFunctions(\n      this.realm,\n      options,\n      this.modules,\n      this.requireReturns,\n      {\n        getContainingAdditionalFunction: functionValue => {\n          let instance = this.residualFunctionInstances.get(functionValue);\n          invariant(instance !== undefined);\n          return instance.containingAdditionalFunction;\n        },\n        getLocation: value => this.getSerializeObjectIdentifier(value),\n        createLocation: containingAdditionalFunction => {\n          let location = t.identifier(this.initializeConditionNameGenerator.generate());\n          let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(location)]);\n          this.getPrelude(containingAdditionalFunction).push(declar);\n          return location;\n        },\n        createFunction: (containingAdditionalFunction, statements) => {\n          let id = t.identifier(this.initializerNameGenerator.generate());\n          this.getPrelude(containingAdditionalFunction).push(\n            t.functionDeclaration(id, [], t.blockStatement(statements))\n          );\n          return id;\n        },\n      },\n      this.prelude,\n      this.factoryNameGenerator,\n      residualFunctionInfos,\n      residualFunctionInstances,\n      residualClassMethodInstances,\n      additionalFunctionValueInfos,\n      this.additionalFunctionValueNestedFunctions,\n      referentializer\n    );\n    this.emitter = new Emitter(\n      this.residualFunctions,\n      referencedDeclaredValues,\n      conditionalFeasibility,\n      this.realm.derivedIds\n    );\n    this.mainBody = this.emitter.getBody();\n    this.residualHeapInspector = residualHeapInspector;\n    this.residualValues = residualValues;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.residualFunctionInfos = residualFunctionInfos;\n    this._options = options;\n    this.referencedDeclaredValues = referencedDeclaredValues;\n    this.activeGeneratorBodies = new Map();\n    this.additionalFunctionValuesAndEffects = additionalFunctionValuesAndEffects;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.rewrittenAdditionalFunctions = new Map();\n    this.declarativeEnvironmentRecordsBindings = declarativeEnvironmentRecordsBindings;\n    this.generatorDAG = generatorDAG;\n    this.conditionalFeasibility = conditionalFeasibility;\n    this.additionalFunctionGenerators = new Map();\n    this.declaredGlobalLets = new Map();\n    this._objectSemaphores = new Map();\n    this.additionalGeneratorRoots = additionalGeneratorRoots;\n  }\n\n  emitter: Emitter;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  functionInstances: Array<FunctionInstance>;\n  prelude: Array<BabelNodeStatement>;\n  body: Array<BabelNodeStatement>;\n  mainBody: SerializedBody;\n  realm: Realm;\n  preludeGenerator: PreludeGenerator;\n  generator: Generator;\n  _descriptors: Map<string, BabelNodeIdentifier>;\n  needsEmptyVar: boolean;\n  needsAuxiliaryConstructor: boolean;\n  descriptorNameGenerator: NameGenerator;\n  factoryNameGenerator: NameGenerator;\n  intrinsicNameGenerator: NameGenerator;\n  functionNameGenerator: NameGenerator;\n  initializeConditionNameGenerator: NameGenerator;\n  initializerNameGenerator: NameGenerator;\n  logger: Logger;\n  modules: Modules;\n  residualHeapValueIdentifiers: ResidualHeapValueIdentifiers;\n  requireReturns: Map<number | string, Replacement>;\n  residualHeapInspector: HeapInspector;\n  residualValues: Map<Value, Set<Scope>>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  serializedValues: Set<Value>;\n  _serializedValueWithIdentifiers: Set<Value>;\n  residualFunctions: ResidualFunctions;\n  _options: SerializerOptions;\n  referencedDeclaredValues: Map<Value, void | FunctionValue>;\n  activeGeneratorBodies: Map<Generator, SerializedBody>;\n  additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects> | void;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>;\n  declarativeEnvironmentRecordsBindings: Map<DeclarativeEnvironmentRecord, Map<string, ResidualFunctionBinding>>;\n  residualReactElementSerializer: ResidualReactElementSerializer;\n  referentializer: Referentializer;\n  additionalFunctionGenerators: Map<FunctionValue, Generator>;\n\n  // function values nested in additional functions can't delay initializations\n  // TODO: revisit this and fix additional functions to be capable of delaying initializations\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n\n  generatorDAG: GeneratorDAG;\n  conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>;\n  additionalGeneratorRoots: Map<Generator, Set<ObjectValue>>;\n\n  declaredGlobalLets: Map<string, Value>;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  _objectSemaphores: Map<ObjectValue, CountingSemaphore>;\n\n  _acquireOneObjectSemaphore(object: ObjectValue): void | CountingSemaphore {\n    let semaphore = this._objectSemaphores.get(object);\n    if (semaphore !== undefined) semaphore.acquireOne();\n    return semaphore;\n  }\n\n  // Configures all mutable aspects of an object, in particular:\n  // symbols, properties, prototype.\n  // For every created object that corresponds to a value,\n  // this function should be invoked once.\n  // Thus, as a side effect, we gather statistics here on all emitted objects.\n  _emitObjectProperties(\n    obj: ObjectValue,\n    properties: Map<string, PropertyBinding> = obj.properties,\n    objectPrototypeAlreadyEstablished: boolean = false,\n    cleanupDummyProperties: ?Set<string>,\n    skipPrototype: boolean = false\n  ): void {\n    //inject symbols\n    for (let [symbol, propertyBinding] of obj.symbols) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      let semaphore = this._acquireOneObjectSemaphore(obj);\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        this._getDescriptorValues(desc).concat([symbol, obj]),\n        () => {\n          invariant(desc !== undefined);\n          this._emitProperty(obj, symbol, desc);\n          if (semaphore !== undefined) semaphore.releaseOne();\n        },\n        this.emitter.getBody()\n      );\n    }\n\n    // inject properties\n    for (let [key, propertyBinding] of properties) {\n      invariant(propertyBinding);\n      if (propertyBinding.pathNode !== undefined) continue; // Property is assigned to inside loop\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      if (this.residualHeapInspector.canIgnoreProperty(obj, key)) continue;\n      invariant(desc !== undefined);\n      let semaphore = this._acquireOneObjectSemaphore(obj);\n      let body = this.emitter.getBody();\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        this._getDescriptorValues(desc).concat(obj),\n        () => {\n          invariant(desc !== undefined);\n          this._emitProperty(obj, key, desc, cleanupDummyProperties != null && cleanupDummyProperties.has(key));\n          if (semaphore !== undefined) semaphore.releaseOne();\n        },\n        body\n      );\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        let semaphore = this._acquireOneObjectSemaphore(obj);\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          this._getNestedValuesFromAbstract(val, [obj]),\n          () => {\n            invariant(val instanceof AbstractValue);\n            this._emitPropertiesWithComputedNames(obj, val);\n            if (semaphore !== undefined) semaphore.releaseOne();\n          },\n          this.emitter.getBody()\n        );\n      }\n    }\n\n    // prototype\n    if (!skipPrototype) {\n      this._emitObjectPrototype(obj, objectPrototypeAlreadyEstablished);\n      if (obj instanceof FunctionValue) this._emitConstructorPrototype(obj);\n    }\n\n    this.getStatistics().objects++;\n    this.getStatistics().objectProperties += obj.properties.size;\n  }\n\n  _emitObjectPrototype(obj: ObjectValue, objectPrototypeAlreadyEstablished: boolean): void {\n    let kind = obj.getKind();\n    let proto = obj.$Prototype;\n    if (objectPrototypeAlreadyEstablished) {\n      if (this.realm.invariantLevel >= 3) {\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          [proto, obj],\n          () => {\n            invariant(proto);\n            let serializedProto = this.serializeValue(proto);\n            let uid = this.getSerializeObjectIdentifier(obj);\n            const fetchedPrototype =\n              this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith(\"mobile\")\n                ? t.memberExpression(uid, protoExpression)\n                : t.callExpression(this.preludeGenerator.memoizeReference(\"Object.getPrototypeOf\"), [uid]);\n            let condition = t.binaryExpression(\"!==\", fetchedPrototype, serializedProto);\n            let consequent = this.generator.getErrorStatement(t.stringLiteral(\"unexpected prototype\"));\n            this.emitter.emit(t.ifStatement(condition, consequent));\n          },\n          this.emitter.getBody()\n        );\n      }\n      return;\n    }\n    if (proto === this.realm.intrinsics[kind + \"Prototype\"]) return;\n\n    let semaphore = this._acquireOneObjectSemaphore(obj);\n    this.emitter.emitNowOrAfterWaitingForDependencies(\n      [proto, obj],\n      () => {\n        invariant(proto);\n        let serializedProto = this.serializeValue(proto);\n        let uid = this.getSerializeObjectIdentifier(obj);\n        if (!this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) && !this.realm.isCompatibleWith(\"mobile\"))\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n            )\n          );\n        else {\n          this.emitter.emit(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", t.memberExpression(uid, protoExpression), serializedProto)\n            )\n          );\n        }\n        if (semaphore !== undefined) semaphore.releaseOne();\n      },\n      this.emitter.getBody()\n    );\n  }\n\n  _emitConstructorPrototype(func: FunctionValue): void {\n    // If the original prototype object was mutated,\n    // request its serialization here as this might be observable by\n    // residual code.\n    let prototype = HeapInspector.getPropertyValue(func, \"prototype\");\n    if (prototype instanceof ObjectValue && this.residualValues.has(prototype)) {\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        [func],\n        () => {\n          invariant(prototype instanceof Value);\n          this.serializeValue(prototype);\n        },\n        this.emitter.getBody()\n      );\n    }\n  }\n\n  _getNestedValuesFromAbstract(absVal: AbstractValue, values: Array<Value>): Array<Value> {\n    if (absVal.kind === \"widened property\") return values;\n    if (absVal.kind === \"template for prototype member expression\") return values;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      values.push(P);\n      let V = absVal.args[1];\n      values.push(V);\n      let W = absVal.args[2];\n      if (W instanceof AbstractValue) this._getNestedValuesFromAbstract(W, values);\n      else values.push(W);\n    } else {\n      // conditional assignment\n      values.push(cond);\n      let consequent = absVal.args[1];\n      if (consequent instanceof AbstractValue) {\n        this._getNestedValuesFromAbstract(consequent, values);\n      } else {\n        values.push(consequent);\n      }\n      let alternate = absVal.args[2];\n      if (alternate instanceof AbstractValue) {\n        this._getNestedValuesFromAbstract(alternate, values);\n      } else {\n        values.push(alternate);\n      }\n    }\n    return values;\n  }\n\n  _emitPropertiesWithComputedNames(obj: ObjectValue, absVal: AbstractValue): void {\n    if (absVal.kind === \"widened property\") return;\n    if (absVal.kind === \"template for prototype member expression\") return;\n    invariant(absVal.args.length === 3);\n    let cond = absVal.args[0];\n    invariant(cond instanceof AbstractValue);\n    if (cond.kind === \"template for property name condition\") {\n      let P = cond.args[0];\n      invariant(P instanceof AbstractValue);\n      let V = absVal.args[1];\n      let earlier_props = absVal.args[2];\n      if (earlier_props instanceof AbstractValue) this._emitPropertiesWithComputedNames(obj, earlier_props);\n      let uid = this.getSerializeObjectIdentifier(obj);\n      let serializedP = this.serializeValue(P);\n      let serializedV = this.serializeValue(V);\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(uid, serializedP, true), serializedV))\n      );\n    } else {\n      // conditional assignment\n      let serializedCond = this.serializeValue(cond);\n      let consequent = absVal.args[1];\n      let valuesToProcess = new Set();\n      let consequentStatement;\n      let alternateStatement;\n\n      if (consequent instanceof AbstractValue) {\n        let oldBody = this.emitter.beginEmitting(\n          \"consequent\",\n          {\n            type: \"ConditionalAssignmentBranch\",\n            parentBody: undefined,\n            entries: [],\n            done: false,\n          },\n          /*isChild*/ true\n        );\n        this._emitPropertiesWithComputedNames(obj, consequent);\n        let consequentBody = this.emitter.endEmitting(\"consequent\", oldBody, valuesToProcess, /*isChild*/ true);\n        consequentStatement = t.blockStatement(consequentBody.entries);\n      }\n      let alternate = absVal.args[2];\n      if (alternate instanceof AbstractValue) {\n        let oldBody = this.emitter.beginEmitting(\n          \"alternate\",\n          {\n            type: \"ConditionalAssignmentBranch\",\n            parentBody: undefined,\n            entries: [],\n            done: false,\n          },\n          /*isChild*/ true\n        );\n        this._emitPropertiesWithComputedNames(obj, alternate);\n        let alternateBody = this.emitter.endEmitting(\"alternate\", oldBody, valuesToProcess, /*isChild*/ true);\n        alternateStatement = t.blockStatement(alternateBody.entries);\n      }\n      if (consequentStatement) {\n        this.emitter.emit(t.ifStatement(serializedCond, consequentStatement, alternateStatement));\n      } else if (alternateStatement) {\n        this.emitter.emit(t.ifStatement(t.unaryExpression(\"!\", serializedCond), alternateStatement));\n      }\n      this.emitter.processValues(valuesToProcess);\n    }\n  }\n\n  // Overridable.\n  getSerializeObjectIdentifier(val: Value): BabelNodeIdentifier {\n    return this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val);\n  }\n\n  _emitProperty(\n    val: ObjectValue,\n    key: string | SymbolValue | AbstractValue,\n    desc: Descriptor | void,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): void {\n    // Location for the property to be assigned to\n    let locationFunction = () => {\n      let serializedKey =\n        key instanceof SymbolValue || key instanceof AbstractValue\n          ? this.serializeValue(key)\n          : getAsPropertyNameExpression(key);\n      let computed = key instanceof SymbolValue || key instanceof AbstractValue || !t.isIdentifier(serializedKey);\n      return t.memberExpression(this.getSerializeObjectIdentifier(val), serializedKey, computed);\n    };\n    if (desc === undefined) {\n      this._deleteProperty(locationFunction());\n    } else {\n      this.emitter.emit(this.emitDefinePropertyBody(deleteIfMightHaveBeenDeleted, locationFunction, val, key, desc));\n    }\n  }\n\n  emitDefinePropertyBody(\n    deleteIfMightHaveBeenDeleted: boolean,\n    locationFunction: void | (() => BabelNodeLVal),\n    val: ObjectValue,\n    key: string | SymbolValue | AbstractValue,\n    desc: Descriptor\n  ): BabelNodeStatement {\n    if (desc.joinCondition) {\n      let cond = this.serializeValue(desc.joinCondition);\n      invariant(cond !== undefined);\n      let trueBody;\n      let falseBody;\n      if (desc.descriptor1)\n        trueBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor1\n        );\n      if (desc.descriptor2)\n        falseBody = this.emitDefinePropertyBody(\n          deleteIfMightHaveBeenDeleted,\n          locationFunction,\n          val,\n          key,\n          desc.descriptor2\n        );\n      if (trueBody && falseBody) return t.ifStatement(cond, trueBody, falseBody);\n      if (trueBody) return t.ifStatement(cond, trueBody);\n      if (falseBody) return t.ifStatement(t.unaryExpression(\"!\", cond), falseBody);\n      invariant(false);\n    }\n    if (locationFunction !== undefined && this._canEmbedProperty(val, key, desc)) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      invariant(!this.emitter.getReasonToWaitForDependencies([descValue, val]), \"precondition of _emitProperty\");\n      let mightHaveBeenDeleted = descValue.mightHaveBeenDeleted();\n      // The only case we do not need to remove the dummy property is array index property.\n      return this._getPropertyAssignmentStatement(\n        locationFunction(),\n        descValue,\n        mightHaveBeenDeleted,\n        deleteIfMightHaveBeenDeleted\n      );\n    }\n    let body = [];\n    let descProps = [];\n    let boolKeys = [\"enumerable\", \"configurable\"];\n    let valKeys = [];\n\n    if (!desc.get && !desc.set) {\n      boolKeys.push(\"writable\");\n      valKeys.push(\"value\");\n    } else {\n      valKeys.push(\"set\", \"get\");\n    }\n\n    let descriptorsKey = [];\n    for (let boolKey of boolKeys) {\n      if (boolKey in desc) {\n        let b = desc[boolKey];\n        invariant(b !== undefined);\n        descProps.push(t.objectProperty(t.identifier(boolKey), t.booleanLiteral(b)));\n        descriptorsKey.push(`${boolKey}:${b.toString()}`);\n      }\n    }\n\n    descriptorsKey = descriptorsKey.join(\",\");\n    let descriptorId = this._descriptors.get(descriptorsKey);\n    if (descriptorId === undefined) {\n      descriptorId = t.identifier(this.descriptorNameGenerator.generate(descriptorsKey));\n      let declar = t.variableDeclaration(\"var\", [t.variableDeclarator(descriptorId, t.objectExpression(descProps))]);\n      // The descriptors are used across all scopes, and thus must be declared in the prelude.\n      this.prelude.push(declar);\n      this._descriptors.set(descriptorsKey, descriptorId);\n    }\n    invariant(descriptorId !== undefined);\n\n    for (let descKey of valKeys) {\n      if (descKey in desc) {\n        let descValue = desc[descKey];\n        invariant(descValue instanceof Value);\n        if (descValue instanceof UndefinedValue) {\n          this.serializeValue(descValue);\n          continue;\n        }\n        invariant(!this.emitter.getReasonToWaitForDependencies([descValue]), \"precondition of _emitProperty\");\n        body.push(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(descriptorId, t.identifier(descKey)),\n            this.serializeValue(descValue)\n          )\n        );\n      }\n    }\n    let serializedKey =\n      key instanceof SymbolValue || key instanceof AbstractValue\n        ? this.serializeValue(key)\n        : getAsPropertyNameExpression(key, /*canBeIdentifier*/ false);\n    invariant(!this.emitter.getReasonToWaitForDependencies([val]), \"precondition of _emitProperty\");\n    body.push(\n      t.callExpression(this.preludeGenerator.memoizeReference(\"Object.defineProperty\"), [\n        this.getSerializeObjectIdentifier(val),\n        serializedKey,\n        descriptorId,\n      ])\n    );\n    return t.expressionStatement(t.sequenceExpression(body));\n  }\n\n  _serializeDeclarativeEnvironmentRecordBinding(residualFunctionBinding: ResidualFunctionBinding): void {\n    if (!residualFunctionBinding.serializedValue) {\n      let value = residualFunctionBinding.value;\n      invariant(residualFunctionBinding.declarativeEnvironmentRecord);\n\n      if (residualFunctionBinding.hasLeaked) {\n        this.referentializer.referentializeLeakedBinding(residualFunctionBinding);\n      } else {\n        residualFunctionBinding.serializedValue = value !== undefined ? this.serializeValue(value) : voidExpression;\n        if (residualFunctionBinding.modified) {\n          this.referentializer.referentializeModifiedBinding(residualFunctionBinding);\n        }\n      }\n\n      if (value !== undefined && value.mightBeObject()) {\n        // Increment ref count one more time to ensure that this object will be assigned a unique id.\n        // This ensures that only once instance is created across all possible residual function invocations.\n        this.residualHeapValueIdentifiers.incrementReferenceCount(value);\n      }\n    }\n  }\n\n  // Augments an initial set of generators with all generators from\n  // which any of a given set of function values is referenced.\n  _getReferencingGenerators(\n    initialGenerators: Array<Generator>,\n    functionValues: Array<FunctionValue>,\n    referencingOnlyOptimizedFunction: void | FunctionValue\n  ): Array<Generator> {\n    let result = new Set(initialGenerators);\n    let activeFunctions = functionValues.slice();\n    let visitedFunctions = new Set();\n\n    while (activeFunctions.length > 0) {\n      let f = activeFunctions.pop();\n      if (visitedFunctions.has(f)) continue;\n      visitedFunctions.add(f);\n\n      if (f === referencingOnlyOptimizedFunction) {\n        let g = this.additionalFunctionGenerators.get(f);\n        invariant(g !== undefined);\n        result.add(g);\n      } else {\n        let scopes = this.residualValues.get(f);\n        invariant(scopes);\n        for (let scope of scopes)\n          if (scope instanceof FunctionValue) {\n            activeFunctions.push(scope);\n          } else {\n            invariant(scope instanceof Generator);\n            result.add(scope);\n          }\n      }\n    }\n    return Array.from(result);\n  }\n\n  isDefinedInsideFunction(childFunction: FunctionValue, maybeParentFunctions: Set<FunctionValue>): boolean {\n    for (let maybeParentFunction of maybeParentFunctions) {\n      if (childFunction === maybeParentFunction) {\n        continue;\n      }\n      let env = childFunction.$Environment;\n      while (env.parent !== null) {\n        let envRecord = env.environmentRecord;\n        if (envRecord instanceof FunctionEnvironmentRecord && envRecord.$FunctionObject === maybeParentFunction) {\n          return true;\n        }\n        env = env.parent;\n      }\n    }\n    return false;\n  }\n\n  // Try and get the root optimized function when passed in an optimized function\n  // that may or may not be nested in the tree of said root, or is the root optimized function\n  tryGetOptimizedFunctionRoot(val: Value): void | FunctionValue {\n    let scopes = this.residualValues.get(val);\n    let functionValues = new Set();\n    invariant(scopes !== undefined);\n    for (let scope of scopes) {\n      let s = scope;\n      while (s instanceof Generator) {\n        s = this.generatorDAG.getParent(s);\n      }\n      if (s === \"GLOBAL\") return undefined;\n      invariant(s instanceof FunctionValue);\n      functionValues.add(s);\n    }\n    let additionalFunction;\n\n    for (let functionValue of functionValues) {\n      if (this.additionalFunctionGenerators.has(functionValue)) {\n        if (this.isDefinedInsideFunction(functionValue, functionValues)) {\n          continue;\n        }\n        if (additionalFunction !== undefined && additionalFunction !== functionValue) {\n          return undefined;\n        }\n        additionalFunction = functionValue;\n      } else {\n        let f = this.tryGetOptimizedFunctionRoot(functionValue);\n        if (f === undefined) return undefined;\n        if (additionalFunction !== undefined && additionalFunction !== f) return undefined;\n        additionalFunction = f;\n      }\n    }\n    return additionalFunction;\n  }\n\n  _getActiveBodyOfGenerator(generator: Generator): void | SerializedBody {\n    return generator === this.generator ? this.mainBody : this.activeGeneratorBodies.get(generator);\n  }\n\n  // Determine whether initialization code for a value should go into the main body, or a more specific initialization body.\n  _getTarget(\n    val: Value,\n    trace?: true\n  ): {\n    body: SerializedBody,\n    usedOnlyByResidualFunctions?: true,\n    referencingOnlyOptimizedFunction?: void | FunctionValue,\n    commonAncestor?: Scope,\n    description?: string,\n  } {\n    let scopes = this.residualValues.get(val);\n    invariant(scopes !== undefined, \"value must have been visited\");\n\n    // All relevant values were visited in at least one scope.\n    invariant(scopes.size >= 1);\n    if (trace) this._logScopes(scopes);\n\n    // If a value is used in more than one scope, prevent inlining as it might be an additional root with a particular creation scope\n    if (scopes.size > 1) this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    // First, let's figure out from which function and generator scopes this value is referenced.\n    let functionValues = [];\n    let generators = [];\n    for (let scope of scopes) {\n      if (scope instanceof FunctionValue) {\n        functionValues.push(scope);\n      } else {\n        invariant(scope instanceof Generator, \"scope must be either function value or generator\");\n        generators.push(scope);\n      }\n    }\n\n    let referencingOnlyOptimizedFunction = this.tryGetOptimizedFunctionRoot(val);\n    if (generators.length === 0) {\n      // This value is only referenced from residual functions.\n      if (\n        this._options.delayInitializations &&\n        (referencingOnlyOptimizedFunction === undefined || !functionValues.includes(referencingOnlyOptimizedFunction))\n      ) {\n        // We can delay the initialization, and move it into a conditional code block in the residual functions!\n        let body = this.residualFunctions.residualFunctionInitializers.registerValueOnlyReferencedByResidualFunctions(\n          functionValues,\n          val\n        );\n\n        return {\n          body,\n          usedOnlyByResidualFunctions: true,\n          referencingOnlyOptimizedFunction,\n          description: \"delay_initializer\",\n        };\n      }\n    }\n\n    if (trace)\n      console.log(\n        `  is referenced only by additional function? ${referencingOnlyOptimizedFunction !== undefined ? \"yes\" : \"no\"}`\n      );\n\n    // flatten all function values into the scopes that use them\n    generators = this._getReferencingGenerators(generators, functionValues, referencingOnlyOptimizedFunction);\n\n    if (referencingOnlyOptimizedFunction === undefined) {\n      // Remove all generators rooted in additional functions,\n      // since we know that there's at least one root that's not in an additional function\n      // which requires the value to be emitted outside of the additional function.\n      generators = generators.filter(generator => {\n        let s = generator;\n        while (s instanceof Generator) {\n          s = this.generatorDAG.getParent(s);\n        }\n        return s === \"GLOBAL\";\n      });\n      if (generators.length === 0) {\n        // This means that the value was referenced by multiple additional functions, and thus it must have existed at the end of global code execution.\n        // TODO: Emit to the end, not somewhere in the middle of the mainBody.\n        // TODO: Revisit for nested additional functions\n        return { body: this.mainBody };\n      }\n    }\n\n    const getGeneratorParent = g => {\n      let s = this.generatorDAG.getParent(g);\n      return s instanceof Generator ? s : undefined;\n    };\n    // This value is referenced from more than one generator.\n    // Let's find the body associated with their common ancestor.\n    let commonAncestor = Array.from(generators).reduce(\n      (x, y) => commonAncestorOf(x, y, getGeneratorParent),\n      generators[0]\n    );\n    // In the case where we have no common ancestor but we have an optimized function reference,\n    // we can attempt to use the generator of the single optimized function\n    if (commonAncestor === undefined && referencingOnlyOptimizedFunction !== undefined) {\n      commonAncestor = this.additionalFunctionGenerators.get(referencingOnlyOptimizedFunction);\n    }\n    invariant(commonAncestor !== undefined, \"there must always be a common generator ancestor\");\n    if (trace) console.log(`  common ancestor: ${commonAncestor.getName()}`);\n\n    let body;\n    while (true) {\n      body = this._getActiveBodyOfGenerator(commonAncestor);\n      if (body !== undefined) break;\n      commonAncestor = getGeneratorParent(commonAncestor);\n      invariant(commonAncestor !== undefined, \"there must always be an active body for the common generator ancestor\");\n    }\n\n    // So we have a (common ancestor) body now.\n    invariant(body !== undefined, \"there must always be an active body\");\n\n    // However, there's a potential problem: That body might belong to a generator\n    // which has nested generators that are currently being processed (they are not \"done\" yet).\n    // This becomes a problem when the value for which we are trying to determine the target body\n    // depends on other values which are only declared in such not-yet-done nested generator!\n    // So we find all such not-yet-done bodies here, and pick a most nested one\n    // which is related to one of the scopes this value is used by.\n    let notYetDoneBodies = new Set();\n    this.emitter.dependenciesVisitor(val, {\n      onArrayWithWidenedNumericProperty: dependency => {\n        if (trace) {\n          console.log(\n            `  depending on unknown array with numeric properties and an identifier ${dependency.intrinsicName || \"?\"}`\n          );\n        }\n        invariant(\n          referencingOnlyOptimizedFunction === undefined || this.emitter.emittingToAdditionalFunction(),\n          \"additional function inconsistency\"\n        );\n        let declarationBody = this.emitter.getDeclarationBody(dependency);\n        if (declarationBody !== undefined) {\n          if (trace) console.log(`    has declaration body`);\n          for (let b = declarationBody; b !== undefined; b = b.parentBody) {\n            if (notYetDoneBodies.has(b)) break;\n            notYetDoneBodies.add(b);\n          }\n        }\n      },\n      onAbstractValueWithIdentifier: dependency => {\n        if (trace) console.log(`  depending on abstract value with identifier ${dependency.intrinsicName || \"?\"}`);\n        invariant(\n          referencingOnlyOptimizedFunction === undefined || this.emitter.emittingToAdditionalFunction(),\n          \"additional function inconsistency\"\n        );\n        let declarationBody = this.emitter.getDeclarationBody(dependency);\n        if (declarationBody !== undefined) {\n          if (trace) console.log(`    has declaration body`);\n          for (let b = declarationBody; b !== undefined; b = b.parentBody) {\n            if (notYetDoneBodies.has(b)) break;\n            notYetDoneBodies.add(b);\n          }\n        }\n      },\n    });\n    if (trace) console.log(`  got ${notYetDoneBodies.size} not yet done bodies`);\n    for (let s of generators)\n      for (let g = s; g !== undefined; g = getGeneratorParent(g)) {\n        let scopeBody = this._getActiveBodyOfGenerator(g);\n        if (\n          scopeBody !== undefined &&\n          (scopeBody.nestingLevel || 0) > (body.nestingLevel || 0) &&\n          notYetDoneBodies.has(scopeBody)\n        ) {\n          // TODO: If there are multiple such scopeBody's, why is it okay to pick an arbitrary one?\n          body = scopeBody;\n          break;\n        }\n      }\n\n    return { body, commonAncestor };\n  }\n\n  _getValueDebugName(val: Value): string {\n    let name;\n    if (val instanceof FunctionValue) {\n      name = val.getName();\n    } else {\n      const id = this.residualHeapValueIdentifiers.getIdentifier(val);\n      invariant(id);\n      name = id.name;\n    }\n    return name;\n  }\n\n  serializeBinding(binding: Binding): BabelNodeIdentifier | BabelNodeMemberExpression {\n    let record = binding.environment;\n    invariant(record instanceof DeclarativeEnvironmentRecord, \"only declarative environments has bindings\");\n\n    let residualFunctionBindings = this.declarativeEnvironmentRecordsBindings.get(record);\n    invariant(\n      residualFunctionBindings,\n      \"all bindings that create abstract values must have at least one call emitted to the generator so the function environment should have been visited\"\n    );\n    let residualBinding = residualFunctionBindings.get(binding.name);\n    invariant(residualBinding, \"any referenced residual binding should have been visited\");\n\n    this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);\n\n    let location = residualBinding.serializedUnscopedLocation;\n    invariant(location !== undefined);\n    return location;\n  }\n\n  getPrelude(additionalFunction: void | FunctionValue): Array<BabelNodeStatement> {\n    if (additionalFunction !== undefined) {\n      let body = this.residualFunctions.additionalFunctionPreludes.get(additionalFunction);\n      invariant(body !== undefined);\n      return body;\n    } else {\n      return this.prelude;\n    }\n  }\n\n  _declare(\n    emittingToResidualFunction: boolean,\n    referencingOnlyOptimizedFunction: void | FunctionValue,\n    bindingType: BabelVariableKind,\n    id: BabelNodeLVal,\n    init: BabelNodeExpression\n  ): void {\n    if (emittingToResidualFunction) {\n      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id)]);\n      this.getPrelude(referencingOnlyOptimizedFunction).push(declar);\n      let assignment = t.expressionStatement(t.assignmentExpression(\"=\", id, init));\n      this.emitter.emit(assignment);\n    } else {\n      let declar = t.variableDeclaration(bindingType, [t.variableDeclarator(id, init)]);\n      this.emitter.emit(declar);\n    }\n  }\n\n  serializeValue(val: Value, referenceOnly?: boolean, bindingType?: BabelVariableKind): BabelNodeExpression {\n    invariant(!(val instanceof ObjectValue && val.refuseSerialization));\n    if (val instanceof AbstractValue) {\n      if (val.kind === \"widened\") {\n        this.serializedValues.add(val);\n        let name = val.intrinsicName;\n        invariant(name !== undefined);\n        return t.identifier(name);\n      } else if (val.kind === \"widened property\") {\n        this.serializedValues.add(val);\n        return this._serializeAbstractValueHelper(val);\n      }\n    }\n\n    // make sure we're not serializing a class method here\n    if (val instanceof ECMAScriptSourceFunctionValue && this.residualClassMethodInstances.has(val)) {\n      let classMethodInstance = this.residualClassMethodInstances.get(val);\n      invariant(classMethodInstance);\n      // anything other than a class constructor should never go through serializeValue()\n      // so we need to log a nice error message to the user\n      if (classMethodInstance.methodType !== \"constructor\") {\n        let error = new CompilerDiagnostic(\n          \"a class method incorrectly went through the serializeValue() code path\",\n          val.$ECMAScriptCode.loc,\n          \"PP0022\",\n          \"FatalError\"\n        );\n        this.realm.handleError(error);\n        throw new FatalError();\n      }\n    }\n\n    if (this._serializedValueWithIdentifiers.has(val)) {\n      return this.getSerializeObjectIdentifier(val);\n    }\n\n    this.serializedValues.add(val);\n    if (!referenceOnly && HeapInspector.isLeaf(val)) {\n      let res = this._serializeValue(val);\n      invariant(res !== undefined);\n      return res;\n    }\n    this._serializedValueWithIdentifiers.add(val);\n\n    let target = this._getTarget(val);\n    let oldBody = this.emitter.beginEmitting(val, target.body);\n    let init = this._serializeValue(val);\n\n    let id = this.residualHeapValueIdentifiers.getIdentifier(val);\n    if (this._options.debugIdentifiers !== undefined && this._options.debugIdentifiers.includes(id.name)) {\n      console.log(`Tracing value with identifier ${id.name} (${val.constructor.name}) targetting ${target.body.type}`);\n      this._getTarget(val, true);\n    }\n    let result = id;\n    this.residualHeapValueIdentifiers.incrementReferenceCount(val);\n\n    if (this.residualHeapValueIdentifiers.needsIdentifier(val)) {\n      if (init) {\n        if (this._options.debugScopes) {\n          let scopes = this.residualValues.get(val);\n          invariant(scopes !== undefined);\n          const scopeList = Array.from(scopes)\n            .map(s => `\"${s.getName()}\"`)\n            .join(\",\");\n          let comment = `${this._getValueDebugName(val)} referenced from scopes [${scopeList}]`;\n          if (target.commonAncestor !== undefined)\n            comment = `${comment} with common ancestor: ${target.commonAncestor.getName()}`;\n          if (target.description !== undefined) comment = `${comment} => ${target.description} `;\n          this.emitter.emit(commentStatement(comment));\n        }\n        if (init !== id) {\n          this._declare(\n            !!target.usedOnlyByResidualFunctions,\n            target.referencingOnlyOptimizedFunction,\n            bindingType || \"var\",\n            id,\n            init\n          );\n        }\n        this.getStatistics().valueIds++;\n        if (target.usedOnlyByResidualFunctions) this.getStatistics().delayedValues++;\n      }\n    } else {\n      if (init) {\n        this.residualHeapValueIdentifiers.deleteIdentifier(val);\n        result = init;\n        this.getStatistics().valuesInlined++;\n      }\n    }\n\n    this.emitter.endEmitting(val, oldBody);\n    return result;\n  }\n\n  _serializeValueIntrinsic(val: Value): BabelNodeExpression {\n    let intrinsicName = val.intrinsicName;\n    invariant(intrinsicName);\n    if (val instanceof ObjectValue && val.intrinsicNameGenerated) {\n      // The intrinsic was generated at a particular point in time.\n      return this.preludeGenerator.convertStringToMember(intrinsicName);\n    } else {\n      // The intrinsic conceptually exists ahead of time.\n      invariant(\n        this.emitter.getBody().type === \"MainGenerator\" ||\n          this.emitter.getBody().type === \"AdditionalFunction\" ||\n          this.emitter.getBody().type === \"DelayInitializations\"\n      );\n      return this.preludeGenerator.memoizeReference(intrinsicName);\n    }\n  }\n\n  _getDescriptorValues(desc: Descriptor): Array<Value> {\n    if (desc.joinCondition !== undefined) return [desc.joinCondition];\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) return [desc.value];\n    invariant(desc.get !== undefined);\n    invariant(desc.set !== undefined);\n    return [desc.get, desc.set];\n  }\n\n  _deleteProperty(location: BabelNodeLVal): void {\n    invariant(location.type === \"MemberExpression\");\n    this.emitter.emit(\n      t.expressionStatement(t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true))\n    );\n  }\n\n  _assignProperty(\n    location: BabelNodeLVal,\n    value: Value,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): void {\n    this.emitter.emit(\n      this._getPropertyAssignmentStatement(location, value, mightHaveBeenDeleted, deleteIfMightHaveBeenDeleted)\n    );\n  }\n\n  _getPropertyAssignmentStatement(\n    location: BabelNodeLVal,\n    value: Value,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean = false\n  ): BabelNodeStatement {\n    if (mightHaveBeenDeleted) {\n      // We always need to serialize this value in order to keep the invariants happy.\n      let serializedValue = this.serializeValue(value);\n      let condition;\n      if (value instanceof AbstractValue && value.kind === \"conditional\") {\n        let [c, x, y] = value.args;\n        if (x instanceof EmptyValue) {\n          if (c instanceof AbstractValue && c.kind === \"!\") condition = this.serializeValue(c.args[0]);\n          else condition = t.unaryExpression(\"!\", this.serializeValue(c));\n          serializedValue = this.serializeValue(y);\n        } else if (y instanceof EmptyValue) {\n          condition = this.serializeValue(c);\n          serializedValue = this.serializeValue(x);\n        }\n      }\n      if (condition === undefined) {\n        condition = t.binaryExpression(\"!==\", this.serializeValue(value), this._serializeEmptyValue());\n      }\n      let assignment = t.expressionStatement(t.assignmentExpression(\"=\", location, serializedValue));\n      let deletion = null;\n      if (deleteIfMightHaveBeenDeleted) {\n        invariant(location.type === \"MemberExpression\");\n        deletion = t.expressionStatement(\n          t.unaryExpression(\"delete\", ((location: any): BabelNodeMemberExpression), true)\n        );\n      }\n      return t.ifStatement(condition, assignment, deletion);\n    } else {\n      return t.expressionStatement(t.assignmentExpression(\"=\", location, this.serializeValue(value)));\n    }\n  }\n\n  _serializeArrayIndexProperties(\n    array: ObjectValue,\n    indexPropertyLength: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ): Array<null | BabelNodeExpression | BabelNodeSpreadElement> {\n    let elems = [];\n    for (let i = 0; i < indexPropertyLength; i++) {\n      let key = i + \"\";\n      let propertyBinding = remainingProperties.get(key);\n      let elem = null;\n      // \"propertyBinding === undefined\" means array has a hole in the middle.\n      if (propertyBinding !== undefined) {\n        let descriptor = propertyBinding.descriptor;\n        // \"descriptor === undefined\" means this array item has been deleted.\n        if (\n          descriptor !== undefined &&\n          descriptor.value !== undefined &&\n          this._canEmbedProperty(array, key, descriptor)\n        ) {\n          let elemVal = descriptor.value;\n          invariant(elemVal instanceof Value);\n          let mightHaveBeenDeleted = elemVal.mightHaveBeenDeleted();\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(elemVal) ||\n            this.emitter.getReasonToWaitForActiveValue(array, mightHaveBeenDeleted);\n          if (!delayReason) {\n            elem = this.serializeValue(elemVal);\n            remainingProperties.delete(key);\n          }\n        }\n      }\n      elems.push(elem);\n    }\n    return elems;\n  }\n\n  _serializeArrayLengthIfNeeded(\n    val: ObjectValue,\n    numberOfIndexProperties: number,\n    remainingProperties: Map<string, PropertyBinding>\n  ): void {\n    const realm = this.realm;\n    let lenProperty;\n    if (val.mightBeHavocedObject()) {\n      lenProperty = this.realm.evaluateWithoutLeakLogic(() => Get(realm, val, \"length\"));\n    } else {\n      lenProperty = Get(realm, val, \"length\");\n    }\n    // Need to serialize length property if:\n    // 1. array length is abstract.\n    // 2. array length is concrete, but different from number of index properties\n    //  we put into initialization list.\n    if (lenProperty instanceof AbstractValue || To.ToLength(realm, lenProperty) !== numberOfIndexProperties) {\n      if (!(lenProperty instanceof AbstractValue) || lenProperty.kind !== \"widened property\") {\n        let semaphore = this._acquireOneObjectSemaphore(val);\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          [val, lenProperty],\n          () => {\n            this._assignProperty(\n              t.memberExpression(this.getSerializeObjectIdentifier(val), t.identifier(\"length\")),\n              lenProperty,\n              false /*mightHaveBeenDeleted*/\n            );\n            if (semaphore !== undefined) semaphore.releaseOne();\n          },\n          this.emitter.getBody()\n        );\n      }\n      remainingProperties.delete(\"length\");\n    }\n  }\n\n  _serializeValueArray(val: ObjectValue): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n\n    let [unconditionalLength, assignmentNotNeeded] = getSuggestedArrayLiteralLength(this.realm, val);\n    // Use the unconditional serialized index properties as array initialization list.\n    const initProperties = this._serializeArrayIndexProperties(val, unconditionalLength, remainingProperties);\n    if (!assignmentNotNeeded) this._serializeArrayLengthIfNeeded(val, unconditionalLength, remainingProperties);\n    this._emitObjectProperties(val, remainingProperties);\n    return t.arrayExpression(initProperties);\n  }\n\n  _serializeValueMap(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    let omitDeadEntries;\n\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n      omitDeadEntries = false;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n      omitDeadEntries = true;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let mapConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined || (omitDeadEntries && !this.residualValues.has(key))) continue;\n      let mightHaveBeenDeleted = key.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(key) ||\n        this.emitter.getReasonToWaitForDependencies(value) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || mapConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(\n          delayReason,\n          [key, value, val],\n          () => {\n            invariant(key !== undefined);\n            invariant(value !== undefined);\n            this.emitter.emit(\n              t.expressionStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                    t.identifier(\"set\")\n                  ),\n                  [this.serializeValue(key), this.serializeValue(value)]\n                )\n              )\n            );\n          },\n          this.emitter.getBody()\n        );\n      } else {\n        let serializedKey = this.serializeValue(key);\n        let serializedValue = this.serializeValue(value);\n        let elem = t.arrayExpression([serializedKey, serializedValue]);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueSet(val: ObjectValue): BabelNodeExpression {\n    let kind = val.getKind();\n    let elems = [];\n\n    let entries;\n    let omitDeadEntries;\n\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n      omitDeadEntries = false;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n      omitDeadEntries = true;\n    }\n\n    invariant(entries !== undefined);\n    let len = entries.length;\n    let setConstructorDoesntTakeArguments = this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION);\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined || (omitDeadEntries && !this.residualValues.has(entry))) continue;\n      let mightHaveBeenDeleted = entry.mightHaveBeenDeleted();\n      let delayReason =\n        this.emitter.getReasonToWaitForDependencies(entry) ||\n        this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted || setConstructorDoesntTakeArguments);\n      if (delayReason) {\n        this.emitter.emitAfterWaiting(\n          delayReason,\n          [entry, val],\n          () => {\n            invariant(entry !== undefined);\n            this.emitter.emit(\n              t.expressionStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    this.residualHeapValueIdentifiers.getIdentifierAndIncrementReferenceCount(val),\n                    t.identifier(\"add\")\n                  ),\n                  [this.serializeValue(entry)]\n                )\n              )\n            );\n          },\n          this.emitter.getBody()\n        );\n      } else {\n        let elem = this.serializeValue(entry);\n        elems.push(elem);\n      }\n    }\n\n    this._emitObjectProperties(val);\n    let args = elems.length > 0 ? [t.arrayExpression(elems)] : [];\n    return t.newExpression(this.preludeGenerator.memoizeReference(kind), args);\n  }\n\n  _serializeValueTypedArrayOrDataView(val: ObjectValue): BabelNodeExpression {\n    let buf = val.$ViewedArrayBuffer;\n    invariant(buf !== undefined);\n    let outlinedArrayBuffer = this.serializeValue(buf, true);\n    this._emitObjectProperties(val);\n    return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [outlinedArrayBuffer]);\n  }\n\n  _serializeValueArrayBuffer(val: ObjectValue): BabelNodeExpression {\n    let elems = [];\n\n    let len = val.$ArrayBufferByteLength;\n    let db = val.$ArrayBufferData;\n    invariant(len !== undefined);\n    invariant(db);\n    let allzero = true;\n    for (let i = 0; i < len; i++) {\n      if (db[i] !== 0) {\n        allzero = false;\n      }\n      let elem = t.numericLiteral(db[i]);\n      elems.push(elem);\n    }\n\n    this._emitObjectProperties(val);\n    if (allzero) {\n      // if they're all zero, just emit the array buffer constructor\n      return t.newExpression(this.preludeGenerator.memoizeReference(val.getKind()), [t.numericLiteral(len)]);\n    } else {\n      // initialize from a byte array otherwise\n      let arrayValue = t.arrayExpression(elems);\n      let consExpr = t.newExpression(this.preludeGenerator.memoizeReference(\"Uint8Array\"), [arrayValue]);\n      // access the Uint8Array.buffer property to extract the created buffer\n      return t.memberExpression(consExpr, t.identifier(\"buffer\"));\n    }\n  }\n\n  _serializeValueFunction(val: FunctionValue): void | BabelNodeExpression {\n    if (val instanceof BoundFunctionValue) {\n      this._emitObjectProperties(val);\n      return t.callExpression(\n        t.memberExpression(this.serializeValue(val.$BoundTargetFunction), t.identifier(\"bind\")),\n        [].concat(\n          this.serializeValue(val.$BoundThis),\n          val.$BoundArguments.map((boundArg, i) => this.serializeValue(boundArg))\n        )\n      );\n    }\n\n    invariant(!(val instanceof NativeFunctionValue), \"all native function values should be intrinsics\");\n    invariant(val instanceof ECMAScriptSourceFunctionValue);\n\n    let instance = this.residualFunctionInstances.get(val);\n    invariant(instance !== undefined);\n    let residualBindings = instance.residualFunctionBindings;\n\n    let inOptimizedFunction = this.tryGetOptimizedFunctionRoot(val);\n    if (inOptimizedFunction !== undefined) instance.containingAdditionalFunction = inOptimizedFunction;\n    let bindingsEmittedSemaphore = new CountingSemaphore(() => {\n      invariant(instance);\n      // hoist if we are in an additionalFunction\n      if (inOptimizedFunction !== undefined && canHoistFunction(this.realm, val, undefined, new Set())) {\n        instance.insertionPoint = new BodyReference(this.mainBody, this.mainBody.entries.length);\n        instance.containingAdditionalFunction = undefined;\n      } else {\n        instance.insertionPoint = this.emitter.getBodyReference();\n      }\n    });\n\n    for (let [boundName, residualBinding] of residualBindings) {\n      let referencedValues = [];\n      let serializeBindingFunc;\n      if (!residualBinding.declarativeEnvironmentRecord) {\n        serializeBindingFunc = () => this._serializeGlobalBinding(boundName, residualBinding);\n      } else {\n        serializeBindingFunc = () => this._serializeDeclarativeEnvironmentRecordBinding(residualBinding);\n        if (residualBinding.value !== undefined) referencedValues.push(residualBinding.value);\n      }\n      bindingsEmittedSemaphore.acquireOne();\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        referencedValues,\n        () => {\n          serializeBindingFunc();\n          bindingsEmittedSemaphore.releaseOne();\n        },\n        this.emitter.getBody()\n      );\n    }\n    if (val.$FunctionKind === \"classConstructor\") {\n      let homeObject = val.$HomeObject;\n      if (homeObject instanceof ObjectValue && homeObject.$IsClassPrototype) {\n        this._serializeClass(val, homeObject, bindingsEmittedSemaphore);\n        return;\n      }\n    }\n    bindingsEmittedSemaphore.releaseOne();\n    this._emitObjectProperties(val);\n    let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n    let additionalEffects = additionalFVEffects && additionalFVEffects.get(val);\n    if (additionalEffects) this._serializeAdditionalFunction(val, additionalEffects);\n  }\n\n  _serializeClass(\n    classFunc: ECMAScriptSourceFunctionValue,\n    classPrototype: ObjectValue,\n    bindingsEmittedSemaphore: CountingSemaphore\n  ): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(classFunc);\n\n    invariant(classMethodInstance !== undefined);\n\n    let classProtoId;\n    let hasSerializedClassProtoId = false;\n    let propertiesToSerialize = new Map();\n\n    // handle class inheritance\n    if (!(classFunc.$Prototype instanceof NativeFunctionValue)) {\n      classMethodInstance.classSuperNode = this.serializeValue(classFunc.$Prototype);\n    }\n\n    let serializeClassPrototypeId = () => {\n      if (!hasSerializedClassProtoId) {\n        let classId = this.getSerializeObjectIdentifier(classFunc);\n        classProtoId = t.identifier(this.intrinsicNameGenerator.generate());\n        hasSerializedClassProtoId = true;\n        this.emitter.emit(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(classProtoId, t.memberExpression(classId, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    let serializeClassMethodOrProperty = (propertyNameOrSymbol, methodFuncOrProperty) => {\n      const serializeNameAndId = () => {\n        let methodFuncOrPropertyId = this.serializeValue(methodFuncOrProperty);\n        let name;\n\n        if (typeof propertyNameOrSymbol === \"string\") {\n          name = t.identifier(propertyNameOrSymbol);\n        } else {\n          name = this.serializeValue(propertyNameOrSymbol);\n        }\n        return { name, methodFuncOrPropertyId };\n      };\n\n      if (methodFuncOrProperty instanceof ECMAScriptSourceFunctionValue) {\n        if (methodFuncOrProperty !== classFunc) {\n          // if the method does not have a $HomeObject, it's not a class method\n          if (methodFuncOrProperty.$HomeObject !== undefined) {\n            this.serializedValues.add(methodFuncOrProperty);\n            this._serializeClassMethod(propertyNameOrSymbol, methodFuncOrProperty);\n          } else {\n            // if the method is not part of the class, we have to assign it to the prototype\n            // we can't serialize via emitting the properties as that will emit all\n            // the prototype and we only want to mutate the prototype here\n            serializeClassPrototypeId();\n            invariant(classProtoId !== undefined);\n            let { name, methodFuncOrPropertyId } = serializeNameAndId();\n            this.emitter.emit(\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", t.memberExpression(classProtoId, name), methodFuncOrPropertyId)\n              )\n            );\n          }\n        }\n      } else {\n        let prototypeId = t.memberExpression(this.getSerializeObjectIdentifier(classFunc), t.identifier(\"prototype\"));\n        let { name, methodFuncOrPropertyId } = serializeNameAndId();\n        this.emitter.emit(\n          t.expressionStatement(\n            t.assignmentExpression(\"=\", t.memberExpression(prototypeId, name), methodFuncOrPropertyId)\n          )\n        );\n      }\n    };\n\n    let serializeClassProperty = (propertyNameOrSymbol, propertyValue) => {\n      // we handle the prototype via class syntax\n      if (propertyNameOrSymbol === \"prototype\") {\n        this.serializedValues.add(propertyValue);\n      } else if (propertyValue instanceof ECMAScriptSourceFunctionValue && propertyValue.$HomeObject === classFunc) {\n        serializeClassMethodOrProperty(propertyNameOrSymbol, propertyValue);\n      } else {\n        let prop = classFunc.properties.get(propertyNameOrSymbol);\n        invariant(prop);\n        propertiesToSerialize.set(propertyNameOrSymbol, prop);\n      }\n    };\n\n    // find the all the properties on the class that we need to serialize\n    for (let [propertyName, method] of classFunc.properties) {\n      if (\n        !this.residualHeapInspector.canIgnoreProperty(classFunc, propertyName) &&\n        !ClassPropertiesToIgnore.has(propertyName) &&\n        method.descriptor !== undefined &&\n        !(propertyName === \"length\" && canIgnoreClassLengthProperty(classFunc, method.descriptor, this.logger))\n      ) {\n        withDescriptorValue(propertyName, method.descriptor, serializeClassProperty);\n      }\n    }\n    // pass in the properties and set it so we don't serialize the prototype\n    bindingsEmittedSemaphore.releaseOne();\n    this._emitObjectProperties(classFunc, propertiesToSerialize, undefined, undefined, true);\n\n    // handle non-symbol properties\n    for (let [propertyName, method] of classPrototype.properties) {\n      withDescriptorValue(propertyName, method.descriptor, serializeClassMethodOrProperty);\n    }\n    // handle symbol properties\n    for (let [symbol, method] of classPrototype.symbols) {\n      withDescriptorValue(symbol, method.descriptor, serializeClassMethodOrProperty);\n    }\n    // assign the AST method key node for the \"constructor\"\n    classMethodInstance.classMethodKeyNode = t.identifier(\"constructor\");\n  }\n\n  _serializeClassMethod(key: string | SymbolValue, methodFunc: ECMAScriptSourceFunctionValue): void {\n    let classMethodInstance = this.residualClassMethodInstances.get(methodFunc);\n\n    invariant(classMethodInstance !== undefined);\n    if (typeof key === \"string\") {\n      classMethodInstance.classMethodKeyNode = t.identifier(key);\n      // as we know the method name is a string again, we can remove the computed status\n      classMethodInstance.classMethodComputed = false;\n    } else if (key instanceof SymbolValue) {\n      classMethodInstance.classMethodKeyNode = this.serializeValue(key);\n    } else {\n      invariant(false, \"Unknown method key type\");\n    }\n    this._serializeValueFunction(methodFunc);\n  }\n\n  // Checks whether a property can be defined via simple assignment, or using object literal syntax.\n  _canEmbedProperty(obj: ObjectValue, key: string | SymbolValue | AbstractValue, prop: Descriptor): boolean {\n    if (prop.joinCondition !== undefined) return false;\n\n    let targetDescriptor = this.residualHeapInspector.getTargetIntegrityDescriptor(obj);\n\n    if ((obj instanceof FunctionValue && key === \"prototype\") || (obj.getKind() === \"RegExp\" && key === \"lastIndex\"))\n      return (\n        prop.writable === targetDescriptor.writable && !prop.configurable && !prop.enumerable && !prop.set && !prop.get\n      );\n    else if (\n      prop.writable === targetDescriptor.writable &&\n      prop.configurable === targetDescriptor.configurable &&\n      !!prop.enumerable &&\n      !prop.set &&\n      !prop.get\n    ) {\n      return !(prop.value instanceof AbstractValue && prop.value.kind === \"widened property\");\n    } else {\n      return false;\n    }\n  }\n\n  _findLastObjectPrototype(obj: ObjectValue): ObjectValue {\n    while (obj.$Prototype instanceof ObjectValue) obj = obj.$Prototype;\n    return obj;\n  }\n\n  _serializeValueRegExpObject(val: ObjectValue): BabelNodeExpression {\n    let source = val.$OriginalSource;\n    let flags = val.$OriginalFlags;\n    invariant(typeof source === \"string\");\n    invariant(typeof flags === \"string\");\n    this._emitObjectProperties(val);\n    source = new RegExp(source).source; // add escapes as per 21.2.3.2.4\n    return t.regExpLiteral(source, flags);\n  }\n\n  // Overridable.\n  serializeValueRawObject(\n    val: ObjectValue,\n    skipPrototype: boolean,\n    emitIntegrityCommand: void | (SerializedBody => void)\n  ): BabelNodeExpression {\n    let remainingProperties = new Map(val.properties);\n    const dummyProperties = new Set();\n    let props = [];\n    if (val.temporalAlias !== undefined) {\n      return t.objectExpression(props);\n    } else {\n      for (let [key, propertyBinding] of val.properties) {\n        if (propertyBinding.pathNode !== undefined) continue; // written to inside loop\n        let descriptor = propertyBinding.descriptor;\n        if (descriptor === undefined || descriptor.value === undefined) continue; // deleted\n        let serializedKey = getAsPropertyNameExpression(key);\n        if (this._canEmbedProperty(val, key, descriptor)) {\n          let propValue = descriptor.value;\n          invariant(propValue instanceof Value);\n          if (this.residualHeapInspector.canIgnoreProperty(val, key)) continue;\n          let mightHaveBeenDeleted = propValue.mightHaveBeenDeleted();\n          let delayReason =\n            this.emitter.getReasonToWaitForDependencies(propValue) ||\n            this.emitter.getReasonToWaitForActiveValue(val, mightHaveBeenDeleted);\n          // Although the property needs to be delayed, we still want to emit dummy \"undefined\"\n          // value as part of the object literal to ensure a consistent property ordering.\n          let serializedValue = voidExpression;\n          if (delayReason) {\n            // May need to be cleaned up later.\n            dummyProperties.add(key);\n          } else {\n            remainingProperties.delete(key);\n            serializedValue = this.serializeValue(propValue);\n          }\n          props.push(t.objectProperty(serializedKey, serializedValue));\n        } else if (descriptor.value instanceof Value && descriptor.value.mightHaveBeenDeleted()) {\n          dummyProperties.add(key);\n          props.push(t.objectProperty(serializedKey, voidExpression));\n        }\n      }\n    }\n    this._emitObjectProperties(\n      val,\n      remainingProperties,\n      /*objectPrototypeAlreadyEstablished*/ false,\n      dummyProperties,\n      skipPrototype\n    );\n    return t.objectExpression(props);\n  }\n\n  _serializeValueObjectViaConstructor(\n    val: ObjectValue,\n    skipPrototype: boolean,\n    classConstructor?: Value\n  ): BabelNodeExpression {\n    let proto = val.$Prototype;\n    this._emitObjectProperties(\n      val,\n      val.properties,\n      /*objectPrototypeAlreadyEstablished*/ true,\n      undefined,\n      skipPrototype\n    );\n    let serializedProto = this.serializeValue(classConstructor ? classConstructor : proto);\n    if (val.temporalAlias === undefined) {\n      this.needsAuxiliaryConstructor = true;\n      return t.sequenceExpression([\n        t.assignmentExpression(\n          \"=\",\n          t.memberExpression(constructorExpression, t.identifier(\"prototype\")),\n          classConstructor ? t.memberExpression(serializedProto, t.identifier(\"prototype\")) : serializedProto\n        ),\n        t.newExpression(constructorExpression, []),\n      ]);\n    } else {\n      this.emitter.emitAfterWaiting(\n        val.temporalAlias,\n        [],\n        () => {\n          invariant(val.temporalAlias !== undefined);\n          let uid = this.serializeValue(val.temporalAlias);\n          this.emitter.emit(\n            t.expressionStatement(\n              t.callExpression(this.preludeGenerator.memoizeReference(\"Object.setPrototypeOf\"), [uid, serializedProto])\n            )\n          );\n        },\n        this.emitter.getBody()\n      );\n      return t.objectExpression([]);\n    }\n  }\n\n  serializeValueObject(\n    val: ObjectValue,\n    emitIntegrityCommand: void | (SerializedBody => void)\n  ): BabelNodeExpression | void {\n    // If this object is a prototype object that was implicitly created by the runtime\n    // for a constructor, then we can obtain a reference to this object\n    // in a special way that's handled alongside function serialization.\n    let constructor = val.originalConstructor;\n    if (constructor !== undefined) {\n      let prototypeId = this.residualHeapValueIdentifiers.getIdentifier(val);\n      this.emitter.emitNowOrAfterWaitingForDependencies(\n        [constructor],\n        () => {\n          invariant(constructor !== undefined);\n          invariant(prototypeId !== undefined);\n          this.serializeValue(constructor);\n          this._emitObjectProperties(val);\n          invariant(prototypeId.type === \"Identifier\");\n          this.residualFunctions.setFunctionPrototype(constructor, prototypeId);\n        },\n        this.emitter.getBody()\n      );\n      return prototypeId;\n    }\n\n    let kind = val.getKind();\n    switch (kind) {\n      case \"RegExp\":\n        return this._serializeValueRegExpObject(val);\n      case \"Number\":\n        let numberData = val.$NumberData;\n        invariant(numberData !== undefined);\n        numberData.throwIfNotConcreteNumber();\n        invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Number\"), [t.numericLiteral(numberData.value)]);\n      case \"String\":\n        let stringData = val.$StringData;\n        invariant(stringData !== undefined);\n        stringData.throwIfNotConcreteString();\n        invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"String\"), [t.stringLiteral(stringData.value)]);\n      case \"Boolean\":\n        let booleanData = val.$BooleanData;\n        invariant(booleanData !== undefined);\n        booleanData.throwIfNotConcreteBoolean();\n        invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Boolean\"), [\n          t.booleanLiteral(booleanData.value),\n        ]);\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        let serializedDateValue = this.serializeValue(dateValue);\n        this._emitObjectProperties(val);\n        return t.newExpression(this.preludeGenerator.memoizeReference(\"Date\"), [serializedDateValue]);\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        return this._serializeValueTypedArrayOrDataView(val);\n      case \"ArrayBuffer\":\n        return this._serializeValueArrayBuffer(val);\n      case \"ReactElement\":\n        this.residualReactElementSerializer.serializeReactElement(val);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        return this._serializeValueMap(val);\n      case \"Set\":\n      case \"WeakSet\":\n        return this._serializeValueSet(val);\n      default:\n        invariant(kind === \"Object\", \"invariant established by visitor\");\n\n        let proto = val.$Prototype;\n        let { skipPrototype, constructor: _constructor } = getObjectPrototypeMetadata(this.realm, val);\n        let createViaAuxiliaryConstructor =\n          val.temporalAlias === undefined &&\n          proto !== this.realm.intrinsics.ObjectPrototype &&\n          this._findLastObjectPrototype(val) === this.realm.intrinsics.ObjectPrototype &&\n          proto instanceof ObjectValue &&\n          !skipPrototype;\n\n        return createViaAuxiliaryConstructor || _constructor\n          ? this._serializeValueObjectViaConstructor(val, skipPrototype, _constructor)\n          : this.serializeValueRawObject(val, skipPrototype, emitIntegrityCommand);\n    }\n  }\n\n  _serializeValueSymbol(val: SymbolValue): BabelNodeExpression {\n    let args = [];\n    if (val.$Description instanceof Value) {\n      let serializedArg = this.serializeValue(val.$Description);\n      invariant(serializedArg);\n      args.push(serializedArg);\n    }\n    // check if symbol value exists in the global symbol map, in that case we emit an invocation of System.for\n    // to look it up\n    let globalReg = this.realm.globalSymbolRegistry.find(e => e.$Symbol === val) !== undefined;\n    if (globalReg) {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol.for\"), args);\n    } else {\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Symbol\"), args);\n    }\n  }\n\n  _serializeValueProxy(val: ProxyValue): BabelNodeExpression {\n    return t.newExpression(this.preludeGenerator.memoizeReference(\"Proxy\"), [\n      this.serializeValue(val.$ProxyTarget),\n      this.serializeValue(val.$ProxyHandler),\n    ]);\n  }\n\n  _serializeAbstractValueHelper(val: AbstractValue): BabelNodeExpression {\n    let serializedArgs = val.args.map((abstractArg, i) => this.serializeValue(abstractArg));\n    if (val.kind === \"abstractConcreteUnion\") {\n      let abstractIndex = val.args.findIndex(v => v instanceof AbstractValue);\n      invariant(abstractIndex >= 0 && abstractIndex < val.args.length);\n      return serializedArgs[abstractIndex];\n    }\n    if (val.kind === \"explicit conversion to object\") {\n      let ob = serializedArgs[0];\n      invariant(ob !== undefined);\n      return t.callExpression(this.preludeGenerator.memoizeReference(\"Object.assign\"), [ob]);\n    } else if (val.kind === \"template for prototype member expression\") {\n      let obj = this.serializeValue(val.args[0]);\n      let prop = this.serializeValue(val.args[1]);\n      return t.memberExpression(obj, prop, true);\n    }\n    let serializedValue = val.buildNode(serializedArgs);\n    if (serializedValue.type === \"Identifier\") {\n      let id = ((serializedValue: any): BabelNodeIdentifier);\n      invariant(\n        !this.realm.derivedIds.has(id.name) ||\n          this.emitter.cannotDeclare() ||\n          this.emitter.hasBeenDeclared(val) ||\n          (this.emitter.emittingToAdditionalFunction() && this.referencedDeclaredValues.get(val) === undefined),\n        `an abstract value with an identifier \"${id.name}\" was referenced before being declared`\n      );\n    }\n    return serializedValue;\n  }\n\n  _serializeAbstractValue(val: AbstractValue): void | BabelNodeExpression {\n    invariant(val.kind !== \"sentinel member expression\", \"invariant established by visitor\");\n    if (val.kind === \"conditional\") {\n      let cf = this.conditionalFeasibility.get(val);\n      invariant(cf !== undefined);\n      if (cf.t && !cf.f) return this.serializeValue(val.args[1]);\n      else if (!cf.t && cf.f) return this.serializeValue(val.args[2]);\n      else invariant(cf.t && cf.f);\n    }\n    if (val.hasIdentifier()) {\n      return this._serializeAbstractValueHelper(val);\n    } else {\n      // This abstract value's dependencies should all be declared\n      // but still need to check them again in case their serialized bodies are in different generator scope.\n      let reason = this.emitter.getReasonToWaitForDependencies(val.args);\n      if (reason === undefined) {\n        return this._serializeAbstractValueHelper(val);\n      } else {\n        this.emitter.emitAfterWaiting(\n          reason,\n          val.args,\n          () => {\n            const serializedValue = this._serializeAbstractValueHelper(val);\n            let uid = this.getSerializeObjectIdentifier(val);\n            this._declare(this.emitter.cannotDeclare(), undefined, \"var\", uid, serializedValue);\n          },\n          this.emitter.getBody()\n        );\n      }\n    }\n  }\n\n  _serializeEmptyValue(): BabelNodeExpression {\n    this.needsEmptyVar = true;\n    return emptyExpression;\n  }\n\n  _serializeValue(val: Value): void | BabelNodeExpression {\n    if (val instanceof AbstractValue) {\n      return this._serializeAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      return this._serializeValueIntrinsic(val);\n    } else if (val instanceof EmptyValue) {\n      return this._serializeEmptyValue();\n    } else if (val instanceof UndefinedValue) {\n      return voidExpression;\n    } else if (HeapInspector.isLeaf(val)) {\n      return t.valueToNode(val.serialize());\n    } else if (val instanceof ObjectValue) {\n      return this._serializeValueObjectBase(val);\n    } else {\n      invariant(val instanceof SymbolValue);\n      return this._serializeValueSymbol(val);\n    }\n  }\n\n  _serializeValueObjectBase(obj: ObjectValue): void | BabelNodeExpression {\n    if (obj instanceof ProxyValue) {\n      return this._serializeValueProxy(obj);\n    }\n\n    let objectSemaphore;\n    let targetCommand = this.residualHeapInspector.getTargetIntegrityCommand(obj);\n    let emitIntegrityCommand;\n    if (targetCommand) {\n      let body = this.emitter.getBody();\n      objectSemaphore = new CountingSemaphore(() => {\n        this.emitter.emitNowOrAfterWaitingForDependencies(\n          [obj],\n          () => {\n            let uid = this.getSerializeObjectIdentifier(obj);\n            this.emitter.emit(\n              t.expressionStatement(\n                t.callExpression(this.preludeGenerator.memoizeReference(\"Object.\" + targetCommand), [uid])\n              )\n            );\n          },\n          body\n        );\n      });\n      this._objectSemaphores.set(obj, objectSemaphore);\n      emitIntegrityCommand = alternateBody => {\n        if (objectSemaphore !== undefined) {\n          if (alternateBody !== undefined) body = alternateBody;\n          objectSemaphore.releaseOne();\n          this._objectSemaphores.delete(obj);\n        }\n        objectSemaphore = undefined;\n      };\n    }\n    let res;\n    if (IsArray(this.realm, obj)) {\n      res = this._serializeValueArray(obj);\n    } else if (obj instanceof FunctionValue) {\n      res = this._serializeValueFunction(obj);\n    } else {\n      res = this.serializeValueObject(obj, emitIntegrityCommand);\n    }\n    if (emitIntegrityCommand !== undefined) emitIntegrityCommand();\n    return res;\n  }\n\n  _serializeGlobalBinding(boundName: string, binding: ResidualFunctionBinding): void {\n    invariant(!binding.declarativeEnvironmentRecord);\n    if (!binding.serializedValue) {\n      binding.referentialized = true;\n      if (boundName === \"undefined\") {\n        binding.serializedValue = voidExpression;\n      } else if (binding.value !== undefined) {\n        binding.serializedValue = t.identifier(boundName);\n        invariant(binding.value !== undefined);\n        this.declaredGlobalLets.set(boundName, binding.value);\n      }\n    }\n  }\n\n  _annotateGeneratorStatements(generator: Generator, statements: Array<BabelNodeStatement>): void {\n    let comment = `generator \"${generator.getName()}\"`;\n    let parent = this.generatorDAG.getParent(generator);\n    if (parent instanceof Generator) {\n      comment = `${comment} with parent \"${parent.getName()}\"`;\n    } else if (parent instanceof FunctionValue) {\n      comment = `${comment} with function parent`;\n    } else {\n      invariant(parent === \"GLOBAL\");\n      comment = `${comment} with global parent`;\n    }\n    let beginComments = [commentStatement(\"begin \" + comment)];\n    let effects = generator.effectsToApply;\n    if (effects) {\n      let valueToString = value =>\n        this.residualHeapValueIdentifiers.hasIdentifier(value)\n          ? this.residualHeapValueIdentifiers.getIdentifier(value).name\n          : \"?\";\n      let keyToString = key => (typeof key === \"string\" ? key : key instanceof Value ? valueToString(key) : \"?\");\n\n      beginComments.push(\n        commentStatement(\n          `  has effects: ${effects.createdObjects.size} created objects, ${\n            effects.modifiedBindings.size\n          } modified bindings, ${effects.modifiedProperties.size} modified properties`\n        )\n      );\n      if (effects.createdObjects.size > 0)\n        beginComments.push(\n          commentStatement(\n            `    created objects: ${Array.from(effects.createdObjects)\n              .map(valueToString)\n              .join(\", \")}`\n          )\n        );\n      if (effects.modifiedBindings.size > 0)\n        beginComments.push(\n          commentStatement(\n            `    modified bindings: ${Array.from(effects.modifiedBindings.keys())\n              .map(b => b.name)\n              .join(\", \")}`\n          )\n        );\n      if (effects.modifiedProperties.size > 0)\n        beginComments.push(\n          commentStatement(\n            `    modified properties: ${Array.from(effects.modifiedProperties.keys())\n              .map(b => `${valueToString(b.object)}.${keyToString(b.key)}`)\n              .join(\", \")}`\n          )\n        );\n    }\n    statements.unshift(...beginComments);\n    statements.push(commentStatement(\"end \" + comment));\n  }\n\n  _withGeneratorScope(\n    type: \"Generator\" | \"AdditionalFunction\",\n    generator: Generator,\n    valuesToProcess: void | Set<AbstractValue | ObjectValue>,\n    callback: SerializedBody => void,\n    isChildOverride?: boolean\n  ): Array<BabelNodeStatement> {\n    let newBody = { type, parentBody: undefined, entries: [], done: false };\n    let isChild = isChildOverride || type === \"Generator\";\n    let oldBody = this.emitter.beginEmitting(generator, newBody, /*isChild*/ isChild);\n    invariant(!this.activeGeneratorBodies.has(generator));\n    this.activeGeneratorBodies.set(generator, newBody);\n    callback(newBody);\n    invariant(this.activeGeneratorBodies.has(generator));\n    this.activeGeneratorBodies.delete(generator);\n    const statements = this.emitter.endEmitting(generator, oldBody, valuesToProcess, /*isChild*/ isChild).entries;\n    if (this._options.debugScopes) this._annotateGeneratorStatements(generator, statements);\n    this.getStatistics().generators++;\n    return statements;\n  }\n\n  _getContext(): SerializationContext {\n    // TODO #482: Values serialized by nested generators would currently only get defined\n    // along the code of the nested generator; their definitions need to get hoisted\n    // or repeated so that they are accessible and defined from all using scopes\n    let context = {\n      serializeValue: this.serializeValue.bind(this),\n      serializeBinding: this.serializeBinding.bind(this),\n      serializeGenerator: (\n        generator: Generator,\n        valuesToProcess: Set<AbstractValue | ObjectValue>\n      ): Array<BabelNodeStatement> =>\n        this._withGeneratorScope(\"Generator\", generator, valuesToProcess, () => generator.serialize(context)),\n      initGenerator: (generator: Generator) => {\n        let activeGeneratorBody = this._getActiveBodyOfGenerator(generator);\n        invariant(activeGeneratorBody === this.emitter.getBody(), \"generator to init must be current emitter body\");\n        let s = this.additionalGeneratorRoots.get(generator);\n        if (s !== undefined) for (let value of s) this.serializeValue(value);\n      },\n      finalizeGenerator: (generator: Generator) => {\n        let activeGeneratorBody = this._getActiveBodyOfGenerator(generator);\n        invariant(activeGeneratorBody === this.emitter.getBody(), \"generator to finalize must be current emitter body\");\n        this.emitter.finalizeCurrentBody();\n      },\n      emit: (statement: BabelNodeStatement) => {\n        this.emitter.emit(statement);\n      },\n      processValues: (valuesToProcess: Set<AbstractValue | ObjectValue>) => {\n        this.emitter.processValues(valuesToProcess);\n      },\n      getPropertyAssignmentStatement: this._getPropertyAssignmentStatement.bind(this),\n      emitDefinePropertyBody: this.emitDefinePropertyBody.bind(this, false, undefined),\n      canOmit: (value: Value) => {\n        let canOmit = !this.referencedDeclaredValues.has(value) && !this.residualValues.has(value);\n        if (!canOmit) {\n          return false;\n        }\n        if (value instanceof ObjectValue && value.temporalAlias !== undefined) {\n          let temporalAlias = value.temporalAlias;\n          return !this.referencedDeclaredValues.has(temporalAlias) && !this.residualValues.has(temporalAlias);\n        }\n        return canOmit;\n      },\n      declare: (value: AbstractValue | ObjectValue) => {\n        this.emitter.declare(value);\n      },\n      emitPropertyModification: (propertyBinding: PropertyBinding) => {\n        let desc = propertyBinding.descriptor;\n        let object = propertyBinding.object;\n        invariant(object instanceof ObjectValue);\n        if (this.residualValues.has(object)) {\n          let key = propertyBinding.key;\n          invariant(key !== undefined, \"established by visitor\");\n          let dependencies = [];\n          if (desc !== undefined) dependencies.push(...this._getDescriptorValues(desc));\n          dependencies.push(object);\n          if (key instanceof Value) dependencies.push(key);\n          this.emitter.emitNowOrAfterWaitingForDependencies(\n            dependencies,\n            () => {\n              // separate serialize object, as _emitProperty assumes that this already happened\n              this.serializeValue(object);\n              this._emitProperty(object, key, desc, true);\n            },\n            this.emitter.getBody()\n          );\n        }\n      },\n      options: this._options,\n    };\n    return context;\n  }\n\n  _shouldBeWrapped(body: Array<any>): boolean {\n    for (let i = 0; i < body.length; i++) {\n      let item = body[i];\n      if (item.type === \"ExpressionStatement\") {\n        continue;\n      } else if (item.type === \"VariableDeclaration\" || item.type === \"FunctionDeclaration\") {\n        return true;\n      } else if (item.type === \"BlockStatement\") {\n        if (this._shouldBeWrapped(item.body)) {\n          return true;\n        }\n      } else if (item.type === \"IfStatement\") {\n        if (item.alternate) {\n          if (this._shouldBeWrapped(item.alternate.body)) {\n            return true;\n          }\n        }\n        if (item.consequent) {\n          if (this._shouldBeWrapped(item.consequent.body)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  _serializeAdditionalFunctionGeneratorAndEffects(\n    generator: Generator,\n    functionValue: FunctionValue,\n    additionalEffects: AdditionalFunctionEffects\n  ): Array<BabelNodeStatement> {\n    let inAdditionalFunction = this.tryGetOptimizedFunctionRoot(functionValue);\n    return this._withGeneratorScope(\n      \"AdditionalFunction\",\n      generator,\n      /*valuesToProcess*/ undefined,\n      newBody => {\n        let effectsGenerator = additionalEffects.generator;\n        invariant(effectsGenerator === generator);\n        effectsGenerator.serialize(this._getContext());\n        this.realm.withEffectsAppliedInGlobalEnv(() => {\n          const lazyHoistedReactNodes = this.residualReactElementSerializer.serializeLazyHoistedNodes();\n          this.mainBody.entries.push(...lazyHoistedReactNodes);\n          return null;\n        }, additionalEffects.effects);\n      },\n      !!inAdditionalFunction\n    );\n  }\n\n  // result -- serialize it, a return statement will be generated later, must be a Value\n  // Generator -- visit all entries\n  // Bindings -- only need to serialize bindings if they're captured by some nested function?\n  //          -- need to apply them and maybe need to revisit functions in ancestors to make sure\n  //          -- we don't overwrite anything they capture\n  // PropertyBindings -- visit any property bindings that aren't to createdobjects\n  // CreatedObjects -- should take care of itself\n  _serializeAdditionalFunction(\n    additionalFunctionValue: FunctionValue,\n    additionalEffects: AdditionalFunctionEffects\n  ): void {\n    let { effects, transforms, generator, additionalRoots } = additionalEffects;\n    // No function info means the function is dead code, also break recursive cycles where we've already started\n    // serializing this value\n    if (\n      !this.additionalFunctionValueInfos.has(additionalFunctionValue) ||\n      this.rewrittenAdditionalFunctions.has(additionalFunctionValue)\n    ) {\n      return;\n    }\n    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, []);\n\n    // visit all additional roots before going into the additional functions;\n    // this ensures that those potentially stateful additional roots will get\n    // initially serialized with the right initial effects applied.\n    for (let additionalRoot of additionalRoots) this.serializeValue(additionalRoot);\n\n    let createdObjects = effects.createdObjects;\n    let nestedFunctions = new Set([...createdObjects].filter(object => object instanceof FunctionValue));\n    // Allows us to emit function declarations etc. inside of this additional\n    // function instead of adding them at global scope\n    // TODO: make sure this generator isn't getting mutated oddly\n    ((nestedFunctions: any): Set<FunctionValue>).forEach(val => this.additionalFunctionValueNestedFunctions.add(val));\n    let body = this._serializeAdditionalFunctionGeneratorAndEffects(\n      generator,\n      additionalFunctionValue,\n      additionalEffects\n    );\n    invariant(additionalFunctionValue instanceof ECMAScriptSourceFunctionValue);\n    for (let transform of transforms) {\n      transform(body);\n    }\n    this.rewrittenAdditionalFunctions.set(additionalFunctionValue, body);\n  }\n\n  prepareAdditionalFunctionValues(): void {\n    let additionalFVEffects = this.additionalFunctionValuesAndEffects;\n    if (additionalFVEffects)\n      for (let [additionalFunctionValue, { generator }] of additionalFVEffects.entries()) {\n        invariant(!this.additionalFunctionGenerators.has(additionalFunctionValue));\n        this.additionalFunctionGenerators.set(additionalFunctionValue, generator);\n      }\n  }\n\n  // Hook point for any serialization needs to be done after generator serialization is complete.\n  postGeneratorSerialization(): void {\n    // For overriding only.\n  }\n\n  serialize(): BabelNodeFile {\n    this.prepareAdditionalFunctionValues();\n\n    this.generator.serialize(this._getContext());\n    this.getStatistics().generators++;\n    invariant(this.emitter.declaredCount() <= this.realm.derivedIds.size);\n\n    // TODO #20: add timers\n\n    // TODO #21: add event listeners\n\n    for (let [moduleId, moduleValue] of this.modules.initializedModules)\n      this.requireReturns.set(moduleId, getReplacement(this.serializeValue(moduleValue), moduleValue));\n\n    for (let [name, value] of this.declaredGlobalLets) {\n      this.emitter.emit(\n        t.expressionStatement(t.assignmentExpression(\"=\", t.identifier(name), this.serializeValue(value)))\n      );\n    }\n\n    this.postGeneratorSerialization();\n\n    Array.prototype.push.apply(this.prelude, this.preludeGenerator.prelude);\n\n    this.emitter.finalize();\n\n    this.residualFunctions.residualFunctionInitializers.factorifyInitializers(this.factoryNameGenerator);\n    let { unstrictFunctionBodies, strictFunctionBodies } = this.residualFunctions.spliceFunctions(\n      this.rewrittenAdditionalFunctions\n    );\n\n    // add strict modes\n    let strictDirective = t.directive(t.directiveLiteral(\"use strict\"));\n    let globalDirectives = [];\n    if (!this.realm.isStrict && !unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // no unstrict functions, only strict ones\n      globalDirectives.push(strictDirective);\n    } else if (unstrictFunctionBodies.length && strictFunctionBodies.length) {\n      // strict and unstrict functions\n      funcLoop: for (let node of strictFunctionBodies) {\n        if (t.isFunctionExpression(node)) {\n          let func = ((node: any): BabelNodeFunctionExpression);\n          if (func.body.directives) {\n            for (let directive of func.body.directives) {\n              if (directive.value.value === \"use strict\") {\n                // already have a use strict directive\n                continue funcLoop;\n              }\n            }\n          } else func.body.directives = [];\n\n          func.body.directives.unshift(strictDirective);\n        }\n      }\n    }\n\n    // build ast\n    if (this.needsEmptyVar) {\n      this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(emptyExpression, t.objectExpression([]))]));\n    }\n    if (this.needsAuxiliaryConstructor) {\n      this.prelude.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(constructorExpression, t.functionExpression(null, [], t.blockStatement([]))),\n        ])\n      );\n    }\n\n    let body = this.prelude.concat(this.emitter.getBody().entries);\n    factorifyObjects(body, this.factoryNameGenerator);\n\n    let ast_body = [];\n    if (this.preludeGenerator.declaredGlobals.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"var\",\n          Array.from(this.preludeGenerator.declaredGlobals).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (this.declaredGlobalLets.size > 0)\n      ast_body.push(\n        t.variableDeclaration(\n          \"let\",\n          Array.from(this.declaredGlobalLets.keys()).map(key => t.variableDeclarator(t.identifier(key)))\n        )\n      );\n    if (body.length) {\n      if (this.realm.isCompatibleWith(\"node-source-maps\")) {\n        ast_body.push(\n          t.expressionStatement(\n            t.callExpression(\n              t.memberExpression(\n                t.callExpression(t.identifier(\"require\"), [t.stringLiteral(\"source-map-support\")]),\n                t.identifier(\"install\")\n              ),\n              []\n            )\n          )\n        );\n      }\n\n      if (this._shouldBeWrapped(body)) {\n        let globalExpression = this.realm.isCompatibleWith(\"node-cli\") ? t.identifier(\"global\") : t.thisExpression();\n\n        let functionExpression = t.functionExpression(null, [], t.blockStatement(body, globalDirectives));\n        let callExpression = this.preludeGenerator.usesThis\n          ? t.callExpression(t.memberExpression(functionExpression, t.identifier(\"call\")), [globalExpression])\n          : t.callExpression(functionExpression, []);\n        ast_body.push(t.expressionStatement(callExpression));\n      } else {\n        Array.prototype.push.apply(ast_body, body);\n      }\n    }\n\n    // Make sure that the visitor visited exactly the same values as the serializer\n    if (\n      this.serializedValues.size !== this.residualValues.size ||\n      !Array.from(this.serializedValues).every(val => this.residualValues.has(val))\n    ) {\n      this._logSerializedResidualMismatches();\n      invariant(false, \"serialized \" + this.serializedValues.size + \" of \" + this.residualValues.size);\n    }\n\n    // TODO: find better way to do this?\n    // revert changes to functionInstances in case we do multiple serialization passes\n    for (let instance of this.residualFunctionInstances.values()) {\n      this.referentializer.cleanInstance(instance);\n    }\n\n    let program_directives = [];\n    if (this.realm.isStrict) program_directives.push(strictDirective);\n    return t.file(t.program(ast_body, program_directives));\n  }\n\n  _logScopes(scopes: Set<Scope>): void {\n    console.log(`  referenced by ${scopes.size} scopes`);\n    for (let s of scopes)\n      if (s instanceof Generator) {\n        let text = \"\";\n        for (; s instanceof Generator; s = this.generatorDAG.getParent(s)) text += \"=>\" + s.getName();\n        console.log(`      ${text}`);\n      } else {\n        invariant(s instanceof FunctionValue);\n        console.log(`      ${s.__originalName || JSON.stringify(s.expressionLocation) || s.constructor.name}`);\n      }\n  }\n\n  _logSerializedResidualMismatches(): void {\n    let logValue = value => {\n      console.log(describeValue(value));\n      let scopes = this.residualValues.get(value);\n      if (scopes !== undefined) this._logScopes(scopes);\n    };\n    console.log(\"=== serialized but not visited values\");\n    for (let value of this.serializedValues) if (!this.residualValues.has(value)) logValue(value);\n    console.log(\"=== visited but not serialized values\");\n    for (let value of this.residualValues.keys()) if (!this.serializedValues.has(value)) logValue(value);\n  }\n}\n"]}