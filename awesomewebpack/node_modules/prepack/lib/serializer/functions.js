"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Functions = undefined;

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _realm = require("../realm.js");

var _errors2 = require("../utils/errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _modules = require("../utils/modules.js");

var _utils = require("./utils.js");

var _types = require("./types");

var _utils2 = require("../react/utils.js");

var _optimizing = require("../react/optimizing.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Functions {
  constructor(realm, moduleTracer) {
    this.realm = realm;
    this.moduleTracer = moduleTracer;
    this.writeEffects = new Map();
    this.functionExpressions = new Map();
    this._noopFunction = undefined;
  }
  // maps back from FunctionValue to the expression string


  __optimizedFunctionEntryOfValue(value) {
    let realm = this.realm;

    if (value instanceof _index.AbstractValue) {
      // if we conditionally called __optimize, we may have an AbstractValue that is the union of Empty or Undefined and
      // a function/component to optimize
      let elements = value.values.getElements();
      if (elements) {
        let possibleValues = [...elements].filter(element => !(element instanceof _index.EmptyValue || element instanceof _index.UndefinedValue));
        if (possibleValues.length === 1) {
          value = possibleValues[0];
        }
      }
    }
    if (value instanceof _index.ECMAScriptSourceFunctionValue) {
      // additional function logic
      return { value };
    } else if (value instanceof _index.ObjectValue) {
      // React component tree logic
      let config = (0, _index2.Get)(realm, value, "config");
      let rootComponent = (0, _index2.Get)(realm, value, "rootComponent");
      let validConfig = config instanceof _index.ObjectValue || config === realm.intrinsics.undefined;
      let validRootComponent = rootComponent instanceof _index.ECMAScriptSourceFunctionValue || rootComponent instanceof _index.AbstractValue && (0, _utils2.valueIsKnownReactAbstraction)(this.realm, rootComponent);

      if (validConfig && validRootComponent) {
        return {
          value: rootComponent,
          config: (0, _utils2.convertConfigObjectToReactComponentTreeConfig)(realm, config)
        };
      }
    }

    let location = value.expressionLocation ? `${value.expressionLocation.start.line}:${value.expressionLocation.start.column} ` + `${value.expressionLocation.end.line}:${value.expressionLocation.end.line}` : "location unknown";
    realm.handleError(new _errors.CompilerDiagnostic(`Optimized Function Value ${location} is an not a function or react element`, realm.currentLocation, "PP0033", "FatalError"));
    throw new _errors.FatalError("Optimized Function Values must be functions or react elements");
  }

  __generateInitialAdditionalFunctions(globalKey) {
    let recordedAdditionalFunctions = [];
    let realm = this.realm;
    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(() => (0, _index2.Get)(realm, realm.$GlobalObject, globalKey), realm.intrinsics.undefined);
    (0, _invariant2.default)(globalRecordedAdditionalFunctionsMap instanceof _index.ObjectValue);
    for (let funcId of globalRecordedAdditionalFunctionsMap.getOwnPropertyKeysArray(true)) {
      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);
      if (property) {
        let value = property.descriptor && property.descriptor.value;
        (0, _invariant2.default)(value !== undefined);
        (0, _invariant2.default)(value instanceof _index.Value);
        let entry = this.__optimizedFunctionEntryOfValue(value);
        if (entry) recordedAdditionalFunctions.push(entry);
      }
    }
    return recordedAdditionalFunctions;
  }

  optimizeReactComponentTreeRoots(statistics, environmentRecordIdAfterGlobalCode) {
    let logger = this.moduleTracer.modules.logger;
    let recordedReactRootValues = this.__generateInitialAdditionalFunctions("__reactComponentTrees");
    // Get write effects of the components
    if (this.realm.react.verbose) {
      logger.logInformation(`Evaluating ${recordedReactRootValues.length} React component tree roots...`);
    }
    for (let _ref of recordedReactRootValues) {
      let { value: componentRoot, config } = _ref;

      (0, _invariant2.default)(config);
      (0, _optimizing.optimizeReactComponentTreeRoot)(this.realm, componentRoot, config, this.writeEffects, environmentRecordIdAfterGlobalCode, logger, statistics);
    }
    (0, _optimizing.applyOptimizedReactComponents)(this.realm, this.writeEffects, environmentRecordIdAfterGlobalCode);
  }

  _callOfFunction(funcValue) {
    let call = funcValue.$Call;
    (0, _invariant2.default)(call);
    let numArgs = funcValue.getLength();
    let args = [];
    (0, _invariant2.default)(funcValue instanceof _index.ECMAScriptSourceFunctionValue);
    let params = funcValue.$FormalParameters;
    if (numArgs && numArgs > 0 && params) {
      for (let parameterId of params) {
        if (t.isIdentifier(parameterId)) {
          // Create an AbstractValue similar to __abstract being called
          args.push(_index.AbstractValue.createAbstractArgument(this.realm, parameterId.name, funcValue.expressionLocation));
        } else {
          this.realm.handleError(new _errors.CompilerDiagnostic("Non-identifier args to additional functions unsupported", funcValue.expressionLocation, "PP1005", "FatalError"));
          throw new _errors.FatalError("Non-identifier args to additional functions unsupported");
        }
      }
    }

    let thisArg = _index.AbstractValue.createAbstractArgument(this.realm, "this", funcValue.expressionLocation, _index.ObjectValue);
    return call.bind(this, thisArg, args);
  }

  checkThatFunctionsAreIndependent(environmentRecordIdAfterGlobalCode) {
    let additionalFunctionsToProcess = this.__generateInitialAdditionalFunctions("__optimizedFunctions");
    // When we find declarations of nested optimized functions, we need to apply the parent
    // effects.
    let additionalFunctionStack = [];
    let additionalFunctions = new Set(additionalFunctionsToProcess.map(entry => entry.value));
    let optimizedFunctionsObject = this.moduleTracer.modules.logger.tryQuery(() => (0, _index2.Get)(this.realm, this.realm.$GlobalObject, "__optimizedFunctions"), this.realm.intrinsics.undefined);
    (0, _invariant2.default)(optimizedFunctionsObject instanceof _index.ObjectValue);

    // If there's an additional function that delcared functionValue, it must be
    // have already been evaluated for the __optimize call to have happened, so
    // this should always return either the defining additional function or void
    let getDeclaringAdditionalFunction = functionValue => {
      for (let [additionalFunctionValue, additionalEffects] of this.writeEffects) {
        // CreatedObjects is all objects created by this additional function but not
        // nested additional functions.
        let createdObjects = additionalEffects.effects.createdObjects;
        if (createdObjects.has(functionValue)) return additionalFunctionValue;
      }
    };

    let optimizedFunctionId = 0;
    let getEffectsFromAdditionalFunctionAndNestedFunctions = functionValue => {
      let currentOptimizedFunctionId = optimizedFunctionId++;
      additionalFunctionStack.push(functionValue);
      (0, _invariant2.default)(functionValue instanceof _index.ECMAScriptSourceFunctionValue);
      let logCompilerDiagnostic = msg => {
        let error = new _errors.CompilerDiagnostic(msg, undefined, "PP1007", "Warning");
        realm.handleError(error);
      };
      for (let t1 of this.realm.tracers) t1.beginOptimizingFunction(currentOptimizedFunctionId, functionValue);
      let call = this._callOfFunction(functionValue);
      let realm = this.realm;
      let effects = realm.evaluatePure(() => realm.evaluateForEffectsInGlobalEnv(call, undefined, "additional function"), (sideEffectType, binding, expressionLocation) => (0, _utils.handleReportedSideEffect)(logCompilerDiagnostic, sideEffectType, binding, expressionLocation));
      (0, _invariant2.default)(effects);
      let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(this.realm, effects, true, "AdditionalFunctionEffects", environmentRecordIdAfterGlobalCode, getDeclaringAdditionalFunction(functionValue));
      (0, _invariant2.default)(additionalFunctionEffects);
      effects = additionalFunctionEffects.effects;
      this.writeEffects.set(functionValue, additionalFunctionEffects);

      // look for newly registered optimized functions
      let modifiedProperties = additionalFunctionEffects.effects.modifiedProperties;
      // Conceptually this will ensure that the nested additional function is defined
      // although for later cases, we'll apply the effects of the parents only.
      this.realm.withEffectsAppliedInGlobalEnv(() => {
        for (let [propertyBinding] of modifiedProperties) {
          let descriptor = propertyBinding.descriptor;
          if (descriptor && propertyBinding.object === optimizedFunctionsObject) {
            let newValue = descriptor.value;
            (0, _invariant2.default)(newValue instanceof _index.Value); //todo: this does not seem invariantly true
            let newEntry = this.__optimizedFunctionEntryOfValue(newValue);
            if (newEntry) {
              additionalFunctions.add(newEntry.value);
              getEffectsFromAdditionalFunctionAndNestedFunctions(newEntry.value);
              // Now we have to rember the stack of effects that need to be applied to deal with
              // this additional function.
            }
          }
        }
        return null;
      }, additionalFunctionEffects.effects);
      (0, _invariant2.default)(additionalFunctionStack.pop() === functionValue);
      for (let t2 of this.realm.tracers) t2.endOptimizingFunction(currentOptimizedFunctionId);
    };

    while (additionalFunctionsToProcess.length > 0) {
      let funcValue = additionalFunctionsToProcess.shift().value;
      getEffectsFromAdditionalFunctionAndNestedFunctions(funcValue);
    }
    (0, _invariant2.default)(additionalFunctionStack.length === 0);

    // check that functions are independent
    let conflicts = new Map();
    for (let fun1 of additionalFunctions) {
      (0, _invariant2.default)(fun1 instanceof _index.FunctionValue);
      let fun1Name = this.functionExpressions.get(fun1) || fun1.intrinsicName || "(unknown function)";
      // Also do argument validation here
      let additionalFunctionEffects = this.writeEffects.get(fun1);
      (0, _invariant2.default)(additionalFunctionEffects !== undefined);
      let e1 = additionalFunctionEffects.effects;
      (0, _invariant2.default)(e1 !== undefined);
      if (e1.result instanceof _completions.Completion && !e1.result instanceof _completions.PossiblyNormalCompletion) {
        let error = new _errors.CompilerDiagnostic(`Additional function ${fun1Name} may terminate abruptly`, e1.result.location, "PP1002", "FatalError");
        this.realm.handleError(error);
        throw new _errors.FatalError();
      }
      for (let fun2 of additionalFunctions) {
        if (fun1 === fun2) continue;
        (0, _invariant2.default)(fun2 instanceof _index.FunctionValue);
        let reportFn = () => {
          this.reportWriteConflicts(fun1Name, conflicts, e1.modifiedProperties, this._callOfFunction(fun2));
          return null;
        };
        let fun2Effects = this.writeEffects.get(fun2);
        (0, _invariant2.default)(fun2Effects);
        if (fun2Effects.parentAdditionalFunction) {
          let parentEffects = this.writeEffects.get(fun2Effects.parentAdditionalFunction);
          (0, _invariant2.default)(parentEffects);
          this.realm.withEffectsAppliedInGlobalEnv(reportFn, parentEffects.effects);
        } else {
          reportFn();
        }
      }
    }
    if (conflicts.size > 0) {
      for (let diagnostic of conflicts.values()) this.realm.handleError(diagnostic);
      throw new _errors.FatalError();
    }
  }

  getAdditionalFunctionValuesToEffects() {
    return this.writeEffects;
  }

  reportWriteConflicts(fname, conflicts, pbs, call2) {
    let reportConflict = location => {
      let error = new _errors.CompilerDiagnostic(`Property access conflicts with write in optimized function ${fname}`, location, "PP1003", "FatalError");
      conflicts.set(location, error);
    };
    let writtenObjects = new Set();
    pbs.forEach((val, key, m) => {
      writtenObjects.add(key.object);
    });
    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;
    this.realm.reportObjectGetOwnProperties = ob => {
      let location = this.realm.currentLocation;
      (0, _invariant2.default)(location);
      if (writtenObjects.has(ob) && !conflicts.has(location)) reportConflict(location);
    };
    let oldReportPropertyAccess = this.realm.reportPropertyAccess;
    this.realm.reportPropertyAccess = pb => {
      if (pb.object.refuseSerialization) return;
      let location = this.realm.currentLocation;
      if (!location) return; // happens only when accessing an additional function property
      if (pbs.has(pb) && !conflicts.has(location)) reportConflict(location);
    };
    try {
      (0, _errors2.ignoreErrorsIn)(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));
    } finally {
      this.realm.reportPropertyAccess = oldReportPropertyAccess;
      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;
    }
  }
}
exports.Functions = Functions; /**
                                * Copyright (c) 2017-present, Facebook, Inc.
                                * All rights reserved.
                                *
                                * This source code is licensed under the BSD-style license found in the
                                * LICENSE file in the root directory of this source tree. An additional grant
                                * of patent rights can be found in the PATENTS file in the same directory.
                                */
//# sourceMappingURL=functions.js.map