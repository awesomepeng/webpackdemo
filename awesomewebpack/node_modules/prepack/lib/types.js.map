{"version":3,"sources":["../src/types.js"],"names":["ElementSize","Float32","Float64","Int8","Int16","Int32","Uint8","Uint16","Uint32","Uint8Clamped"],"mappings":";;;;;;;AA6BA;;AACA;;AAQA;;AACA;;AAaA;;AAIO,MAAMA,oCAAc;AACzBC,WAAS,CADgB;AAEzBC,WAAS,CAFgB;AAGzBC,QAAM,CAHmB;AAIzBC,SAAO,CAJkB;AAKzBC,SAAO,CALkB;AAMzBC,SAAO,CANkB;AAOzBC,UAAQ,CAPiB;AAQzBC,UAAQ,CARiB;AASzBC,gBAAc;AATW,CAApB;;AA4DP;;AAOA;;AAIA;;AAuNA;;AAtVA","file":"types.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ConcreteValue,\n  ECMAScriptFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n} from \"./values/index.js\";\nimport { Value } from \"./values/index.js\";\nimport {\n  AbruptCompletion,\n  Completion,\n  ForkedAbruptCompletion,\n  SimpleNormalCompletion,\n  PossiblyNormalCompletion,\n  NormalCompletion,\n} from \"./completions.js\";\nimport { EnvironmentRecord, LexicalEnvironment, Reference } from \"./environment.js\";\nimport { Generator } from \"./utils/generator.js\";\nimport { ObjectValue } from \"./values/index.js\";\nimport type {\n  BabelNode,\n  BabelNodeBlockStatement,\n  BabelNodeClassMethod,\n  BabelNodeLVal,\n  BabelNodeObjectMethod,\n  BabelNodePattern,\n  BabelNodeVariableDeclaration,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport type { Bindings, Effects, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"./realm.js\";\nimport { CompilerDiagnostic } from \"./errors.js\";\nimport type { Severity } from \"./errors.js\";\nimport type { DebugChannel } from \"./debugger/server/channel/DebugChannel.js\";\n\nexport const ElementSize = {\n  Float32: 4,\n  Float64: 8,\n  Int8: 1,\n  Int16: 2,\n  Int32: 4,\n  Uint8: 1,\n  Uint16: 2,\n  Uint32: 4,\n  Uint8Clamped: 1,\n};\n\nexport type ConsoleMethodTypes =\n  | \"assert\"\n  | \"clear\"\n  | \"count\"\n  | \"dir\"\n  | \"dirxml\"\n  | \"error\"\n  | \"group\"\n  | \"groupCollapsed\"\n  | \"groupEnd\"\n  | \"info\"\n  | \"log\"\n  | \"table\"\n  | \"time\"\n  | \"timeEnd\"\n  | \"trace\"\n  | \"warn\";\n\nexport type IterationKind = \"key+value\" | \"value\" | \"key\";\n\nexport type SourceType = \"module\" | \"script\";\n\nexport type SourceFile = {\n  filePath: string,\n  fileContents: string,\n  sourceMapContents?: string,\n};\n\nexport type SourceMap = {\n  sources: Array<string>,\n  names: Array<string>,\n  mappings: string,\n  sourcesContent: Array<string>,\n};\n\nexport type AbstractTime = \"early\" | \"late\";\n\nexport type ElementType =\n  | \"Float32\"\n  | \"Float64\"\n  | \"Int8\"\n  | \"Int16\"\n  | \"Int32\"\n  | \"Uint8\"\n  | \"Uint16\"\n  | \"Uint32\"\n  | \"Uint8Clamped\";\n\n//\n\ndeclare class _CallableObjectValue extends ObjectValue {\n  $Call: void | ((thisArgument: Value, argsList: Array<Value>) => Value);\n}\nexport type CallableObjectValue = _CallableObjectValue | FunctionValue | NativeFunctionValue;\n\n//\n\nexport type DataBlock = Uint8Array;\n\n//\n\nexport type Descriptor = {\n  writable?: boolean,\n  enumerable?: boolean,\n  configurable?: boolean,\n\n  // If value instanceof EmptyValue, then this descriptor indicates that the\n  // corresponding property has been deleted.\n  // Only internal properties (those starting with $ / where internalSlot of owning property binding is true) will ever have array values.\n  value?: Value | Array<any>,\n\n  get?: UndefinedValue | CallableObjectValue | AbstractValue,\n  set?: UndefinedValue | CallableObjectValue | AbstractValue,\n\n  // Only used if the result of a join of two descriptors is not a data descriptor with identical attribute values.\n  // When present, any update to the property must produce effects that are the join of updating both desriptors,\n  // using joinCondition as the condition of the join.\n  joinCondition?: AbstractValue,\n  descriptor1?: Descriptor,\n  descriptor2?: Descriptor,\n};\n\nexport type FunctionBodyAstNode = {\n  // Function body ast node will have uniqueOrderedTag after being interpreted.\n  // This tag value is unique and sorted in ast DFS traversal ordering.\n  uniqueOrderedTag?: number,\n};\n\nexport type PropertyBinding = {\n  descriptor?: Descriptor,\n  object: ObjectValue,\n  key: void | string | SymbolValue | AbstractValue, // where an abstract value must be of type String or Number or Symbol\n  // contains a build node that produces a member expression that resolves to this property binding (location)\n  pathNode?: AbstractValue,\n  internalSlot?: boolean,\n};\n\nexport type LexicalEnvironmentTypes = \"global\" | \"module\" | \"script\" | \"function\" | \"block\" | \"catch\" | \"loop\" | \"with\";\n\nexport type PropertyKeyValue = string | StringValue | SymbolValue;\n\nexport type Intrinsics = {\n  undefined: UndefinedValue,\n  empty: EmptyValue,\n  null: NullValue,\n  false: BooleanValue,\n  true: BooleanValue,\n  NaN: NumberValue,\n  Infinity: NumberValue,\n  negativeInfinity: NumberValue,\n  zero: NumberValue,\n  negativeZero: NumberValue,\n  emptyString: StringValue,\n\n  SymbolHasInstance: SymbolValue,\n  SymbolIsConcatSpreadable: SymbolValue,\n  SymbolSpecies: SymbolValue,\n  SymbolReplace: SymbolValue,\n  SymbolIterator: SymbolValue,\n  SymbolSplit: SymbolValue,\n  SymbolToPrimitive: SymbolValue,\n  SymbolToStringTag: SymbolValue,\n  SymbolMatch: SymbolValue,\n  SymbolSearch: SymbolValue,\n  SymbolUnscopables: SymbolValue,\n\n  ObjectPrototype: ObjectValue,\n  FunctionPrototype: NativeFunctionValue,\n  ArrayPrototype: ObjectValue,\n  RegExpPrototype: ObjectValue,\n  DatePrototype: ObjectValue,\n  Boolean: NativeFunctionValue,\n  BooleanPrototype: ObjectValue,\n\n  Error: NativeFunctionValue,\n  ErrorPrototype: ObjectValue,\n  ReferenceError: NativeFunctionValue,\n  ReferenceErrorPrototype: ObjectValue,\n  SyntaxError: NativeFunctionValue,\n  SyntaxErrorPrototype: ObjectValue,\n  TypeError: NativeFunctionValue,\n  TypeErrorPrototype: ObjectValue,\n  URIError: NativeFunctionValue,\n  URIErrorPrototype: ObjectValue,\n  EvalError: NativeFunctionValue,\n  EvalErrorPrototype: ObjectValue,\n  JSON: ObjectValue,\n  Reflect: ObjectValue,\n  Proxy: NativeFunctionValue,\n  RangeError: NativeFunctionValue,\n  RangeErrorPrototype: ObjectValue,\n  ArrayIteratorPrototype: ObjectValue,\n  StringIteratorPrototype: ObjectValue,\n  IteratorPrototype: ObjectValue,\n  SetIteratorPrototype: ObjectValue,\n  MapIteratorPrototype: ObjectValue,\n  Number: NativeFunctionValue,\n  NumberPrototype: ObjectValue,\n  Symbol: NativeFunctionValue,\n  SymbolPrototype: ObjectValue,\n  StringPrototype: ObjectValue,\n  Object: NativeFunctionValue,\n  Function: NativeFunctionValue,\n  Array: NativeFunctionValue,\n  RegExp: NativeFunctionValue,\n  Date: NativeFunctionValue,\n  String: NativeFunctionValue,\n  Math: ObjectValue,\n  isNaN: NativeFunctionValue,\n  parseInt: NativeFunctionValue,\n  parseFloat: NativeFunctionValue,\n  isFinite: NativeFunctionValue,\n  decodeURI: NativeFunctionValue,\n  decodeURIComponent: NativeFunctionValue,\n  encodeURI: NativeFunctionValue,\n  encodeURIComponent: NativeFunctionValue,\n  ThrowTypeError: NativeFunctionValue,\n  ArrayProto_values: NativeFunctionValue,\n  ArrayProto_toString: NativeFunctionValue,\n  ObjectProto_toString: NativeFunctionValue,\n  TypedArrayProto_values: NativeFunctionValue,\n  eval: NativeFunctionValue,\n  console: ObjectValue,\n  document: ObjectValue,\n  process: ObjectValue,\n\n  DataView: NativeFunctionValue,\n  DataViewPrototype: ObjectValue,\n  TypedArray: NativeFunctionValue,\n  TypedArrayPrototype: ObjectValue,\n  Float32Array: NativeFunctionValue,\n  Float32ArrayPrototype: ObjectValue,\n  Float64Array: NativeFunctionValue,\n  Float64ArrayPrototype: ObjectValue,\n  Int8Array: NativeFunctionValue,\n  Int8ArrayPrototype: ObjectValue,\n  Int16Array: NativeFunctionValue,\n  Int16ArrayPrototype: ObjectValue,\n  Int32Array: NativeFunctionValue,\n  Int32ArrayPrototype: ObjectValue,\n  Map: NativeFunctionValue,\n  MapPrototype: ObjectValue,\n  WeakMap: NativeFunctionValue,\n  WeakMapPrototype: ObjectValue,\n  Set: NativeFunctionValue,\n  SetPrototype: ObjectValue,\n  Promise: NativeFunctionValue,\n  PromisePrototype: ObjectValue,\n  Uint8Array: NativeFunctionValue,\n  Uint8ArrayPrototype: ObjectValue,\n  Uint8ClampedArray: NativeFunctionValue,\n  Uint8ClampedArrayPrototype: ObjectValue,\n  Uint16Array: NativeFunctionValue,\n  Uint16ArrayPrototype: ObjectValue,\n  Uint32Array: NativeFunctionValue,\n  Uint32ArrayPrototype: ObjectValue,\n  WeakSet: NativeFunctionValue,\n  WeakSetPrototype: ObjectValue,\n  ArrayBuffer: NativeFunctionValue,\n  ArrayBufferPrototype: ObjectValue,\n\n  Generator: ObjectValue,\n  GeneratorPrototype: ObjectValue,\n  GeneratorFunction: NativeFunctionValue,\n\n  __IntrospectionError: NativeFunctionValue,\n  __IntrospectionErrorPrototype: ObjectValue,\n};\n\nexport type PromiseCapability = {\n  promise: ObjectValue | UndefinedValue,\n  resolve: Value,\n  reject: Value,\n};\n\nexport type PromiseReaction = {\n  capabilities: PromiseCapability,\n  handler: Value,\n};\n\nexport type ResolvingFunctions = {\n  resolve: Value,\n  reject: Value,\n};\n\nexport type TypedArrayKind =\n  | \"Float32Array\"\n  | \"Float64Array\"\n  | \"Int8Array\"\n  | \"Int16Array\"\n  | \"Int32Array\"\n  | \"Uint8Array\"\n  | \"Uint16Array\"\n  | \"Uint32Array\"\n  | \"Uint8ClampedArray\";\n\nexport type ObjectKind =\n  | \"Object\"\n  | \"Array\"\n  | \"Function\"\n  | \"Symbol\"\n  | \"String\"\n  | \"Number\"\n  | \"Boolean\"\n  | \"Date\"\n  | \"RegExp\"\n  | \"Set\"\n  | \"Map\"\n  | \"DataView\"\n  | \"ArrayBuffer\"\n  | \"WeakMap\"\n  | \"WeakSet\"\n  | TypedArrayKind\n  | \"ReactElement\";\n// TODO #26 #712: Promises. All kinds of iterators. Generators.\n\nexport type ClassComponentMetadata = {\n  instanceProperties: Set<string>,\n  instanceSymbols: Set<SymbolValue>,\n};\n\nexport type ReactHint = {| firstRenderValue: Value, object: ObjectValue, propertyName: string, args: Array<Value> |};\n\nexport type ReactComponentTreeConfig = {\n  firstRenderOnly: boolean,\n  isRoot: boolean,\n};\n\nexport type DebugServerType = {\n  checkForActions: BabelNode => void,\n  handlePrepackError: CompilerDiagnostic => void,\n  shouldStopForSeverity: Severity => boolean,\n  shutdown: () => void,\n};\n\nexport type PathType = {\n  implies(condition: Value): boolean,\n  impliesNot(condition: Value): boolean,\n  withCondition<T>(condition: Value, evaluate: () => T): T,\n  withInverseCondition<T>(condition: Value, evaluate: () => T): T,\n  pushAndRefine(condition: Value): void,\n  pushInverseAndRefine(condition: Value): void,\n};\n\nexport type HavocType = {\n  value(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation): void,\n};\n\nexport type PropertiesType = {\n  // ECMA262 9.1.9.1\n  OrdinarySet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value, Receiver: Value): boolean,\n\n  // ECMA262 6.2.4.4\n  FromPropertyDescriptor(realm: Realm, Desc: ?Descriptor): Value,\n\n  //\n  OrdinaryDelete(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean,\n\n  // ECMA262 7.3.8\n  DeletePropertyOrThrow(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean,\n\n  // ECMA262 6.2.4.6\n  CompletePropertyDescriptor(realm: Realm, Desc: Descriptor): Descriptor,\n\n  // ECMA262 9.1.6.2\n  IsCompatiblePropertyDescriptor(realm: Realm, extensible: boolean, Desc: Descriptor, current: ?Descriptor): boolean,\n\n  // ECMA262 9.1.6.3\n  ValidateAndApplyPropertyDescriptor(\n    realm: Realm,\n    O: void | ObjectValue,\n    P: void | PropertyKeyValue,\n    extensible: boolean,\n    Desc: Descriptor,\n    current: ?Descriptor\n  ): boolean,\n\n  // ECMA262 9.1.6.1\n  OrdinaryDefineOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, Desc: Descriptor): boolean,\n\n  // ECMA262 19.1.2.3.1\n  ObjectDefineProperties(realm: Realm, O: Value, Properties: Value): ObjectValue | AbstractObjectValue,\n\n  // ECMA262 7.3.3\n  Set(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value, Throw: boolean): boolean,\n\n  // ECMA262 7.3.7\n  DefinePropertyOrThrow(\n    realm: Realm,\n    O: ObjectValue | AbstractObjectValue,\n    P: PropertyKeyValue,\n    desc: Descriptor\n  ): boolean,\n\n  // ECMA262 6.2.3.2\n  PutValue(realm: Realm, V: Value | Reference, W: Value): void | boolean | Value,\n\n  // ECMA262 9.4.2.4\n  ArraySetLength(realm: Realm, A: ArrayValue, Desc: Descriptor): boolean,\n\n  // ECMA262 9.1.5.1\n  OrdinaryGetOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): Descriptor | void,\n\n  // ECMA262 9.1.2.1\n  OrdinarySetPrototypeOf(realm: Realm, O: ObjectValue, V: ObjectValue | NullValue): boolean,\n\n  // ECMA262 13.7.5.15\n  EnumerateObjectProperties(realm: Realm, O: ObjectValue): ObjectValue,\n\n  ThrowIfMightHaveBeenDeleted(\n    value: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): void,\n\n  ThrowIfInternalSlotNotWritable<T: ObjectValue>(realm: Realm, object: T, key: string): T,\n\n  // ECMA 14.3.9\n  PropertyDefinitionEvaluation(\n    realm: Realm,\n    MethodDefinition: BabelNodeObjectMethod | BabelNodeClassMethod,\n    object: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    enumerable: boolean\n  ): boolean,\n};\n\nexport type FunctionType = {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode>,\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue,\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, name: PropertyKeyValue | AbstractValue, prefix?: string): boolean,\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean,\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value,\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue,\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue | AbstractObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue,\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value,\n\n  // If c is an abrupt completion and realm.savedCompletion is defined, the result is an instance of\n  // ForkedAbruptCompletion and the effects that have been captured since the PossiblyNormalCompletion instance\n  // in realm.savedCompletion has been created, becomes the effects of the branch that terminates in c.\n  // If c is a normal completion, the result is realm.savedCompletion, with its value updated to c.\n  // If c is undefined, the result is just realm.savedCompletion.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | AbruptCompletion | Value): void | Completion | Value,\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value,\n\n  PartiallyEvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    blockValue: void | NormalCompletion | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): [Completion | Value, Array<BabelNodeStatement>],\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value,\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value,\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue },\n};\n\nexport type EnvironmentType = {\n  // ECMA262 6.2.3\n  // IsSuperReference(V). Returns true if this reference has a thisValue component.\n  IsSuperReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\n  HasPrimitiveBase(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // GetReferencedName(V). Returns the referenced name component of the reference V.\n  GetReferencedName(realm: Realm, V: Reference): string | SymbolValue,\n\n  GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue,\n\n  // ECMA262 6.2.3.1\n  GetValue(realm: Realm, V: Reference | Value): Value,\n  GetConditionValue(realm: Realm, V: Reference | Value): Value,\n\n  // ECMA262 6.2.3\n  // IsStrictReference(V). Returns the strict reference flag component of the reference V.\n  IsStrictReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\n  IsPropertyReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // GetBase(V). Returns the base value component of the reference V.\n  GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord,\n\n  // ECMA262 6.2.3\n  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\n  IsUnresolvableReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 8.1.2.2\n  NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment, active?: boolean): LexicalEnvironment,\n\n  BoundNames(realm: Realm, node: BabelNode): Array<string>,\n\n  // ECMA262 13.3.3.2\n  ContainsExpression(realm: Realm, node: ?BabelNode): boolean,\n\n  // ECMA262 8.3.2\n  ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference,\n\n  // ECMA262 8.1.2.1\n  GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference,\n\n  // ECMA262 6.2.3.4\n  InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value,\n\n  // ECMA262 13.2.14\n  BlockDeclarationInstantiation(\n    realm: Realm,\n    strictCode: boolean,\n    body: Array<BabelNodeStatement>,\n    env: LexicalEnvironment\n  ): void,\n\n  // ECMA262 8.1.2.5\n  NewGlobalEnvironment(\n    realm: Realm,\n    G: ObjectValue | AbstractObjectValue,\n    thisValue: ObjectValue | AbstractObjectValue\n  ): LexicalEnvironment,\n\n  // ECMA262 8.1.2.3\n  NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment,\n\n  // ECMA262 8.1.2.4\n  NewFunctionEnvironment(realm: Realm, F: ECMAScriptFunctionValue, newTarget?: ObjectValue): LexicalEnvironment,\n\n  // ECMA262 8.3.1\n  GetActiveScriptOrModule(realm: Realm): any,\n\n  // ECMA262 8.3.3\n  GetThisEnvironment(realm: Realm): EnvironmentRecord,\n\n  // ECMA262 8.3.4\n  ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue,\n\n  BindingInitialization(\n    realm: Realm,\n    node: BabelNodeLVal | BabelNodeVariableDeclaration,\n    value: Value,\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value,\n\n  // ECMA262 13.3.3.6\n  // ECMA262 14.1.19\n  IteratorBindingInitialization(\n    realm: Realm,\n    formals: $ReadOnlyArray<BabelNodeLVal | null>,\n    iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void,\n\n  // ECMA262 12.1.5.1\n  InitializeBoundName(\n    realm: Realm,\n    name: string,\n    value: Value,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value,\n\n  // ECMA262 12.3.1.3 and 13.7.5.6\n  IsDestructuring(ast: BabelNode): boolean,\n\n  // ECMA262 13.3.3.7\n  KeyedBindingInitialization(\n    realm: Realm,\n    node: BabelNodeIdentifier | BabelNodePattern,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment,\n    propertyName: PropertyKeyValue\n  ): void | boolean | Value,\n};\n\nexport type JoinType = {\n  stopEffectCaptureJoinApplyAndReturnCompletion(\n    c1: PossiblyNormalCompletion,\n    c2: AbruptCompletion,\n    realm: Realm\n  ): ForkedAbruptCompletion,\n\n  unbundleNormalCompletion(\n    completionOrValue: Completion | Value | Reference\n  ): [void | NormalCompletion, Value | Reference],\n\n  composeNormalCompletions(\n    leftCompletion: void | NormalCompletion,\n    rightCompletion: void | NormalCompletion,\n    resultValue: Value,\n    realm: Realm\n  ): PossiblyNormalCompletion | Value,\n\n  composePossiblyNormalCompletions(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    c: PossiblyNormalCompletion,\n    priorEffects?: Effects\n  ): PossiblyNormalCompletion,\n\n  updatePossiblyNormalCompletionWithSubsequentEffects(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    subsequentEffects: Effects\n  ): void,\n\n  updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value): void,\n\n  replacePossiblyNormalCompletionWithForkedAbruptCompletion(\n    realm: Realm,\n    // a forked path with a non abrupt (normal) component\n    pnc: PossiblyNormalCompletion,\n    // an abrupt completion that completes the normal path\n    ac: AbruptCompletion,\n    // effects collected after pnc was constructed\n    e: Effects\n  ): ForkedAbruptCompletion,\n\n  updatePossiblyNormalCompletionWithConditionalSimpleNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    nc: SimpleNormalCompletion\n  ): void,\n\n  updatePossiblyNormalCompletionWithInverseConditionalSimpleNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    nc: SimpleNormalCompletion\n  ): void,\n\n  extractAndJoinCompletionsOfType(CompletionType: typeof AbruptCompletion, realm: Realm, c: AbruptCompletion): Effects,\n\n  joinForkOrChoose(realm: Realm, joinCondition: Value, e1: Effects, e2: Effects): Effects,\n\n  joinNestedEffects(realm: Realm, c: Completion, precedingEffects?: Effects): Effects,\n\n  collapseResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    precedingEffects: Effects,\n    result1: EvaluationResult,\n    result2: EvaluationResult\n  ): Completion,\n\n  joinOrForkResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    result1: EvaluationResult,\n    result2: EvaluationResult,\n    e1: Effects,\n    e2: Effects\n  ): Completion,\n\n  composeGenerators(realm: Realm, generator1: Generator, generator2: Generator): Generator,\n\n  // Creates a single map that joins together maps m1 and m2 using the given join\n  // operator. If an entry is present in one map but not the other, the missing\n  // entry is treated as if it were there and its value were undefined.\n  joinMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, join: (K, void | V, void | V) => V): Map<K, V>,\n\n  // Creates a single map that has an key, value pair for the union of the key\n  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n  // where the join is defined to be just m1[key] if m1[key] === m2[key] and\n  // and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\n  joinBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    g1: Generator,\n    m1: Bindings,\n    g2: Generator,\n    m2: Bindings\n  ): [Generator, Generator, Bindings],\n\n  // If v1 is known and defined and v1 === v2 return v1,\n  // otherwise return getAbstractValue(v1, v2)\n  joinValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    getAbstractValue: (void | Value, void | Value) => Value\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n\n  joinPropertyBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings,\n\n  // Returns a field by field join of two descriptors.\n  // Descriptors with get/set are not yet supported.\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor,\n\n  mapAndJoin(\n    realm: Realm,\n    values: Set<ConcreteValue>,\n    joinConditionFactory: (ConcreteValue) => Value,\n    functionToMap: (ConcreteValue) => Completion | Value\n  ): Value,\n};\n\nexport type CreateType = {\n  // ECMA262 9.4.3.3\n  StringCreate(realm: Realm, value: StringValue, prototype: ObjectValue | AbstractObjectValue): ObjectValue,\n\n  // B.2.3.2.1\n  CreateHTML(realm: Realm, string: Value, tag: string, attribute: string, value: string | Value): StringValue,\n\n  // ECMA262 9.4.4.8.1\n  MakeArgGetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue,\n\n  // ECMA262 9.4.4.8.1\n  MakeArgSetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue,\n\n  // ECMA262 21.1.5.1\n  CreateStringIterator(realm: Realm, string: StringValue): ObjectValue,\n\n  // ECMA262 9.4.2.3\n  ArraySpeciesCreate(realm: Realm, originalArray: ObjectValue, length: number): ObjectValue,\n\n  // ECMA262 7.4.7\n  CreateIterResultObject(realm: Realm, value: Value, done: boolean): ObjectValue,\n\n  // ECMA262 22.1.5.1\n  CreateArrayIterator(realm: Realm, array: ObjectValue, kind: IterationKind): ObjectValue,\n\n  // ECMA262 9.4.2.2\n  ArrayCreate(realm: Realm, length: number, proto?: ObjectValue | AbstractObjectValue): ArrayValue,\n\n  // ECMA262 7.3.16\n  CreateArrayFromList(realm: Realm, elems: Array<Value>): ArrayValue,\n\n  // ECMA262 9.4.4.7\n  CreateUnmappedArgumentsObject(realm: Realm, argumentsList: Array<Value>): ObjectValue,\n\n  // ECMA262 9.4.4.8\n  CreateMappedArgumentsObject(\n    realm: Realm,\n    func: FunctionValue,\n    formals: Array<BabelNodeLVal>,\n    argumentsList: Array<Value>,\n    env: EnvironmentRecord\n  ): ObjectValue,\n\n  // ECMA262 7.3.23 (sec-copydataproperties)\n  CopyDataProperties(realm: Realm, target: ObjectValue, source: Value, excluded: Array<PropertyKeyValue>): ObjectValue,\n\n  // ECMA262 7.3.4\n  CreateDataProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value): boolean,\n\n  // ECMA262 7.3.5\n  CreateMethodProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value): boolean,\n\n  // ECMA262 7.3.6\n  CreateDataPropertyOrThrow(realm: Realm, O: Value, P: PropertyKeyValue, V: Value): boolean,\n\n  // ECMA262 9.1.12\n  ObjectCreate(\n    realm: Realm,\n    proto: ObjectValue | AbstractObjectValue | NullValue,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue,\n\n  // ECMA262 9.1.13\n  OrdinaryCreateFromConstructor(\n    realm: Realm,\n    constructor: ObjectValue,\n    intrinsicDefaultProto: string,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue,\n\n  // ECMA262 7.3.17\n  CreateListFromArrayLike(realm: Realm, obj: Value, elementTypes?: Array<string>): Array<Value>,\n\n  // ECMA262 19.2.1.1.1\n  CreateDynamicFunction(\n    realm: Realm,\n    constructor: ObjectValue,\n    newTarget: void | ObjectValue,\n    kind: \"normal\" | \"generator\",\n    args: Array<Value>\n  ): Value,\n};\n\nexport type WidenType = {\n  // Returns a new effects summary that includes both e1 and e2.\n  widenEffects(realm: Realm, e1: Effects, e2: Effects): Effects,\n\n  // Returns an abstract value that includes both v1 and v2 as potential values.\n  widenValues(\n    realm: Realm,\n    v1: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n\n  containsArraysOfValue(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): boolean,\n\n  // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,\n  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general\n  // summary of the loop, regardless of how many iterations will be performed at runtime.\n  containsEffects(e1: Effects, e2: Effects): boolean,\n};\n\nexport type numberOrValue = number | Value;\n\nexport type ElementConvType = {\n  Int8: (Realm, numberOrValue) => number,\n  Int16: (Realm, numberOrValue) => number,\n  Int32: (Realm, numberOrValue) => number,\n  Uint8: (Realm, numberOrValue) => number,\n  Uint16: (Realm, numberOrValue) => number,\n  Uint32: (Realm, numberOrValue) => number,\n  Uint8Clamped: (Realm, numberOrValue) => number,\n};\n\nexport type ToType = {\n  ElementConv: ElementConvType,\n\n  // ECMA262 7.1.5\n  ToInt32(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.6\n  ToUint32(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.7\n  ToInt16(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.8\n  ToUint16(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.9\n  ToInt8(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.10\n  ToUint8(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.11\n  ToUint8Clamp(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 19.3.3.1\n  thisBooleanValue(realm: Realm, value: Value): BooleanValue,\n\n  // ECMA262 20.1.3\n  thisNumberValue(realm: Realm, value: Value): NumberValue,\n\n  // ECMA262 21.1.3\n  thisStringValue(realm: Realm, value: Value): StringValue,\n\n  // ECMA262 6.2.4.5\n  ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor,\n\n  // ECMA262 7.1.13\n  ToObject(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue,\n\n  // ECMA262 7.1.15\n  ToLength(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.4\n  ToInteger(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.17\n  ToIndex(realm: Realm, value: number | ConcreteValue): number,\n\n  ToIndexPartial(realm: Realm, value: numberOrValue): number,\n\n  // ECMA262 7.1.3\n  ToNumber(realm: Realm, val: numberOrValue): number,\n\n  ToNumberOrAbstract(realm: Realm, val: numberOrValue): number | AbstractValue,\n\n  IsToNumberPure(realm: Realm, val: numberOrValue): boolean,\n\n  // ECMA262 7.1.1\n  ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue,\n\n  ToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ConcreteValue,\n    hint?: \"default\" | \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue,\n\n  // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\n  GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value,\n\n  IsToPrimitivePure(realm: Realm, input: Value): boolean,\n\n  // ECMA262 7.1.1\n  OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue,\n\n  OrdinaryToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ObjectValue,\n    hint: \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue,\n\n  // ECMA262 7.1.12\n  ToString(realm: Realm, val: string | ConcreteValue): string,\n\n  ToStringPartial(realm: Realm, val: string | Value): string,\n\n  ToStringValue(realm: Realm, val: Value): Value,\n\n  ToStringAbstract(realm: Realm, val: AbstractValue): AbstractValue,\n\n  // ECMA262 7.1.2\n  ToBoolean(realm: Realm, val: ConcreteValue): boolean,\n\n  ToBooleanPartial(realm: Realm, val: Value): boolean,\n\n  // ECMA262 7.1.14\n  ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */,\n\n  ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */,\n\n  // ECMA262 7.1.16\n  CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void,\n};\n\nexport type ConcretizeType = (realm: Realm, val: Value) => ConcreteValue;\n\nexport type UtilsType = {|\n  typeToString: (typeof Value) => void | string,\n  getTypeFromName: string => void | typeof Value,\n  describeValue: Value => string,\n|};\n\nexport type DebuggerConfigArguments = {\n  diagnosticSeverity?: Severity,\n  sourcemaps?: Array<SourceFile>,\n  buckRoot?: string,\n  debugChannel?: DebugChannel,\n};\n"]}