"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepackNodeCLI = prepackNodeCLI;
exports.prepackNodeCLISync = prepackNodeCLISync;

var _invariant = require("./invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _realm = require("./realm.js");

var _index = require("./serializer/index.js");

var _index2 = _interopRequireDefault(_index);

var _statistics = require("./serializer/statistics.js");

var _completions = require("./completions.js");

var _values = require("./values");

var _construct_realm = require("./construct_realm.js");

var _construct_realm2 = _interopRequireDefault(_construct_realm);

var _globals = require("./globals.js");

var _globals2 = _interopRequireDefault(_globals);

var _prepackOptions = require("./prepack-options");

var _errors = require("./errors.js");

var _bootstrap = require("./intrinsics/node/bootstrap.js");

var _bootstrap2 = _interopRequireDefault(_bootstrap);

var _process = require("./intrinsics/node/process.js");

var _process2 = _interopRequireDefault(_process);

var _options = require("./options");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function prepackNodeCLI(filename, options = _options.defaultOptions, callback) {
  let serialized;
  try {
    serialized = prepackNodeCLISync(filename, options);
  } catch (err) {
    callback(err);
    return;
  }
  callback(null, serialized);
} /**
   * Copyright (c) 2017-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

/* API functions for running Prepack on code that expects to run on Node */

function prepackNodeCLISync(filename, options = _options.defaultOptions) {
  if (process.version !== "v7.9.0") {
    console.warn(`Prepack's node-cli mode currently only works on Node v7.9.0.\n` + `You are running version ${process.version} which will likely fail.`);
  }

  let realm = (0, _construct_realm2.default)((0, _prepackOptions.getRealmOptions)(options), undefined, new _statistics.SerializerStatistics());
  (0, _globals2.default)(realm);

  let processObj = (0, _process2.default)(realm, ["node", filename]);
  let bootstrapFn = (0, _bootstrap2.default)(realm);

  let serializer = new _index2.default(realm, (0, _prepackOptions.getSerializerOptions)(options));

  let context = new _realm.ExecutionContext();
  context.lexicalEnvironment = realm.$GlobalEnv;
  context.variableEnvironment = realm.$GlobalEnv;
  context.realm = realm;
  realm.pushContext(context);
  let res;
  try {
    if (bootstrapFn.$Call) {
      res = bootstrapFn.$Call(realm.intrinsics.null, [processObj]);
    }
  } catch (err) {
    if (err instanceof _completions.Completion) {
      res = err;
    } else if (err instanceof Error) {
      throw err;
    } else {
      throw new _errors.FatalError(err);
    }
  } finally {
    realm.popContext(context);
  }
  if (res instanceof _completions.Completion) {
    context = new _realm.ExecutionContext();
    realm.pushContext(context);
    try {
      serializer.logger.logCompletion(res);
    } finally {
      realm.popContext(context);
      realm.onDestroyScope(realm.$GlobalEnv);
    }
  }

  // Hack: Turn these objects generated by the bootstrap script into
  // intrinsics that exist in a preinitialized environment. This ensures
  // that we don't end up with duplicates of these. This won't work in an
  // uninitialized environment.
  let nextTick = realm.$GlobalEnv.execute("process.nextTick", "", "");
  (0, _invariant2.default)(nextTick instanceof _values.Value);
  nextTick.intrinsicName = "process.nextTick";
  let tickCallback = realm.$GlobalEnv.execute("process._tickCallback", "", "");
  (0, _invariant2.default)(tickCallback instanceof _values.Value);
  tickCallback.intrinsicName = "process._tickCallback";
  let tickDomainCallback = realm.$GlobalEnv.execute("process._tickDomainCallback", "", "");
  (0, _invariant2.default)(tickDomainCallback instanceof _values.Value);
  tickDomainCallback.intrinsicName = "process._tickDomainCallback";

  // Serialize
  let sources = [{ filePath: "", fileContents: "" }];
  let serialized = serializer.init(sources, options.sourceMaps);
  if (!serialized) {
    throw new _errors.FatalError("serializer failed");
  }
  return serialized;
}
//# sourceMappingURL=prepack-node-environment.js.map