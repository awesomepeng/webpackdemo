"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optimizeReactComponentTreeRoot = optimizeReactComponentTreeRoot;
exports.applyOptimizedReactComponents = applyOptimizedReactComponents;

var _realm = require("../realm.js");

var _index = require("../values/index.js");

var _utils = require("../serializer/utils.js");

var _utils2 = require("./utils.js");

var _types = require("../serializer/types.js");

var _reconcilation = require("./reconcilation.js");

var _errors = require("./errors.js");

var _singletons = require("../singletons.js");

var _index2 = require("../methods/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _logger = require("../utils/logger.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyWriteEffectsForOptimizedComponent(realm, componentType, _effects, componentTreeState, evaluatedNode, writeEffects, environmentRecordIdAfterGlobalCode) {
  let effects = _effects;
  let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(realm, effects, false, "ReactAdditionalFunctionEffects", environmentRecordIdAfterGlobalCode);
  if (additionalFunctionEffects === null) {
    throw new _errors.ReconcilerFatalError(`Failed to optimize React component tree for "${evaluatedNode.name}" due to an unsupported completion`, evaluatedNode);
  }
  effects = additionalFunctionEffects.effects;
  let value = effects.result;

  if (value === realm.intrinsics.undefined) {
    // if we get undefined, then this component tree failed and a message was already logged
    // in the reconciler
    return;
  }
  if ((0, _utils2.valueIsClassComponent)(realm, componentType)) {
    if (componentTreeState.status === "SIMPLE") {
      // if the root component was a class and is now simple, we can convert it from a class
      // component to a functional component
      (0, _utils2.convertSimpleClassComponentToFunctionalComponent)(realm, componentType, additionalFunctionEffects);
      (0, _utils2.normalizeFunctionalComponentParamaters)(componentType);
      writeEffects.set(componentType, additionalFunctionEffects);
    } else {
      let prototype = (0, _index2.Get)(realm, componentType, "prototype");
      (0, _invariant2.default)(prototype instanceof _index.ObjectValue);
      let renderMethod = (0, _index2.Get)(realm, prototype, "render");
      (0, _invariant2.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
      writeEffects.set(renderMethod, additionalFunctionEffects);
    }
  } else {
    if (componentTreeState.status === "COMPLEX") {
      (0, _utils2.convertFunctionalComponentToComplexClassComponent)(realm, componentType, componentTreeState.componentType, additionalFunctionEffects);
      let prototype = (0, _index2.Get)(realm, componentType, "prototype");
      (0, _invariant2.default)(prototype instanceof _index.ObjectValue);
      let renderMethod = (0, _index2.Get)(realm, prototype, "render");
      (0, _invariant2.default)(renderMethod instanceof _index.ECMAScriptSourceFunctionValue);
      writeEffects.set(renderMethod, additionalFunctionEffects);
    } else {
      (0, _utils2.normalizeFunctionalComponentParamaters)(componentType);
      writeEffects.set(componentType, additionalFunctionEffects);
    }
  }
  // apply contextTypes for legacy context
  if (componentTreeState.contextTypes.size > 0) {
    let contextTypes = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype);
    let noOpFunc = (0, _utils2.createNoopFunction)(realm);
    for (let key of componentTreeState.contextTypes) {
      _singletons.Properties.Set(realm, contextTypes, key, noOpFunc, true);
    }
    _singletons.Properties.Set(realm, componentType, "contextTypes", contextTypes, true);
  }
} /**
   * Copyright (c) 2017-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

/*  strict-local */

function optimizeReactComponentTreeBranches(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger) {
  if (realm.react.verbose && reconciler.branchedComponentTrees.length > 0) {
    logger.logInformation(`  Evaluating React component tree branches...`);
  }
  // for now we just use abstract props/context, in the future we'll create a new branch with a new component
  // that used the props/context. It will extend the original component and only have a render method
  for (let _ref of reconciler.branchedComponentTrees) {
    let { rootValue: branchRootValue, evaluatedNode } = _ref;

    let branchComponentType = (0, _utils2.getComponentTypeFromRootValue)(realm, branchRootValue);
    if (branchComponentType === null) {
      evaluatedNode.status = "UNKNOWN_TYPE";
      continue;
    }
    // so we don't process the same component multiple times (we might change this logic later)
    if (reconciler.hasEvaluatedRootNode(branchComponentType, evaluatedNode)) {
      continue;
    }
    reconciler.clearComponentTreeState();
    if (realm.react.verbose) {
      logger.logInformation(`    Evaluating ${evaluatedNode.name} (branch)`);
    }
    let branchEffects = reconciler.resolveReactComponentTree(branchComponentType, null, null, evaluatedNode);
    if (realm.react.verbose) {
      logger.logInformation(`    ✔ ${evaluatedNode.name} (branch)`);
    }
    let branchComponentTreeState = reconciler.componentTreeState;
    applyWriteEffectsForOptimizedComponent(realm, branchComponentType, branchEffects, branchComponentTreeState, evaluatedNode, writeEffects, environmentRecordIdAfterGlobalCode);
  }
}

function optimizeReactNestedClosures(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger) {
  if (realm.react.verbose && reconciler.nestedOptimizedClosures.length > 0) {
    logger.logInformation(`  Evaluating nested closures...`);
  }
  for (let _ref2 of reconciler.nestedOptimizedClosures) {
    let { func, evaluatedNode, nestedEffects, componentType, context } = _ref2;

    if (reconciler.hasEvaluatedNestedClosure(func)) {
      continue;
    }
    if (func instanceof _index.ECMAScriptSourceFunctionValue && reconciler.hasEvaluatedRootNode(func, evaluatedNode)) {
      continue;
    }
    if (realm.react.verbose) {
      logger.logInformation(`    Evaluating function "${(0, _utils2.getComponentName)(realm, func)}"`);
    }
    let closureEffects = reconciler.resolveNestedOptimizedClosure(func, nestedEffects, componentType, context, evaluatedNode);
    if (realm.react.verbose) {
      logger.logInformation(`    ✔ function "${(0, _utils2.getComponentName)(realm, func)}"`);
    }
    let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(realm, closureEffects, true, "ReactNestedAdditionalFunctionEffects", environmentRecordIdAfterGlobalCode);
    (0, _invariant2.default)(additionalFunctionEffects);
    if (func instanceof _index.BoundFunctionValue) {
      (0, _invariant2.default)(func.$BoundTargetFunction instanceof _index.ECMAScriptSourceFunctionValue);
      writeEffects.set(func.$BoundTargetFunction, additionalFunctionEffects);
    } else {
      writeEffects.set(func, additionalFunctionEffects);
    }
  }
}

function optimizeReactComponentTreeRoot(realm, componentRoot, config, writeEffects, environmentRecordIdAfterGlobalCode, logger, statistics) {
  let reconciler = new _reconcilation.Reconciler(realm, config, statistics, logger);
  let componentType = (0, _utils2.getComponentTypeFromRootValue)(realm, componentRoot);
  if (componentType === null) {
    return;
  }
  let evaluatedRootNode = (0, _utils2.createReactEvaluatedNode)("ROOT", (0, _utils2.getComponentName)(realm, componentType));
  statistics.evaluatedRootNodes.push(evaluatedRootNode);
  if (reconciler.hasEvaluatedRootNode(componentType, evaluatedRootNode)) {
    return;
  }
  if (realm.react.verbose) {
    logger.logInformation(`  Evaluating ${evaluatedRootNode.name} (root)`);
  }
  let componentTreeEffects = reconciler.resolveReactComponentTree(componentType, null, null, evaluatedRootNode);
  if (realm.react.verbose) {
    logger.logInformation(`  ✔ ${evaluatedRootNode.name} (root)`);
  }

  applyWriteEffectsForOptimizedComponent(realm, componentType, componentTreeEffects, reconciler.componentTreeState, evaluatedRootNode, writeEffects, environmentRecordIdAfterGlobalCode);

  let startingComponentTreeBranches = 0;
  do {
    startingComponentTreeBranches = reconciler.branchedComponentTrees.length;
    optimizeReactComponentTreeBranches(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger);
    if (realm.react.optimizeNestedFunctions) {
      optimizeReactNestedClosures(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger);
    }
  } while (startingComponentTreeBranches !== reconciler.branchedComponentTrees.length);
}

function applyOptimizedReactComponents(realm, writeEffects, environmentRecordIdAfterGlobalCode) {
  for (let _ref3 of realm.react.optimizedNestedClosuresToWrite) {
    let { effects, func } = _ref3;

    let additionalFunctionEffects = (0, _utils.createAdditionalEffects)(realm, effects, true, "ReactNestedAdditionalFunctionEffects", environmentRecordIdAfterGlobalCode);
    (0, _invariant2.default)(additionalFunctionEffects);
    if (func instanceof _index.BoundFunctionValue) {
      (0, _invariant2.default)(func.$BoundTargetFunction instanceof _index.ECMAScriptSourceFunctionValue);
      writeEffects.set(func.$BoundTargetFunction, additionalFunctionEffects);
    } else {
      writeEffects.set(func, additionalFunctionEffects);
    }
  }
}
//# sourceMappingURL=optimizing.js.map