{"version":3,"sources":["../../src/react/reconcilation.js"],"names":["t","setContextCurrentValue","contextObject","value","values","isTop","elements","getElements","size","element","binding","properties","get","descriptor","Reconciler","constructor","realm","componentTreeConfig","statistics","logger","componentTreeState","_createComponentTreeState","alreadyEvaluatedRootNodes","Map","alreadyEvaluatedNestedClosures","Set","nestedOptimizedClosures","branchedComponentTrees","resolveReactComponentTree","componentType","props","context","evaluatedRootNode","resolveComponentTree","initialProps","initialContext","set","result","_resolveComponent","optimizedTrees","error","_handleComponentTreeRootFailure","react","activeReconciler","throwUnsupportedSideEffectError","msg","effects","wrapInGlobalEnv","evaluatePure","evaluateForEffects","sideEffectType","expressionLocation","_handleNestedOptimizedClosuresFromEffects","undefined","evaluatedNode","nestedEffects","length","push","resolveNestedOptimizedClosure","func","resolveOptimizedClosure","baseObject","$GlobalEnv","environmentRecord","WithBaseObject","$BoundThis","$BoundTargetFunction","numArgs","getLength","args","targetFunc","add","params","$FormalParameters","parameterId","isIdentifier","createAbstractArgument","name","handleError","_resolveDeeply","optimizedNestedClosures","clearComponentTreeState","_queueOptimizedClosure","optimizeNestedFunctions","_queueNewComponentTree","rootValue","deadEnds","hasEvaluatedRootNode","_resolveComplexClassComponent","classMetadata","branchStatus","evaluatedComplexNode","status","instance","renderMethod","_resolveSimpleClassComponent","_resolveFunctionalComponent","intrinsics","_getClassComponentMetadata","classComponentMetadata","has","_resolveContextProviderComponent","reactElement","typeValue","propsValue","evaluatedChildNode","children","componentsEvaluated","contextConsumer","lastValueProp","_incremementReferenceForContextNode","valueProp","firstRenderOnly","resolvedReactElement","_resolveReactElementHostChildren","resolvedPropsValue","_decremementReferenceForContextNode","childrenValue","inlinedComponents","contextNode","references","contextNodeReferences","_isContextValueKnown","isRoot","_resolveContextConsumerComponent","renderProp","_findReactComponentTrees","_resolveForwardRefComponent","refValue","reactHint","abstractHints","forwardedComponent","_resolveRelayQueryRendererComponent","_resolveClassComponent","instanceProperties","instanceSymbols","_resolveClassComponentForFirstRenderOnly","getDerivedStateFromProps","getSnapshotBeforeUpdate","$Call","componentWillMount","unsafeComponentWillMount","_resolveRelayContainer","message","firstRenderValue","abstractRelayContext","createAbstractObject","abstractRelayEnvironment","abstractRelayInternal","contextTypes","object","fbLibraries","reactRelay","childContext","_getComponentResolutionStrategy","QueryRenderer","propertyName","kind","$$typeof","_resolveReactDomPortal","createPortalNode","reactPortalValue","domNodeValue","resolvedReactPortalValue","reactDomValue","reactDom","reactDomPortalFunc","createTemporalFromBuildFunction","renderNode","_args","callExpression","skipInvariant","isPure","_resolveAbstractConditionalValue","condValue","consequentVal","alternateVal","evaluateWithAbstractConditional","_resolveAbstractLogicalValue","leftValue","rightValue","operator","_resolveAbstractValue","generator","_resolveUnknownComponentType","bailOutMessage","_assignBailOutMessage","_resolveReactElementBadRef","_resolveReactElementUndefinedRender","resolvedChildren","intrinsicName","newProps","_resolveFragmentComponent","_resolveReactElement","componentResolutionStrategy","render","verbose","logInformation","_resolveComponentResolutionFailure","stack","_isFinal","_resolveArray","location","$BailOutReason","arrayValue","isIntrinsicAndHasWidenedNumericProperty","arrayHint","arrayHints","thisVal","elementValue","makeFinal","evaluateNode","alreadyEvaluatedNode","hasEvaluatedNestedClosure","treatFunctionsAs","arg","ref","propName","enumerable"],"mappings":"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","file":"reconcilation.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm, type Effects } from \"../realm.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  Value,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport { ReactStatistics, type ReactEvaluatedNode } from \"../serializer/types.js\";\nimport {\n  cloneReactElement,\n  cloneProps,\n  createReactEvaluatedNode,\n  doNotOptimizeComponent,\n  evaluateWithNestedParentEffects,\n  flattenChildren,\n  hardModifyReactObjectPropertyBinding,\n  getComponentName,\n  getComponentTypeFromRootValue,\n  getLocationFromValue,\n  getProperty,\n  getReactSymbol,\n  getValueFromFunctionCall,\n  isReactElement,\n  mapArrayValue,\n  valueIsClassComponent,\n  valueIsFactoryClassComponent,\n  valueIsKnownReactAbstraction,\n  valueIsLegacyCreateClassComponent,\n} from \"./utils\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { Properties } from \"../singletons.js\";\nimport { FatalError, CompilerDiagnostic } from \"../errors.js\";\nimport {\n  type BranchStatusEnum,\n  getValueWithBranchingLogicApplied,\n  wrapReactElementInBranchOrReturnValue,\n} from \"./branching.js\";\nimport * as t from \"babel-types\";\nimport { Completion } from \"../completions.js\";\nimport {\n  getInitialProps,\n  getInitialContext,\n  createClassInstance,\n  createSimpleClassInstance,\n  evaluateClassConstructor,\n  createClassInstanceForFirstRenderOnly,\n  applyGetDerivedStateFromProps,\n} from \"./components.js\";\nimport {\n  DoNotOptimize,\n  ExpectedBailOut,\n  NewComponentTreeBranch,\n  ReconcilerFatalError,\n  SimpleClassBailOut,\n  UnsupportedSideEffect,\n} from \"./errors.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport type { ClassComponentMetadata, ReactComponentTreeConfig, ReactHint } from \"../types.js\";\nimport { handleReportedSideEffect } from \"../serializer/utils.js\";\n\ntype ComponentResolutionStrategy =\n  | \"NORMAL\"\n  | \"FRAGMENT\"\n  | \"RELAY_QUERY_RENDERER\"\n  | \"CONTEXT_PROVIDER\"\n  | \"CONTEXT_CONSUMER\"\n  | \"FORWARD_REF\";\n\nexport type OptimizedClosure = {\n  evaluatedNode: ReactEvaluatedNode,\n  func: ECMAScriptSourceFunctionValue | BoundFunctionValue,\n  nestedEffects: Array<Effects>,\n  componentType: Value | null,\n  context: ObjectValue | AbstractObjectValue | null,\n};\n\nexport type BranchReactComponentTree = {\n  context: ObjectValue | AbstractObjectValue | null,\n  evaluatedNode: ReactEvaluatedNode,\n  props: ObjectValue | AbstractObjectValue | null,\n  rootValue: ECMAScriptSourceFunctionValue | AbstractValue,\n};\n\nexport type ComponentTreeState = {\n  componentType: void | ECMAScriptSourceFunctionValue,\n  contextTypes: Set<string>,\n  deadEnds: number,\n  status: \"SIMPLE\" | \"COMPLEX\",\n  contextNodeReferences: Map<ObjectValue | AbstractObjectValue, number>,\n};\n\nfunction setContextCurrentValue(contextObject: ObjectValue | AbstractObjectValue, value: Value): void {\n  if (contextObject instanceof AbstractObjectValue && !contextObject.values.isTop()) {\n    let elements = contextObject.values.getElements();\n    if (elements && elements.size === 1) {\n      for (let element of elements) {\n        invariant(element instanceof ObjectValue);\n        contextObject = element;\n      }\n    } else {\n      invariant(false, \"TODO: deal with multiple possible context objects\");\n    }\n  }\n  if (!(contextObject instanceof ObjectValue)) {\n    throw new ExpectedBailOut(\"cannot set currentValue on an abstract context consumer\");\n  }\n  let binding = contextObject.properties.get(\"currentValue\");\n\n  if (binding && binding.descriptor) {\n    binding.descriptor.value = value;\n  } else {\n    invariant(false, \"setContextCurrentValue failed to set the currentValue\");\n  }\n}\n\nexport class Reconciler {\n  constructor(\n    realm: Realm,\n    componentTreeConfig: ReactComponentTreeConfig,\n    statistics: ReactStatistics,\n    logger?: Logger\n  ) {\n    this.realm = realm;\n    this.statistics = statistics;\n    this.logger = logger;\n    this.componentTreeConfig = componentTreeConfig;\n    this.componentTreeState = this._createComponentTreeState();\n    this.alreadyEvaluatedRootNodes = new Map();\n    this.alreadyEvaluatedNestedClosures = new Set();\n    this.nestedOptimizedClosures = [];\n    this.branchedComponentTrees = [];\n  }\n\n  realm: Realm;\n  statistics: ReactStatistics;\n  logger: void | Logger;\n  componentTreeState: ComponentTreeState;\n  alreadyEvaluatedRootNodes: Map<ECMAScriptSourceFunctionValue, ReactEvaluatedNode>;\n  alreadyEvaluatedNestedClosures: Set<FunctionValue>;\n  componentTreeConfig: ReactComponentTreeConfig;\n  currentEffectsStack: Array<Effects>;\n  nestedOptimizedClosures: Array<OptimizedClosure>;\n  branchedComponentTrees: Array<BranchReactComponentTree>;\n\n  resolveReactComponentTree(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue | null,\n    context: ObjectValue | AbstractObjectValue | null,\n    evaluatedRootNode: ReactEvaluatedNode\n  ): Effects {\n    const resolveComponentTree = () => {\n      try {\n        let initialProps = props || getInitialProps(this.realm, componentType);\n        let initialContext = context || getInitialContext(this.realm, componentType);\n        this.alreadyEvaluatedRootNodes.set(componentType, evaluatedRootNode);\n        let { result } = this._resolveComponent(componentType, initialProps, initialContext, \"ROOT\", evaluatedRootNode);\n        this.statistics.optimizedTrees++;\n        return result;\n      } catch (error) {\n        this._handleComponentTreeRootFailure(error, evaluatedRootNode);\n        // flow belives we can get here, when it should never be possible\n        invariant(false, \"resolveReactComponentTree error not handled correctly\");\n      }\n    };\n\n    try {\n      this.realm.react.activeReconciler = this;\n      let throwUnsupportedSideEffectError = (msg: string) => {\n        throw new UnsupportedSideEffect(msg);\n      };\n      let effects = this.realm.wrapInGlobalEnv(() =>\n        this.realm.evaluatePure(\n          () =>\n            this.realm.evaluateForEffects(\n              resolveComponentTree,\n              /*state*/ null,\n              `react component: ${getComponentName(this.realm, componentType)}`\n            ),\n          (sideEffectType, binding, expressionLocation) =>\n            handleReportedSideEffect(throwUnsupportedSideEffectError, sideEffectType, binding, expressionLocation)\n        )\n      );\n      this._handleNestedOptimizedClosuresFromEffects(effects, evaluatedRootNode);\n      return effects;\n    } finally {\n      this.realm.react.activeReconciler = undefined;\n    }\n  }\n\n  _handleNestedOptimizedClosuresFromEffects(effects: Effects, evaluatedNode: ReactEvaluatedNode) {\n    for (let { nestedEffects } of this.nestedOptimizedClosures) {\n      if (nestedEffects.length === 0) {\n        nestedEffects.push(...nestedEffects, effects);\n      }\n    }\n  }\n\n  resolveNestedOptimizedClosure(\n    func: ECMAScriptSourceFunctionValue | BoundFunctionValue,\n    nestedEffects: Array<Effects>,\n    componentType: Value | null,\n    context: ObjectValue | AbstractObjectValue | null,\n    evaluatedNode: ReactEvaluatedNode\n  ): Effects {\n    const resolveOptimizedClosure = () => {\n      let baseObject = this.realm.$GlobalEnv.environmentRecord.WithBaseObject();\n      // we want to optimize the function that is bound\n      if (func instanceof BoundFunctionValue) {\n        // we want to set the \"this\" to be the bound object\n        // for firstRender this will optimize the function\n        // for updates, \"this\" will be intrinsic, so either way\n        // they should both work\n        baseObject = func.$BoundThis;\n        invariant(func.$BoundTargetFunction instanceof ECMAScriptSourceFunctionValue);\n        func = func.$BoundTargetFunction;\n      }\n      let numArgs = func.getLength();\n      let args = [];\n      let targetFunc = func;\n\n      this.alreadyEvaluatedNestedClosures.add(func);\n      invariant(targetFunc instanceof ECMAScriptSourceFunctionValue);\n      let params = targetFunc.$FormalParameters;\n      if (numArgs && numArgs > 0 && params) {\n        for (let parameterId of params) {\n          if (t.isIdentifier(parameterId)) {\n            // Create an AbstractValue similar to __abstract being called\n            args.push(\n              AbstractValue.createAbstractArgument(\n                this.realm,\n                ((parameterId: any): BabelNodeIdentifier).name,\n                targetFunc.expressionLocation\n              )\n            );\n          } else {\n            this.realm.handleError(\n              new CompilerDiagnostic(\n                \"Non-identifier args to additional functions unsupported\",\n                targetFunc.expressionLocation,\n                \"PP1005\",\n                \"FatalError\"\n              )\n            );\n            throw new FatalError(\"Non-identifier args to additional functions unsupported\");\n          }\n        }\n      }\n      try {\n        invariant(\n          baseObject instanceof ObjectValue ||\n            baseObject instanceof AbstractObjectValue ||\n            baseObject instanceof UndefinedValue\n        );\n        let value = getValueFromFunctionCall(this.realm, func, baseObject, args);\n        invariant(componentType instanceof Value);\n        invariant(context instanceof ObjectValue || context instanceof AbstractObjectValue);\n        let result = this._resolveDeeply(componentType, value, context, \"NEW_BRANCH\", evaluatedNode);\n        this.statistics.optimizedNestedClosures++;\n        return result;\n      } catch (error) {\n        this._handleComponentTreeRootFailure(error, evaluatedNode);\n        // flow belives we can get here, when it should never be possible\n        invariant(false, \"resolveNestedOptimizedClosure error not handled correctly\");\n      }\n    };\n\n    try {\n      this.realm.react.activeReconciler = this;\n      let throwUnsupportedSideEffectError = (msg: string) => {\n        throw new UnsupportedSideEffect(msg);\n      };\n      let effects = this.realm.wrapInGlobalEnv(() =>\n        this.realm.evaluatePure(\n          () =>\n            evaluateWithNestedParentEffects(this.realm, nestedEffects, () =>\n              this.realm.evaluateForEffects(resolveOptimizedClosure, /*state*/ null, `react nested optimized closure`)\n            ),\n          (sideEffectType, binding, expressionLocation) =>\n            handleReportedSideEffect(throwUnsupportedSideEffectError, sideEffectType, binding, expressionLocation)\n        )\n      );\n      this._handleNestedOptimizedClosuresFromEffects(effects, evaluatedNode);\n      return effects;\n    } finally {\n      this.realm.react.activeReconciler = undefined;\n    }\n  }\n\n  clearComponentTreeState(): void {\n    this.componentTreeState = this._createComponentTreeState();\n  }\n\n  _queueOptimizedClosure(\n    func: ECMAScriptSourceFunctionValue | BoundFunctionValue,\n    evaluatedNode: ReactEvaluatedNode,\n    componentType: Value | null,\n    context: ObjectValue | AbstractObjectValue | null\n  ): void {\n    if (this.realm.react.optimizeNestedFunctions) {\n      this.nestedOptimizedClosures.push({\n        evaluatedNode,\n        func,\n        nestedEffects: [],\n        componentType,\n        context,\n      });\n    }\n  }\n\n  _queueNewComponentTree(\n    rootValue: Value,\n    evaluatedNode: ReactEvaluatedNode,\n    props?: ObjectValue | AbstractObjectValue | null = null,\n    context?: ObjectValue | AbstractObjectValue | null = null\n  ): void {\n    if (rootValue instanceof SymbolValue) {\n      return;\n    }\n    invariant(rootValue instanceof ECMAScriptSourceFunctionValue || rootValue instanceof AbstractValue);\n    this.componentTreeState.deadEnds++;\n    let componentType = getComponentTypeFromRootValue(this.realm, rootValue);\n    if (componentType !== null && !this.hasEvaluatedRootNode(componentType, evaluatedNode)) {\n      this.branchedComponentTrees.push({\n        context,\n        evaluatedNode,\n        props,\n        rootValue,\n      });\n    }\n  }\n\n  _resolveComplexClassComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    classMetadata: ClassComponentMetadata,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    if (branchStatus !== \"ROOT\") {\n      // if the tree is simple and we're not in a branch, we can make this tree complex\n      // and make this complex component the root\n      let evaluatedComplexNode = this.alreadyEvaluatedRootNodes.get(componentType);\n      if (\n        branchStatus === \"NO_BRANCH\" &&\n        this.componentTreeState.status === \"SIMPLE\" &&\n        evaluatedComplexNode &&\n        evaluatedComplexNode.status !== \"RENDER_PROPS\"\n      ) {\n        this.componentTreeState.componentType = componentType;\n      } else {\n        this._queueNewComponentTree(componentType, evaluatedNode);\n        evaluatedNode.status = \"NEW_TREE\";\n        throw new NewComponentTreeBranch(evaluatedNode);\n      }\n    }\n    this.componentTreeState.status = \"COMPLEX\";\n    // create a new instance of this React class component\n    let instance = createClassInstance(this.realm, componentType, props, context, classMetadata);\n    // get the \"render\" method off the instance\n    let renderMethod = Get(this.realm, instance, \"render\");\n    invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n    // the render method doesn't have any arguments, so we just assign the context of \"this\" to be the instance\n    return getValueFromFunctionCall(this.realm, renderMethod, instance, []);\n  }\n\n  _resolveSimpleClassComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    // create a new simple instance of this React class component\n    let instance = createSimpleClassInstance(this.realm, componentType, props, context);\n    // get the \"render\" method off the instance\n    let renderMethod = Get(this.realm, instance, \"render\");\n    invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n    // the render method doesn't have any arguments, so we just assign the context of \"this\" to be the instance\n    return getValueFromFunctionCall(this.realm, renderMethod, instance, []);\n  }\n\n  _resolveFunctionalComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    return getValueFromFunctionCall(this.realm, componentType, this.realm.intrinsics.undefined, [props, context]);\n  }\n\n  _getClassComponentMetadata(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue\n  ): ClassComponentMetadata {\n    if (this.realm.react.classComponentMetadata.has(componentType)) {\n      let classMetadata = this.realm.react.classComponentMetadata.get(componentType);\n      invariant(classMetadata);\n      return classMetadata;\n    }\n    // get all this assignments in the constructor\n    let classMetadata = evaluateClassConstructor(this.realm, componentType, props, context);\n    this.realm.react.classComponentMetadata.set(componentType, classMetadata);\n    return classMetadata;\n  }\n\n  _resolveContextProviderComponent(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n\n    let evaluatedChildNode = createReactEvaluatedNode(\"NORMAL\", \"Context.Provider\");\n    evaluatedNode.children.push(evaluatedChildNode);\n    this.statistics.componentsEvaluated++;\n    invariant(typeValue instanceof ObjectValue || typeValue instanceof AbstractObjectValue);\n    const contextConsumer = getProperty(this.realm, typeValue, \"context\");\n    invariant(contextConsumer instanceof ObjectValue || contextConsumer instanceof AbstractObjectValue);\n    let lastValueProp = getProperty(this.realm, contextConsumer, \"currentValue\");\n    this._incremementReferenceForContextNode(contextConsumer);\n\n    let valueProp;\n    // if we have a value prop, set it\n    if (propsValue instanceof ObjectValue || propsValue instanceof AbstractObjectValue) {\n      valueProp = Get(this.realm, propsValue, \"value\");\n      setContextCurrentValue(contextConsumer, valueProp);\n    }\n    if (propsValue instanceof ObjectValue) {\n      // if the value is abstract, we need to keep the render prop as unless\n      // we are in firstRenderOnly mode, where we can just inline the abstract value\n      if (!(valueProp instanceof AbstractValue) || this.componentTreeConfig.firstRenderOnly) {\n        let resolvedReactElement = this._resolveReactElementHostChildren(\n          componentType,\n          reactElement,\n          context,\n          branchStatus,\n          evaluatedChildNode\n        );\n        let resolvedPropsValue = getProperty(this.realm, resolvedReactElement, \"props\");\n        invariant(resolvedPropsValue instanceof ObjectValue || resolvedPropsValue instanceof AbstractObjectValue);\n        invariant(lastValueProp instanceof Value);\n        setContextCurrentValue(contextConsumer, lastValueProp);\n        this._decremementReferenceForContextNode(contextConsumer);\n        // if we no dead ends, we know the rest of the tree and can safely remove the provider\n        if (this.componentTreeState.deadEnds === 0) {\n          let childrenValue = Get(this.realm, resolvedPropsValue, \"children\");\n          evaluatedChildNode.status = \"INLINED\";\n          this.statistics.inlinedComponents++;\n          return childrenValue;\n        }\n        return resolvedReactElement;\n      }\n    }\n    let children = this._resolveReactElementHostChildren(\n      componentType,\n      reactElement,\n      context,\n      branchStatus,\n      evaluatedChildNode\n    );\n    setContextCurrentValue(contextConsumer, lastValueProp);\n    this._decremementReferenceForContextNode(contextConsumer);\n    return children;\n  }\n\n  _decremementReferenceForContextNode(contextNode: ObjectValue | AbstractObjectValue): void {\n    let references = this.componentTreeState.contextNodeReferences.get(contextNode);\n    if (!references) {\n      references = 0;\n    } else {\n      references--;\n    }\n    this.componentTreeState.contextNodeReferences.set(contextNode, references);\n  }\n\n  _incremementReferenceForContextNode(contextNode: ObjectValue | AbstractObjectValue): void {\n    let references = this.componentTreeState.contextNodeReferences.get(contextNode);\n    if (!references) {\n      references = 1;\n    } else {\n      references++;\n    }\n    this.componentTreeState.contextNodeReferences.set(contextNode, references);\n  }\n\n  _isContextValueKnown(contextNode: ObjectValue | AbstractObjectValue): boolean {\n    if (this.componentTreeConfig.isRoot) {\n      return true;\n    }\n    if (this.componentTreeState.contextNodeReferences.has(contextNode)) {\n      let references = this.componentTreeState.contextNodeReferences.get(contextNode);\n      if (!references) {\n        return false;\n      }\n      return references > 0;\n    }\n    return false;\n  }\n\n  _resolveContextConsumerComponent(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value | void {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n    let evaluatedChildNode = createReactEvaluatedNode(\"RENDER_PROPS\", \"Context.Consumer\");\n    evaluatedNode.children.push(evaluatedChildNode);\n\n    if (propsValue instanceof ObjectValue || propsValue instanceof AbstractObjectValue) {\n      // get the \"render\" prop child off the instance\n      if (propsValue instanceof ObjectValue && propsValue.properties.has(\"children\")) {\n        let renderProp = getProperty(this.realm, propsValue, \"children\");\n\n        this._findReactComponentTrees(propsValue, evaluatedChildNode, \"NORMAL_FUNCTIONS\");\n        if (renderProp instanceof ECMAScriptSourceFunctionValue) {\n          if (typeValue instanceof ObjectValue || typeValue instanceof AbstractObjectValue) {\n            // make sure this context is in our tree\n            if (this._isContextValueKnown(typeValue)) {\n              let valueProp = Get(this.realm, typeValue, \"currentValue\");\n              // if the value is abstract, we need to keep the render prop as unless\n              // we are in firstRenderOnly mode, where we can just inline the abstract value\n              if (!(valueProp instanceof AbstractValue) || this.componentTreeConfig.firstRenderOnly) {\n                let result = getValueFromFunctionCall(this.realm, renderProp, this.realm.intrinsics.undefined, [\n                  valueProp,\n                ]);\n                this.statistics.inlinedComponents++;\n                this.statistics.componentsEvaluated++;\n                evaluatedChildNode.status = \"INLINED\";\n                return this._resolveDeeply(componentType, result, context, branchStatus, evaluatedNode);\n              }\n            }\n          }\n          this._queueOptimizedClosure(renderProp, evaluatedChildNode, componentType, context);\n          return;\n        } else {\n          this._findReactComponentTrees(renderProp, evaluatedChildNode, \"NESTED_CLOSURES\");\n        }\n      }\n    }\n    this.componentTreeState.deadEnds++;\n    return;\n  }\n\n  _resolveForwardRefComponent(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value | void {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n    let refValue = getProperty(this.realm, reactElement, \"ref\");\n    invariant(typeValue instanceof AbstractValue || typeValue instanceof ObjectValue);\n    let reactHint = this.realm.react.abstractHints.get(typeValue);\n\n    invariant(reactHint !== undefined);\n    let [forwardedComponent] = reactHint.args;\n    let evaluatedChildNode = createReactEvaluatedNode(\"FORWARD_REF\", getComponentName(this.realm, forwardedComponent));\n    evaluatedNode.children.push(evaluatedChildNode);\n    invariant(\n      forwardedComponent instanceof ECMAScriptSourceFunctionValue,\n      \"expect React.forwardRef() to be passed function value\"\n    );\n    let value = getValueFromFunctionCall(this.realm, forwardedComponent, this.realm.intrinsics.undefined, [\n      propsValue,\n      refValue,\n    ]);\n    return this._resolveDeeply(componentType, value, context, branchStatus, evaluatedChildNode);\n  }\n\n  _resolveRelayQueryRendererComponent(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value | void {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n\n    let evaluatedChildNode = createReactEvaluatedNode(\"RENDER_PROPS\", getComponentName(this.realm, typeValue));\n    evaluatedNode.children.push(evaluatedChildNode);\n\n    if (propsValue instanceof ObjectValue || propsValue instanceof AbstractObjectValue) {\n      // get the \"render\" prop\n      if (propsValue instanceof ObjectValue && propsValue.properties.has(\"render\")) {\n        let renderProp = getProperty(this.realm, propsValue, \"render\");\n\n        if (renderProp instanceof ECMAScriptSourceFunctionValue) {\n          this._queueOptimizedClosure(renderProp, evaluatedChildNode, componentType, context);\n        } else if (renderProp instanceof AbstractValue) {\n          this._findReactComponentTrees(renderProp, evaluatedChildNode, \"NESTED_CLOSURES\", componentType, context);\n        }\n      }\n      this._findReactComponentTrees(propsValue, evaluatedChildNode, \"NORMAL_FUNCTIONS\");\n      return;\n    }\n    // this is the worst case, we were unable to find the render prop function\n    // and won't be able to find any further components to evaluate as trees\n    // because of that\n    this.componentTreeState.deadEnds++;\n  }\n\n  _resolveClassComponent(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    let value;\n\n    let classMetadata = this._getClassComponentMetadata(componentType, props, context);\n    let { instanceProperties, instanceSymbols } = classMetadata;\n\n    // if there were no this assignments we can try and render it as a simple class component\n    if (instanceProperties.size === 0 && instanceSymbols.size === 0) {\n      // We first need to know what type of class component we're dealing with.\n      // A \"simple\" class component is defined as:\n      //\n      // - having only a \"render\" method\n      // - having no lifecycle events\n      // - having no state\n      // - having no instance variables\n      //\n      // the only things a class component should be able to access on \"this\" are:\n      // - this.props\n      // - this.context\n      // - this._someRenderMethodX() etc\n      //\n      // Otherwise, the class component is a \"complex\" one.\n      // To begin with, we don't know what type of component it is, so we try and render it as if it were\n      // a simple component using the above heuristics. If an error occurs during this process, we assume\n      // that the class wasn't simple, then try again with the \"complex\" heuristics.\n      try {\n        value = this._resolveSimpleClassComponent(componentType, props, context, branchStatus, evaluatedNode);\n      } catch (error) {\n        // if we get back a SimpleClassBailOut error, we know that this class component\n        // wasn't a simple one and is likely to be a complex class component instead\n        if (error instanceof SimpleClassBailOut) {\n          // the component was not simple, so we continue with complex case\n        } else {\n          // else we rethrow the error\n          throw error;\n        }\n      }\n    }\n    // handle the complex class component if there is not value\n    if (value === undefined) {\n      value = this._resolveComplexClassComponent(\n        componentType,\n        props,\n        context,\n        classMetadata,\n        branchStatus,\n        evaluatedNode\n      );\n    }\n    return value;\n  }\n\n  _resolveClassComponentForFirstRenderOnly(\n    componentType: ECMAScriptSourceFunctionValue,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    // create a new simple instance of this React class component\n    let instance = createClassInstanceForFirstRenderOnly(this.realm, componentType, props, context, evaluatedNode);\n    let getDerivedStateFromProps = Get(this.realm, componentType, \"getDerivedStateFromProps\");\n    let getSnapshotBeforeUpdate = Get(this.realm, instance, \"getSnapshotBeforeUpdate\");\n\n    // if either getDerivedStateFromProps or getSnapshotBeforeUpdate exist, then\n    // we don't try and execute componentWillMount and UNSAFE_componentWillMount\n    if (\n      getDerivedStateFromProps !== this.realm.intrinsics.undefined ||\n      getSnapshotBeforeUpdate !== this.realm.intrinsics.undefined\n    ) {\n      if (getDerivedStateFromProps instanceof ECMAScriptSourceFunctionValue && getDerivedStateFromProps.$Call) {\n        applyGetDerivedStateFromProps(this.realm, getDerivedStateFromProps, instance, props);\n      }\n    } else {\n      // get the \"componentWillMount\" and \"render\" methods off the instance\n      let componentWillMount = Get(this.realm, instance, \"componentWillMount\");\n\n      if (componentWillMount instanceof ECMAScriptSourceFunctionValue && componentWillMount.$Call) {\n        componentWillMount.$Call(instance, []);\n      }\n      let unsafeComponentWillMount = Get(this.realm, instance, \"UNSAFE_componentWillMount\");\n\n      if (unsafeComponentWillMount instanceof ECMAScriptSourceFunctionValue && unsafeComponentWillMount.$Call) {\n        unsafeComponentWillMount.$Call(instance, []);\n      }\n    }\n    let renderMethod = Get(this.realm, instance, \"render\");\n\n    invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n    return getValueFromFunctionCall(this.realm, renderMethod, instance, []);\n  }\n\n  _resolveRelayContainer(\n    reactHint: ReactHint,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    evaluatedNode.status = \"INLINED\";\n    evaluatedNode.message = \"RelayContainer\";\n    invariant(reactHint.firstRenderValue instanceof Value);\n    // for better serialization, ensure context has the right abstract properties defined\n    if (getProperty(this.realm, context, \"relay\") === this.realm.intrinsics.undefined) {\n      let abstractRelayContext = AbstractValue.createAbstractObject(this.realm, \"context.relay\");\n      let abstractRelayEnvironment = AbstractValue.createAbstractObject(this.realm, \"context.relay.environment\");\n      let abstractRelayInternal = AbstractValue.createAbstractObject(\n        this.realm,\n        \"context.relay.environment.unstable_internal\"\n      );\n      Properties.Set(this.realm, context, \"relay\", abstractRelayContext, true);\n      Properties.Set(this.realm, abstractRelayContext, \"environment\", abstractRelayEnvironment, true);\n      Properties.Set(this.realm, abstractRelayEnvironment, \"unstable_internal\", abstractRelayInternal, true);\n    }\n    // add contextType to this component\n    this.componentTreeState.contextTypes.add(\"relay\");\n    return this._resolveComponent(reactHint.firstRenderValue, props, context, branchStatus, evaluatedNode);\n  }\n\n  _resolveComponent(\n    componentType: Value,\n    props: ObjectValue | AbstractObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    if (doNotOptimizeComponent(this.realm, componentType)) {\n      throw new DoNotOptimize(\"__reactCompilerDoNotOptimize flag detected\");\n    }\n    this.statistics.componentsEvaluated++;\n    if (valueIsKnownReactAbstraction(this.realm, componentType)) {\n      invariant(componentType instanceof AbstractValue);\n      let reactHint = this.realm.react.abstractHints.get(componentType);\n\n      invariant(reactHint);\n      if (\n        typeof reactHint !== \"string\" &&\n        reactHint.object === this.realm.fbLibraries.reactRelay &&\n        this.componentTreeConfig.firstRenderOnly\n      ) {\n        return this._resolveRelayContainer(reactHint, props, context, branchStatus, evaluatedNode);\n      }\n      this._queueNewComponentTree(componentType, evaluatedNode);\n      evaluatedNode.status = \"NEW_TREE\";\n      evaluatedNode.message = \"RelayContainer\";\n      throw new NewComponentTreeBranch(evaluatedNode);\n    }\n    invariant(componentType instanceof ECMAScriptSourceFunctionValue);\n    let value;\n    let childContext = context;\n\n    // first we check if it's a legacy class component\n    if (valueIsLegacyCreateClassComponent(this.realm, componentType)) {\n      throw new ExpectedBailOut(\"components created with create-react-class are not supported\");\n    } else if (valueIsClassComponent(this.realm, componentType)) {\n      if (this.componentTreeConfig.firstRenderOnly) {\n        value = this._resolveClassComponentForFirstRenderOnly(\n          componentType,\n          props,\n          context,\n          branchStatus,\n          evaluatedNode\n        );\n      } else {\n        value = this._resolveClassComponent(componentType, props, context, branchStatus, evaluatedNode);\n      }\n    } else {\n      value = this._resolveFunctionalComponent(componentType, props, context, evaluatedNode);\n      if (valueIsFactoryClassComponent(this.realm, value)) {\n        invariant(value instanceof ObjectValue);\n        if (branchStatus !== \"ROOT\") {\n          throw new ExpectedBailOut(\"non-root factory class components are not suppoted\");\n        } else {\n          // TODO support factory components\n          return {\n            result: value,\n            childContext,\n          };\n        }\n      }\n    }\n    invariant(value !== undefined);\n    return {\n      result: this._resolveDeeply(\n        componentType,\n        value,\n        context,\n        branchStatus === \"ROOT\" ? \"NO_BRANCH\" : branchStatus,\n        evaluatedNode\n      ),\n      childContext,\n    };\n  }\n\n  _createComponentTreeState(): ComponentTreeState {\n    return {\n      componentType: undefined,\n      contextTypes: new Set(),\n      deadEnds: 0,\n      status: \"SIMPLE\",\n      contextNodeReferences: new Map(),\n    };\n  }\n\n  _getComponentResolutionStrategy(value: Value): ComponentResolutionStrategy {\n    // check if it's a ReactRelay.QueryRenderer\n    if (this.realm.fbLibraries.reactRelay !== undefined) {\n      let QueryRenderer = getProperty(this.realm, this.realm.fbLibraries.reactRelay, \"QueryRenderer\");\n      if (value === QueryRenderer) {\n        return \"RELAY_QUERY_RENDERER\";\n      }\n    }\n    if (value === getReactSymbol(\"react.fragment\", this.realm)) {\n      return \"FRAGMENT\";\n    }\n    if (value instanceof AbstractValue && this.realm.react.abstractHints.has(value)) {\n      let reactHint = this.realm.react.abstractHints.get(value);\n\n      invariant(reactHint !== undefined);\n      if (reactHint.object === this.realm.fbLibraries.react && reactHint.propertyName === \"forwardRef\") {\n        return \"FORWARD_REF\";\n      }\n    }\n    if ((value instanceof ObjectValue || value instanceof AbstractObjectValue) && value.kind !== \"conditional\") {\n      let $$typeof = getProperty(this.realm, value, \"$$typeof\");\n\n      if ($$typeof === getReactSymbol(\"react.context\", this.realm)) {\n        return \"CONTEXT_CONSUMER\";\n      }\n      if ($$typeof === getReactSymbol(\"react.provider\", this.realm)) {\n        return \"CONTEXT_PROVIDER\";\n      }\n    }\n    return \"NORMAL\";\n  }\n\n  _resolveReactDomPortal(\n    createPortalNode: AbstractValue,\n    args: Array<Value>,\n    componentType: Value,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    let [reactPortalValue, domNodeValue] = args;\n    let evaluatedChildNode = createReactEvaluatedNode(\"INLINED\", \"ReactDOM.createPortal\");\n    let resolvedReactPortalValue = this._resolveDeeply(\n      componentType,\n      reactPortalValue,\n      context,\n      branchStatus,\n      evaluatedChildNode\n    );\n    evaluatedNode.children.push(evaluatedChildNode);\n    if (resolvedReactPortalValue !== reactPortalValue) {\n      this.statistics.inlinedComponents++;\n      let reactDomValue = this.realm.fbLibraries.reactDom;\n      invariant(reactDomValue instanceof ObjectValue);\n      let reactDomPortalFunc = getProperty(this.realm, reactDomValue, \"createPortal\");\n      return AbstractValue.createTemporalFromBuildFunction(\n        this.realm,\n        ObjectValue,\n        [reactDomPortalFunc, resolvedReactPortalValue, domNodeValue],\n        ([renderNode, ..._args]) => {\n          return t.callExpression(renderNode, ((_args: any): Array<any>));\n        },\n        { skipInvariant: true, isPure: true }\n      );\n    }\n    return createPortalNode;\n  }\n\n  _resolveAbstractConditionalValue(\n    componentType: Value,\n    condValue: AbstractValue,\n    consequentVal: Value,\n    alternateVal: Value,\n    context: ObjectValue | AbstractObjectValue,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    let value = this.realm.evaluateWithAbstractConditional(\n      condValue,\n      () => {\n        return this.realm.evaluateForEffects(\n          () =>\n            wrapReactElementInBranchOrReturnValue(\n              this.realm,\n              this._resolveDeeply(componentType, consequentVal, context, \"NEW_BRANCH\", evaluatedNode)\n            ),\n          null,\n          \"_resolveAbstractConditionalValue consequent\"\n        );\n      },\n      () => {\n        return this.realm.evaluateForEffects(\n          () =>\n            wrapReactElementInBranchOrReturnValue(\n              this.realm,\n              this._resolveDeeply(componentType, alternateVal, context, \"NEW_BRANCH\", evaluatedNode)\n            ),\n          null,\n          \"_resolveAbstractConditionalValue alternate\"\n        );\n      }\n    );\n    if (value instanceof AbstractValue && value.kind === \"conditional\") {\n      return getValueWithBranchingLogicApplied(this.realm, consequentVal, alternateVal, value);\n    }\n    return value;\n  }\n\n  _resolveAbstractLogicalValue(\n    componentType: Value,\n    value: AbstractValue,\n    context: ObjectValue | AbstractObjectValue,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    let [leftValue, rightValue] = value.args;\n    let operator = value.kind;\n\n    invariant(leftValue instanceof AbstractValue);\n    if (operator === \"||\") {\n      return this._resolveAbstractConditionalValue(\n        componentType,\n        leftValue,\n        leftValue,\n        rightValue,\n        context,\n        evaluatedNode\n      );\n    } else {\n      return this._resolveAbstractConditionalValue(\n        componentType,\n        leftValue,\n        rightValue,\n        leftValue,\n        context,\n        evaluatedNode\n      );\n    }\n  }\n\n  _resolveAbstractValue(\n    componentType: Value,\n    value: AbstractValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    invariant(this.realm.generator);\n    // TODO investigate what other kinds than \"conditional\" might be safe to deeply resolve\n    if (value.kind === \"conditional\") {\n      let [condValue, consequentVal, alternateVal] = value.args;\n      invariant(condValue instanceof AbstractValue);\n      return this._resolveAbstractConditionalValue(\n        componentType,\n        condValue,\n        consequentVal,\n        alternateVal,\n        context,\n        evaluatedNode\n      );\n    } else if (value.kind === \"||\" || value.kind === \"&&\") {\n      return this._resolveAbstractLogicalValue(componentType, value, context, evaluatedNode);\n    } else {\n      if (value instanceof AbstractValue && this.realm.react.abstractHints.has(value)) {\n        let reactHint = this.realm.react.abstractHints.get(value);\n\n        invariant(reactHint !== undefined);\n        if (reactHint.object === this.realm.fbLibraries.reactDom && reactHint.propertyName === \"createPortal\") {\n          return this._resolveReactDomPortal(\n            value,\n            reactHint.args,\n            componentType,\n            context,\n            branchStatus,\n            evaluatedNode\n          );\n        }\n      }\n      this.componentTreeState.deadEnds++;\n    }\n    return value;\n  }\n\n  _resolveUnknownComponentType(reactElement: ObjectValue, evaluatedNode: ReactEvaluatedNode) {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n\n    this._findReactComponentTrees(propsValue, evaluatedNode, \"NORMAL_FUNCTIONS\");\n    if (typeValue instanceof AbstractValue) {\n      this._findReactComponentTrees(typeValue, evaluatedNode, \"FUNCTIONAL_COMPONENTS\");\n      return reactElement;\n    } else {\n      let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n      evaluatedNode.children.push(evaluatedChildNode);\n      let bailOutMessage = `type on <Component /> was not a ECMAScriptSourceFunctionValue`;\n      evaluatedChildNode.message = bailOutMessage;\n      this._assignBailOutMessage(reactElement, bailOutMessage);\n      this.componentTreeState.deadEnds++;\n      return reactElement;\n    }\n  }\n\n  _resolveReactElementBadRef(reactElement: ObjectValue, evaluatedNode: ReactEvaluatedNode) {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n\n    let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n    evaluatedNode.children.push(evaluatedChildNode);\n    let bailOutMessage = `refs are not supported on <Components />`;\n    evaluatedChildNode.message = bailOutMessage;\n\n    this._queueNewComponentTree(typeValue, evaluatedChildNode);\n    this._findReactComponentTrees(propsValue, evaluatedNode, \"NORMAL_FUNCTIONS\");\n    this._assignBailOutMessage(reactElement, bailOutMessage);\n    return reactElement;\n  }\n\n  _resolveReactElementUndefinedRender(\n    reactElement: ObjectValue,\n    evaluatedNode: ReactEvaluatedNode,\n    branchStatus: BranchStatusEnum\n  ) {\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n\n    let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n    evaluatedNode.children.push(evaluatedChildNode);\n    let bailOutMessage = `undefined was returned from render`;\n    evaluatedChildNode.message = bailOutMessage;\n\n    this._assignBailOutMessage(reactElement, bailOutMessage);\n    this._findReactComponentTrees(propsValue, evaluatedNode, \"NORMAL_FUNCTIONS\");\n    return reactElement;\n  }\n\n  _resolveReactElementHostChildren(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n    // terminal host component. Start evaluating its children.\n    if (propsValue instanceof ObjectValue && propsValue.properties.has(\"children\")) {\n      let childrenValue = Get(this.realm, propsValue, \"children\");\n\n      if (childrenValue instanceof Value) {\n        let resolvedChildren = this._resolveDeeply(componentType, childrenValue, context, branchStatus, evaluatedNode);\n        // we can optimize further and flatten arrays on non-composite components\n        if (resolvedChildren instanceof ArrayValue && !resolvedChildren.intrinsicName) {\n          resolvedChildren = flattenChildren(this.realm, resolvedChildren);\n        }\n        if (resolvedChildren !== childrenValue) {\n          let newProps = cloneProps(this.realm, propsValue, resolvedChildren);\n\n          // This is safe to do as we clone a new ReactElement as part of reconcilation\n          // so we will never be mutating an object used by something else. Furthermore,\n          // the ReactElement is \"immutable\" so it can never change and only React controls\n          // this object.\n          hardModifyReactObjectPropertyBinding(this.realm, reactElement, \"props\", newProps);\n        }\n      }\n    }\n    return reactElement;\n  }\n\n  _resolveFragmentComponent(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    this.statistics.componentsEvaluated++;\n    if (this.componentTreeConfig.firstRenderOnly) {\n      let evaluatedChildNode = createReactEvaluatedNode(\"INLINED\", \"React.Fragment\");\n      evaluatedNode.children.push(evaluatedChildNode);\n      this.statistics.inlinedComponents++;\n      let children = this._resolveReactElementHostChildren(\n        componentType,\n        reactElement,\n        context,\n        branchStatus,\n        evaluatedChildNode\n      );\n      return children;\n    } else {\n      let evaluatedChildNode = createReactEvaluatedNode(\"NORMAL\", \"React.Fragment\");\n      evaluatedNode.children.push(evaluatedChildNode);\n      return this._resolveReactElementHostChildren(\n        componentType,\n        reactElement,\n        context,\n        branchStatus,\n        evaluatedChildNode\n      );\n    }\n  }\n\n  _resolveReactElement(\n    componentType: Value,\n    reactElement: ObjectValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ) {\n    // We create a clone of the ReactElement to be safe. This is because the same\n    // ReactElement might be a temporal referenced in other effects and also it allows us to\n    // easily mutate and swap the props of the ReactElement with the optimized version with\n    // resolved/inlined children.\n    // Note: We used to sanitize out props for firstRender here, we now do this during serialization.\n    reactElement = cloneReactElement(this.realm, reactElement, false);\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n    let refValue = getProperty(this.realm, reactElement, \"ref\");\n\n    invariant(\n      !(typeValue instanceof AbstractValue && typeValue.kind === \"conditional\"),\n      `the reconciler should never encounter a ReactElement \"type\" that is conditional abstract value`\n    );\n    invariant(\n      !(propsValue instanceof AbstractValue && propsValue.kind === \"conditional\"),\n      `the reconciler should never encounter a ReactElement \"props\" that is conditional abstract value`\n    );\n\n    if (typeValue instanceof StringValue) {\n      return this._resolveReactElementHostChildren(componentType, reactElement, context, branchStatus, evaluatedNode);\n    }\n    if (!(propsValue instanceof ObjectValue || propsValue instanceof AbstractObjectValue)) {\n      this._assignBailOutMessage(\n        reactElement,\n        `props on <Component /> was not not an ObjectValue or an AbstractObjectValue`\n      );\n      return reactElement;\n    }\n    let componentResolutionStrategy = this._getComponentResolutionStrategy(typeValue);\n\n    // We do not support \"ref\" on <Component /> ReactElements, unless it's a forwarded ref\n    // or we are firstRenderOnly mode (in which case, we ignore the ref)\n    if (\n      !this.componentTreeConfig.firstRenderOnly &&\n      !(refValue instanceof NullValue) &&\n      componentResolutionStrategy !== \"FORWARD_REF\" &&\n      // If we have an abstract value, it might mean a bad ref, but we will have\n      // already thrown a FatalError in the createElement implementation by this\n      // point, so if we're here, then the FatalError has been recovered explicitly\n      !(refValue instanceof AbstractValue)\n    ) {\n      this._resolveReactElementBadRef(reactElement, evaluatedNode);\n    }\n    try {\n      let result;\n\n      switch (componentResolutionStrategy) {\n        case \"NORMAL\": {\n          if (\n            !(typeValue instanceof ECMAScriptSourceFunctionValue || valueIsKnownReactAbstraction(this.realm, typeValue))\n          ) {\n            return this._resolveUnknownComponentType(reactElement, evaluatedNode);\n          }\n          let evaluatedChildNode = createReactEvaluatedNode(\"INLINED\", getComponentName(this.realm, typeValue));\n          let render = this._resolveComponent(\n            typeValue,\n            propsValue,\n            context,\n            branchStatus === \"NEW_BRANCH\" ? \"BRANCH\" : branchStatus,\n            evaluatedChildNode\n          );\n          if (this.logger !== undefined && this.realm.react.verbose && evaluatedChildNode.status === \"INLINED\") {\n            this.logger.logInformation(`     ${evaluatedChildNode.name} (inlined)`);\n          }\n          evaluatedNode.children.push(evaluatedChildNode);\n          result = render.result;\n          this.statistics.inlinedComponents++;\n          break;\n        }\n        case \"FRAGMENT\": {\n          return this._resolveFragmentComponent(componentType, reactElement, context, branchStatus, evaluatedNode);\n        }\n        case \"RELAY_QUERY_RENDERER\": {\n          invariant(typeValue instanceof AbstractObjectValue);\n          result = this._resolveRelayQueryRendererComponent(componentType, reactElement, context, evaluatedNode);\n          break;\n        }\n        case \"CONTEXT_PROVIDER\": {\n          return this._resolveContextProviderComponent(\n            componentType,\n            reactElement,\n            context,\n            branchStatus,\n            evaluatedNode\n          );\n        }\n        case \"CONTEXT_CONSUMER\": {\n          result = this._resolveContextConsumerComponent(\n            componentType,\n            reactElement,\n            context,\n            branchStatus,\n            evaluatedNode\n          );\n          break;\n        }\n        case \"FORWARD_REF\": {\n          result = this._resolveForwardRefComponent(componentType, reactElement, context, branchStatus, evaluatedNode);\n          break;\n        }\n        default:\n          invariant(false, \"unsupported component resolution strategy\");\n      }\n\n      if (result === undefined) {\n        result = reactElement;\n      }\n      if (result instanceof UndefinedValue) {\n        return this._resolveReactElementUndefinedRender(reactElement, evaluatedNode, branchStatus);\n      }\n      return result;\n    } catch (error) {\n      return this._resolveComponentResolutionFailure(error, reactElement, evaluatedNode, branchStatus);\n    }\n  }\n\n  _handleComponentTreeRootFailure(error: Error | Completion, evaluatedRootNode: ReactEvaluatedNode): void {\n    if (error.name === \"Invariant Violation\") {\n      throw error;\n    } else if (error instanceof ReconcilerFatalError) {\n      throw new ReconcilerFatalError(error.message, evaluatedRootNode);\n    } else if (error instanceof UnsupportedSideEffect || error instanceof DoNotOptimize) {\n      throw new ReconcilerFatalError(\n        `Failed to render React component root \"${evaluatedRootNode.name}\" due to ${error.message}`,\n        evaluatedRootNode\n      );\n    } else if (error instanceof Completion) {\n      let value = error.value;\n      invariant(value instanceof ObjectValue);\n      let message = getProperty(this.realm, value, \"message\");\n      let stack = getProperty(this.realm, value, \"stack\");\n      invariant(message instanceof StringValue);\n      invariant(stack instanceof StringValue);\n      throw new ReconcilerFatalError(\n        `Failed to render React component \"${evaluatedRootNode.name}\" due to a JS error: ${message.value}\\n${\n          stack.value\n        }`,\n        evaluatedRootNode\n      );\n    }\n    let message;\n    if (error instanceof ExpectedBailOut) {\n      message = `Failed to optimize React component tree for \"${evaluatedRootNode.name}\" due to an expected bail-out: ${\n        error.message\n      }`;\n    } else if (error instanceof FatalError) {\n      message = `Failed to optimize React component tree for \"${\n        evaluatedRootNode.name\n      }\" due to a fatal error during evaluation: ${error.message}`;\n    } else {\n      // if we don't know what the error is, then best to rethrow\n      throw error;\n    }\n    throw new ReconcilerFatalError(message, evaluatedRootNode);\n  }\n\n  _resolveComponentResolutionFailure(\n    error: Error | Completion,\n    reactElement: ObjectValue,\n    evaluatedNode: ReactEvaluatedNode,\n    branchStatus: BranchStatusEnum\n  ): Value {\n    if (error.name === \"Invariant Violation\") {\n      throw error;\n    } else if (error instanceof ReconcilerFatalError) {\n      throw error;\n    } else if (error instanceof UnsupportedSideEffect) {\n      throw new ReconcilerFatalError(\n        `Failed to render React component \"${evaluatedNode.name}\" due to ${error.message}`,\n        evaluatedNode\n      );\n    } else if (error instanceof DoNotOptimize) {\n      return reactElement;\n    } else if (error instanceof Completion) {\n      let value = error.value;\n      invariant(value instanceof ObjectValue);\n      let message = getProperty(this.realm, value, \"message\");\n      let stack = getProperty(this.realm, value, \"stack\");\n      invariant(message instanceof StringValue);\n      invariant(stack instanceof StringValue);\n      throw new ReconcilerFatalError(\n        `Failed to render React component \"${evaluatedNode.name}\" due to a JS error: ${message.value}\\n${stack.value}`,\n        evaluatedNode\n      );\n    }\n    let typeValue = getProperty(this.realm, reactElement, \"type\");\n    let propsValue = getProperty(this.realm, reactElement, \"props\");\n    // assign a bail out message\n    if (error instanceof NewComponentTreeBranch) {\n      this._findReactComponentTrees(propsValue, evaluatedNode, \"NORMAL_FUNCTIONS\");\n      evaluatedNode.children.push(error.evaluatedNode);\n      // NO-OP (we don't queue a newComponentTree as this was already done)\n    } else {\n      let evaluatedChildNode = createReactEvaluatedNode(\"BAIL-OUT\", getComponentName(this.realm, typeValue));\n      if (this.logger !== undefined && this.realm.react.verbose) {\n        this.logger.logInformation(`     ${evaluatedChildNode.name} (bail-out)`);\n      }\n      evaluatedNode.children.push(evaluatedChildNode);\n      this._queueNewComponentTree(typeValue, evaluatedChildNode);\n      this._findReactComponentTrees(propsValue, evaluatedNode, \"NORMAL_FUNCTIONS\");\n      if (error instanceof ExpectedBailOut) {\n        evaluatedChildNode.message = error.message;\n        this._assignBailOutMessage(reactElement, error.message);\n      } else if (error instanceof FatalError) {\n        let message = \"evaluation failed\";\n        evaluatedChildNode.message = message;\n        this._assignBailOutMessage(reactElement, message);\n      } else {\n        evaluatedChildNode.message = `unknown error`;\n        throw error;\n      }\n    }\n    // a child component bailed out during component folding, so return the function value and continue\n    return reactElement;\n  }\n\n  _resolveDeeply(\n    componentType: Value,\n    value: Value,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): Value {\n    if (\n      value instanceof StringValue ||\n      value instanceof NumberValue ||\n      value instanceof BooleanValue ||\n      value instanceof NullValue ||\n      value instanceof UndefinedValue\n    ) {\n      // terminal values\n      return value;\n    }\n    invariant(\n      !(value instanceof ObjectValue) || value._isFinal !== undefined,\n      `An object value was detected during React reconcilation without its bindings properly applied`\n    );\n    if (value instanceof AbstractValue) {\n      return this._resolveAbstractValue(componentType, value, context, branchStatus, evaluatedNode);\n    } else if (value instanceof ArrayValue) {\n      // TODO investigate what about other iterables type objects\n      return this._resolveArray(componentType, value, context, branchStatus, evaluatedNode);\n    } else if (value instanceof ObjectValue && isReactElement(value)) {\n      return this._resolveReactElement(componentType, value, context, branchStatus, evaluatedNode);\n    } else {\n      let location = getLocationFromValue(value.expressionLocation);\n      throw new ExpectedBailOut(`invalid return value from render${location}`);\n    }\n  }\n\n  _assignBailOutMessage(reactElement: ObjectValue, message: string): void {\n    // $BailOutReason is a field on ObjectValue that allows us to specify a message\n    // that gets serialized as a comment node during the ReactElement serialization stage\n    message = `Bail-out: ${message}`;\n    if (reactElement.$BailOutReason !== undefined) {\n      // merge bail out messages if one already exists\n      reactElement.$BailOutReason += `, ${message}`;\n    } else {\n      reactElement.$BailOutReason = message;\n    }\n  }\n\n  _resolveArray(\n    componentType: Value,\n    arrayValue: ArrayValue,\n    context: ObjectValue | AbstractObjectValue,\n    branchStatus: BranchStatusEnum,\n    evaluatedNode: ReactEvaluatedNode\n  ): ArrayValue {\n    if (ArrayValue.isIntrinsicAndHasWidenedNumericProperty(arrayValue)) {\n      let arrayHint = this.realm.react.arrayHints.get(arrayValue);\n\n      if (arrayHint !== undefined) {\n        let { func, thisVal } = arrayHint;\n        if (func instanceof ECMAScriptSourceFunctionValue || func instanceof BoundFunctionValue) {\n          if (thisVal && thisVal !== this.realm.intrinsics.undefined) {\n            throw new ExpectedBailOut(`abstract mapped arrays with \"this\" argument are not yet supported`);\n          }\n          this._queueOptimizedClosure(func, evaluatedNode, componentType, context);\n        }\n      }\n      return arrayValue;\n    }\n    let children = mapArrayValue(this.realm, arrayValue, elementValue =>\n      this._resolveDeeply(componentType, elementValue, context, \"NEW_BRANCH\", evaluatedNode)\n    );\n    children.makeFinal();\n    return children;\n  }\n\n  hasEvaluatedRootNode(componentType: ECMAScriptSourceFunctionValue, evaluateNode: ReactEvaluatedNode): boolean {\n    if (this.alreadyEvaluatedRootNodes.has(componentType)) {\n      let alreadyEvaluatedNode = this.alreadyEvaluatedRootNodes.get(componentType);\n      invariant(alreadyEvaluatedNode);\n      evaluateNode.children = alreadyEvaluatedNode.children;\n      evaluateNode.status = alreadyEvaluatedNode.status;\n      evaluateNode.name = alreadyEvaluatedNode.name;\n      return true;\n    }\n    return false;\n  }\n\n  hasEvaluatedNestedClosure(func: ECMAScriptSourceFunctionValue | BoundFunctionValue): boolean {\n    return this.alreadyEvaluatedNestedClosures.has(func);\n  }\n\n  _findReactComponentTrees(\n    value: Value,\n    evaluatedNode: ReactEvaluatedNode,\n    treatFunctionsAs: \"NORMAL_FUNCTIONS\" | \"NESTED_CLOSURES\" | \"FUNCTIONAL_COMPONENTS\",\n    componentType?: Value,\n    context?: ObjectValue | AbstractObjectValue\n  ): void {\n    if (value instanceof AbstractValue) {\n      if (value.args.length > 0) {\n        for (let arg of value.args) {\n          this._findReactComponentTrees(arg, evaluatedNode, treatFunctionsAs, componentType, context);\n        }\n      } else {\n        this.componentTreeState.deadEnds++;\n      }\n    } else if (valueIsKnownReactAbstraction(this.realm, value)) {\n      let evaluatedChildNode = createReactEvaluatedNode(\"NEW_TREE\", getComponentName(this.realm, value));\n      evaluatedNode.children.push(evaluatedChildNode);\n      this._queueNewComponentTree(value, evaluatedChildNode);\n    } else if (value instanceof ECMAScriptSourceFunctionValue || value instanceof BoundFunctionValue) {\n      if (valueIsClassComponent(this.realm, value) || treatFunctionsAs === \"FUNCTIONAL_COMPONENTS\") {\n        let evaluatedChildNode = createReactEvaluatedNode(\"NEW_TREE\", getComponentName(this.realm, value));\n        evaluatedNode.children.push(evaluatedChildNode);\n        this._queueNewComponentTree(value, evaluatedChildNode);\n      } else if (treatFunctionsAs === \"NESTED_CLOSURES\") {\n        invariant(componentType && context);\n        this._queueOptimizedClosure(value, evaluatedNode, componentType, context);\n      }\n    } else if (value instanceof ObjectValue) {\n      if (isReactElement(value)) {\n        let typeValue = getProperty(this.realm, value, \"type\");\n        let ref = getProperty(this.realm, value, \"ref\");\n        let props = getProperty(this.realm, value, \"props\");\n\n        if (valueIsKnownReactAbstraction(this.realm, typeValue) || typeValue instanceof ECMAScriptSourceFunctionValue) {\n          let evaluatedChildNode = createReactEvaluatedNode(\"NEW_TREE\", getComponentName(this.realm, typeValue));\n          evaluatedNode.children.push(evaluatedChildNode);\n          this._queueNewComponentTree(typeValue, evaluatedChildNode);\n        }\n        this._findReactComponentTrees(ref, evaluatedNode, treatFunctionsAs, componentType, context);\n        this._findReactComponentTrees(props, evaluatedNode, treatFunctionsAs, componentType, context);\n      } else {\n        for (let [propName, binding] of value.properties) {\n          if (binding && binding.descriptor && binding.descriptor.enumerable) {\n            this._findReactComponentTrees(\n              getProperty(this.realm, value, propName),\n              evaluatedNode,\n              treatFunctionsAs,\n              componentType,\n              context\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"]}