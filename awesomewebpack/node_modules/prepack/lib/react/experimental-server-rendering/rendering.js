"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMarkupForCustomAttribute = createMarkupForCustomAttribute;
exports.renderToString = renderToString;

var _types = require("../../serializer/types.js");

var _completions = require("../../completions.js");

var _index = require("../../values/index.js");

var _reconcilation = require("../reconcilation.js");

var _utils = require("../utils.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _utils2 = require("./utils.js");

var _domConfig = require("./dom-config.js");

var _hyphenateStyleName = require("fbjs/lib/hyphenateStyleName");

var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);

var _singletons = require("../../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// $FlowFixMe: flow complains that this isn't a module but it is, and it seems to load fine
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

// Warning: This code is experimental and might not fully work. There is no guarantee
// that it is up-to-date with the current react-dom/server logic and there may also be
// security holes in the string escaping because of this.

function renderValueWithHelper(realm, value, helper) {
  // given we know nothing of this value, we need to escape the contents of it at runtime
  let val = _index.AbstractValue.createFromBuildFunction(realm, _index.Value, [helper, value], ([helperNode, valueNode]) => t.callExpression(helperNode, [valueNode]));
  (0, _invariant2.default)(val instanceof _index.AbstractValue);
  return val;
}

function dangerousStyleValue(realm, name, value, isCustomProperty) {
  let isEmpty = value === realm.intrinsics.null || value === realm.intrinsics.undefined || value instanceof _index.BooleanValue || value instanceof _index.StringValue && value.value === "";
  if (isEmpty) {
    return "";
  }

  if (!isCustomProperty && value instanceof _index.NumberValue && value.value !== 0 && !(_domConfig.isUnitlessNumber.hasOwnProperty(name) && _domConfig.isUnitlessNumber[name])) {
    return value.value + "px";
  }

  if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
    return ("" + value.value).trim();
  } else {
    (0, _invariant2.default)(false, "TODO");
  }
}

function createMarkupForCustomAttribute(realm, name, value) {
  if (!(0, _domConfig.isAttributeNameSafe)(name) || value == null) {
    return "";
  }
  if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
    return name + "=" + (0, _utils2.quoteAttributeValueForBrowser)(value.value + "");
  } else {
    (0, _invariant2.default)(false, "TODO");
  }
}

function createMarkupForProperty(realm, name, value, htmlEscapeHelper) {
  const propertyInfo = (0, _domConfig.getPropertyInfo)(name);
  if (name !== "style" && (0, _domConfig.shouldIgnoreAttribute)(name, propertyInfo, false)) {
    return "";
  }
  if ((0, _domConfig.shouldRemoveAttribute)(realm, name, value, propertyInfo, false)) {
    return "";
  }
  if (propertyInfo !== null) {
    const attributeName = propertyInfo.attributeName;
    const { type } = propertyInfo;
    if (type === _domConfig.BOOLEAN || type === _domConfig.OVERLOADED_BOOLEAN && value === true) {
      return attributeName + '=""';
    } else if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
      return attributeName + "=" + (0, _utils2.quoteAttributeValueForBrowser)(value.value + "");
    } else if (value instanceof _index.AbstractValue) {
      return [attributeName + "=", renderValueWithHelper(realm, value, htmlEscapeHelper)];
    }
  } else if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
    return name + "=" + (0, _utils2.quoteAttributeValueForBrowser)(value.value + "");
  } else if (value instanceof _index.AbstractValue) {
    return [name + '="', renderValueWithHelper(realm, value, htmlEscapeHelper), '"'];
  }
  (0, _invariant2.default)(false, "TODO");
}

function createMarkupForStyles(realm, styles) {
  let serialized = [];
  let delimiter = "";

  if (styles instanceof _index.ObjectValue && !styles.isPartialObject()) {
    for (let [styleName, binding] of styles.properties) {
      if (binding.descriptor !== undefined) {
        let isCustomProperty = styleName.indexOf("--") === 0;
        let styleValue = (0, _utils.getProperty)(realm, styles, styleName);

        if (styleValue !== realm.intrinsics.null && styleValue !== realm.intrinsics.undefined) {
          serialized.push(delimiter + (0, _hyphenateStyleName2.default)(styleName) + ":");
          serialized.push(dangerousStyleValue(realm, styleName, styleValue, isCustomProperty));
          delimiter = ";";
        }
      }
    }
  }
  if (serialized.length > 0) {
    return renderReactNode(realm, serialized);
  }
  return realm.intrinsics.null;
}

function createOpenTagMarkup(realm, tagVerbatim, tagLowercase, propsValue, namespace, makeStaticMarkup, isRootElement, htmlEscapeHelper) {
  let ret = ["<" + tagVerbatim];

  if (propsValue instanceof _index.ObjectValue && !propsValue.isPartialObject()) {
    for (let [propName, binding] of propsValue.properties) {
      if (binding.descriptor !== undefined) {
        let propValue = (0, _utils.getProperty)(realm, propsValue, propName);
        if (propValue === realm.intrinsics.null || propValue === realm.intrinsics.undefined) {
          continue;
        }
        if (propName === _domConfig.STYLE) {
          propValue = createMarkupForStyles(realm, propValue);
        }
        let markup;

        if ((0, _utils2.isCustomComponent)(realm, tagLowercase, propsValue)) {
          if (!_domConfig.RESERVED_PROPS.has(propName)) {
            markup = createMarkupForCustomAttribute(realm, propName, propValue);
          }
        } else {
          markup = createMarkupForProperty(realm, propName, propValue, htmlEscapeHelper);
        }
        if (Array.isArray(markup)) {
          ret.push(" ", ...markup);
        } else if (typeof markup === "string" && markup !== "") {
          ret.push(" " + markup);
        } else if (markup) {
          ret.push(" ", markup);
        }
      }
    }
  } else {
    (0, _invariant2.default)(false, "TODO");
  }

  // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.
  if (makeStaticMarkup) {
    return ret;
  }

  if (isRootElement) {
    ret.push(" " + (0, _utils2.createMarkupForRoot)());
  }
  return ret;
}

function renderReactNode(realm, reactNode) {
  let normalizedNode = (0, _utils2.normalizeNode)(realm, reactNode);
  if (typeof normalizedNode === "string") {
    return new _index.StringValue(realm, normalizedNode);
  } else if (normalizedNode instanceof _index.AbstractValue) {
    return normalizedNode;
  }
  (0, _invariant2.default)(Array.isArray(normalizedNode));
  let args = [];
  let quasis = [];
  let lastWasAbstract = false;
  for (let element of normalizedNode) {
    if (typeof element === "string") {
      lastWasAbstract = false;
      quasis.push(t.templateElement({ raw: element, cooked: element }));
    } else {
      if (lastWasAbstract) {
        quasis.push(t.templateElement({ raw: "", cooked: "" }));
      }
      lastWasAbstract = true;
      (0, _invariant2.default)(element instanceof _index.Value);
      args.push(element);
    }
  }
  let val = _index.AbstractValue.createFromBuildFunction(realm, _index.StringValue, args, valueNodes => t.templateLiteral(quasis, valueNodes));
  (0, _invariant2.default)(val instanceof _index.AbstractValue);
  return val;
}

class ReactDOMServerRenderer {
  constructor(realm, makeStaticMarkup) {
    this.realm = realm;
    this.makeStaticMarkup = makeStaticMarkup;
    this.previousWasTextNode = false;
    this.htmlEscapeHelper = (0, _utils2.createHtmlEscapeHelper)(realm);
    this.arrayHelper = (0, _utils2.createArrayHelper)(realm);
  }


  render(value, namespace = "html", depth = 0) {
    let rootReactNode = this._renderValue(value, namespace, depth);
    return renderReactNode(this.realm, rootReactNode);
  }

  _renderText(value) {
    let text = value.value + "";

    if (text === "") {
      return "";
    }
    if (this.makeStaticMarkup) {
      return (0, _utils2.escapeHtml)(text);
    }
    if (this.previousWasTextNode) {
      return "<!-- -->" + (0, _utils2.escapeHtml)(text);
    }
    this.previousWasTextNode = true;
    return (0, _utils2.escapeHtml)(text);
  }

  _renderAbstractConditionalValue(condValue, consequentVal, alternateVal, namespace, depth) {
    let val = this.realm.evaluateWithAbstractConditional(condValue, () => {
      return this.realm.evaluateForEffects(() => this.render(consequentVal, namespace, depth), null, "_renderAbstractConditionalValue consequent");
    }, () => {
      return this.realm.evaluateForEffects(() => this.render(alternateVal, namespace, depth), null, "_renderAbstractConditionalValue consequent");
    });
    return (0, _utils2.convertValueToNode)(val);
  }

  _renderAbstractValue(value, namespace, depth) {
    if (value.kind === "conditional") {
      let [condValue, consequentVal, alternateVal] = value.args;
      (0, _invariant2.default)(condValue instanceof _index.AbstractValue);
      return this._renderAbstractConditionalValue(condValue, consequentVal, alternateVal, namespace, depth);
    } else {
      return renderValueWithHelper(this.realm, value, this.htmlEscapeHelper);
    }
  }

  _renderArrayValue(value, namespace, depth) {
    if (_index.ArrayValue.isIntrinsicAndHasWidenedNumericProperty(value)) {
      let arrayHint = this.realm.react.arrayHints.get(value);

      if (arrayHint !== undefined) {
        return renderValueWithHelper(this.realm, value, this.arrayHelper);
      }
    }
    let elements = [];
    (0, _utils.forEachArrayValue)(this.realm, value, elementValue => {
      let renderedElement = this._renderValue(elementValue, namespace, depth);
      if (Array.isArray(renderedElement)) {
        elements.push(...renderedElement);
      } else {
        elements.push(renderedElement);
      }
    });
    // $FlowFixMe: flow gets confused here
    return elements;
  }

  _renderReactElement(reactElement, namespace, depth) {
    let typeValue = (0, _utils.getProperty)(this.realm, reactElement, "type");
    let propsValue = (0, _utils.getProperty)(this.realm, reactElement, "props");

    (0, _invariant2.default)(propsValue instanceof _index.AbstractObjectValue || propsValue instanceof _index.ObjectValue);
    if (typeValue instanceof _index.StringValue) {
      let type = typeValue.value;
      let tag = type.toLowerCase();

      if (tag === "input") {
        (0, _invariant2.default)(false, "TODO");
      } else if (tag === "textarea") {
        (0, _invariant2.default)(false, "TODO");
      } else if (tag === "select") {
        (0, _invariant2.default)(false, "TODO");
      } else if (tag === "option") {
        (0, _invariant2.default)(false, "TODO");
      }
      let out = createOpenTagMarkup(this.realm, type, tag, propsValue, namespace, this.makeStaticMarkup, depth === 0, this.htmlEscapeHelper);
      let footer = "";

      if (_domConfig.omittedCloseTags.has(tag)) {
        out.push("/>");
      } else {
        out.push(">");
        footer = "</" + type + ">";
      }
      let innerMarkup = (0, _utils2.getNonChildrenInnerMarkup)(this.realm, propsValue);
      if (innerMarkup instanceof _index.StringValue) {
        if (_domConfig.newlineEatingTags[tag] && innerMarkup.value.charAt(0) === "\n") {
          out.push("\n");
        }
        out.push(innerMarkup.value);
      } else if (innerMarkup instanceof _index.ObjectValue) {
        (0, _invariant2.default)(false, "TODO");
      } else {
        this.previousWasTextNode = false;
        let childrenValue = (0, _utils.getProperty)(this.realm, propsValue, "children");
        let childrenOut = this._renderValue(childrenValue, namespace, depth + 1);

        if (Array.isArray(childrenOut)) {
          out.push(...childrenOut);
        } else {
          out.push(childrenOut);
        }
      }
      out.push(footer);
      this.previousWasTextNode = false;
      return out;
    } else if (typeValue instanceof _index.SymbolValue && typeValue === (0, _utils.getReactSymbol)("react.fragment", this.realm)) {
      let childrenValue = (0, _utils.getProperty)(this.realm, propsValue, "children");
      let childrenOut = this._renderValue(childrenValue, namespace, depth + 1);
      let out = [];

      if (Array.isArray(childrenOut)) {
        out.push(...childrenOut);
      } else {
        out.push(childrenOut);
      }
      this.previousWasTextNode = false;
      return out;
    } else {
      (0, _invariant2.default)(false, "TODO");
    }
  }

  _renderValue(value, namespace, depth) {
    if (value instanceof _index.StringValue || value instanceof _index.NumberValue) {
      return this._renderText(value);
    } else if (value instanceof _index.ObjectValue && (0, _utils.isReactElement)(value)) {
      return this._renderReactElement(value, namespace, depth);
    } else if (value instanceof _index.AbstractValue) {
      return this._renderAbstractValue(value, namespace, depth);
    } else if (value instanceof _index.ArrayValue) {
      return this._renderArrayValue(value, namespace, depth);
    } else if (value instanceof _index.BooleanValue || value instanceof _index.UndefinedValue || value instanceof _index.NullValue) {
      return "";
    }
    (0, _invariant2.default)(false, "TODO");
  }
}

function handleNestedOptimizedFunctions(realm, reconciler, staticMarkup) {
  for (let _ref of reconciler.nestedOptimizedClosures) {
    let { func, evaluatedNode, componentType, context } = _ref;

    if (reconciler.hasEvaluatedNestedClosure(func)) {
      continue;
    }
    if (func instanceof _index.ECMAScriptSourceFunctionValue && reconciler.hasEvaluatedRootNode(func, evaluatedNode)) {
      continue;
    }
    let closureEffects = reconciler.resolveNestedOptimizedClosure(func, [], componentType, context, evaluatedNode);

    let closureEffectsRenderedToString = realm.evaluateForEffectsWithPriorEffects([closureEffects], () => {
      let serverRenderer = new ReactDOMServerRenderer(realm, staticMarkup);
      (0, _invariant2.default)(closureEffects.result instanceof _completions.SimpleNormalCompletion);
      return serverRenderer.render(closureEffects.result.value);
    }, "handleNestedOptimizedFunctions");

    realm.react.optimizedNestedClosuresToWrite.push({
      effects: closureEffectsRenderedToString,
      func
    });
  }
}

function renderToString(realm, reactElement, staticMarkup) {
  let reactStatistics = new _types.ReactStatistics();
  let reconciler = new _reconcilation.Reconciler(realm, { firstRenderOnly: true, isRoot: true }, reactStatistics);
  let typeValue = (0, _utils.getProperty)(realm, reactElement, "type");
  let propsValue = (0, _utils.getProperty)(realm, reactElement, "props");
  let evaluatedRootNode = (0, _utils.createReactEvaluatedNode)("ROOT", (0, _utils.getComponentName)(realm, typeValue));
  (0, _invariant2.default)(typeValue instanceof _index.ECMAScriptSourceFunctionValue);
  if (propsValue instanceof _index.AbstractValue && !(propsValue instanceof _index.AbstractObjectValue)) {
    propsValue = _singletons.To.ToObject(realm, propsValue);
  }
  (0, _invariant2.default)(propsValue instanceof _index.ObjectValue || propsValue instanceof _index.AbstractObjectValue);
  let effects = reconciler.resolveReactComponentTree(typeValue, propsValue, null, evaluatedRootNode);

  (0, _invariant2.default)(realm.generator);
  // create a single regex used for the escape functions
  // by hoisting it, it gets cached by the VM JITs
  realm.generator.emitStatement([], () => t.variableDeclaration("var", [t.variableDeclarator(t.identifier("matchHtmlRegExp"), t.regExpLiteral("[\"'&<>]"))]));
  (0, _invariant2.default)(realm.generator);
  realm.generator.emitStatement([], () => t.variableDeclaration("var", [t.variableDeclarator(t.identifier("previousWasTextNode"), t.booleanLiteral(false))]));
  (0, _invariant2.default)(effects);
  realm.applyEffects(effects);
  (0, _invariant2.default)(effects.result instanceof _completions.SimpleNormalCompletion);
  let serverRenderer = new ReactDOMServerRenderer(realm, staticMarkup);
  let renderValue = serverRenderer.render(effects.result.value);
  handleNestedOptimizedFunctions(realm, reconciler, staticMarkup);
  return renderValue;
}
//# sourceMappingURL=rendering.js.map