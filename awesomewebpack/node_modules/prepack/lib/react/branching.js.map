{"version":3,"sources":["../../src/react/branching.js"],"names":["getValueWithBranchingLogicApplied","wrapReactElementInBranchOrReturnValue","realm","parentX","parentY","value","needsKeys","searchAndFlagMatchingComponentTypes","x","y","xTypeParent","yTypeParent","xType","yType","equals","xElem","index","yElem","kind","consequentVal","alternateVal","args","searchAndFlagMismatchingNonHostTypes","arrayDepth","xProps","yProps","xChildren","yChildren","xVal","yVal","isIntrinsicAndHasWidenedNumericProperty","applyBranchedLogicValue","newArray","elementValue","makeFinal","condValue","evaluateWithAbstractConditional","evaluateForEffects","temporal","createTemporalFromBuildFunction","node","isPure","skipInvariant","values","temporalAlias"],"mappings":"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","file":"branching.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport { ValuesDomain } from \"../domains/index.js\";\nimport {\n  cloneReactElement,\n  isReactElement,\n  addKeyToReactElement,\n  forEachArrayValue,\n  getProperty,\n  mapArrayValue,\n} from \"./utils\";\nimport { ExpectedBailOut } from \"./errors.js\";\n\n// Branch status is used for when Prepack returns an abstract value from a render\n// that results in a conditional path occuring. This can be problematic for reconcilation\n// as the reconciler then needs to understand if this is the start of a new branch, or if\n// it's actually deep into an existing branch. If it's a new branch, we need to apply\n// keys to the root JSX element so that it keeps it identity (because we're folding trees).\n// Furthermore, we also need to bail-out of folding class components where they have lifecycle\n// events, as we can't merge lifecycles of mutliple trees when branched reliably\nexport type BranchStatusEnum = \"ROOT\" | \"NO_BRANCH\" | \"NEW_BRANCH\" | \"BRANCH\";\n\n// This function aims to determine if we need to add keys to the ReactElements\n// of the returned conditional abstract value branches. It does this by first\n// checking the parent branch nodes (these were use to render both respective branches)\n// for any cases where ReactElement types on host components mismatch.\n// Note: this implementation is not fully sound and is likely missing support\n// for all React reconcilation cases for handling of keys, see issue #1131\n\nexport function getValueWithBranchingLogicApplied(\n  realm: Realm,\n  parentX: Value,\n  parentY: Value,\n  value: AbstractValue\n): Value {\n  let needsKeys = false;\n\n  // we check the inlined value and see if the component types match\n  const searchAndFlagMatchingComponentTypes = (x, y, xTypeParent, yTypeParent) => {\n    // The returned value is the result of getting the \"render\" from a component.\n    // We need to search the value returned to see if the nodes need keys adding to them.\n\n    // 1. If we have <X? /> and <Y? />, then check if their\n    // types are the same, if they are the same and the parent types\n    // are not the same as then we need to add keys\n    if (x instanceof ObjectValue && isReactElement(x) && y instanceof ObjectValue && isReactElement(y)) {\n      let xType = getProperty(realm, x, \"type\");\n      let yType = getProperty(realm, y, \"type\");\n\n      if (xType.equals(yType) && !xTypeParent.equals(xType) && !yTypeParent.equals(yType)) {\n        needsKeys = true;\n      }\n    } else if (x instanceof ArrayValue) {\n      // If we have x: []\n      // Go  through the elements of array x\n      forEachArrayValue(realm, x, (xElem, index) => {\n        let yElem = y;\n        // And if we also have y: [], with a given element from x\n        // search element of y at the same index from x.\n        // If y is not an array, then continue but use x: [] against y\n        if (y instanceof ArrayValue) {\n          yElem = getProperty(realm, y, index + \"\");\n        }\n        searchAndFlagMatchingComponentTypes(xElem, yElem, xTypeParent, yTypeParent);\n      });\n    } else if (y instanceof ArrayValue) {\n      // If we have y: []\n      // Go  through the elements of array y\n      forEachArrayValue(realm, y, (yElem, index) => {\n        let xElem = x;\n        // And if we also have x: [], with a given element from y\n        // search element of x at the same index from y.\n        // If x is not an array, then continue but use y: [] against x\n        if (x instanceof ArrayValue) {\n          xElem = getProperty(realm, x, index + \"\");\n        }\n        searchAndFlagMatchingComponentTypes(xElem, yElem, xTypeParent, yTypeParent);\n      });\n    } else if (x instanceof AbstractValue && x.kind === \"conditional\") {\n      // if x is a conditional value like \"a ? b : c\",\n      // then recusrively check b and c agaginst that y\n      let [, consequentVal, alternateVal] = x.args;\n\n      searchAndFlagMatchingComponentTypes(consequentVal, y, xTypeParent, yTypeParent);\n      searchAndFlagMatchingComponentTypes(alternateVal, y, xTypeParent, yTypeParent);\n    } else if (y instanceof AbstractValue && y.kind === \"conditional\") {\n      // if y is a conditional value like \"a ? b : c\",\n      // then recusrively check b and c agaginst that x\n      let [, consequentVal, alternateVal] = y.args;\n\n      searchAndFlagMatchingComponentTypes(x, consequentVal, xTypeParent, yTypeParent);\n      searchAndFlagMatchingComponentTypes(x, alternateVal, xTypeParent, yTypeParent);\n    }\n  };\n\n  // we first check our \"parent\" value, that was used to get the inlined value\n  const searchAndFlagMismatchingNonHostTypes = (x: Value, y: Value, arrayDepth: number): void => {\n    if (x instanceof ObjectValue && isReactElement(x) && y instanceof ObjectValue && isReactElement(y)) {\n      let xType = getProperty(realm, x, \"type\");\n      let yType = getProperty(realm, y, \"type\");\n\n      if (xType instanceof StringValue && yType instanceof StringValue) {\n        let xProps = getProperty(realm, x, \"props\");\n        let yProps = getProperty(realm, y, \"props\");\n        if (xProps instanceof ObjectValue && yProps instanceof ObjectValue) {\n          let xChildren = getProperty(realm, xProps, \"children\");\n          let yChildren = getProperty(realm, yProps, \"children\");\n\n          if (xChildren instanceof Value && yChildren instanceof Value) {\n            searchAndFlagMismatchingNonHostTypes(xChildren, yChildren, arrayDepth);\n          }\n        }\n      } else if (!xType.equals(yType)) {\n        let [, xVal, yVal] = value.args;\n        searchAndFlagMatchingComponentTypes(xVal, yVal, xType, yType);\n      }\n    } else if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(x) ||\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(y)\n    ) {\n      // If either case is an unknown array, we do not know\n      // the contents of the array, so we cannot add keys\n    } else if (x instanceof ArrayValue && arrayDepth === 0) {\n      forEachArrayValue(realm, x, (xElem, index) => {\n        let yElem;\n        if (y instanceof ArrayValue) {\n          // handle the case of [x].equals([y])\n          yElem = getProperty(realm, y, index + \"\");\n        } else if (index === 0) {\n          // handle the case of [x].equals(y)\n          yElem = y;\n        }\n\n        if (xElem instanceof Value && yElem instanceof Value) {\n          searchAndFlagMismatchingNonHostTypes(xElem, yElem, arrayDepth + 1);\n        }\n      });\n    } else if (y instanceof ArrayValue && arrayDepth === 0) {\n      forEachArrayValue(realm, y, (yElem, index) => {\n        let xElem;\n        if (x instanceof ArrayValue) {\n          // handle the case of [y].equals([x]\n          xElem = getProperty(realm, x, index + \"\");\n        } else if (index === 0) {\n          // handle the case of [y].equals(x)\n          xElem = x;\n        }\n\n        if (xElem instanceof Value && yElem instanceof Value) {\n          searchAndFlagMismatchingNonHostTypes(xElem, yElem, arrayDepth + 1);\n        }\n      });\n    }\n  };\n\n  searchAndFlagMismatchingNonHostTypes(parentX, parentY, 0);\n\n  if (needsKeys) {\n    return applyBranchedLogicValue(realm, value);\n  }\n  return value;\n}\n\n// When we apply branching logic, it means to add keys to all ReactElement nodes\n// we encounter, thus returning new ReactElements with the keys on them\nfunction applyBranchedLogicValue(realm: Realm, value: Value): Value {\n  if (\n    value instanceof StringValue ||\n    value instanceof NumberValue ||\n    value instanceof BooleanValue ||\n    value instanceof NullValue ||\n    value instanceof UndefinedValue\n  ) {\n    // terminal values\n  } else if (value instanceof ObjectValue && isReactElement(value)) {\n    return addKeyToReactElement(realm, value);\n  } else if (value instanceof ArrayValue) {\n    let newArray = mapArrayValue(realm, value, elementValue => applyBranchedLogicValue(realm, elementValue));\n    newArray.makeFinal();\n    return newArray;\n  } else if (value instanceof AbstractValue && value.kind === \"conditional\") {\n    let [condValue, consequentVal, alternateVal] = value.args;\n    invariant(condValue instanceof AbstractValue);\n\n    return realm.evaluateWithAbstractConditional(\n      condValue,\n      () => {\n        return realm.evaluateForEffects(\n          () => wrapReactElementInBranchOrReturnValue(realm, applyBranchedLogicValue(realm, consequentVal)),\n          null,\n          \"applyBranchedLogicValue consequent\"\n        );\n      },\n      () => {\n        return realm.evaluateForEffects(\n          () => wrapReactElementInBranchOrReturnValue(realm, applyBranchedLogicValue(realm, alternateVal)),\n          null,\n          \"applyBranchedLogicValue alternate\"\n        );\n      }\n    );\n  } else if (value instanceof AbstractValue && (value.kind === \"||\" || value.kind === \"&&\")) {\n    invariant(false, \"applyBranchedLogicValue encounterted a logical expression (|| or &&), this should never occur\");\n  } else {\n    throw new ExpectedBailOut(\"Unsupported value encountered when applying branched logic to values\");\n  }\n  return value;\n}\n\n// when a ReactElement is resolved in a conditional branch we\n// can improve runtime performance by ensuring that the ReactElement\n// is only created lazily in that specific branch and referenced\n// from then on. To do this we create a temporal abstract value\n// and set its kind to \"branched ReactElement\" so we properly track\n// the original ReactElement. If we don't have a ReactElement,\n// return the original value\nexport function wrapReactElementInBranchOrReturnValue(realm: Realm, value: Value): Value {\n  if (value instanceof ObjectValue && isReactElement(value)) {\n    let temporal = AbstractValue.createTemporalFromBuildFunction(\n      realm,\n      ObjectValue,\n      [cloneReactElement(realm, value, false)],\n      ([node]) => node,\n      { isPure: true, skipInvariant: true }\n    );\n    invariant(temporal instanceof AbstractObjectValue);\n    temporal.values = new ValuesDomain(value);\n    value.temporalAlias = temporal;\n  }\n  return value;\n}\n"]}