{"version":3,"sources":["../../src/react/optimizing.js"],"names":["optimizeReactComponentTreeRoot","applyOptimizedReactComponents","applyWriteEffectsForOptimizedComponent","realm","componentType","_effects","componentTreeState","evaluatedNode","writeEffects","environmentRecordIdAfterGlobalCode","effects","additionalFunctionEffects","name","value","result","intrinsics","undefined","status","set","prototype","renderMethod","contextTypes","size","ObjectPrototype","noOpFunc","key","Set","optimizeReactComponentTreeBranches","reconciler","logger","react","verbose","branchedComponentTrees","length","logInformation","rootValue","branchRootValue","branchComponentType","hasEvaluatedRootNode","clearComponentTreeState","branchEffects","resolveReactComponentTree","branchComponentTreeState","optimizeReactNestedClosures","nestedOptimizedClosures","func","nestedEffects","context","hasEvaluatedNestedClosure","closureEffects","resolveNestedOptimizedClosure","$BoundTargetFunction","componentRoot","config","statistics","evaluatedRootNode","evaluatedRootNodes","push","componentTreeEffects","startingComponentTreeBranches","optimizeNestedFunctions","optimizedNestedClosuresToWrite"],"mappings":"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","file":"optimizing.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { type Effects, Realm } from \"../realm.js\";\nimport { AbstractValue, ECMAScriptSourceFunctionValue, BoundFunctionValue, ObjectValue } from \"../values/index.js\";\nimport { createAdditionalEffects } from \"../serializer/utils.js\";\nimport {\n  convertFunctionalComponentToComplexClassComponent,\n  convertSimpleClassComponentToFunctionalComponent,\n  createNoopFunction,\n  createReactEvaluatedNode,\n  getComponentName,\n  getComponentTypeFromRootValue,\n  normalizeFunctionalComponentParamaters,\n  valueIsClassComponent,\n} from \"./utils.js\";\nimport { type WriteEffects, type ReactEvaluatedNode, ReactStatistics } from \"../serializer/types.js\";\nimport { Reconciler, type ComponentTreeState } from \"./reconcilation.js\";\nimport { ReconcilerFatalError } from \"./errors.js\";\nimport { Properties } from \"../singletons.js\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { ReactComponentTreeConfig } from \"../types.js\";\nimport { Logger } from \"../utils/logger.js\";\n\nfunction applyWriteEffectsForOptimizedComponent(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue,\n  _effects: Effects,\n  componentTreeState: ComponentTreeState,\n  evaluatedNode: ReactEvaluatedNode,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number\n): void {\n  let effects = _effects;\n  let additionalFunctionEffects = createAdditionalEffects(\n    realm,\n    effects,\n    false,\n    \"ReactAdditionalFunctionEffects\",\n    environmentRecordIdAfterGlobalCode\n  );\n  if (additionalFunctionEffects === null) {\n    throw new ReconcilerFatalError(\n      `Failed to optimize React component tree for \"${evaluatedNode.name}\" due to an unsupported completion`,\n      evaluatedNode\n    );\n  }\n  effects = additionalFunctionEffects.effects;\n  let value = effects.result;\n\n  if (value === realm.intrinsics.undefined) {\n    // if we get undefined, then this component tree failed and a message was already logged\n    // in the reconciler\n    return;\n  }\n  if (valueIsClassComponent(realm, componentType)) {\n    if (componentTreeState.status === \"SIMPLE\") {\n      // if the root component was a class and is now simple, we can convert it from a class\n      // component to a functional component\n      convertSimpleClassComponentToFunctionalComponent(realm, componentType, additionalFunctionEffects);\n      normalizeFunctionalComponentParamaters(componentType);\n      writeEffects.set(componentType, additionalFunctionEffects);\n    } else {\n      let prototype = Get(realm, componentType, \"prototype\");\n      invariant(prototype instanceof ObjectValue);\n      let renderMethod = Get(realm, prototype, \"render\");\n      invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(renderMethod, additionalFunctionEffects);\n    }\n  } else {\n    if (componentTreeState.status === \"COMPLEX\") {\n      convertFunctionalComponentToComplexClassComponent(\n        realm,\n        componentType,\n        componentTreeState.componentType,\n        additionalFunctionEffects\n      );\n      let prototype = Get(realm, componentType, \"prototype\");\n      invariant(prototype instanceof ObjectValue);\n      let renderMethod = Get(realm, prototype, \"render\");\n      invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(renderMethod, additionalFunctionEffects);\n    } else {\n      normalizeFunctionalComponentParamaters(componentType);\n      writeEffects.set(componentType, additionalFunctionEffects);\n    }\n  }\n  // apply contextTypes for legacy context\n  if (componentTreeState.contextTypes.size > 0) {\n    let contextTypes = new ObjectValue(realm, realm.intrinsics.ObjectPrototype);\n    let noOpFunc = createNoopFunction(realm);\n    for (let key of componentTreeState.contextTypes) {\n      Properties.Set(realm, contextTypes, key, noOpFunc, true);\n    }\n    Properties.Set(realm, componentType, \"contextTypes\", contextTypes, true);\n  }\n}\n\nfunction optimizeReactComponentTreeBranches(\n  realm: Realm,\n  reconciler: Reconciler,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number,\n  logger: Logger\n): void {\n  if (realm.react.verbose && reconciler.branchedComponentTrees.length > 0) {\n    logger.logInformation(`  Evaluating React component tree branches...`);\n  }\n  // for now we just use abstract props/context, in the future we'll create a new branch with a new component\n  // that used the props/context. It will extend the original component and only have a render method\n  for (let { rootValue: branchRootValue, evaluatedNode } of reconciler.branchedComponentTrees) {\n    let branchComponentType = getComponentTypeFromRootValue(realm, branchRootValue);\n    if (branchComponentType === null) {\n      evaluatedNode.status = \"UNKNOWN_TYPE\";\n      continue;\n    }\n    // so we don't process the same component multiple times (we might change this logic later)\n    if (reconciler.hasEvaluatedRootNode(branchComponentType, evaluatedNode)) {\n      continue;\n    }\n    reconciler.clearComponentTreeState();\n    if (realm.react.verbose) {\n      logger.logInformation(`    Evaluating ${evaluatedNode.name} (branch)`);\n    }\n    let branchEffects = reconciler.resolveReactComponentTree(branchComponentType, null, null, evaluatedNode);\n    if (realm.react.verbose) {\n      logger.logInformation(`    ✔ ${evaluatedNode.name} (branch)`);\n    }\n    let branchComponentTreeState = reconciler.componentTreeState;\n    applyWriteEffectsForOptimizedComponent(\n      realm,\n      branchComponentType,\n      branchEffects,\n      branchComponentTreeState,\n      evaluatedNode,\n      writeEffects,\n      environmentRecordIdAfterGlobalCode\n    );\n  }\n}\n\nfunction optimizeReactNestedClosures(\n  realm: Realm,\n  reconciler: Reconciler,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number,\n  logger: Logger\n): void {\n  if (realm.react.verbose && reconciler.nestedOptimizedClosures.length > 0) {\n    logger.logInformation(`  Evaluating nested closures...`);\n  }\n  for (let { func, evaluatedNode, nestedEffects, componentType, context } of reconciler.nestedOptimizedClosures) {\n    if (reconciler.hasEvaluatedNestedClosure(func)) {\n      continue;\n    }\n    if (func instanceof ECMAScriptSourceFunctionValue && reconciler.hasEvaluatedRootNode(func, evaluatedNode)) {\n      continue;\n    }\n    if (realm.react.verbose) {\n      logger.logInformation(`    Evaluating function \"${getComponentName(realm, func)}\"`);\n    }\n    let closureEffects = reconciler.resolveNestedOptimizedClosure(\n      func,\n      nestedEffects,\n      componentType,\n      context,\n      evaluatedNode\n    );\n    if (realm.react.verbose) {\n      logger.logInformation(`    ✔ function \"${getComponentName(realm, func)}\"`);\n    }\n    let additionalFunctionEffects = createAdditionalEffects(\n      realm,\n      closureEffects,\n      true,\n      \"ReactNestedAdditionalFunctionEffects\",\n      environmentRecordIdAfterGlobalCode\n    );\n    invariant(additionalFunctionEffects);\n    if (func instanceof BoundFunctionValue) {\n      invariant(func.$BoundTargetFunction instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(func.$BoundTargetFunction, additionalFunctionEffects);\n    } else {\n      writeEffects.set(func, additionalFunctionEffects);\n    }\n  }\n}\n\nexport function optimizeReactComponentTreeRoot(\n  realm: Realm,\n  componentRoot: ECMAScriptSourceFunctionValue | AbstractValue,\n  config: ReactComponentTreeConfig,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number,\n  logger: Logger,\n  statistics: ReactStatistics\n): void {\n  let reconciler = new Reconciler(realm, config, statistics, logger);\n  let componentType = getComponentTypeFromRootValue(realm, componentRoot);\n  if (componentType === null) {\n    return;\n  }\n  let evaluatedRootNode = createReactEvaluatedNode(\"ROOT\", getComponentName(realm, componentType));\n  statistics.evaluatedRootNodes.push(evaluatedRootNode);\n  if (reconciler.hasEvaluatedRootNode(componentType, evaluatedRootNode)) {\n    return;\n  }\n  if (realm.react.verbose) {\n    logger.logInformation(`  Evaluating ${evaluatedRootNode.name} (root)`);\n  }\n  let componentTreeEffects = reconciler.resolveReactComponentTree(componentType, null, null, evaluatedRootNode);\n  if (realm.react.verbose) {\n    logger.logInformation(`  ✔ ${evaluatedRootNode.name} (root)`);\n  }\n\n  applyWriteEffectsForOptimizedComponent(\n    realm,\n    componentType,\n    componentTreeEffects,\n    reconciler.componentTreeState,\n    evaluatedRootNode,\n    writeEffects,\n    environmentRecordIdAfterGlobalCode\n  );\n\n  let startingComponentTreeBranches = 0;\n  do {\n    startingComponentTreeBranches = reconciler.branchedComponentTrees.length;\n    optimizeReactComponentTreeBranches(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger);\n    if (realm.react.optimizeNestedFunctions) {\n      optimizeReactNestedClosures(realm, reconciler, writeEffects, environmentRecordIdAfterGlobalCode, logger);\n    }\n  } while (startingComponentTreeBranches !== reconciler.branchedComponentTrees.length);\n}\n\nexport function applyOptimizedReactComponents(\n  realm: Realm,\n  writeEffects: WriteEffects,\n  environmentRecordIdAfterGlobalCode: number\n): void {\n  for (let { effects, func } of realm.react.optimizedNestedClosuresToWrite) {\n    let additionalFunctionEffects = createAdditionalEffects(\n      realm,\n      effects,\n      true,\n      \"ReactNestedAdditionalFunctionEffects\",\n      environmentRecordIdAfterGlobalCode\n    );\n    invariant(additionalFunctionEffects);\n    if (func instanceof BoundFunctionValue) {\n      invariant(func.$BoundTargetFunction instanceof ECMAScriptSourceFunctionValue);\n      writeEffects.set(func.$BoundTargetFunction, additionalFunctionEffects);\n    } else {\n      writeEffects.set(func, additionalFunctionEffects);\n    }\n  }\n}\n"]}