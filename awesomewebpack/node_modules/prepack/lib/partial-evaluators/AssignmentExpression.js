"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  let LeftHandSideExpression = ast.left;
  let AssignmentExpression = ast.right;
  let AssignmentOperator = ast.operator;

  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression
  if (AssignmentOperator === "=") {
    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
    if (LeftHandSideExpression.type !== "ObjectLiteral" && LeftHandSideExpression.type !== "ArrayLiteral") {
      // a. Let lref be the result of evaluating LeftHandSideExpression.
      let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);

      // b. ReturnIfAbrupt(lref).
      if (lref instanceof _completions.AbruptCompletion) return [lref, last, lio];
      let leftCompletion;
      [leftCompletion, lref] = _singletons.Join.unbundleNormalCompletion(lref);

      // c. Let rref be the result of evaluating AssignmentExpression.
      // d. Let rval be ? GetValue(rref).
      let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);
      let io = lio.concat(rio);
      if (rval instanceof _completions.AbruptCompletion) {
        return [rval, t.assignmentExpression(ast.operator, last, rast), io];
      }
      let rightCompletion;
      [rightCompletion, rval] = _singletons.Join.unbundleNormalCompletion(rval);
      (0, _invariant2.default)(rval instanceof _index.Value);

      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
      if ((0, _index2.IsAnonymousFunctionDefinition)(realm, AssignmentExpression) && (0, _index2.IsIdentifierRef)(realm, LeftHandSideExpression)) {
        (0, _invariant2.default)(rval instanceof _index.ObjectValue);

        // i. Let hasNameProperty be ? HasOwnProperty(rval, "name").
        let hasNameProperty = (0, _index2.HasOwnProperty)(realm, rval, "name");

        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).
        if (!hasNameProperty) {
          (0, _invariant2.default)(lref instanceof _environment.Reference);
          _singletons.Functions.SetFunctionName(realm, rval, _singletons.Environment.GetReferencedName(realm, lref));
        }
      }

      // f. Perform ? PutValue(lref, rval).
      _singletons.Properties.PutValue(realm, lref, rval);

      // g. Return rval.
      let resultAst = t.assignmentExpression(ast.operator, last, rast);
      rval = _singletons.Join.composeNormalCompletions(leftCompletion, rightCompletion, rval, realm);
      return [rval, resultAst, io];
    }
    throw new _errors.FatalError("Patterns aren't supported yet");
    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.
    // 3. Let rref be the result of evaluating AssignmentExpression.
    // 4. Let rval be ? GetValue(rref).
    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.
    // 6. ReturnIfAbrupt(status).
    // 7. Return rval.
  }

  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression

  // 1. Let lref be the result of evaluating LeftHandSideExpression.
  let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);
  if (lref instanceof _completions.AbruptCompletion) return [lref, last, lio];
  let leftCompletion;
  [leftCompletion, lref] = _singletons.Join.unbundleNormalCompletion(lref);

  // 2. Let lval be ? GetValue(lref).
  let lval = _singletons.Environment.GetValue(realm, lref);

  // 3. Let rref be the result of evaluating AssignmentExpression.
  // 4. Let rval be ? GetValue(rref).
  let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);
  let io = lio.concat(rio);
  if (rval instanceof _completions.AbruptCompletion) {
    return [rval, t.assignmentExpression(ast.operator, last, rast), io];
  }
  let rightCompletion;
  [rightCompletion, rval] = _singletons.Join.unbundleNormalCompletion(rval);
  (0, _invariant2.default)(rval instanceof _index.Value);

  // 5. Let op be the @ where AssignmentOperator is @=.
  let op = AssignmentOperator.slice(0, -1);

  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.
  let resultValue, resultAst;
  if (lval instanceof _index.ConcreteValue) {
    if (rval instanceof _index.ConcreteValue) {
      resultValue = (0, _BinaryExpression.computeBinary)(realm, op, lval, rval);
      resultAst = t.assignmentExpression(ast.operator, last, t.valueToNode(resultValue.serialize()));
    }
  }
  // if resultValue is undefined, one or both operands are abstract.
  if (resultValue === undefined && (op === "==" || op === "===" || op === "!=" || op === "!==")) {
    // When comparing to null or undefined, we can return a compile time value if we know the
    // other operand must be an object.
    if (!lval.mightNotBeObject() && (rval instanceof _index.NullValue || rval instanceof _index.UndefinedValue) || !rval.mightNotBeObject() && (lval instanceof _index.NullValue || lval instanceof _index.UndefinedValue)) {
      resultValue = new _index.BooleanValue(realm, op[0] !== "=");
      resultAst = t.assignmentExpression(ast.operator, last, t.valueToNode(resultValue.serialize()));
    }
  }
  // todo: special case if one result is known to be 0 or 1
  if (resultAst === undefined) {
    resultAst = t.assignmentExpression(ast.operator, last, rast);
  }
  return (0, _BinaryExpression2.createAbstractValueForBinary)(op, resultAst, lval, rval, last.loc, rast.loc, leftCompletion, rightCompletion, resultValue, io, realm);
};

var _BinaryExpression = require("../evaluators/BinaryExpression.js");

var _BinaryExpression2 = require("../partial-evaluators/BinaryExpression.js");

var _completions = require("../completions.js");

var _environment = require("../environment.js");

var _errors = require("../errors.js");

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
//# sourceMappingURL=AssignmentExpression.js.map