{"version":3,"sources":["../../src/partial-evaluators/AssignmentExpression.js"],"names":["ast","strictCode","env","realm","LeftHandSideExpression","left","AssignmentExpression","right","AssignmentOperator","operator","type","lref","last","lio","partiallyEvaluateCompletion","leftCompletion","unbundleNormalCompletion","rval","rast","rio","partiallyEvaluateCompletionDeref","io","concat","t","assignmentExpression","rightCompletion","hasNameProperty","SetFunctionName","GetReferencedName","PutValue","resultAst","composeNormalCompletions","lval","GetValue","op","slice","resultValue","valueToNode","serialize","undefined","mightNotBeObject","loc"],"mappings":"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","file":"AssignmentExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelBinaryOperator,\n  BabelNodeAssignmentExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n} from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { computeBinary } from \"../evaluators/BinaryExpression.js\";\nimport { createAbstractValueForBinary } from \"../partial-evaluators/BinaryExpression.js\";\nimport { AbruptCompletion, Completion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { BooleanValue, ConcreteValue, NullValue, ObjectValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { IsAnonymousFunctionDefinition, IsIdentifierRef, HasOwnProperty } from \"../methods/index.js\";\nimport { Environment, Functions, Join, Properties } from \"../singletons.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.15 Assignment Operators\nexport default function(\n  ast: BabelNodeAssignmentExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  let LeftHandSideExpression = ast.left;\n  let AssignmentExpression = ast.right;\n  let AssignmentOperator = ast.operator;\n\n  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n  if (AssignmentOperator === \"=\") {\n    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (LeftHandSideExpression.type !== \"ObjectLiteral\" && LeftHandSideExpression.type !== \"ArrayLiteral\") {\n      // a. Let lref be the result of evaluating LeftHandSideExpression.\n      let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n      if (lref instanceof AbruptCompletion) return [lref, (last: any), lio];\n      let leftCompletion;\n      [leftCompletion, lref] = Join.unbundleNormalCompletion(lref);\n\n      // c. Let rref be the result of evaluating AssignmentExpression.\n      // d. Let rval be ? GetValue(rref).\n      let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);\n      let io = lio.concat(rio);\n      if (rval instanceof AbruptCompletion) {\n        return [rval, t.assignmentExpression(ast.operator, (last: any), (rast: any)), io];\n      }\n      let rightCompletion;\n      [rightCompletion, rval] = Join.unbundleNormalCompletion(rval);\n      invariant(rval instanceof Value);\n\n      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n      if (\n        IsAnonymousFunctionDefinition(realm, AssignmentExpression) &&\n        IsIdentifierRef(realm, LeftHandSideExpression)\n      ) {\n        invariant(rval instanceof ObjectValue);\n\n        // i. Let hasNameProperty be ? HasOwnProperty(rval, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, rval, \"name\");\n\n        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).\n        if (!hasNameProperty) {\n          invariant(lref instanceof Reference);\n          Functions.SetFunctionName(realm, rval, Environment.GetReferencedName(realm, lref));\n        }\n      }\n\n      // f. Perform ? PutValue(lref, rval).\n      Properties.PutValue(realm, lref, rval);\n\n      // g. Return rval.\n      let resultAst = t.assignmentExpression(ast.operator, (last: any), (rast: any));\n      rval = Join.composeNormalCompletions(leftCompletion, rightCompletion, rval, realm);\n      return [rval, resultAst, io];\n    }\n    throw new FatalError(\"Patterns aren't supported yet\");\n    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.\n    // 3. Let rref be the result of evaluating AssignmentExpression.\n    // 4. Let rval be ? GetValue(rref).\n    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n    // 6. ReturnIfAbrupt(status).\n    // 7. Return rval.\n  }\n\n  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n  // 1. Let lref be the result of evaluating LeftHandSideExpression.\n  let [lref, last, lio] = env.partiallyEvaluateCompletion(LeftHandSideExpression, strictCode);\n  if (lref instanceof AbruptCompletion) return [lref, (last: any), lio];\n  let leftCompletion;\n  [leftCompletion, lref] = Join.unbundleNormalCompletion(lref);\n\n  // 2. Let lval be ? GetValue(lref).\n  let lval = Environment.GetValue(realm, lref);\n\n  // 3. Let rref be the result of evaluating AssignmentExpression.\n  // 4. Let rval be ? GetValue(rref).\n  let [rval, rast, rio] = env.partiallyEvaluateCompletionDeref(AssignmentExpression, strictCode);\n  let io = lio.concat(rio);\n  if (rval instanceof AbruptCompletion) {\n    return [rval, t.assignmentExpression(ast.operator, (last: any), (rast: any)), io];\n  }\n  let rightCompletion;\n  [rightCompletion, rval] = Join.unbundleNormalCompletion(rval);\n  invariant(rval instanceof Value);\n\n  // 5. Let op be the @ where AssignmentOperator is @=.\n  let op = ((AssignmentOperator.slice(0, -1): any): BabelBinaryOperator);\n\n  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n  let resultValue, resultAst;\n  if (lval instanceof ConcreteValue) {\n    if (rval instanceof ConcreteValue) {\n      resultValue = computeBinary(realm, op, lval, rval);\n      resultAst = t.assignmentExpression(ast.operator, (last: any), t.valueToNode(resultValue.serialize()));\n    }\n  }\n  // if resultValue is undefined, one or both operands are abstract.\n  if (resultValue === undefined && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    // When comparing to null or undefined, we can return a compile time value if we know the\n    // other operand must be an object.\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      (!rval.mightNotBeObject() && (lval instanceof NullValue || lval instanceof UndefinedValue))\n    ) {\n      resultValue = new BooleanValue(realm, op[0] !== \"=\");\n      resultAst = t.assignmentExpression(ast.operator, (last: any), t.valueToNode(resultValue.serialize()));\n    }\n  }\n  // todo: special case if one result is known to be 0 or 1\n  if (resultAst === undefined) {\n    resultAst = t.assignmentExpression(ast.operator, (last: any), (rast: any));\n  }\n  return createAbstractValueForBinary(\n    op,\n    resultAst,\n    lval,\n    rval,\n    last.loc,\n    rast.loc,\n    leftCompletion,\n    rightCompletion,\n    resultValue,\n    io,\n    realm\n  );\n}\n"]}