"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  strictCode = (0, _strict2.default)(ast);

  (0, _Program.GlobalDeclarationInstantiation)(realm, ast, env, strictCode);

  let partialBody = [];
  let val;

  for (let node of ast.body) {
    if (node.type !== "FunctionDeclaration") {
      let [potentialVal, partialAst, nio] = env.partiallyEvaluateCompletionDeref(node, strictCode);
      for (let ioAst of nio) partialBody.push(ioAst);
      partialBody.push(partialAst);
      if (!(potentialVal instanceof _index.EmptyValue)) val = potentialVal;
    } else {
      // TODO: this goes away once residual functions are partially evaluated.
      partialBody.push(node);
    }
  }

  // todo: compute a global fixed point by invoking each escaped (i.e. call back)
  // function with dummy arguments and joining their effects with the
  // global state until there is no invocation that causes further changes to
  // the global state.

  let result = val || realm.intrinsics.empty;
  return [result, t.program(partialBody, ast.directives), []];
};

var _completions = require("../completions.js");

var _index = require("../values/index.js");

var _Program = require("../evaluators/Program.js");

var _strict = require("../utils/strict.js");

var _strict2 = _interopRequireDefault(_strict);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=Program.js.map