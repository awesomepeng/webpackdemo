{"version":3,"sources":["../../src/partial-evaluators/Program.js"],"names":["ast","strictCode","env","realm","partialBody","val","node","body","type","potentialVal","partialAst","nio","partiallyEvaluateCompletionDeref","ioAst","push","result","intrinsics","empty","t","program","directives"],"mappings":";;;;;;kBAsBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKsD;AACnEF,eAAa,sBAASD,GAAT,CAAb;;AAEA,+CAA+BG,KAA/B,EAAsCH,GAAtC,EAA2CE,GAA3C,EAAgDD,UAAhD;;AAEA,MAAIG,cAAsE,EAA1E;AACA,MAAIC,GAAJ;;AAEA,OAAK,IAAIC,IAAT,IAAiBN,IAAIO,IAArB,EAA2B;AACzB,QAAID,KAAKE,IAAL,KAAc,qBAAlB,EAAyC;AACvC,UAAI,CAACC,YAAD,EAAeC,UAAf,EAA2BC,GAA3B,IAAkCT,IAAIU,gCAAJ,CAAqCN,IAArC,EAA2CL,UAA3C,CAAtC;AACA,WAAK,IAAIY,KAAT,IAAkBF,GAAlB,EAAuBP,YAAYU,IAAZ,CAAiBD,KAAjB;AACvBT,kBAAYU,IAAZ,CAAkBJ,UAAlB;AACA,UAAI,EAAED,yCAAF,CAAJ,EAA2CJ,MAAMI,YAAN;AAC5C,KALD,MAKO;AACL;AACAL,kBAAYU,IAAZ,CAAiBR,IAAjB;AACD;AACF;;AAED;AACA;AACA;AACA;;AAEA,MAAIS,SAASV,OAAOF,MAAMa,UAAN,CAAiBC,KAArC;AACA,SAAO,CAACF,MAAD,EAASG,EAAEC,OAAF,CAAUf,WAAV,EAAuBJ,IAAIoB,UAA3B,CAAT,EAAiD,EAAjD,CAAP;AACD,C;;AAvCD;;AACA;;AACA;;AAEA;;;;AACA;;IAAYF,C","file":"Program.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeProgram, BabelNodeStatement, BabelNodeModuleDeclaration } from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { Completion } from \"../completions.js\";\nimport { EmptyValue, Value } from \"../values/index.js\";\nimport { GlobalDeclarationInstantiation } from \"../evaluators/Program.js\";\n\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeProgram,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeProgram, Array<BabelNodeStatement>] {\n  strictCode = IsStrict(ast);\n\n  GlobalDeclarationInstantiation(realm, ast, env, strictCode);\n\n  let partialBody: Array<BabelNodeStatement | BabelNodeModuleDeclaration> = [];\n  let val;\n\n  for (let node of ast.body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let [potentialVal, partialAst, nio] = env.partiallyEvaluateCompletionDeref(node, strictCode);\n      for (let ioAst of nio) partialBody.push(ioAst);\n      partialBody.push((partialAst: any));\n      if (!(potentialVal instanceof EmptyValue)) val = potentialVal;\n    } else {\n      // TODO: this goes away once residual functions are partially evaluated.\n      partialBody.push(node);\n    }\n  }\n\n  // todo: compute a global fixed point by invoking each escaped (i.e. call back)\n  // function with dummy arguments and joining their effects with the\n  // global state until there is no invocation that causes further changes to\n  // the global state.\n\n  let result = val || realm.intrinsics.empty;\n  return [result, t.program(partialBody, ast.directives), []];\n}\n"]}