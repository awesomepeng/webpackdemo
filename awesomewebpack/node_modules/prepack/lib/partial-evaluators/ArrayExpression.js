"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  // 1. Let array be ArrayCreate(0).
  let array = _singletons.Create.ArrayCreate(realm, 0);

  // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
  let elements = ast.elements || [];
  let partial_elements = [];
  let io = [];
  let len = elements.length;
  let nextIndex = 0;
  for (let i = 0; i < len; i++) {
    let elem = elements[i];
    if (!elem) {
      nextIndex++;
      continue;
    }

    let elemValue, elemAst, elemIO;
    if (elem.type === "SpreadElement") [elemValue, elemAst, elemIO] = env.partiallyEvaluateCompletionDeref(elem.argument, strictCode);else [elemValue, elemAst, elemIO] = env.partiallyEvaluateCompletionDeref(elem, strictCode);
    io.concat(elemIO);
    if (elemValue instanceof _completions.AbruptCompletion) {
      return [elemValue, ast, io]; //todo: log an error message
    } else if (elemValue instanceof _completions.PossiblyNormalCompletion) {
      // TODO: there was a conditional abrupt completion while evaluating elem, so join states somehow
      _index2.AbstractValue.reportIntrospectionError(elemValue.value);
      throw new _errors.FatalError();
    }
    (0, _invariant2.default)(elemValue instanceof _index2.Value);
    partial_elements[nextIndex] = elemAst;

    // ECMA262 12.2.5.2
    if (elem.type === "SpreadElement") {
      let spreadObj = elemValue;
      partial_elements[nextIndex] = t.spreadElement(elemAst);

      // update the abstract state with the contents of spreadObj, if known
      if (spreadObj instanceof _index2.ObjectValue && !spreadObj.isPartialObject()) {
        // 3. Let iterator be ? GetIterator(spreadObj).
        let iterator = (0, _index.GetIterator)(realm, spreadObj);

        // 4. Repeat
        while (true) {
          // a. Let next be ? IteratorStep(iterator).
          let next = (0, _index.IteratorStep)(realm, iterator);

          // b. If next is false, return nextIndex.
          if (next === false) break;

          // c. Let nextValue be ? IteratorValue(next).
          let nextValue = (0, _index.IteratorValue)(realm, next);

          // d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).
          let status = _singletons.Create.CreateDataProperty(realm, array, new _index2.StringValue(realm, nextIndex + ""), nextValue);

          // e. Assert: status is true.
          (0, _invariant2.default)(status === true);

          // f. Let nextIndex be nextIndex + 1.
          nextIndex++;
        }
      } else {
        // Update the abstract state to reflect our lack of complete knowledge
        // of all of the properties of the result of evaluating elem.
        array.makePartial();

        // terminate the loop if all elements have been processed
        if (i === len - 1) break;

        // If there are elements that come after this spread element, we need
        // to take their effects into account for the abstract state that results
        // from the array expression.

        // First check if the runtime spread operation cannot fail
        if (spreadObj instanceof _index2.AbstractValue && spreadObj.getType() === "Array") {
          let method = (0, _index.GetMethod)(realm, spreadObj, realm.intrinsics.SymbolIterator);
          if (method === realm.intrinsics.ArrayProto_values) continue;
        }

        // At this point we have to be pessimistic and assume that iterating spreadObj may
        // throw an exception, in which case we can't assume that the remaining element
        // expressions will be evaluated at runtime. As a consequence their effects
        // have be provisional.
        // TODO: join states somehow
        _index2.AbstractValue.reportIntrospectionError(spreadObj);
        throw new _errors.FatalError();
      }
    } else if (array.isPartialObject()) {
      // Dealing with an array element that follows on a spread object that
      // could not be iterated at compile time, so the index that this element
      // will have at runtime is not known at this point.

      let abstractIndex = _index2.AbstractValue.createFromType(realm, _index2.NumberValue);
      array.$SetPartial(abstractIndex, elemValue, array);
    } else {
      // Redundant steps.
      // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
      // 2. ReturnIfAbrupt(postIndex).
      // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.

      // 4. Let initResult be the result of evaluating AssignmentExpression.
      // 5. Let initValue be ? GetValue(initResult).
      let initValue = elemValue;

      // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).
      let created = _singletons.Create.CreateDataProperty(realm, array, new _index2.StringValue(realm, nextIndex++ + ""), initValue);

      // 7. Assert: created is true.
      (0, _invariant2.default)(created === true, "expected data property creation");
    }
  }

  // Not necessary since we propagate completions with exceptions.
  // 3. ReturnIfAbrupt(len).

  // 4. Perform Set(array, "length", ToUint32(len), false).
  _singletons.Properties.Set(realm, array, "length", new _index2.NumberValue(realm, nextIndex), false);

  // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.

  // 6. Return array.
  return [array, t.arrayExpression(partial_elements), io];
};

var _completions = require("../completions.js");

var _errors = require("../errors.js");

var _index = require("../methods/index.js");

var _index2 = require("../values/index.js");

var _singletons = require("../singletons.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=ArrayExpression.js.map