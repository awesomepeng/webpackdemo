{"version":3,"sources":["../../src/partial-evaluators/IfStatement.js"],"names":["ast","strictCode","env","realm","exprValue","exprAst","exprIO","partiallyEvaluateCompletionDeref","test","t","expressionStatement","completion","value","mightNotBeTrue","stmtCompletion","stmtAst","stmtIO","consequent","intrinsics","undefined","concat","mightNotBeFalse","alternate","emptyStatement","consequentEffects","conAst","conIO","partiallyEvaluateNodeForEffects","consequentAst","length","blockStatement","alternateEffects","altAst","altIO","alternateAst","ce","ae","joinedEffects","joinForkOrChoose","result","generator","modifiedBindings","modifiedProperties","createdObjects","captureEffects","applyEffects","resultAst","ifStatement"],"mappings":"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","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeIfStatement, BabelNodeStatement } from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\n\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { AbstractValue, Value } from \"../values/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Join } from \"../singletons.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeIfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeStatement, Array<BabelNodeStatement>] {\n  let [exprValue, exprAst, exprIO] = env.partiallyEvaluateCompletionDeref(ast.test, strictCode);\n  if (exprValue instanceof AbruptCompletion) return [exprValue, t.expressionStatement((exprAst: any)), exprIO];\n  let completion;\n  if (exprValue instanceof PossiblyNormalCompletion) {\n    completion = exprValue;\n    exprValue = completion.value;\n  }\n  invariant(exprValue instanceof Value);\n\n  if (!exprValue.mightNotBeTrue()) {\n    // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n    let [stmtCompletion, stmtAst, stmtIO] = env.partiallyEvaluateCompletionDeref(ast.consequent, strictCode);\n\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    return [stmtCompletion, (stmtAst: any), exprIO.concat(stmtIO)];\n  } else if (!exprValue.mightNotBeFalse()) {\n    let stmtCompletion, stmtAst, stmtIO;\n    if (ast.alternate)\n      // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n      [stmtCompletion, stmtAst, stmtIO] = env.partiallyEvaluateCompletionDeref(ast.alternate, strictCode);\n    else {\n      // 3 (of the if only statement). Return NormalCompletion(undefined)\n      stmtCompletion = realm.intrinsics.undefined;\n      stmtAst = t.emptyStatement();\n      stmtIO = [];\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    return [stmtCompletion, (stmtAst: any), exprIO.concat(stmtIO)];\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  // Evaluate consequent and alternate in sandboxes and get their effects.\n  let [consequentEffects, conAst, conIO] = realm.partiallyEvaluateNodeForEffects(ast.consequent, strictCode, env);\n  let consequentAst = (conAst: any);\n  if (conIO.length > 0) consequentAst = t.blockStatement(conIO.concat(consequentAst));\n\n  let [alternateEffects, altAst, altIO] = ast.alternate\n    ? realm.partiallyEvaluateNodeForEffects(ast.alternate, strictCode, env)\n    : [construct_empty_effects(realm), undefined, []];\n  let alternateAst = (altAst: any);\n  if (altIO.length > 0) alternateAst = t.blockStatement(altIO.concat(alternateAst));\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of exprValue.\n  const ce = consequentEffects;\n  const ae = alternateEffects;\n  let joinedEffects = Join.joinForkOrChoose(\n    realm,\n    exprValue,\n    new Effects(ce.result, ce.generator, ce.modifiedBindings, ce.modifiedProperties, ce.createdObjects),\n    new Effects(ae.result, ae.generator, ae.modifiedBindings, ae.modifiedProperties, ae.createdObjects)\n  );\n  completion = joinedEffects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    realm.captureEffects(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  let resultAst = t.ifStatement((exprAst: any), (consequentAst: any), (alternateAst: any));\n  invariant(!(completion instanceof Reference));\n  return [completion, resultAst, exprIO];\n}\n"]}