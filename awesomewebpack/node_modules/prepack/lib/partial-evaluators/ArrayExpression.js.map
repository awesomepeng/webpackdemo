{"version":3,"sources":["../../src/partial-evaluators/ArrayExpression.js"],"names":["ast","strictCode","env","realm","array","ArrayCreate","elements","partial_elements","io","len","length","nextIndex","i","elem","elemValue","elemAst","elemIO","type","partiallyEvaluateCompletionDeref","argument","concat","reportIntrospectionError","value","spreadObj","t","spreadElement","isPartialObject","iterator","next","nextValue","status","CreateDataProperty","makePartial","getType","method","intrinsics","SymbolIterator","ArrayProto_values","abstractIndex","createFromType","$SetPartial","initValue","created","Set","arrayExpression"],"mappings":"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","file":"ArrayExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeArrayExpression, BabelNodeStatement } from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport { GetIterator, GetMethod, IteratorStep, IteratorValue } from \"../methods/index.js\";\nimport { AbstractValue, NumberValue, ObjectValue, StringValue, Value } from \"../values/index.js\";\nimport { Create, Properties } from \"../singletons.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\n// ECMA262 2.2.5.3\nexport default function(\n  ast: BabelNodeArrayExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [AbruptCompletion | Value, BabelNodeArrayExpression, Array<BabelNodeStatement>] {\n  // 1. Let array be ArrayCreate(0).\n  let array = Create.ArrayCreate(realm, 0);\n\n  // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.\n  let elements = ast.elements || [];\n  let partial_elements = [];\n  let io = [];\n  let len = elements.length;\n  let nextIndex = 0;\n  for (let i = 0; i < len; i++) {\n    let elem = elements[i];\n    if (!elem) {\n      nextIndex++;\n      continue;\n    }\n\n    let elemValue, elemAst, elemIO;\n    if (elem.type === \"SpreadElement\")\n      [elemValue, elemAst, elemIO] = env.partiallyEvaluateCompletionDeref(elem.argument, strictCode);\n    else [elemValue, elemAst, elemIO] = env.partiallyEvaluateCompletionDeref(elem, strictCode);\n    io.concat(elemIO);\n    if (elemValue instanceof AbruptCompletion) {\n      return [elemValue, ast, io]; //todo: log an error message\n    } else if (elemValue instanceof PossiblyNormalCompletion) {\n      // TODO: there was a conditional abrupt completion while evaluating elem, so join states somehow\n      AbstractValue.reportIntrospectionError(elemValue.value);\n      throw new FatalError();\n    }\n    invariant(elemValue instanceof Value);\n    partial_elements[nextIndex] = (elemAst: any);\n\n    // ECMA262 12.2.5.2\n    if (elem.type === \"SpreadElement\") {\n      let spreadObj = elemValue;\n      partial_elements[nextIndex] = t.spreadElement((elemAst: any));\n\n      // update the abstract state with the contents of spreadObj, if known\n      if (spreadObj instanceof ObjectValue && !spreadObj.isPartialObject()) {\n        // 3. Let iterator be ? GetIterator(spreadObj).\n        let iterator = GetIterator(realm, spreadObj);\n\n        // 4. Repeat\n        while (true) {\n          // a. Let next be ? IteratorStep(iterator).\n          let next = IteratorStep(realm, iterator);\n\n          // b. If next is false, return nextIndex.\n          if (next === false) break;\n\n          // c. Let nextValue be ? IteratorValue(next).\n          let nextValue = IteratorValue(realm, next);\n\n          // d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).\n          let status = Create.CreateDataProperty(realm, array, new StringValue(realm, nextIndex + \"\"), nextValue);\n\n          // e. Assert: status is true.\n          invariant(status === true);\n\n          // f. Let nextIndex be nextIndex + 1.\n          nextIndex++;\n        }\n      } else {\n        // Update the abstract state to reflect our lack of complete knowledge\n        // of all of the properties of the result of evaluating elem.\n        array.makePartial();\n\n        // terminate the loop if all elements have been processed\n        if (i === len - 1) break;\n\n        // If there are elements that come after this spread element, we need\n        // to take their effects into account for the abstract state that results\n        // from the array expression.\n\n        // First check if the runtime spread operation cannot fail\n        if (spreadObj instanceof AbstractValue && spreadObj.getType() === \"Array\") {\n          let method = GetMethod(realm, spreadObj, realm.intrinsics.SymbolIterator);\n          if (method === realm.intrinsics.ArrayProto_values) continue;\n        }\n\n        // At this point we have to be pessimistic and assume that iterating spreadObj may\n        // throw an exception, in which case we can't assume that the remaining element\n        // expressions will be evaluated at runtime. As a consequence their effects\n        // have be provisional.\n        // TODO: join states somehow\n        AbstractValue.reportIntrospectionError(spreadObj);\n        throw new FatalError();\n      }\n    } else if (array.isPartialObject()) {\n      // Dealing with an array element that follows on a spread object that\n      // could not be iterated at compile time, so the index that this element\n      // will have at runtime is not known at this point.\n\n      let abstractIndex = AbstractValue.createFromType(realm, NumberValue);\n      array.$SetPartial(abstractIndex, elemValue, array);\n    } else {\n      // Redundant steps.\n      // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.\n      // 2. ReturnIfAbrupt(postIndex).\n      // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n\n      // 4. Let initResult be the result of evaluating AssignmentExpression.\n      // 5. Let initValue be ? GetValue(initResult).\n      let initValue = elemValue;\n\n      // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).\n      let created = Create.CreateDataProperty(realm, array, new StringValue(realm, nextIndex++ + \"\"), initValue);\n\n      // 7. Assert: created is true.\n      invariant(created === true, \"expected data property creation\");\n    }\n  }\n\n  // Not necessary since we propagate completions with exceptions.\n  // 3. ReturnIfAbrupt(len).\n\n  // 4. Perform Set(array, \"length\", ToUint32(len), false).\n  Properties.Set(realm, array, \"length\", new NumberValue(realm, nextIndex), false);\n\n  // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.\n\n  // 6. Return array.\n  return [array, t.arrayExpression(partial_elements), io];\n}\n"]}