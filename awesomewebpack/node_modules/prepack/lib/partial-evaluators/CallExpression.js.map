{"version":3,"sources":["../../src/partial-evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","ref","calleeAst","calleeIO","partiallyEvaluateCompletion","callee","completion","value","func","GetValue","io","partialArgs","argVals","arg","arguments","argValue","argAst","argIO","partiallyEvaluateCompletionDeref","concat","push","stopEffectCaptureJoinApplyAndReturnCompletion","resultAst","t","callExpression","composeNormalCompletions","previousLoc","setNextExecutionContextLocation","loc","callResult","EvaluateCall","callCompletion","unbundleNormalCompletion","undefined","captureEffects","callBothFunctionsAndJoinTheirEffects","funcs","cond","func1","func2","getType","isTypeCompatibleWith","e1","evaluateForEffects","e2","joinedEffects","joinForkOrChoose","result","generator","modifiedBindings","modifiedProperties","createdObjects","joinedCompletion","composeWithSavedCompletion","applyEffects","argList","kind","args","createFromType","throwIfNotConcrete","IsPropertyReference","GetReferencedName","intrinsics","eval","length","evalText","strictCaller","evalRealm","PerformEval","thisValue","refEnv","GetBase","WithBaseObject","thisCall","tailCall","currentLocation","err"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeStatement } from \"babel-types\";\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { AbruptCompletion, Completion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport { EvaluateDirectCallWithArgList, GetThisValue, IsInTailPosition, SameValue } from \"../methods/index.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport { AbstractValue, BooleanValue, FunctionValue, Value } from \"../values/index.js\";\n\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 12.3.4.1\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): [Completion | Value, BabelNodeExpression, Array<BabelNodeStatement>] {\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let [ref, calleeAst, calleeIO] = env.partiallyEvaluateCompletion(ast.callee, strictCode);\n  if (ref instanceof AbruptCompletion) return [ref, (calleeAst: any), calleeIO];\n  let completion;\n  if (ref instanceof PossiblyNormalCompletion) {\n    completion = ref;\n    ref = completion.value;\n  }\n  invariant(ref instanceof Value || ref instanceof Reference);\n\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  let io = calleeIO;\n  let partialArgs = [];\n  let argVals = [];\n  for (let arg of ast.arguments) {\n    let [argValue, argAst, argIO] = env.partiallyEvaluateCompletionDeref(arg, strictCode);\n    io = io.concat(argIO);\n    partialArgs.push((argAst: any));\n    if (argValue instanceof AbruptCompletion) {\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, argValue, realm);\n      else completion = argValue;\n      let resultAst = t.callExpression((calleeAst: any), partialArgs);\n      return [completion, resultAst, io];\n    }\n    if (argValue instanceof PossiblyNormalCompletion) {\n      argVals.push(argValue.value);\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.composeNormalCompletions(completion, argValue, argValue.value, realm);\n      else completion = argValue;\n    } else {\n      invariant(argValue instanceof Value);\n      argVals.push(argValue);\n    }\n  }\n\n  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);\n  try {\n    let callResult = EvaluateCall(ref, func, ast, argVals, strictCode, env, realm);\n    if (callResult instanceof AbruptCompletion) {\n      if (completion instanceof PossiblyNormalCompletion)\n        completion = Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, callResult, realm);\n      else completion = callResult;\n      let resultAst = t.callExpression((calleeAst: any), partialArgs);\n      return [completion, resultAst, io];\n    }\n    let callCompletion;\n    [callCompletion, callResult] = Join.unbundleNormalCompletion(callResult);\n    invariant(callResult instanceof Value);\n    invariant(completion === undefined || completion instanceof PossiblyNormalCompletion);\n    completion = Join.composeNormalCompletions(completion, callCompletion, callResult, realm);\n    if (completion instanceof PossiblyNormalCompletion) {\n      realm.captureEffects(completion);\n    }\n    return [completion, t.callExpression((calleeAst: any), partialArgs), io];\n  } finally {\n    realm.setNextExecutionContextLocation(previousLoc);\n  }\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  funcs: Array<Value>,\n  ast: BabelNodeCallExpression,\n  argVals: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): AbruptCompletion | Value {\n  let [cond, func1, func2] = funcs;\n  invariant(cond instanceof AbstractValue && cond.getType() === BooleanValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  const e1 = realm.evaluateForEffects(\n    () => EvaluateCall(func1, func1, ast, argVals, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/1\"\n  );\n\n  const e2 = realm.evaluateForEffects(\n    () => EvaluateCall(func2, func2, ast, argVals, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/2\"\n  );\n\n  let joinedEffects = Join.joinForkOrChoose(\n    realm,\n    cond,\n    new Effects(e1.result, e1.generator, e1.modifiedBindings, e1.modifiedProperties, e1.createdObjects),\n    new Effects(e2.result, e2.generator, e2.modifiedBindings, e2.modifiedProperties, e2.createdObjects)\n  );\n  let joinedCompletion = joinedEffects.result;\n  if (joinedCompletion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    joinedCompletion = realm.composeWithSavedCompletion(joinedCompletion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside joinedCompletion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (joinedCompletion instanceof SimpleNormalCompletion) joinedCompletion = joinedCompletion.value;\n  invariant(joinedCompletion instanceof AbruptCompletion || joinedCompletion instanceof Value);\n  return joinedCompletion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  argList: Array<Value>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): AbruptCompletion | Value {\n  if (func instanceof AbstractValue && Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n    if (func.kind === \"conditional\")\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, argList, strictCode, env, realm);\n\n    // The called function comes from the environmental model and we require that\n    // such functions have no visible side-effects. Hence we can carry on\n    // by returning a call node with the arguments updated with their partial counterparts.\n    // TODO: obtain the type of the return value from the abstract function.\n    return AbstractValue.createFromType(realm, Value);\n  }\n  // If func is abstract and not known to be a safe function, we can't safely continue.\n  func = func.throwIfNotConcrete();\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n\n  try {\n    realm.currentLocation = ast.loc; // this helps us to detect recursive calls\n    return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailCall);\n  } catch (err) {\n    if (err instanceof Completion) return err;\n    throw err;\n  }\n}\n"]}