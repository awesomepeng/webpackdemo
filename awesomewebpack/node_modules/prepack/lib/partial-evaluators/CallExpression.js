"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  // 1. Let ref be the result of evaluating MemberExpression.
  let [ref, calleeAst, calleeIO] = env.partiallyEvaluateCompletion(ast.callee, strictCode);
  if (ref instanceof _completions.AbruptCompletion) return [ref, calleeAst, calleeIO];
  let completion;
  if (ref instanceof _completions.PossiblyNormalCompletion) {
    completion = ref;
    ref = completion.value;
  }
  (0, _invariant2.default)(ref instanceof _index2.Value || ref instanceof _environment.Reference);

  // 2. Let func be ? GetValue(ref).
  let func = _singletons.Environment.GetValue(realm, ref);

  let io = calleeIO;
  let partialArgs = [];
  let argVals = [];
  for (let arg of ast.arguments) {
    let [argValue, argAst, argIO] = env.partiallyEvaluateCompletionDeref(arg, strictCode);
    io = io.concat(argIO);
    partialArgs.push(argAst);
    if (argValue instanceof _completions.AbruptCompletion) {
      if (completion instanceof _completions.PossiblyNormalCompletion) completion = _singletons.Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, argValue, realm);else completion = argValue;
      let resultAst = t.callExpression(calleeAst, partialArgs);
      return [completion, resultAst, io];
    }
    if (argValue instanceof _completions.PossiblyNormalCompletion) {
      argVals.push(argValue.value);
      if (completion instanceof _completions.PossiblyNormalCompletion) completion = _singletons.Join.composeNormalCompletions(completion, argValue, argValue.value, realm);else completion = argValue;
    } else {
      (0, _invariant2.default)(argValue instanceof _index2.Value);
      argVals.push(argValue);
    }
  }

  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);
  try {
    let callResult = EvaluateCall(ref, func, ast, argVals, strictCode, env, realm);
    if (callResult instanceof _completions.AbruptCompletion) {
      if (completion instanceof _completions.PossiblyNormalCompletion) completion = _singletons.Join.stopEffectCaptureJoinApplyAndReturnCompletion(completion, callResult, realm);else completion = callResult;
      let resultAst = t.callExpression(calleeAst, partialArgs);
      return [completion, resultAst, io];
    }
    let callCompletion;
    [callCompletion, callResult] = _singletons.Join.unbundleNormalCompletion(callResult);
    (0, _invariant2.default)(callResult instanceof _index2.Value);
    (0, _invariant2.default)(completion === undefined || completion instanceof _completions.PossiblyNormalCompletion);
    completion = _singletons.Join.composeNormalCompletions(completion, callCompletion, callResult, realm);
    if (completion instanceof _completions.PossiblyNormalCompletion) {
      realm.captureEffects(completion);
    }
    return [completion, t.callExpression(calleeAst, partialArgs), io];
  } finally {
    realm.setNextExecutionContextLocation(previousLoc);
  }
};

var _realm = require("../realm.js");

var _completions = require("../completions.js");

var _environment = require("../environment.js");

var _index = require("../methods/index.js");

var _singletons = require("../singletons.js");

var _index2 = require("../values/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function callBothFunctionsAndJoinTheirEffects(funcs, ast, argVals, strictCode, env, realm) {
  let [cond, func1, func2] = funcs;
  (0, _invariant2.default)(cond instanceof _index2.AbstractValue && cond.getType() === _index2.BooleanValue);
  (0, _invariant2.default)(_index2.Value.isTypeCompatibleWith(func1.getType(), _index2.FunctionValue));
  (0, _invariant2.default)(_index2.Value.isTypeCompatibleWith(func2.getType(), _index2.FunctionValue));

  const e1 = realm.evaluateForEffects(() => EvaluateCall(func1, func1, ast, argVals, strictCode, env, realm), undefined, "callBothFunctionsAndJoinTheirEffects/1");

  const e2 = realm.evaluateForEffects(() => EvaluateCall(func2, func2, ast, argVals, strictCode, env, realm), undefined, "callBothFunctionsAndJoinTheirEffects/2");

  let joinedEffects = _singletons.Join.joinForkOrChoose(realm, cond, new _realm.Effects(e1.result, e1.generator, e1.modifiedBindings, e1.modifiedProperties, e1.createdObjects), new _realm.Effects(e2.result, e2.generator, e2.modifiedBindings, e2.modifiedProperties, e2.createdObjects));
  let joinedCompletion = joinedEffects.result;
  if (joinedCompletion instanceof _completions.PossiblyNormalCompletion) {
    // in this case one of the branches may complete abruptly, which means that
    // not all control flow branches join into one flow at this point.
    // Consequently we have to continue tracking changes until the point where
    // all the branches come together into one.
    joinedCompletion = realm.composeWithSavedCompletion(joinedCompletion);
  }

  // Note that the effects of (non joining) abrupt branches are not included
  // in joinedEffects, but are tracked separately inside joinedCompletion.
  realm.applyEffects(joinedEffects);

  // return or throw completion
  if (joinedCompletion instanceof _completions.SimpleNormalCompletion) joinedCompletion = joinedCompletion.value;
  (0, _invariant2.default)(joinedCompletion instanceof _completions.AbruptCompletion || joinedCompletion instanceof _index2.Value);
  return joinedCompletion;
}

// ECMA262 12.3.4.1
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function EvaluateCall(ref, func, ast, argList, strictCode, env, realm) {
  if (func instanceof _index2.AbstractValue && _index2.Value.isTypeCompatibleWith(func.getType(), _index2.FunctionValue)) {
    if (func.kind === "conditional") return callBothFunctionsAndJoinTheirEffects(func.args, ast, argList, strictCode, env, realm);

    // The called function comes from the environmental model and we require that
    // such functions have no visible side-effects. Hence we can carry on
    // by returning a call node with the arguments updated with their partial counterparts.
    // TODO: obtain the type of the return value from the abstract function.
    return _index2.AbstractValue.createFromType(realm, _index2.Value);
  }
  // If func is abstract and not known to be a safe function, we can't safely continue.
  func = func.throwIfNotConcrete();

  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is "eval", then
  if (ref instanceof _environment.Reference && !_singletons.Environment.IsPropertyReference(realm, ref) && _singletons.Environment.GetReferencedName(realm, ref) === "eval") {
    // a. If SameValue(func, %eval%) is true, then
    if ((0, _index.SameValue)(realm, func, realm.intrinsics.eval)) {
      // i. Let argList be ? ArgumentListEvaluation(Arguments).

      // ii. If argList has no elements, return undefined.
      if (argList.length === 0) return realm.intrinsics.undefined;

      // iii. Let evalText be the first element of argList.
      let evalText = argList[0];

      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.
      let strictCaller = strictCode;

      // v. Let evalRealm be the current Realm Record.
      let evalRealm = realm;

      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).
      return _singletons.Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);
    }
  }

  let thisValue;

  // 4. If Type(ref) is Reference, then
  if (ref instanceof _environment.Reference) {
    // a. If IsPropertyReference(ref) is true, then
    if (_singletons.Environment.IsPropertyReference(realm, ref)) {
      // i. Let thisValue be GetThisValue(ref).
      thisValue = (0, _index.GetThisValue)(realm, ref);
    } else {
      // b. Else, the base of ref is an Environment Record
      // i. Let refEnv be GetBase(ref).
      let refEnv = _singletons.Environment.GetBase(realm, ref);
      (0, _invariant2.default)(refEnv instanceof _environment.EnvironmentRecord);

      // ii. Let thisValue be refEnv.WithBaseObject().
      thisValue = refEnv.WithBaseObject();
    }
  } else {
    // 5. Else Type(ref) is not Reference,
    // a. Let thisValue be undefined.
    thisValue = realm.intrinsics.undefined;
  }

  // 6. Let thisCall be this CallExpression.
  let thisCall = ast;

  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)
  let tailCall = (0, _index.IsInTailPosition)(realm, thisCall);

  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).

  try {
    realm.currentLocation = ast.loc; // this helps us to detect recursive calls
    return (0, _index.EvaluateDirectCallWithArgList)(realm, strictCode, env, ref, func, thisValue, argList, tailCall);
  } catch (err) {
    if (err instanceof _completions.Completion) return err;
    throw err;
  }
}
//# sourceMappingURL=CallExpression.js.map