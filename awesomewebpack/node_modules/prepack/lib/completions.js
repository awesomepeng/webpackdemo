"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PossiblyNormalCompletion = exports.ForkedAbruptCompletion = exports.ReturnCompletion = exports.BreakCompletion = exports.ContinueCompletion = exports.ThrowCompletion = exports.AbruptCompletion = exports.SimpleNormalCompletion = exports.NormalCompletion = exports.Completion = undefined;

var _invariant = require("./invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _realm = require("./realm.js");

var _index = require("./values/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

class Completion {
  constructor(value, precedingEffects, location, target) {
    this.value = value;
    this.effects = precedingEffects;
    if (precedingEffects !== undefined) precedingEffects.result = this;
    this.target = target;
    this.location = location;
    (0, _invariant2.default)(this.constructor !== Completion, "Completion is an abstract base class");
  }

  toDisplayString() {
    return "[" + this.constructor.name + " value " + (this.value ? this.value.toDisplayString() : "undefined") + "]";
  }
}

exports.Completion = Completion; // Normal completions are returned just like spec completions

class NormalCompletion extends Completion {
  constructor(value, precedingEffects, location, target) {
    super(value, precedingEffects, location, target);
    (0, _invariant2.default)(this.constructor !== NormalCompletion, "NormalCompletion is an abstract base class");
  }
}

exports.NormalCompletion = NormalCompletion; // SimpleNormalCompletions are returned just like spec completions. This class exists as the parallel for
// PossiblyNormalCompletion to make comparisons easier.

class SimpleNormalCompletion extends NormalCompletion {}

exports.SimpleNormalCompletion = SimpleNormalCompletion; // Abrupt completions are thrown as exeptions, to make it a easier
// to quickly get to the matching high level construct.

class AbruptCompletion extends Completion {
  constructor(value, precedingEffects, location, target) {
    super(value, precedingEffects, location, target);
    (0, _invariant2.default)(this.constructor !== AbruptCompletion, "AbruptCompletion is an abstract base class");
  }
}

exports.AbruptCompletion = AbruptCompletion;
class ThrowCompletion extends AbruptCompletion {
  constructor(value, precedingEffects, location, nativeStack) {
    super(value, precedingEffects, location);
    this.nativeStack = nativeStack || new Error().stack;
    let realm = value.$Realm;
    if (realm.isInPureScope() && realm.reportSideEffectCallback !== undefined) {
      realm.reportSideEffectCallback("EXCEPTION_THROWN", undefined, location);
    }
  }

}

exports.ThrowCompletion = ThrowCompletion;
class ContinueCompletion extends AbruptCompletion {
  constructor(value, precedingEffects, location, target) {
    super(value, precedingEffects, location, target || null);
  }
}

exports.ContinueCompletion = ContinueCompletion;
class BreakCompletion extends AbruptCompletion {
  constructor(value, precedingEffects, location, target) {
    super(value, precedingEffects, location, target || null);
  }
}

exports.BreakCompletion = BreakCompletion;
class ReturnCompletion extends AbruptCompletion {
  constructor(value, precedingEffects, location) {
    super(value, precedingEffects, location);
  }
}

exports.ReturnCompletion = ReturnCompletion;
class ForkedAbruptCompletion extends AbruptCompletion {
  constructor(realm, joinCondition, consequent, consequentEffects, alternate, alternateEffects) {
    super(realm.intrinsics.empty, undefined, consequent.location);
    (0, _invariant2.default)(consequentEffects);
    (0, _invariant2.default)(alternateEffects);
    this.joinCondition = joinCondition;
    consequent.effects = consequentEffects;
    this.consequent = consequent;
    alternate.effects = alternateEffects;
    this.alternate = alternate;
  }

  // For convenience, this.consequent.effects should always be defined, but accessing it directly requires
  // verifying that with an invariant.
  get consequentEffects() {
    (0, _invariant2.default)(this.consequent.effects);
    return this.consequent.effects;
  }

  get alternateEffects() {
    (0, _invariant2.default)(this.alternate.effects);
    return this.alternate.effects;
  }

  updateConsequentKeepingCurrentEffects(newConsequent) {
    let e = this.consequent.effects;
    (0, _invariant2.default)(e);
    newConsequent.effects = new _realm.Effects(newConsequent, e.generator, e.modifiedBindings, e.modifiedProperties, e.createdObjects);
    this.consequent = newConsequent;
    return this;
  }

  updateAlternateKeepingCurrentEffects(newAlternate) {
    let e = this.alternate.effects;
    (0, _invariant2.default)(e);
    newAlternate.effects = new _realm.Effects(newAlternate, e.generator, e.modifiedBindings, e.modifiedProperties, e.createdObjects);
    this.alternate = newAlternate;
    return this;
  }

  toDisplayString() {
    let superString = super.toDisplayString().slice(0, -1);
    return superString + " c: [" + this.consequent.toDisplayString() + "] a: [" + this.alternate.toDisplayString() + "]]";
  }

  containsCompletion(CompletionType) {
    if (this.consequent instanceof CompletionType) return true;
    if (this.alternate instanceof CompletionType) return true;
    if (this.consequent instanceof ForkedAbruptCompletion) {
      if (this.consequent.containsCompletion(CompletionType)) return true;
    }
    if (this.alternate instanceof ForkedAbruptCompletion) {
      if (this.alternate.containsCompletion(CompletionType)) return true;
    }
    return false;
  }

  containsBreakOrContinue() {
    if (this.consequent instanceof BreakCompletion || this.consequent instanceof ContinueCompletion) return true;
    if (this.alternate instanceof BreakCompletion || this.alternate instanceof ContinueCompletion) return true;
    if (this.consequent instanceof ForkedAbruptCompletion) {
      if (this.consequent.containsBreakOrContinue()) return true;
    }
    if (this.alternate instanceof ForkedAbruptCompletion) {
      if (this.alternate.containsBreakOrContinue()) return true;
    }
    return false;
  }

  transferChildrenToPossiblyNormalCompletion() {
    (0, _invariant2.default)(this.consequent.value instanceof _index.EmptyValue || this.alternate.value instanceof _index.EmptyValue);
    return new PossiblyNormalCompletion(this.value.$Realm.intrinsics.empty, this.joinCondition, this.consequent, this.consequentEffects, this.alternate, this.alternateEffects, []);
  }
}

exports.ForkedAbruptCompletion = ForkedAbruptCompletion; // Possibly normal completions have to be treated like normal completions
// and are thus never thrown. At the end of a try block or loop body, however,
// action must be taken to deal with the possibly abrupt case of the completion.

class PossiblyNormalCompletion extends NormalCompletion {
  constructor(value, joinCondition, consequent, consequentEffects, alternate, alternateEffects, savedPathConditions, savedEffects = undefined) {
    (0, _invariant2.default)(consequent === consequentEffects.result);
    (0, _invariant2.default)(alternate === alternateEffects.result);
    (0, _invariant2.default)(consequent instanceof NormalCompletion || alternate instanceof NormalCompletion);
    super(value, undefined, consequent.location);
    this.joinCondition = joinCondition;
    consequent.effects = consequentEffects;
    alternate.effects = alternateEffects;
    this.consequent = consequent;
    this.alternate = alternate;
    this.savedEffects = savedEffects;
    this.savedPathConditions = savedPathConditions;
  }
  // The path conditions that applied at the time of the oldest fork that caused this completion to arise.


  // For convenience, this.consequent.effects should always be defined, but accessing it directly requires
  // verifying that with an invariant.
  get consequentEffects() {
    (0, _invariant2.default)(this.consequent.effects);
    return this.consequent.effects;
  }

  get alternateEffects() {
    (0, _invariant2.default)(this.alternate.effects);
    return this.alternate.effects;
  }

  updateConsequentKeepingCurrentEffects(newConsequent) {
    if (newConsequent instanceof NormalCompletion) this.value = newConsequent.value;
    let effects = this.consequentEffects;
    newConsequent.effects = effects;
    newConsequent.effects.result = newConsequent;
    this.consequent = newConsequent;
    return this;
  }

  updateAlternateKeepingCurrentEffects(newAlternate) {
    if (newAlternate instanceof NormalCompletion) this.value = newAlternate.value;
    let effects = this.alternateEffects;
    newAlternate.effects = effects;
    newAlternate.effects.result = newAlternate;
    this.alternate = newAlternate;
    return this;
  }

  toDisplayString() {
    let superString = super.toDisplayString().slice(0, -1);
    return superString + " c: [" + this.consequent.toDisplayString() + "] a: [" + this.alternate.toDisplayString() + "]]";
  }

  getNormalCompletion() {
    let result;
    if (this.alternate instanceof SimpleNormalCompletion) {
      result = this.alternate;
    } else if (this.consequent instanceof SimpleNormalCompletion) {
      result = this.consequent;
    } else {
      if (this.alternate instanceof PossiblyNormalCompletion) {
        result = this.alternate.getNormalCompletion();
      } else {
        (0, _invariant2.default)(this.consequent instanceof PossiblyNormalCompletion);
        result = this.consequent.getNormalCompletion();
      }
    }
    (0, _invariant2.default)(result.value === this.value);
    return result;
  }

  containsCompletion(CompletionType) {
    if (this.consequent instanceof CompletionType) return true;
    if (this.alternate instanceof CompletionType) return true;
    if (this.consequent instanceof ForkedAbruptCompletion || this.consequent instanceof PossiblyNormalCompletion) {
      if (this.consequent.containsCompletion(CompletionType)) return true;
    }
    if (this.alternate instanceof ForkedAbruptCompletion || this.alternate instanceof PossiblyNormalCompletion) {
      if (this.alternate.containsCompletion(CompletionType)) return true;
    }
    return false;
  }

  containsBreakOrContinue() {
    if (this.consequent instanceof BreakCompletion || this.consequent instanceof ContinueCompletion) return true;
    if (this.alternate instanceof BreakCompletion || this.alternate instanceof ContinueCompletion) return true;
    if (this.consequent instanceof ForkedAbruptCompletion || this.consequent instanceof PossiblyNormalCompletion) {
      if (this.consequent.containsBreakOrContinue()) return true;
    }
    if (this.alternate instanceof ForkedAbruptCompletion || this.alternate instanceof PossiblyNormalCompletion) {
      if (this.alternate.containsBreakOrContinue()) return true;
    }
    return false;
  }
}
exports.PossiblyNormalCompletion = PossiblyNormalCompletion;
//# sourceMappingURL=completions.js.map