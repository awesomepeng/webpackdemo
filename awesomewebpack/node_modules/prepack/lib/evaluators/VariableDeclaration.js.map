{"version":3,"sources":["../../src/evaluators/VariableDeclaration.js"],"names":["ast","strictCode","env","realm","kind","letAndConst","declar","declarations","Initializer","init","id","type","bindingId","name","lhs","ResolveBinding","rhs","evaluate","value","GetValue","undefined","__originalName","hasNameProperty","SetFunctionName","PutValue","rval","BindingInitialization","intrinsics","empty","InitializeReferencedBinding"],"mappings":"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","file":"VariableDeclaration.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { ObjectValue, StringValue } from \"../values/index.js\";\nimport { IsAnonymousFunctionDefinition, HasOwnProperty } from \"../methods/index.js\";\nimport { Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeVariableDeclaration } from \"babel-types\";\n\n// ECMA262 13.3.1.4\nfunction letAndConst(\n  ast: BabelNodeVariableDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  for (let declar of ast.declarations) {\n    let Initializer = declar.init;\n    if (declar.id.type === \"Identifier\" && !Initializer) {\n      invariant(ast.kind !== \"const\", \"const without an initializer\");\n\n      // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).\n      let bindingId = declar.id.name;\n      let lhs = Environment.ResolveBinding(realm, bindingId, strictCode);\n\n      // 2. Return InitializeReferencedBinding(lhs, undefined).\n      Environment.InitializeReferencedBinding(realm, lhs, realm.intrinsics.undefined);\n      continue;\n    } else if (declar.id.type === \"Identifier\" && Initializer) {\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = declar.id.name;\n\n      // 2. Let lhs be ResolveBinding(bindingId).\n      let lhs = Environment.ResolveBinding(realm, bindingId, strictCode);\n\n      // 3. Let rhs be the result of evaluating Initializer.\n      let rhs = env.evaluate(Initializer, strictCode);\n\n      // 4. Let value be ? GetValue(rhs).\n      let value = Environment.GetValue(realm, rhs);\n\n      // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n        invariant(value instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(value, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).\n        if (!hasNameProperty) Functions.SetFunctionName(realm, value, new StringValue(realm, bindingId));\n      }\n\n      // 6. Return InitializeReferencedBinding(lhs, value).\n      Environment.InitializeReferencedBinding(realm, lhs, value);\n    } else if ((declar.id.type === \"ObjectPattern\" || declar.id.type === \"ArrayPattern\") && Initializer) {\n      // 1. Let rhs be the result of evaluating Initializer.\n      let rhs = env.evaluate(Initializer, strictCode);\n\n      // 2. Let rval be ? GetValue(rhs).\n      let rval = Environment.GetValue(realm, rhs);\n\n      // 3. Let env be the running execution contextâ€™s LexicalEnvironment.\n\n      // 4. Return the result of performing BindingInitialization for BindingPattern using value and env as the arguments.\n      Environment.BindingInitialization(realm, declar.id, rval, strictCode, env);\n    } else {\n      invariant(false, \"unrecognized declaration\");\n    }\n  }\n\n  return realm.intrinsics.empty;\n}\n\n// ECMA262 13.3.2.4\nexport default function(\n  ast: BabelNodeVariableDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.kind === \"let\" || ast.kind === \"const\") {\n    return letAndConst(ast, strictCode, env, realm);\n  }\n\n  for (let declar of ast.declarations) {\n    let Initializer = declar.init;\n\n    if (declar.id.type === \"Identifier\" && !Initializer) {\n      // VariableDeclaration : BindingIdentifier\n\n      // 1. Return NormalCompletion(empty).\n      continue;\n    } else if (declar.id.type === \"Identifier\" && Initializer) {\n      // VariableDeclaration : BindingIdentifier Initializer\n\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = declar.id.name;\n\n      // 2. Let lhs be ? ResolveBinding(bindingId).\n      let lhs = Environment.ResolveBinding(realm, bindingId, strictCode);\n\n      // 3. Let rhs be the result of evaluating Initializer.\n      let rhs = env.evaluate(Initializer, strictCode);\n\n      // 4. Let value be ? GetValue(rhs).\n      let value = Environment.GetValue(realm, rhs);\n      if (declar.id && declar.id.name !== undefined) value.__originalName = bindingId;\n\n      // 5. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n        invariant(value instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(value, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(value, bindingId).\n        if (!hasNameProperty) Functions.SetFunctionName(realm, value, new StringValue(realm, bindingId));\n      }\n\n      // 6. Return ? PutValue(lhs, value).\n      Properties.PutValue(realm, lhs, value);\n    } else if ((declar.id.type === \"ObjectPattern\" || declar.id.type === \"ArrayPattern\") && Initializer) {\n      // 1. Let rhs be the result of evaluating Initializer.\n      let rhs = env.evaluate(Initializer, strictCode);\n\n      // 2. Let rval be ? GetValue(rhs).\n      let rval = Environment.GetValue(realm, rhs);\n\n      // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.\n      Environment.BindingInitialization(realm, declar.id, rval, strictCode, undefined);\n    } else {\n      invariant(false, \"unrecognized declaration\");\n    }\n  }\n\n  return realm.intrinsics.empty;\n}\n"]}