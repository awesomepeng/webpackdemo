{"version":3,"sources":["../../src/evaluators/ForOfStatement.js"],"names":["InternalGetResultValue","TryToApplyEffectsOfJoiningBranches","LoopContinues","ForInOfHeadEvaluation","ForInOfBodyEvaluation","ast","strictCode","env","realm","labelSet","left","right","body","type","kind","keyResult","declarations","id","BoundNames","e","target","intrinsics","undefined","value","result","c","joinedEffects","joinNestedEffects","jr","applyEffects","containsBreakOrContinue","reportIntrospectionError","joinCondition","completion","indexOf","BindingInstantiation","envRec","environmentRecord","name","CreateImmutableBinding","CreateMutableBinding","TDZnames","expr","iterationKind","oldEnv","getRunningContext","lexicalEnvironment","length","TDZ","NewDeclarativeEnvironment","TDZEnvRec","exprRef","evaluate","lexEnv","onDestroyScope","exprValue","GetValue","empty","loc","obj","ToObject","isPartialObject","EnumerateObjectProperties","error","handleError","lhs","stmt","iterator","lhsKind","V","destructuring","IsDestructuring","nextResult","nextValue","iterationEnv","lhsRef","evaluateCompletion","names","lhsName","ResolveBinding","status","InitializeReferencedBinding","PutValue","BindingInitialization","resultValue"],"mappings":"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","file":"ForOfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport { BreakCompletion, AbruptCompletion, ContinueCompletion, ForkedAbruptCompletion } from \"../completions.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  EmptyValue,\n  NullValue,\n  ObjectValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  UpdateEmpty,\n  DestructuringAssignmentEvaluation,\n  GetIterator,\n} from \"../methods/index.js\";\nimport { Environment, Join, Properties, To } from \"../singletons.js\";\nimport type {\n  BabelNode,\n  BabelNodeForOfStatement,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\n\nexport type IterationKind = \"iterate\" | \"enumerate\";\nexport type LhsKind = \"lexicalBinding\" | \"varBinding\" | \"assignment\";\n\nexport function InternalGetResultValue(realm: Realm, result: Value | AbruptCompletion): Value {\n  if (result instanceof AbruptCompletion) {\n    return result.value;\n  } else {\n    return result;\n  }\n}\n\nexport function TryToApplyEffectsOfJoiningBranches(realm: Realm, c: ForkedAbruptCompletion): AbruptCompletion {\n  let joinedEffects = Join.joinNestedEffects(realm, c);\n  let jr = joinedEffects.result;\n  invariant(jr instanceof AbruptCompletion);\n  if (jr instanceof ContinueCompletion || jr instanceof BreakCompletion) {\n    // The end of a loop body is join point for these.\n    realm.applyEffects(joinedEffects, \"end of loop body\");\n  } else if (jr instanceof ForkedAbruptCompletion) {\n    if (jr.containsBreakOrContinue()) {\n      // todo: extract the continue completions, apply those while stashing the other comletions\n      // in realm.savedCompletion. This may need customization depending on the caller.\n      AbstractValue.reportIntrospectionError(jr.joinCondition);\n      throw new FatalError();\n    }\n  }\n  return jr;\n}\n\n// ECMA262 13.7.1.2\nexport function LoopContinues(realm: Realm, completion: Value | AbruptCompletion, labelSet: ?Array<string>): boolean {\n  // 1. If completion.[[Type]] is normal, return true.\n  if (completion instanceof Value) return true;\n  invariant(completion instanceof AbruptCompletion);\n\n  // 2. If completion.[[Type]] is not continue, return false.\n  if (!(completion instanceof ContinueCompletion)) return false;\n\n  // 3. If completion.[[Target]] is empty, return true.\n  if (!completion.target) return true;\n\n  // 4. If completion.[[Target]] is an element of labelSet, return true.\n  if (labelSet != null && labelSet.indexOf(completion.target) >= 0) return true;\n\n  // 5. Return false.\n  return false;\n}\n\n// ECMA262 13.7.5.10\nfunction BindingInstantiation(realm: Realm, ast: BabelNodeVariableDeclaration, env: LexicalEnvironment) {\n  // ast = ForDeclaration : LetOrConst ForBinding\n\n  // 1. Let envRec be environment's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord);\n\n  // 3. For each element name of the BoundNames of ForBinding do\n  for (let name of Environment.BoundNames(realm, ast)) {\n    // a. If IsConstantDeclaration of LetOrConst is true, then\n    if (ast.kind === \"const\") {\n      // i. Perform ! envRec.CreateImmutableBinding(name, true).\n      envRec.CreateImmutableBinding(name, true);\n    } else {\n      // b.\n      // i. Perform ! envRec.CreateMutableBinding(name, false).\n      envRec.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// ECMA262 13.7.5.12\nexport function ForInOfHeadEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  TDZnames: Array<string>,\n  expr: BabelNode,\n  iterationKind: IterationKind,\n  strictCode: boolean\n): ObjectValue | AbstractObjectValue {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. If TDZnames is not an empty List, then\n  if (TDZnames.length) {\n    // a. Assert: TDZnames has no duplicate entries.\n\n    // b. Let TDZ be NewDeclarativeEnvironment(oldEnv).\n    let TDZ = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n    // c. Let TDZEnvRec be TDZ's EnvironmentRecord.\n    let TDZEnvRec = TDZ.environmentRecord;\n\n    // d. For each string name in TDZnames, do\n    for (let name of TDZnames) {\n      // i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).\n      TDZEnvRec.CreateMutableBinding(name, false);\n    }\n\n    // e. Set the running execution context's LexicalEnvironment to TDZ.\n    realm.getRunningContext().lexicalEnvironment = TDZ;\n    env = TDZ;\n  }\n\n  let exprRef;\n  try {\n    // 3. Let exprRef be the result of evaluating expr.\n    exprRef = env.evaluate(expr, strictCode);\n  } finally {\n    // 4. Set the running execution context's LexicalEnvironment to oldEnv.\n    let lexEnv = realm.getRunningContext().lexicalEnvironment;\n    if (lexEnv !== oldEnv) realm.onDestroyScope(lexEnv);\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n  env = oldEnv;\n\n  // 5. Let exprValue be ? GetValue(exprRef).\n  let exprValue = Environment.GetValue(realm, exprRef);\n\n  // 6. If iterationKind is enumerate, then\n  if (iterationKind === \"enumerate\") {\n    // a. If exprValue.[[Value]] is null or undefined, then\n    if (exprValue instanceof NullValue || exprValue instanceof UndefinedValue) {\n      // i. Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.\n      throw new BreakCompletion(realm.intrinsics.empty, undefined, expr.loc, null);\n    }\n\n    // b. Let obj be ToObject(exprValue).\n    let obj = To.ToObject(realm, exprValue);\n\n    // c. Return ? EnumerateObjectProperties(obj).\n    if (obj.isPartialObject() || obj instanceof AbstractObjectValue) {\n      return obj;\n    } else {\n      return Properties.EnumerateObjectProperties(realm, obj);\n    }\n  } else {\n    // 8. Else,\n    // 1. Assert: iterationKind is iterate.\n    invariant(iterationKind === \"iterate\", \"expected iterationKind to be iterate\");\n\n    if (exprValue instanceof AbstractValue) {\n      let error = new CompilerDiagnostic(\n        \"for of loops over unknown collections are not yet supported\",\n        expr.loc,\n        \"PP0014\",\n        \"FatalError\"\n      );\n      realm.handleError(error);\n      throw new FatalError();\n    }\n\n    // 1. Return ? GetIterator(exprValue).\n    return GetIterator(realm, exprValue);\n  }\n}\n\n// ECMA262 13.7.5.13\nexport function ForInOfBodyEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  lhs: BabelNodeVariableDeclaration | BabelNodeLVal,\n  stmt: BabelNodeStatement,\n  iterator: ObjectValue,\n  lhsKind: LhsKind,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 3. Let destructuring be IsDestructuring of lhs.\n  let destructuring = Environment.IsDestructuring(lhs);\n\n  // 4. If destructuring is true and if lhsKind is assignment, then\n  if (destructuring && lhsKind === \"assignment\") {\n    // a. Assert: lhs is a LeftHandSideExpression.\n    invariant(lhs.type !== \"VariableDeclaration\");\n\n    // b. Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.\n  }\n\n  // 5. Repeat\n  while (true) {\n    // a. Let nextResult be ? IteratorStep(iterator).\n    let nextResult = IteratorStep(realm, iterator);\n\n    // b. If nextResult is false, return NormalCompletion(V).\n    if (!nextResult) return V;\n\n    // c. Let nextValue be ? IteratorValue(nextResult).\n    let nextValue = IteratorValue(realm, nextResult);\n\n    // d. If lhsKind is either assignment or varBinding, then\n    let iterationEnv: void | LexicalEnvironment;\n    let lhsRef;\n    if (lhsKind === \"assignment\" || lhsKind === \"varBinding\") {\n      // i. If destructuring is false, then\n      if (!destructuring) {\n        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)\n        lhsRef = env.evaluateCompletion(lhs, strictCode);\n      }\n    } else {\n      // e. Else,\n      // i. Assert: lhsKind is lexicalBinding.\n      invariant(lhsKind === \"lexicalBinding\", \"expected lhsKind to be lexicalBinding\");\n      invariant(lhs.type === \"VariableDeclaration\");\n\n      // ii. Assert: lhs is a ForDeclaration.\n\n      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).\n      iterationEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.\n      BindingInstantiation(realm, lhs, iterationEnv);\n\n      // v. Set the running execution context's LexicalEnvironment to iterationEnv.\n      realm.getRunningContext().lexicalEnvironment = iterationEnv;\n      env = iterationEnv;\n\n      // vi. If destructuring is false, then\n      if (!destructuring) {\n        let names = Environment.BoundNames(realm, lhs);\n\n        // 1. Assert: lhs binds a single name.\n        invariant(names.length === 1, \"expected single name\");\n\n        // 2. Let lhsName be the sole element of BoundNames of lhs.\n        let lhsName = names[0];\n\n        // 3. Let lhsRef be ! ResolveBinding(lhsName).\n        lhsRef = Environment.ResolveBinding(realm, lhsName, strictCode);\n      }\n    }\n\n    // f. If destructuring is false, then\n    let status;\n    try {\n      if (!destructuring) {\n        // i. If lhsRef is an abrupt completion, then\n        if (lhsRef instanceof AbruptCompletion) {\n          // 1. Let status be lhsRef.\n          status = lhsRef;\n        } else if (lhsKind === \"lexicalBinding\") {\n          // ii. Else if lhsKind is lexicalBinding, then\n          // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).\n          invariant(lhsRef instanceof Reference);\n          status = Environment.InitializeReferencedBinding(realm, lhsRef, nextValue);\n        } else {\n          // iii. Else,\n          // 1. Let status be PutValue(lhsRef, nextValue).\n          invariant(lhsRef !== undefined);\n          status = Properties.PutValue(realm, lhsRef, nextValue);\n        }\n      } else {\n        // g. Else,\n        // i. If lhsKind is assignment, then\n        if (lhsKind === \"assignment\") {\n          invariant(lhs.type === \"ArrayPattern\" || lhs.type === \"ObjectPattern\");\n\n          // 1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.\n          status = DestructuringAssignmentEvaluation(realm, lhs, nextValue, strictCode, iterationEnv || env);\n        } else if (lhsKind === \"varBinding\") {\n          // ii. Else if lhsKind is varBinding, then\n          // 1. Assert: lhs is a ForBinding.\n\n          // 2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.\n          status = Environment.BindingInitialization(realm, lhs, nextValue, strictCode, undefined);\n        } else {\n          // iii. Else,\n          // 1. Assert: lhsKind is lexicalBinding.\n          invariant(lhsKind === \"lexicalBinding\");\n\n          // 2. Assert: lhs is a ForDeclaration.\n\n          // 3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.\n          invariant(iterationEnv !== undefined);\n          status = Environment.BindingInitialization(realm, lhs, nextValue, strictCode, iterationEnv);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        status = e;\n      } else {\n        throw e;\n      }\n    }\n\n    // h. If status is an abrupt completion, then\n    if (status instanceof AbruptCompletion) {\n      // i. Set the running execution context's LexicalEnvironment to oldEnv.\n      realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n      // ii. Return ? IteratorClose(iterator, status).\n      throw IteratorClose(realm, iterator, status);\n    }\n\n    // i. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n    if (result instanceof ForkedAbruptCompletion) result = TryToApplyEffectsOfJoiningBranches(realm, result);\n\n    // j. Set the running execution context's LexicalEnvironment to oldEnv.\n\n    let lexEnv = realm.getRunningContext().lexicalEnvironment;\n    if (lexEnv !== oldEnv) realm.onDestroyScope(lexEnv);\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    env = oldEnv;\n\n    // k. If LoopContinues(result, labelSet) is false, return ? IteratorClose(iterator, UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      result = UpdateEmpty(realm, result, V);\n      invariant(result instanceof AbruptCompletion);\n      throw IteratorClose(realm, iterator, result);\n    }\n\n    // l. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n  }\n\n  /* istanbul ignore next */\n  invariant(false); // can't get here but there is no other way to make Flow happy\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForOfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding o fAssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration of AssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(\n          realm,\n          env,\n          Environment.BoundNames(realm, left),\n          right,\n          \"iterate\",\n          strictCode\n        );\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression of AssignmentExpression) Statement\n      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n"]}