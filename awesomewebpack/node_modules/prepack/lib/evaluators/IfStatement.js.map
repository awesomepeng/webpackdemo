{"version":3,"sources":["../../src/evaluators/IfStatement.js"],"names":["evaluate","ast","strictCode","env","realm","exprRef","test","exprValue","GetConditionValue","stmtCompletion","ToBoolean","evaluateCompletion","consequent","alternate","intrinsics","undefined","mightNotBeTrue","mightNotBeFalse","evaluateWithAbstractConditional","evaluateNodeForEffects"],"mappings":";;;;;QAsBgBA,Q,GAAAA,Q;;AAXhB;;AAEA;;AAEA;;AACA;;AACA;;AAEA;;;;AACA;;;;AAEO,SAASA,QAAT,CAAkBC,GAAlB,EAA6CC,UAA7C,EAAkEC,GAAlE,EAA2FC,KAA3F,EAAgH;AACrH;AACA,MAAIC,UAAUF,IAAIH,QAAJ,CAAaC,IAAIK,IAAjB,EAAuBJ,UAAvB,CAAd;AACA;AACA,MAAIK,YAAmB,wBAAYC,iBAAZ,CAA8BJ,KAA9B,EAAqCC,OAArC,CAAvB;;AAEA,MAAIE,yCAAJ,EAAwC;AACtC,QAAIE,cAAJ;AACA,QAAI,eAAGC,SAAH,CAAaN,KAAb,EAAoBG,SAApB,CAAJ,EAAoC;AAClC;AACAE,uBAAiBN,IAAIQ,kBAAJ,CAAuBV,IAAIW,UAA3B,EAAuCV,UAAvC,CAAjB;AACD,KAHD,MAGO;AACL,UAAID,IAAIY,SAAR,EAAmB;AACjB;AACAJ,yBAAiBN,IAAIQ,kBAAJ,CAAuBV,IAAIY,SAA3B,EAAsCX,UAAtC,CAAjB;AACD,OAHD,MAGO;AACL;AACAO,yBAAiBL,MAAMU,UAAN,CAAiBC,SAAlC;AACD;AACF;AACD;AACA;AACA,6BAAU,EAAEN,gDAAF,CAAV;AACAA,qBAAiB,yBAAYL,KAAZ,EAAmBK,cAAnB,EAAmCL,MAAMU,UAAN,CAAiBC,SAApD,CAAjB;AACA,QAAIN,uDAAJ,EAAgD;AAC9C,YAAMA,cAAN;AACD;AACD,6BAAUA,sCAAV;AACA,WAAOA,cAAP;AACD;AACD,2BAAUF,yCAAV;;AAEA,MAAI,CAACA,UAAUS,cAAV,EAAL,EAAiC;AAC/B,QAAIP,iBAAiBN,IAAIH,QAAJ,CAAaC,IAAIW,UAAjB,EAA6BV,UAA7B,CAArB;AACA,6BAAU,EAAEO,gDAAF,CAAV;AACAA,qBAAiB,yBAAYL,KAAZ,EAAmBK,cAAnB,EAAmCL,MAAMU,UAAN,CAAiBC,SAApD,CAAjB;AACA,QAAIN,uDAAJ,EAAgD;AAC9C,YAAMA,cAAN;AACD;AACD,6BAAUA,sCAAV;AACA,WAAOA,cAAP;AACD,GATD,MASO,IAAI,CAACF,UAAUU,eAAV,EAAL,EAAkC;AACvC,QAAIR,cAAJ;AACA,QAAIR,IAAIY,SAAR,EAAmBJ,iBAAiBN,IAAIH,QAAJ,CAAaC,IAAIY,SAAjB,EAA4BX,UAA5B,CAAjB,CAAnB,KACKO,iBAAiBL,MAAMU,UAAN,CAAiBC,SAAlC;AACL,6BAAU,EAAEN,gDAAF,CAAV;AACAA,qBAAiB,yBAAYL,KAAZ,EAAmBK,cAAnB,EAAmCL,MAAMU,UAAN,CAAiBC,SAApD,CAAjB;AACA,QAAIN,uDAAJ,EAAgD;AAC9C,YAAMA,cAAN;AACD;AACD,6BAAUA,sCAAV;AACA,WAAOA,cAAP;AACD,GAXM,MAWA;AACL,6BAAUF,yCAAV;AACA,WAAOH,MAAMc,+BAAN,CACLX,SADK,EAEL,MAAMH,MAAMe,sBAAN,CAA6BlB,IAAIW,UAAjC,EAA6CV,UAA7C,EAAyDC,GAAzD,CAFD,EAGL,MACEF,IAAIY,SAAJ,GAAgBT,MAAMe,sBAAN,CAA6BlB,IAAIY,SAAjC,EAA4CX,UAA5C,EAAwDC,GAAxD,CAAhB,GAA+E,oCAAwBC,KAAxB,CAJ5E,CAAP;AAMD;AACF,C,CAnFD;;;;;;;;;AASA","file":"IfStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { AbruptCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport type { BabelNodeIfStatement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Environment, To } from \"../singletons.js\";\n\nexport function evaluate(ast: BabelNodeIfStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  // 1. Let exprRef be the result of evaluating Expression\n  let exprRef = env.evaluate(ast.test, strictCode);\n  // 2. Let exprValue be ToBoolean(? GetValue(exprRef))\n  let exprValue: Value = Environment.GetConditionValue(realm, exprRef);\n\n  if (exprValue instanceof ConcreteValue) {\n    let stmtCompletion;\n    if (To.ToBoolean(realm, exprValue)) {\n      // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);\n    } else {\n      if (ast.alternate) {\n        // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);\n      } else {\n        // 3 (of the if only statement). Return NormalCompletion(undefined)\n        stmtCompletion = realm.intrinsics.undefined;\n      }\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    //if (stmtCompletion instanceof Reference) return stmtCompletion;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  if (!exprValue.mightNotBeTrue()) {\n    let stmtCompletion = env.evaluate(ast.consequent, strictCode);\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else if (!exprValue.mightNotBeFalse()) {\n    let stmtCompletion;\n    if (ast.alternate) stmtCompletion = env.evaluate(ast.alternate, strictCode);\n    else stmtCompletion = realm.intrinsics.undefined;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else {\n    invariant(exprValue instanceof AbstractValue);\n    return realm.evaluateWithAbstractConditional(\n      exprValue,\n      () => realm.evaluateNodeForEffects(ast.consequent, strictCode, env),\n      () =>\n        ast.alternate ? realm.evaluateNodeForEffects(ast.alternate, strictCode, env) : construct_empty_effects(realm)\n    );\n  }\n}\n"]}