{"version":3,"sources":["../../src/evaluators/LogicalExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","GetValue","lbool","ToBoolean","operator","rref","right","lcond","GetConditionValue","mightNotBeFalse","mightNotBeTrue","result","result1","generator","generator1","modifiedBindings","modifiedBindings1","modifiedProperties","modifiedProperties1","createdObjects","createdObjects1","result2","generator2","modifiedBindings2","modifiedProperties2","createdObjects2","wrapper","withCondition","withInverseCondition","evaluateNodeForEffects","e","joinedEffects","joinForkOrChoose","completion","composeWithSavedCompletion","applyEffects","value","createFromLogicalOp","loc"],"mappings":"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","file":"LogicalExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { InfeasiblePathError } from \"../errors.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeLogicalExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Join, Path, To } from \"../singletons.js\";\n\nexport default function(\n  ast: BabelNodeLogicalExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value | Reference {\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  if (lval instanceof ConcreteValue) {\n    let lbool = To.ToBoolean(realm, lval);\n\n    if (ast.operator === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else {\n      invariant(ast.operator === \"||\");\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n\n    let rref = env.evaluate(ast.right, strictCode);\n    return Environment.GetValue(realm, rref);\n  }\n  invariant(lval instanceof AbstractValue);\n  let lcond = Environment.GetConditionValue(realm, lref);\n\n  if (!lcond.mightNotBeFalse()) return ast.operator === \"||\" ? env.evaluate(ast.right, strictCode) : lval;\n  if (!lcond.mightNotBeTrue()) return ast.operator === \"&&\" ? env.evaluate(ast.right, strictCode) : lval;\n  invariant(lcond instanceof AbstractValue);\n\n  // Create empty effects for the case where ast.right is not evaluated\n  let {\n    result: result1,\n    generator: generator1,\n    modifiedBindings: modifiedBindings1,\n    modifiedProperties: modifiedProperties1,\n    createdObjects: createdObjects1,\n  } = construct_empty_effects(realm);\n  result1; // ignore\n\n  // Evaluate ast.right in a sandbox to get its effects\n  let result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2;\n  try {\n    let wrapper = ast.operator === \"&&\" ? Path.withCondition : Path.withInverseCondition;\n    ({\n      result: result2,\n      generator: generator2,\n      modifiedBindings: modifiedBindings2,\n      modifiedProperties: modifiedProperties2,\n      createdObjects: createdObjects2,\n    } = wrapper(lcond, () => realm.evaluateNodeForEffects(ast.right, strictCode, env)));\n  } catch (e) {\n    if (e instanceof InfeasiblePathError) {\n      // if && then lcond cannot be true on this path else lcond cannot be false on this path.\n      // Either way, we need to return just lval and not evaluate ast.right\n      return lval;\n    }\n    throw e;\n  }\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of lval.\n  // Note that converting a value to boolean never has a side effect, so we can\n  // use lval as is for the join condition.\n  let joinedEffects;\n  if (ast.operator === \"&&\") {\n    joinedEffects = Join.joinForkOrChoose(\n      realm,\n      lval,\n      new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2),\n      new Effects(new SimpleNormalCompletion(lval), generator1, modifiedBindings1, modifiedProperties1, createdObjects1)\n    );\n  } else {\n    joinedEffects = Join.joinForkOrChoose(\n      realm,\n      lval,\n      new Effects(\n        new SimpleNormalCompletion(lval),\n        generator1,\n        modifiedBindings1,\n        modifiedProperties1,\n        createdObjects1\n      ),\n      new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2)\n    );\n  }\n  let completion = joinedEffects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case the evaluation of ast.right may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n  if (result2 instanceof SimpleNormalCompletion) result2 = result2.value;\n  invariant(completion instanceof Value);\n  if (lval instanceof Value && result2 instanceof Value) {\n    // joinForkOrChoose does the right thing for the side effects of the second expression but for the result the join\n    // produces a conditional expressions of the form (a ? b : a) for a && b and (a ? a : b) for a || b\n    // Rather than look for this pattern everywhere, we override this behavior and replace the completion with\n    // the actual logical operator. This helps with simplification and reasoning when dealing with path conditions.\n    completion = AbstractValue.createFromLogicalOp(realm, ast.operator, lval, result2, ast.loc);\n  }\n  return completion;\n}\n"]}