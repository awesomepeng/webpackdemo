{"version":3,"sources":["../../src/evaluators/ClassDeclaration.js"],"names":["ClassDefinitionEvaluation","ast","strictCode","env","realm","BindingClassDeclarationEvaluation","intrinsics","empty","EvaluateClassHeritage","ClassHeritage","ref","getRunningContext","lexicalEnvironment","evaluate","val","GetValue","error","loc","handleError","className","lex","classScope","NewDeclarativeEnvironment","F","classScopeEnvRec","environmentRecord","undefined","CreateImmutableBinding","protoParent","constructorParent","superClass","ObjectPrototype","FunctionPrototype","superclass","null","createErrorThrowCompletion","TypeError","$FunctionKind","proto","ObjectCreate","$IsClassPrototype","constructor","emptyConstructor","ClassBody","elem","body","type","push","length","constructorFile","program","classDeclaration","constructorInfo","DefineMethod","$Closure","$HasEmptyConstructor","$ConstructorKind","CreateMethodProperty","methods","m","PropertyDefinitionEvaluation","InitializeBinding","onDestroyScope","id","name","value","hasNameProperty","SetFunctionName","InitializeBoundName"],"mappings":"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","file":"ClassDeclaration.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, Value, type ECMAScriptSourceFunctionValue } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { NullValue, EmptyValue, ObjectValue, ECMAScriptFunctionValue } from \"../values/index.js\";\nimport type {\n  BabelNodeClassDeclaration,\n  BabelNodeClassExpression,\n  BabelNodeClassMethod,\n  BabelNodeExpression,\n} from \"babel-types\";\nimport parse from \"../utils/parse.js\";\nimport {\n  HasOwnProperty,\n  IsConstructor,\n  Get,\n  MakeConstructor,\n  MakeClassConstructor,\n  ConstructorMethod,\n  IsStatic,\n  NonConstructorMethodDefinitions,\n} from \"../methods/index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nfunction EvaluateClassHeritage(\n  realm: Realm,\n  ClassHeritage: BabelNodeExpression,\n  strictCode: boolean\n): ObjectValue | null {\n  let ref = realm.getRunningContext().lexicalEnvironment.evaluate(ClassHeritage, strictCode);\n  let val = Environment.GetValue(realm, ref);\n  if (val instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown super class\", ClassHeritage.loc, \"PP0009\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n  if (!(val instanceof ObjectValue)) {\n    return null;\n  }\n  return val;\n}\n\n// ECMA262 14.5.14\nexport function ClassDefinitionEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration | BabelNodeClassExpression,\n  className: string | void,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): ECMAScriptSourceFunctionValue {\n  // 1. Let lex be the LexicalEnvironment of the running execution context.\n  let lex = env;\n\n  // 2. Let classScope be NewDeclarativeEnvironment(lex).\n  let classScope = Environment.NewDeclarativeEnvironment(realm, lex);\n  let F;\n\n  try {\n    // 3. Let classScopeEnvRec be classScope’s EnvironmentRecord.\n    let classScopeEnvRec = classScope.environmentRecord;\n\n    // 4. If className is not undefined, then\n    if (className !== undefined) {\n      // a. Perform classScopeEnvRec.CreateImmutableBinding(className, true).\n      classScopeEnvRec.CreateImmutableBinding(className, true);\n    }\n\n    let protoParent;\n    let constructorParent;\n    // 5. If ClassHeritage opt is not present, then\n    let ClassHeritage = ast.superClass;\n    if (!ClassHeritage) {\n      // a. Let protoParent be the intrinsic object %ObjectPrototype%.\n      protoParent = realm.intrinsics.ObjectPrototype;\n\n      // b. Let constructorParent be the intrinsic object %FunctionPrototype%.\n      constructorParent = realm.intrinsics.FunctionPrototype;\n    } else {\n      // 6. Else\n      // a. Set the running execution context’s LexicalEnvironment to classScope.\n      realm.getRunningContext().lexicalEnvironment = classScope;\n      let superclass = null;\n      try {\n        // b. Let superclass be the result of evaluating ClassHeritage.\n        superclass = EvaluateClassHeritage(realm, ClassHeritage, strictCode);\n      } finally {\n        // c. Set the running execution context’s LexicalEnvironment to lex.\n        realm.getRunningContext().lexicalEnvironment = lex;\n      }\n\n      // d. ReturnIfAbrupt(superclass).\n\n      // e. If superclass is null, then\n      if (superclass === null) {\n        // i. Let protoParent be null.\n        protoParent = realm.intrinsics.null;\n\n        // ii. Let constructorParent be the intrinsic object %FunctionPrototype%.\n        constructorParent = realm.intrinsics.FunctionPrototype;\n      } else if (!IsConstructor(realm, superclass)) {\n        // f. Else if IsConstructor(superclass) is false, throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass must be a constructor\");\n      } else {\n        // g. Else\n        // i. If superclass has a [[FunctionKind]] internal slot whose value is \"generator\", throw a TypeError exception.\n        if (superclass instanceof ECMAScriptFunctionValue && superclass.$FunctionKind === \"generator\") {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass cannot be a generator\");\n        }\n\n        // ii. Let protoParent be Get(superclass, \"prototype\").\n        protoParent = Get(realm, superclass, \"prototype\");\n\n        // iii. ReturnIfAbrupt(protoParent).\n\n        // iv. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.\n        if (!(protoParent instanceof ObjectValue || protoParent instanceof NullValue)) {\n          if (protoParent instanceof AbstractValue) {\n            let error = new CompilerDiagnostic(\n              \"unknown super class prototype\",\n              ClassHeritage.loc,\n              \"PP0010\",\n              \"RecoverableError\"\n            );\n            if (realm.handleError(error) === \"Fail\") throw new FatalError();\n            protoParent = realm.intrinsics.ObjectPrototype;\n          } else {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.TypeError,\n              \"protoParent must be an instance of Object or Null\"\n            );\n          }\n        }\n\n        // v. Let constructorParent be superclass.\n        constructorParent = superclass;\n      }\n    }\n\n    // 7. Let proto be ObjectCreate(protoParent).\n    let proto = Create.ObjectCreate(realm, protoParent);\n\n    // Provide a hint that this prototype is that of a class\n    proto.$IsClassPrototype = true;\n\n    let constructor;\n    let emptyConstructor = false;\n    let ClassBody: Array<BabelNodeClassMethod> = [];\n    for (let elem of ast.body.body) {\n      if (elem.type === \"ClassMethod\") {\n        ClassBody.push(elem);\n      }\n    }\n    // 8. If ClassBody opt is not present, let constructor be empty.\n    if (ClassBody.length === 0) {\n      emptyConstructor = true;\n      constructor = realm.intrinsics.empty;\n    } else {\n      // 9. Else, let constructor be ConstructorMethod of ClassBody.\n      constructor = ConstructorMethod(realm, ClassBody);\n    }\n\n    // 10. If constructor is empty, then,\n    if (constructor instanceof EmptyValue) {\n      emptyConstructor = true;\n      let constructorFile;\n      // a. If ClassHeritage opt is present, then\n      if (ast.superClass) {\n        // i. Let constructor be the result of parsing the source text\n        //     constructor(... args){ super (...args);}\n        // using the syntactic grammar with the goal symbol MethodDefinition.\n        constructorFile = parse(realm, \"class NeedClassForParsing { constructor(... args){ super (...args);} }\", \"\");\n      } else {\n        // b. Else,\n        // i. Let constructor be the result of parsing the source text\n        //     constructor( ){ }\n        // using the syntactic grammar with the goal symbol MethodDefinition.\n        constructorFile = parse(realm, \"class NeedClassForParsing { constructor( ){ } }\", \"\");\n      }\n\n      let {\n        program: {\n          body: [classDeclaration],\n        },\n      } = constructorFile;\n      invariant(classDeclaration.type === \"ClassDeclaration\");\n      let { body } = ((classDeclaration: any): BabelNodeClassDeclaration);\n      invariant(body.body[0].type === \"ClassMethod\");\n      constructor = ((body.body[0]: any): BabelNodeClassMethod);\n    }\n\n    // 11. Set the running execution context’s LexicalEnvironment to classScope.\n    realm.getRunningContext().lexicalEnvironment = classScope;\n\n    try {\n      // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.\n      let constructorInfo = Functions.DefineMethod(realm, constructor, proto, env, strictCode, constructorParent);\n\n      // 13. Assert: constructorInfo is not an abrupt completion.\n\n      // 14. Let F be constructorInfo.[[closure]]\n      F = constructorInfo.$Closure;\n\n      // Assign the empty constructor boolean\n      F.$HasEmptyConstructor = emptyConstructor;\n\n      // 15. If ClassHeritage opt is present, set F’s [[ConstructorKind]] internal slot to \"derived\".\n      if (ast.superClass) {\n        F.$ConstructorKind = \"derived\";\n      }\n\n      // 16. Perform MakeConstructor(F, false, proto).\n      MakeConstructor(realm, F, false, proto);\n\n      // 17. Perform MakeClassConstructor(F).\n      MakeClassConstructor(realm, F);\n\n      // 18. Perform CreateMethodProperty(proto, \"constructor\", F).\n      Create.CreateMethodProperty(realm, proto, \"constructor\", F);\n\n      let methods;\n      // 19. If ClassBody opt is not present, let methods be a new empty List.\n      if (ClassBody.length === 0) {\n        methods = [];\n      } else {\n        // 20. Else, let methods be NonConstructorMethodDefinitions of ClassBody.\n        methods = NonConstructorMethodDefinitions(realm, ClassBody);\n      }\n\n      // 21. For each ClassElement m in order from methods\n      for (let m of methods) {\n        // a. If IsStatic of m is false, then\n        if (!IsStatic(m)) {\n          // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.\n          Properties.PropertyDefinitionEvaluation(realm, m, proto, (env: any), strictCode, false);\n        } else {\n          // Else,\n          // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.\n          Properties.PropertyDefinitionEvaluation(realm, m, F, (env: any), strictCode, false);\n        }\n        // c. If status is an abrupt completion, then\n        // i. Set the running execution context's LexicalEnvironment to lex.\n        // ii. Return Completion(status).\n      }\n    } finally {\n      // 22. Set the running execution context’s LexicalEnvironment to lex.\n      realm.getRunningContext().lexicalEnvironment = lex;\n    }\n\n    // 23. If className is not undefined, then\n    if (className !== undefined) {\n      // Perform classScopeEnvRec.InitializeBinding(className, F).\n      classScopeEnvRec.InitializeBinding(className, F);\n    }\n  } finally {\n    realm.onDestroyScope(classScope);\n  }\n  // Return F.\n  return F;\n}\n\n// ECMA2 14.5.15\nfunction BindingClassDeclarationEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // ClassDeclaration : class BindingIdentifier ClassTail\n  if (ast.id) {\n    // 1. Let className be StringValue of BindingIdentifier.\n    let className = ast.id.name;\n\n    // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.\n    let value = ClassDefinitionEvaluation(realm, ast, className, strictCode, env);\n\n    // 3. ReturnIfAbrupt(value).\n\n    // 4. Let hasNameProperty be HasOwnProperty(value, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n    // 5. ReturnIfAbrupt(hasNameProperty).\n\n    // 6. If hasNameProperty is false, then perform SetFunctionName(value, className).\n    if (hasNameProperty === false) {\n      Functions.SetFunctionName(realm, value, className);\n    }\n\n    // 7. Let env be the running execution context’s LexicalEnvironment.\n\n    // 8. Let status be InitializeBoundName(className, value, env).\n    Environment.InitializeBoundName(realm, className, value, env);\n\n    // 9. ReturnIfAbrupt(status).\n\n    // 10. Return value.\n    return value;\n  } else {\n    // ClassDeclaration : class ClassTail\n    // 1. Return the result of ClassDefinitionEvaluation of ClassTail with argument undefined.\n    return ClassDefinitionEvaluation(realm, ast, undefined, strictCode, env);\n  }\n}\n\n// ECMA262 14.5.16\nexport default function(\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let status be the result of BindingClassDeclarationEvaluation of this ClassDeclaration.\n  BindingClassDeclarationEvaluation(realm, ast, strictCode, env);\n\n  // 2. ReturnIfAbrupt(status).\n\n  // 3. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n"]}