{"version":3,"sources":["../../src/evaluators/FunctionExpression.js"],"names":["ast","strictCode","env","realm","id","generator","strict","body","scope","funcEnv","NewDeclarativeEnvironment","envRec","environmentRecord","name","CreateImmutableBinding","closure","GeneratorFunctionCreate","params","loc","prototype","ObjectCreate","intrinsics","GeneratorPrototype","originalConstructor","DefinePropertyOrThrow","value","writable","enumerable","configurable","SetFunctionName","InitializeBinding","FunctionCreate"],"mappings":"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","file":"FunctionExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { MakeConstructor } from \"../methods/index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport { StringValue } from \"../values/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport type { BabelNodeFunctionExpression } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeFunctionExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 14.1.21\n\n  if (ast.id) {\n    if (ast.generator) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = Environment.NewDeclarativeEnvironment(realm, scope);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false);\n\n      // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).\n      let closure = Functions.GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 9. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(realm, closure, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false,\n      });\n\n      // 10. Perform SetFunctionName(closure, name).\n      Functions.SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure);\n\n      // 12. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = Environment.NewDeclarativeEnvironment(realm, scope, false);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false, false, true);\n      // I don't think this gets deleted anywhere else\n      //if (realm.modifiedBindings) realm.modifiedBindings.delete(name);\n\n      // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).\n      let closure = Functions.FunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 9. Perform SetFunctionName(closure, name).\n      Functions.SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 10. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure, true);\n\n      // 11. Return closure.\n      return closure;\n    }\n  } else {\n    if (ast.generator) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).\n      let closure = Functions.GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n\n      // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 5. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(realm, closure, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false,\n      });\n\n      // 6. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n      closure.loc = ast.loc;\n\n      // 4. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 5. Return closure.\n      return closure;\n    }\n  }\n}\n"]}