{"version":3,"sources":["../../src/evaluators/UpdateExpression.js"],"names":["ast","strictCode","env","realm","expr","evaluate","argument","oldExpr","GetValue","operator","op","newAbstractValue","createFromBinaryOp","loc","IsToNumberPure","isInPureScope","value","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","oldValNode","t","binaryExpression","numericLiteral","topVal","error","handleError","PutValue","prefix","oldValue","ToNumber","newValue","createFromNumberValue"],"mappings":"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","file":"UpdateExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Add } from \"../methods/index.js\";\nimport { AbstractValue, NumberValue, IntegralValue } from \"../values/index.js\";\nimport type { BabelNodeUpdateExpression } from \"babel-types\";\nimport { Environment, Havoc, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport { ValuesDomain, TypesDomain } from \"../domains/index.js\";\n\nexport default function(\n  ast: BabelNodeUpdateExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 12.4 Update Expressions\n\n  // Let expr be the result of evaluating UnaryExpression.\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  // Let oldValue be ? ToNumber(? GetValue(expr)).\n  let oldExpr = Environment.GetValue(realm, expr);\n  if (oldExpr instanceof AbstractValue) {\n    invariant(ast.operator === \"++\" || ast.operator === \"--\"); // As per BabelNodeUpdateExpression\n    let op = ast.operator === \"++\" ? \"+\" : \"-\";\n    let newAbstractValue = AbstractValue.createFromBinaryOp(realm, op, oldExpr, new NumberValue(realm, 1), ast.loc);\n    if (!To.IsToNumberPure(realm, oldExpr)) {\n      if (realm.isInPureScope()) {\n        // In pure scope we have to treat the ToNumber operation as temporal since it\n        // might throw or mutate something. We also need to havoc the argument due to the\n        // possible mutations.\n        Havoc.value(realm, oldExpr);\n        newAbstractValue = realm.evaluateWithPossibleThrowCompletion(\n          () =>\n            AbstractValue.createTemporalFromBuildFunction(realm, NumberValue, [oldExpr], ([oldValNode]) =>\n              t.binaryExpression(op, oldValNode, t.numericLiteral(1))\n            ),\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n      } else {\n        let error = new CompilerDiagnostic(\n          \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n          ast.argument.loc,\n          \"PP0008\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    }\n    Properties.PutValue(realm, expr, newAbstractValue);\n    if (ast.prefix) {\n      return newAbstractValue;\n    } else {\n      return oldExpr;\n    }\n  }\n  let oldValue = To.ToNumber(realm, oldExpr);\n\n  if (ast.prefix) {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.6.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5)\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.7.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    }\n    invariant(false);\n  } else {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.4.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return IntegralValue.createFromNumberValue(realm, oldValue);\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.5.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return IntegralValue.createFromNumberValue(realm, oldValue);\n    }\n    invariant(false);\n  }\n}\n"]}