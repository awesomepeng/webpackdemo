{"version":3,"sources":["../../src/evaluators/DoWhileStatement.js"],"names":["ast","strictCode","env","realm","labelSet","body","test","V","intrinsics","undefined","resultOrDiagnostic","evaluateWithUndoForDiagnostic","stmt","evaluateCompletion","target","value","resultValue","exprRef","evaluate","exprValue","GetConditionValue","ToBooleanPartial","iteration","bodyResult","testResult","result","evaluateForFixpointEffects","outsideEffects","insideEffects","cond","rval","bodyGenerator","generator","applyEffects","emitDoWhileStatement","handleError"],"mappings":";;;;;;kBAuBe,UACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKbC,QALa,EAMN;AACP,MAAI,EAAEC,IAAF,EAAQC,IAAR,KAAiBN,GAArB;;AAEA;AACA,MAAIO,IAAIJ,MAAMK,UAAN,CAAiBC,SAAzB;;AAEA;AACA,MAAIC,qBAAqBP,MAAMQ,6BAAN,CAAoC,MAAM;AACjE,WAAO,IAAP,EAAa;AACX;AACA,UAAIC,OAAOV,IAAIW,kBAAJ,CAAuBR,IAAvB,EAA6BJ,UAA7B,CAAX;AACA;AACA,+BAAUW,gCAAyBA,6CAAnC;AACA,UAAIA,mDAAJ,EAA4CA,OAAO,wDAAmCT,KAAnC,EAA0CS,IAA1C,CAAP;;AAE5C;AACA,UAAI,mCAAcT,KAAd,EAAqBS,IAArB,EAA2BR,QAA3B,MAAyC,KAA7C,EAAoD;AAClD,iCAAUQ,6CAAV;AACA;AACA,YAAIA,4CAAJ,EAAqC;AACnC,cAAI,CAACA,KAAKE,MAAV,EAAkB,OAAQ,yBAAYX,KAAZ,EAAmBS,IAAnB,EAAyBL,CAAzB,CAAD,CAAmCQ,KAA1C;AACnB;AACD,cAAM,yBAAYZ,KAAZ,EAAmBS,IAAnB,EAAyBL,CAAzB,CAAN;AACD;;AAED;AACA,UAAIS,cAAc,4CAAuBb,KAAvB,EAA8BS,IAA9B,CAAlB;AACA,UAAI,EAAEI,wCAAF,CAAJ,EAA0CT,IAAIS,WAAJ;;AAE1C;AACA,UAAIC,UAAUf,IAAIgB,QAAJ,CAAaZ,IAAb,EAAmBL,UAAnB,CAAd;;AAEA;AACA,UAAIkB,YAAY,wBAAYC,iBAAZ,CAA8BjB,KAA9B,EAAqCc,OAArC,CAAhB;;AAEA;AACA,UAAI,eAAGI,gBAAH,CAAoBlB,KAApB,EAA2BgB,SAA3B,MAA0C,KAA9C,EAAqD,OAAOZ,CAAP;AACtD;AACD,6BAAU,KAAV;AACD,GAhCwB,CAAzB;AAiCA,MAAIG,0CAAJ,EAAyC,OAAOA,kBAAP;;AAEzC;AACA;AACA,MAAIY,YAAY,MAAM;AACpB,QAAIC,aAAarB,IAAIW,kBAAJ,CAAuBR,IAAvB,EAA6BJ,UAA7B,CAAjB;AACA,QAAIsB,kCAAJ,EAAiCA,aAAa,wCAA2BA,UAA3B,CAAb;AACjC,QAAIN,UAAUf,IAAIgB,QAAJ,CAAaZ,IAAb,EAAmBL,UAAnB,CAAd;AACA,QAAIuB,aAAa,wBAAYJ,iBAAZ,CAA8BjB,KAA9B,EAAqCc,OAArC,CAAjB;AACA,WAAO,CAACO,UAAD,EAAaD,UAAb,CAAP;AACD,GAND;AAOA,MAAIE,SAAStB,MAAMuB,0BAAN,CAAiCJ,SAAjC,CAAb;AACA,MAAIG,WAAWhB,SAAf,EAA0B;AACxB,QAAI,CAACkB,cAAD,EAAiBC,aAAjB,EAAgCC,IAAhC,IAAwCJ,MAA5C;AACA,QAAIK,OAAOH,eAAeF,MAA1B;AACA,QAAIM,gBAAgBH,cAAcI,SAAlC;AACA7B,UAAM8B,YAAN,CAAmBN,cAAnB;AACA,QAAIK,YAAY7B,MAAM6B,SAAtB;AACA,6BAAUA,cAAcvB,SAAxB;AACAuB,cAAUE,oBAAV,CAA+BL,IAA/B,EAAqCE,aAArC;AACA,6BAAUD,mDAAV,EAAkD,oDAAlD;AACA,WAAOA,KAAKf,KAAZ;AACD;;AAED;AACAZ,QAAMgC,WAAN,CAAkBzB,kBAAlB;AACA,QAAM,wBAAN;AACD,C;;AAnFD;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA","file":"DoWhileStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Value } from \"../values/index.js\";\nimport { EmptyValue } from \"../values/index.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue, TryToApplyEffectsOfJoiningBranches } from \"./ForOfStatement.js\";\nimport { AbruptCompletion, BreakCompletion, ForkedAbruptCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeDoWhileStatement } from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeDoWhileStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { body, test } = ast;\n\n  // 1. Let V be undefined.\n  let V = realm.intrinsics.undefined;\n\n  // 2. Repeat\n  let resultOrDiagnostic = realm.evaluateWithUndoForDiagnostic(() => {\n    while (true) {\n      // a. Let stmt be the result of evaluating Statement.\n      let stmt = env.evaluateCompletion(body, strictCode);\n      //todo: check if stmt is a PossiblyNormalCompletion and defer to fixpoint computation below\n      invariant(stmt instanceof Value || stmt instanceof AbruptCompletion);\n      if (stmt instanceof ForkedAbruptCompletion) stmt = TryToApplyEffectsOfJoiningBranches(realm, stmt);\n\n      // b. If LoopContinues(stmt, labelSet) is false, return Completion(UpdateEmpty(stmt, V)).\n      if (LoopContinues(realm, stmt, labelSet) === false) {\n        invariant(stmt instanceof AbruptCompletion);\n        // ECMA262 13.1.7\n        if (stmt instanceof BreakCompletion) {\n          if (!stmt.target) return (UpdateEmpty(realm, stmt, V): any).value;\n        }\n        throw UpdateEmpty(realm, stmt, V);\n      }\n\n      // c. If stmt.[[Value]] is not empty, let V be stmt.[[Value]].\n      let resultValue = InternalGetResultValue(realm, stmt);\n      if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n      // d. Let exprRef be the result of evaluating Expression.\n      let exprRef = env.evaluate(test, strictCode);\n\n      // e. Let exprValue be ? GetValue(exprRef).\n      let exprValue = Environment.GetConditionValue(realm, exprRef);\n\n      // f. If ToBoolean(exprValue) is false, return NormalCompletion(V).\n      if (To.ToBooleanPartial(realm, exprValue) === false) return V;\n    }\n    invariant(false);\n  });\n  if (resultOrDiagnostic instanceof Value) return resultOrDiagnostic;\n\n  // If we get here then unrolling the loop did not work, possibly because the value of the loop condition is not known,\n  // so instead try to compute a fixpoint for it\n  let iteration = () => {\n    let bodyResult = env.evaluateCompletion(body, strictCode);\n    if (bodyResult instanceof Value) bodyResult = new SimpleNormalCompletion(bodyResult);\n    let exprRef = env.evaluate(test, strictCode);\n    let testResult = Environment.GetConditionValue(realm, exprRef);\n    return [testResult, bodyResult];\n  };\n  let result = realm.evaluateForFixpointEffects(iteration);\n  if (result !== undefined) {\n    let [outsideEffects, insideEffects, cond] = result;\n    let rval = outsideEffects.result;\n    let bodyGenerator = insideEffects.generator;\n    realm.applyEffects(outsideEffects);\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    generator.emitDoWhileStatement(cond, bodyGenerator);\n    invariant(rval instanceof SimpleNormalCompletion, \"todo: handle loops that throw exceptions or return\");\n    return rval.value;\n  }\n\n  // If we get here the fixpoint computation failed as well. Report the diagnostic from the unrolling and throw.\n  realm.handleError(resultOrDiagnostic);\n  throw new FatalError();\n}\n"]}