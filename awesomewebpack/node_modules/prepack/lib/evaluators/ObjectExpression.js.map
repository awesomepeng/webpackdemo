{"version":3,"sources":["../../src/evaluators/ObjectExpression.js"],"names":["EvalPropertyName","ast","strictCode","env","realm","obj","ObjectCreate","intrinsics","ObjectPrototype","prop","properties","type","propKey","EvalPropertyNamePartial","exprValueRef","evaluate","value","propValue","GetValue","hasNameProperty","SetFunctionName","mightNotBeString","error","loc","handleError","$SetPartial","CreateDataPropertyOrThrow","exprValue","argument","fromValue","excludedNames","CopyDataProperties","PropertyDefinitionEvaluation","result","computed","propertyKeyName","key","ToPropertyKey","name","ToString"],"mappings":"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","file":"ObjectExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbstractValue, ConcreteValue, ObjectValue, StringValue } from \"../values/index.js\";\nimport { IsAnonymousFunctionDefinition, HasOwnProperty } from \"../methods/index.js\";\nimport { Create, Environment, Functions, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  BabelNodeObjectExpression,\n  BabelNodeObjectProperty,\n  BabelNodeObjectMethod,\n  BabelNodeClassMethod,\n} from \"babel-types\";\n\n// Returns the result of evaluating PropertyName.\nexport function EvalPropertyName(\n  prop: BabelNodeObjectProperty | BabelNodeObjectMethod | BabelNodeClassMethod,\n  env: LexicalEnvironment,\n  realm: Realm,\n  strictCode: boolean\n): PropertyKeyValue {\n  let result = EvalPropertyNamePartial(prop, env, realm, strictCode);\n  if (result instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown computed property name\", prop.loc, \"PP0014\", \"FatalError\");\n    realm.handleError(error);\n    throw new FatalError();\n  }\n  return (result: any);\n}\n\nfunction EvalPropertyNamePartial(\n  prop: BabelNodeObjectProperty | BabelNodeObjectMethod | BabelNodeClassMethod,\n  env: LexicalEnvironment,\n  realm: Realm,\n  strictCode: boolean\n): AbstractValue | PropertyKeyValue {\n  if (prop.computed) {\n    let propertyKeyName = Environment.GetValue(realm, env.evaluate(prop.key, strictCode));\n    if (propertyKeyName instanceof AbstractValue) return propertyKeyName;\n    invariant(propertyKeyName instanceof ConcreteValue);\n    return To.ToPropertyKey(realm, propertyKeyName);\n  } else {\n    if (prop.key.type === \"Identifier\") {\n      return new StringValue(realm, prop.key.name);\n    } else {\n      let propertyKeyName = Environment.GetValue(realm, env.evaluate(prop.key, strictCode));\n      invariant(propertyKeyName instanceof ConcreteValue); // syntax only allows literals if !prop.computed\n      return To.ToString(realm, propertyKeyName);\n    }\n  }\n}\n\n// ECMA262 12.2.6.8\nexport default function(\n  ast: BabelNodeObjectExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue {\n  // 1. Let obj be ObjectCreate(%ObjectPrototype%).\n  let obj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 2. Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.\n  for (let prop of ast.properties) {\n    if (prop.type === \"ObjectProperty\") {\n      // 12.2.6.9 case 3\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyNamePartial(prop, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. Let exprValueRef be the result of evaluating AssignmentExpression.\n      let exprValueRef = env.evaluate(prop.value, strictCode);\n\n      // 4. Let propValue be ? GetValue(exprValueRef).\n      let propValue = Environment.GetValue(realm, exprValueRef);\n\n      // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then\n      if (IsAnonymousFunctionDefinition(realm, prop.value)) {\n        invariant(propValue instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(propValue, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, propValue, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(propValue, propKey).\n        invariant(!hasNameProperty); // No expression that passes through IsAnonymousFunctionDefinition can have it here\n        Functions.SetFunctionName(realm, propValue, propKey);\n      }\n\n      // 6. Assert: enumerable is true.\n\n      // 7. Return CreateDataPropertyOrThrow(object, propKey, propValue).\n      if (propKey instanceof AbstractValue) {\n        if (propKey.mightNotBeString()) {\n          let error = new CompilerDiagnostic(\"property key value is unknown\", prop.loc, \"PP0011\", \"FatalError\");\n          if (realm.handleError(error) === \"Fail\") throw new FatalError();\n          continue; // recover by ignoring the property, which is only ever safe to do if the property is dead,\n          // which is assuming a bit much, hence the designation as a FatalError.\n        }\n        obj.$SetPartial(propKey, propValue, obj);\n      } else {\n        Create.CreateDataPropertyOrThrow(realm, obj, propKey, propValue);\n      }\n    } else if (prop.type === \"SpreadProperty\") {\n      // 1. Let exprValue be the result of evaluating AssignmentExpression.\n      let exprValue = env.evaluate(prop.argument, strictCode);\n\n      // 2. Let fromValue be GetValue(exprValue).\n      let fromValue = Environment.GetValue(realm, exprValue);\n\n      // 3. ReturnIfAbrupt(fromValue).\n\n      // 4. Let excludedNames be a new empty List.\n      let excludedNames = [];\n\n      // 4. Return ? CopyDataProperties(object, fromValue, excludedNames).\n      Create.CopyDataProperties(realm, obj, fromValue, excludedNames);\n    } else {\n      invariant(prop.type === \"ObjectMethod\");\n      Properties.PropertyDefinitionEvaluation(realm, prop, obj, (env: any), strictCode, true);\n    }\n  }\n\n  // 3. ReturnIfAbrupt(status).\n\n  // 4. Return obj.\n  return obj;\n}\n"]}