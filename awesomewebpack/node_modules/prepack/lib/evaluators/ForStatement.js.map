{"version":3,"sources":["../../src/evaluators/ForStatement.js"],"names":["CreatePerIterationEnvironment","ast","strictCode","env","realm","labelSet","isInPureScope","instantRender","enabled","tryToEvaluateForStatementOrLeaveAsAbstract","evaluateForStatement","t","perIterationBindings","length","lastIterationEnv","getRunningContext","lexicalEnvironment","lastIterationEnvRec","environmentRecord","outer","parent","thisIterationEnv","NewDeclarativeEnvironment","onDestroyScope","thisIterationEnvRec","bn","CreateMutableBinding","lastValue","GetBindingValue","InitializeBinding","intrinsics","undefined","ForBodyEvaluation","test","increment","stmt","V","possibleInfiniteLoopIterations","testRef","evaluate","testValue","GetValue","ToBooleanPartial","useAbstractInterpretation","joinAllLoopExits","result","evaluateCompletion","target","value","containsContinueCompletion","savedCompletion","joinAllLoopContinues","resultValue","incRef","failIfContainsBreakOrReturnOrThrowCompletion","c","diagnostic","location","handleError","consequent","alternate","failIfContainsBreakOrContinueCompletionWithNonLocalTarget","indexOf","valueOrCompletionAtLoopContinuePoint","abruptCompletion","incorporateSavedCompletion","joinedContinueEffects","extractAndJoinCompletionsOfType","applyEffects","remainingCompletions","transferChildrenToPossiblyNormalCompletion","stillAbrupt","containsCompletion","captureEffects","valueOrCompletionAtUnconditionalExit","joinedBreakEffects","BailOutWrapperClosureRefVisitor","ReferencedIdentifier","path","state","node","name","usesArguments","ThisExpression","usesThis","label","usesGotoToLabel","ReturnStatement","usesReturn","ThrowStatement","usesThrow","VariableDeclaration","needsExpressionWrapper","isForStatement","parentPath","isForOfStatement","isForInStatement","getConvertedDeclarator","index","id","init","declarations","isIdentifier","identifier","assignmentExpression","varPatternUnsupported","kind","convertedNodeOrUndefined","replaceWith","expressionStatement","expressions","i","push","sequenceExpression","generateRuntimeForStatement","wrapperFunction","body","cloneDeep","blockStatement","uniqueOrderedTag","functionBodyUniqueTagSeed","$ECMAScriptCode","$FormalParameters","$Environment","functionInfo","file","program","functionExpression","clearCache","currentLocation","args","thisRef","thisExpression","thisVal","wrapperValue","createTemporalFromBuildFunction","func","thisExpr","callExpression","memberExpression","effects","savedSuppressDiagnostics","suppressDiagnostics","evaluateForEffects","error","evaluateWithPossibleThrowCompletion","topVal","completion","composeWithSavedCompletion","update","type","varDcl","oldEnv","loopEnv","loopEnvRec","isConst","boundNames","BoundNames","dn","CreateImmutableBinding","forDcl","currentEnv","destroyed","perIterationLets","bodyResult","exprRef"],"mappings":"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","file":"ForStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Realm } from \"../realm.js\";\nimport {\n  AbstractValue,\n  Value,\n  EmptyValue,\n  ECMAScriptSourceFunctionValue,\n  type UndefinedValue,\n} from \"../values/index.js\";\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  ForkedAbruptCompletion,\n  PossiblyNormalCompletion,\n  ReturnCompletion,\n  SimpleNormalCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport traverse from \"babel-traverse\";\nimport type { BabelTraversePath } from \"babel-traverse\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue, TryToApplyEffectsOfJoiningBranches } from \"./ForOfStatement.js\";\nimport { Environment, Functions, Havoc, Join, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { BabelNodeExpression, BabelNodeForStatement, BabelNodeBlockStatement } from \"babel-types\";\n\ntype BailOutWrapperInfo = {\n  usesArguments: boolean,\n  usesThis: boolean,\n  usesReturn: boolean,\n  usesGotoToLabel: boolean,\n  usesThrow: boolean,\n  varPatternUnsupported: boolean,\n};\n\n// ECMA262 13.7.4.9\nexport function CreatePerIterationEnvironment(realm: Realm, perIterationBindings: Array<string>): UndefinedValue {\n  // 1. If perIterationBindings has any elements, then\n  if (perIterationBindings.length > 0) {\n    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.\n    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment;\n    // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.\n    let lastIterationEnvRec = lastIterationEnv.environmentRecord;\n    // c. Let outer be lastIterationEnv's outer environment reference.\n    let outer = lastIterationEnv.parent;\n    // d. Assert: outer is not null.\n    invariant(outer !== null);\n    // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).\n    let thisIterationEnv = Environment.NewDeclarativeEnvironment(realm, outer);\n    // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.\n    realm.onDestroyScope(lastIterationEnv);\n    let thisIterationEnvRec = thisIterationEnv.environmentRecord;\n    // g. For each element bn of perIterationBindings do,\n    for (let bn of perIterationBindings) {\n      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).\n      thisIterationEnvRec.CreateMutableBinding(bn, false);\n      // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).\n      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true);\n      // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).\n      thisIterationEnvRec.InitializeBinding(bn, lastValue);\n    }\n    // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.\n    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 13.7.4.8\nfunction ForBodyEvaluation(\n  realm: Realm,\n  test,\n  increment,\n  stmt,\n  perIterationBindings: Array<string>,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n  CreatePerIterationEnvironment(realm, perIterationBindings);\n  let env = realm.getRunningContext().lexicalEnvironment;\n  let possibleInfiniteLoopIterations = 0;\n\n  // 3. Repeat\n  while (true) {\n    // a. If test is not [empty], then\n    if (test) {\n      // i. Let testRef be the result of evaluating test.\n      let testRef = env.evaluate(test, strictCode);\n\n      // ii. Let testValue be ? GetValue(testRef).\n      let testValue = Environment.GetValue(realm, testRef);\n\n      // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).\n      if (!To.ToBooleanPartial(realm, testValue)) {\n        // joinAllLoopExits does not handle labeled break/continue, so only use it when doing AI\n        if (realm.useAbstractInterpretation) return joinAllLoopExits(V);\n        return V;\n      }\n    }\n\n    // b. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n    if (result instanceof ForkedAbruptCompletion) result = TryToApplyEffectsOfJoiningBranches(realm, result);\n\n    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      // joinAllLoopExits does not handle labeled break/continue, so only use it when doing AI\n      if (realm.useAbstractInterpretation) {\n        result = UpdateEmpty(realm, result, V);\n        invariant(result instanceof AbruptCompletion);\n        return joinAllLoopExits(result);\n      }\n      // ECMA262 13.1.7\n      if (result instanceof BreakCompletion) {\n        if (!result.target) return (UpdateEmpty(realm, result, V): any).value;\n      }\n      throw UpdateEmpty(realm, result, V);\n    } else if (realm.useAbstractInterpretation) {\n      // This is a join point for conditional continue completions lurking in realm.savedCompletion\n      if (containsContinueCompletion(realm.savedCompletion)) {\n        result = joinAllLoopContinues(result);\n      }\n    }\n\n    // d. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n    CreatePerIterationEnvironment(realm, perIterationBindings);\n    env = realm.getRunningContext().lexicalEnvironment;\n\n    // f. If increment is not [empty], then\n    if (increment) {\n      // i. Let incRef be the result of evaluating increment.\n      let incRef = env.evaluate(increment, strictCode);\n\n      // ii. Perform ? GetValue(incRef).\n      Environment.GetValue(realm, incRef);\n    } else if (realm.useAbstractInterpretation) {\n      // If we have no increment and we've hit 100 iterations of trying to evaluate\n      // this loop body, then see if we have a break, return or throw completion in a\n      // guarded condition and fail if it does. We already have logic to guard\n      // against loops that are actually infinite. However, because there may be so\n      // many forked execution paths, and they're non linear, then it might\n      // computationally lead to a something that seems like an infinite loop.\n      possibleInfiniteLoopIterations++;\n      if (possibleInfiniteLoopIterations > 100) {\n        failIfContainsBreakOrReturnOrThrowCompletion(realm.savedCompletion);\n      }\n    }\n  }\n  invariant(false);\n\n  function failIfContainsBreakOrReturnOrThrowCompletion(c: void | Completion | Value) {\n    if (c === undefined) return;\n    if (c instanceof ThrowCompletion || c instanceof BreakCompletion || c instanceof ReturnCompletion) {\n      let diagnostic = new CompilerDiagnostic(\n        \"break, throw or return cannot be guarded by abstract condition\",\n        c.location,\n        \"PP0035\",\n        \"FatalError\"\n      );\n      realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n    if (c instanceof PossiblyNormalCompletion || c instanceof ForkedAbruptCompletion) {\n      failIfContainsBreakOrReturnOrThrowCompletion(c.consequent);\n      failIfContainsBreakOrReturnOrThrowCompletion(c.alternate);\n    }\n  }\n\n  function failIfContainsBreakOrContinueCompletionWithNonLocalTarget(c: void | Completion | Value) {\n    if (c === undefined) return;\n    if (c instanceof ContinueCompletion || c instanceof BreakCompletion) {\n      if (!c.target) return;\n      if (labelSet && labelSet.indexOf(c.target) >= 0) {\n        c.target = null;\n        return;\n      }\n      let diagnostic = new CompilerDiagnostic(\n        \"break or continue with target cannot be guarded by abstract condition\",\n        c.location,\n        \"PP0034\",\n        \"FatalError\"\n      );\n      realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n    if (c instanceof PossiblyNormalCompletion || c instanceof ForkedAbruptCompletion) {\n      failIfContainsBreakOrContinueCompletionWithNonLocalTarget(c.consequent);\n      failIfContainsBreakOrContinueCompletionWithNonLocalTarget(c.alternate);\n    }\n  }\n\n  function containsContinueCompletion(c: void | Completion | Value) {\n    if (c === undefined) return false;\n    if (c instanceof ContinueCompletion) {\n      if (!c.target) return true;\n      if (labelSet && labelSet.indexOf(c.target) >= 0) {\n        c.target = null;\n        return true;\n      }\n      return false;\n    }\n    if (c instanceof PossiblyNormalCompletion || c instanceof ForkedAbruptCompletion)\n      return containsContinueCompletion(c.consequent) || containsContinueCompletion(c.alternate);\n    return false;\n  }\n\n  function joinAllLoopContinues(\n    valueOrCompletionAtLoopContinuePoint: Value | AbruptCompletion\n  ): Value | AbruptCompletion {\n    // We are about start the next loop iteration and this presents a join point where all non loop breaking abrupt\n    // control flows converge into a single flow using their joined effects as the new state.\n    failIfContainsBreakOrContinueCompletionWithNonLocalTarget(realm.savedCompletion);\n\n    // Incorporate the savedCompletion (we should only get called if there is one).\n    invariant(realm.savedCompletion !== undefined);\n    if (valueOrCompletionAtLoopContinuePoint instanceof Value)\n      valueOrCompletionAtLoopContinuePoint = new ContinueCompletion(valueOrCompletionAtLoopContinuePoint, undefined);\n    let abruptCompletion = Functions.incorporateSavedCompletion(realm, valueOrCompletionAtLoopContinuePoint);\n    invariant(abruptCompletion instanceof AbruptCompletion);\n\n    // If there is now a single completion, we don't need to join\n    if (!(abruptCompletion instanceof ForkedAbruptCompletion)) return abruptCompletion;\n    invariant(containsContinueCompletion(abruptCompletion));\n\n    // Apply the joined effects of continue completions to the current state since these now join the normal path\n    let joinedContinueEffects = Join.extractAndJoinCompletionsOfType(ContinueCompletion, realm, abruptCompletion);\n    realm.applyEffects(joinedContinueEffects);\n    let c = joinedContinueEffects.result;\n    invariant(c instanceof ContinueCompletion);\n\n    // We now make a PossiblyNormalCompletion out of abruptCompletion.\n    // extractAndJoinCompletionsOfType helped with this by cheating and turning all of its nested completions\n    // that contain continue completions into PossiblyNormalCompletions.\n    let remainingCompletions = abruptCompletion.transferChildrenToPossiblyNormalCompletion();\n\n    // At this stage there can still be other kinds of abrupt completions left inside abruptCompletion. If not just return.\n    let stillAbrupt =\n      remainingCompletions.containsCompletion(BreakCompletion) ||\n      remainingCompletions.containsCompletion(ReturnCompletion) ||\n      remainingCompletions.containsCompletion(ThrowCompletion);\n    if (!stillAbrupt) return c;\n\n    // Stash the remaining completions in the realm start tracking the effects that need to be appended\n    // to the normal branch at the next join point.\n    realm.savedCompletion = remainingCompletions;\n    realm.captureEffects(remainingCompletions); // so that we can join the normal path wtih them later on\n    return c;\n  }\n\n  function joinAllLoopExits(valueOrCompletionAtUnconditionalExit: Value | AbruptCompletion): Value {\n    // We are about the leave this loop and this presents a join point where all loop breaking control flows\n    // converge into a single flow using their joined effects as the new state.\n    failIfContainsBreakOrContinueCompletionWithNonLocalTarget(realm.savedCompletion);\n\n    // Incorporate the savedCompletion if there is one.\n    if (valueOrCompletionAtUnconditionalExit instanceof Value)\n      valueOrCompletionAtUnconditionalExit = new BreakCompletion(valueOrCompletionAtUnconditionalExit, undefined);\n    let abruptCompletion = Functions.incorporateSavedCompletion(realm, valueOrCompletionAtUnconditionalExit);\n    invariant(abruptCompletion instanceof AbruptCompletion);\n\n    // If there is now a single completion, we don't need to join\n    if (abruptCompletion instanceof BreakCompletion) return (UpdateEmpty(realm, abruptCompletion, V): any).value;\n    if (!(abruptCompletion instanceof ForkedAbruptCompletion)) throw abruptCompletion;\n\n    // If there are no breaks, we don't need to join\n    if (!abruptCompletion.containsCompletion(BreakCompletion)) throw abruptCompletion;\n\n    // Apply the joined effects of break completions to the current state since these now join the normal path\n    let joinedBreakEffects = Join.extractAndJoinCompletionsOfType(BreakCompletion, realm, abruptCompletion);\n    realm.applyEffects(joinedBreakEffects);\n    let c = joinedBreakEffects.result;\n    invariant(c instanceof BreakCompletion);\n\n    // We now make a PossiblyNormalCompletion out of abruptCompletion.\n    // extractAndJoinCompletionsOfType helped with this by cheating and turning all of its nested completions\n    // that contain continue completions into PossiblyNormalCompletions.\n    let remainingCompletions = abruptCompletion.transferChildrenToPossiblyNormalCompletion();\n\n    // At this stage there can still be other kinds of abrupt completions left inside abruptCompletion. If not just return.\n    let stillAbrupt =\n      remainingCompletions.containsCompletion(ReturnCompletion) ||\n      remainingCompletions.containsCompletion(ThrowCompletion);\n    if (!stillAbrupt) return (UpdateEmpty(realm, c, V): any).value;\n\n    // Stash the remaining completions in the realm start tracking the effects that need to be appended\n    // to the normal branch at the next join point.\n    realm.savedCompletion = remainingCompletions;\n    realm.captureEffects(remainingCompletions); // so that we can join the normal path wtih them later on\n\n    // ECMA262 13.1.7\n    return (UpdateEmpty(realm, c, V): any).value;\n  }\n}\n\nlet BailOutWrapperClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    if (path.node.name === \"arguments\") {\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    state.usesThis = true;\n  },\n  \"BreakStatement|ContinueStatement\"(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    if (path.node.label !== null) {\n      state.usesGotoToLabel = true;\n    }\n  },\n  ReturnStatement(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    state.usesReturn = true;\n  },\n  ThrowStatement(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    state.usesThrow = true;\n  },\n  VariableDeclaration(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    let node = path.node;\n    // If our parent is a for loop (there are 3 kinds) we do not need a wrapper\n    // i.e. for (var x of y) for (var x in y) for (var x; x < y; x++)\n    let needsExpressionWrapper =\n      !t.isForStatement(path.parentPath.node) &&\n      !t.isForOfStatement(path.parentPath.node) &&\n      !t.isForInStatement(path.parentPath.node);\n\n    const getConvertedDeclarator = index => {\n      let { id, init } = node.declarations[index];\n\n      if (t.isIdentifier(id)) {\n        // If init is undefined, then we need to ensure we provide\n        // an actual Babel undefined node for it.\n        if (init === null) {\n          init = t.identifier(\"undefined\");\n        }\n        return t.assignmentExpression(\"=\", id, init);\n      } else {\n        // We do not currently support ObjectPattern, SpreadPattern and ArrayPattern\n        // see: https://github.com/babel/babylon/blob/master/ast/spec.md#patterns\n        state.varPatternUnsupported = true;\n      }\n    };\n\n    if (node.kind === \"var\") {\n      if (node.declarations.length === 1) {\n        let convertedNodeOrUndefined = getConvertedDeclarator(0);\n        if (convertedNodeOrUndefined === undefined) {\n          // Do not continue as we don't support this\n          return;\n        }\n        path.replaceWith(\n          needsExpressionWrapper ? t.expressionStatement(convertedNodeOrUndefined) : convertedNodeOrUndefined\n        );\n      } else {\n        // convert to sequence, so: `var x = 1, y = 2;` becomes `x = 1, y = 2;`\n        let expressions = [];\n        for (let i = 0; i < node.declarations.length; i++) {\n          let convertedNodeOrUndefined = getConvertedDeclarator(i);\n          if (convertedNodeOrUndefined === undefined) {\n            // Do not continue as we don't support this\n            return;\n          }\n          expressions.push(convertedNodeOrUndefined);\n        }\n        let sequenceExpression = t.sequenceExpression(((expressions: any): Array<BabelNodeExpression>));\n        path.replaceWith(needsExpressionWrapper ? t.expressionStatement(sequenceExpression) : sequenceExpression);\n      }\n    }\n  },\n};\n\nfunction generateRuntimeForStatement(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): AbstractValue {\n  let wrapperFunction = new ECMAScriptSourceFunctionValue(realm);\n  let body = ((t.cloneDeep(t.blockStatement([ast])): any): BabelNodeBlockStatement);\n  ((body: any): FunctionBodyAstNode).uniqueOrderedTag = realm.functionBodyUniqueTagSeed++;\n  wrapperFunction.$ECMAScriptCode = body;\n  wrapperFunction.$FormalParameters = [];\n  wrapperFunction.$Environment = env;\n  // We need to scan to AST looking for \"this\", \"return\", \"throw\", labels and \"arguments\"\n  let functionInfo = {\n    usesArguments: false,\n    usesThis: false,\n    usesReturn: false,\n    usesGotoToLabel: false,\n    usesThrow: false,\n    varPatternUnsupported: false,\n  };\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, [], body))])),\n    BailOutWrapperClosureRefVisitor,\n    null,\n    functionInfo\n  );\n  traverse.clearCache();\n  let { usesReturn, usesThrow, usesArguments, usesGotoToLabel, varPatternUnsupported, usesThis } = functionInfo;\n\n  if (usesReturn || usesThrow || usesArguments || usesGotoToLabel || varPatternUnsupported) {\n    // We do not have support for these yet\n    let diagnostic = new CompilerDiagnostic(\n      `failed to recover from a for/while loop bail-out due to unsupported logic in loop body`,\n      realm.currentLocation,\n      \"PP0037\",\n      \"FatalError\"\n    );\n    realm.handleError(diagnostic);\n    throw new FatalError();\n  }\n  let args = [wrapperFunction];\n\n  if (usesThis) {\n    let thisRef = env.evaluate(t.thisExpression(), strictCode);\n    let thisVal = Environment.GetValue(realm, thisRef);\n    Havoc.value(realm, thisVal);\n    args.push(thisVal);\n  }\n\n  // We havoc the wrapping function value, which in turn invokes the havocing\n  // logic which is transitive. The havocing logic should recursively visit\n  // all bindings/objects in the loop and its body and mark the associated\n  // bindings/objects that do havoc appropiately.\n  Havoc.value(realm, wrapperFunction);\n\n  let wrapperValue = AbstractValue.createTemporalFromBuildFunction(\n    realm,\n    Value,\n    args,\n    ([func, thisExpr]) =>\n      usesThis\n        ? t.callExpression(t.memberExpression(func, t.identifier(\"call\")), [thisExpr])\n        : t.callExpression(func, [])\n  );\n  invariant(wrapperValue instanceof AbstractValue);\n  return wrapperValue;\n}\n\nfunction tryToEvaluateForStatementOrLeaveAsAbstract(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  invariant(!realm.instantRender.enabled);\n  let effects;\n  let savedSuppressDiagnostics = realm.suppressDiagnostics;\n  try {\n    realm.suppressDiagnostics = true;\n    effects = realm.evaluateForEffects(\n      () => evaluateForStatement(ast, strictCode, env, realm, labelSet),\n      undefined,\n      \"tryToEvaluateForStatementOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      realm.suppressDiagnostics = savedSuppressDiagnostics;\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeForStatement(ast, strictCode, env, realm, labelSet),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  } finally {\n    realm.suppressDiagnostics = savedSuppressDiagnostics;\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in effects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  let completion = effects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\n// ECMA262 13.7.4.7\nexport default function(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  if (realm.isInPureScope() && !realm.instantRender.enabled) {\n    return tryToEvaluateForStatementOrLeaveAsAbstract(ast, strictCode, env, realm, labelSet);\n  } else {\n    return evaluateForStatement(ast, strictCode, env, realm, labelSet);\n  }\n}\n\nfunction evaluateForStatement(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { init, test, update, body } = ast;\n\n  if (init && init.type === \"VariableDeclaration\") {\n    if (init.kind === \"var\") {\n      // for (var VariableDeclarationList; Expression; Expression) Statement\n      // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n      let varDcl = env.evaluate(init, strictCode);\n\n      // 2. ReturnIfAbrupt(varDcl).\n      varDcl;\n\n      // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n    } else {\n      // for (LexicalDeclaration Expression; Expression) Statement\n      // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n      let oldEnv = env;\n\n      // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n      let loopEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n      let loopEnvRec = loopEnv.environmentRecord;\n\n      // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n      let isConst = init.kind === \"const\";\n\n      // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n      let boundNames = Environment.BoundNames(realm, init);\n\n      // 6. For each element dn of boundNames do\n      for (let dn of boundNames) {\n        // a. If isConst is true, then\n        if (isConst) {\n          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n          loopEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // b. Else,\n          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n          loopEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n      realm.getRunningContext().lexicalEnvironment = loopEnv;\n\n      // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n      let forDcl = loopEnv.evaluateCompletion(init, strictCode);\n\n      // 9. If forDcl is an abrupt completion, then\n      if (forDcl instanceof AbruptCompletion) {\n        // a. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n        // b. Return Completion(forDcl).\n        throw forDcl;\n      }\n\n      // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n      let perIterationLets = !isConst ? boundNames : [];\n\n      let bodyResult;\n      try {\n        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);\n      } finally {\n        // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n      }\n      // 13. Return Completion(bodyResult).\n      return bodyResult;\n    }\n  } else {\n    // for (Expression; Expression; Expression) Statement\n    // 1. If the first Expression is present, then\n    if (init) {\n      // a. Let exprRef be the result of evaluating the first Expression.\n      let exprRef = env.evaluate(init, strictCode);\n\n      // b. Perform ? GetValue(exprRef).\n      Environment.GetValue(realm, exprRef);\n    }\n\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n  }\n}\n"]}