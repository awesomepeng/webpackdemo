{"version":3,"sources":["../../src/evaluators/Program.js"],"names":["GlobalDeclarationInstantiation","ast","strictCode","env","realm","val","node","body","type","res","evaluateCompletionDeref","useAbstractInterpretation","generator","undefined","incorporateSavedCompletion","containsCompletion","joinedEffects","joinNestedEffects","applyEffects","result","emitThrow","value","intrinsics","directives","length","directive","evaluate","e","getCapturedEffects","stopEffectCaptureAndUndoEffects","normalGenerator","pathConditions","r","empty","fc","replacePossiblyNormalCompletionWithForkedAbruptCompletion","allEffects","extractAndJoinCompletionsOfType","emitConditionalThrow","appendGenerator","getRunningContext","isStrict","envRec","environmentRecord","lexNames","varNames","kind","concat","BoundNames","name","HasVarDeclaration","createErrorThrowCompletion","SyntaxError","HasLexicalDeclaration","hasRestrictedGlobal","HasRestrictedGlobalProperty","varDeclarations","FindVarScopedDeclarations","functionsToInitialize","declaredFunctionNames","d","reverse","fn","indexOf","fnDefinable","CanDeclareGlobalFunction","TypeError","push","unshift","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","lexDeclarations","s","dn","CreateImmutableBinding","CreateMutableBinding","f","fo","CreateGlobalFunctionBinding","CreateGlobalVarBinding"],"mappings":"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","file":"Program.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, ForkedAbruptCompletion, PossiblyNormalCompletion, ThrowCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, EmptyValue } from \"../values/index.js\";\nimport { GlobalEnvironmentRecord } from \"../environment.js\";\nimport { Environment, Functions, Join } from \"../singletons.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport type { BabelNodeProgram, BabelNodeVariableDeclaration } from \"babel-types\";\n\n// ECMA262 15.1.11\nexport function GlobalDeclarationInstantiation(\n  realm: Realm,\n  ast: BabelNodeProgram,\n  env: LexicalEnvironment,\n  strictCode: boolean\n): EmptyValue {\n  realm.getRunningContext().isStrict = realm.isStrict = strictCode;\n\n  // 1. Let envRec be env's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a global Environment Record.\n  invariant(envRec instanceof GlobalEnvironmentRecord, \"expected global environment record\");\n\n  // 3. Let lexNames be the LexicallyDeclaredNames of script.\n  let lexNames = [];\n\n  // 4. Let varNames be the VarDeclaredNames of script.\n  let varNames = [];\n\n  traverseFast(ast, node => {\n    if (node.type === \"VariableDeclaration\") {\n      if (((node: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        varNames = varNames.concat(Environment.BoundNames(realm, node));\n      } else {\n        lexNames = lexNames.concat(Environment.BoundNames(realm, node));\n      }\n    } else if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n      return true;\n    }\n    return false;\n  });\n\n  // 5. For each name in lexNames, do\n  for (let name of lexNames) {\n    // a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasVarDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" already declared with var\");\n    }\n\n    // b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n\n    // c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).\n    let hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(name);\n\n    // d. If hasRestrictedGlobal is true, throw a SyntaxError exception.\n    if (hasRestrictedGlobal) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, name + \" global object is restricted\");\n    }\n  }\n\n  // 6. For each name in varNames, do\n  for (let name of varNames) {\n    // a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n    if (envRec.HasLexicalDeclaration(name)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.SyntaxError,\n        name + \" already declared with let or const\"\n      );\n    }\n  }\n\n  // 7. Let varDeclarations be the VarScopedDeclarations of script.\n  let varDeclarations = Functions.FindVarScopedDeclarations(ast);\n\n  // 8. Let functionsToInitialize be a new empty List.\n  let functionsToInitialize = [];\n\n  // 9. Let declaredFunctionNames be a new empty List.\n  let declaredFunctionNames = [];\n\n  // 10. For each d in varDeclarations, in reverse list order do\n  for (let d of varDeclarations.reverse()) {\n    // a. If d is neither a VariableDeclaration or a ForBinding, then\n    if (d.type !== \"VariableDeclaration\") {\n      // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n      invariant(d.type === \"FunctionDeclaration\", \"expected function\");\n\n      // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n\n      // iii. Let fn be the sole element of the BoundNames of d.\n      let fn = Environment.BoundNames(realm, d)[0];\n\n      // iv. If fn is not an element of declaredFunctionNames, then\n      if (declaredFunctionNames.indexOf(fn) < 0) {\n        // 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).\n        let fnDefinable = envRec.CanDeclareGlobalFunction(fn);\n\n        // 2. If fnDefinable is false, throw a TypeError exception.\n        if (!fnDefinable) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.TypeError,\n            fn + \": global function declarations are not allowed\"\n          );\n        }\n\n        // 3. Append fn to declaredFunctionNames.\n        declaredFunctionNames.push(fn);\n\n        // 4. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 11. Let declaredVarNames be a new empty List.\n  let declaredVarNames = [];\n\n  // 12. For each d in varDeclarations, do\n  for (let d of varDeclarations) {\n    // a. If d is a VariableDeclaration or a ForBinding, then\n    if (d.type === \"VariableDeclaration\") {\n      // i. For each String vn in the BoundNames of d, do\n      for (let vn of Environment.BoundNames(realm, d)) {\n        // ii. If vn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(vn) < 0) {\n          // 1. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).\n          let vnDefinable = envRec.CanDeclareGlobalVar(vn);\n\n          // 2. If vnDefinable is false, throw a TypeError exception.\n          if (!vnDefinable) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.TypeError,\n              vn + \": global variable declarations are not allowed\"\n            );\n          }\n\n          // 3. If vn is not an element of declaredVarNames, then\n          if (declaredVarNames.indexOf(vn) < 0) {\n            // a. Append vn to declaredVarNames.\n            declaredVarNames.push(vn);\n          }\n        }\n      }\n    }\n  }\n\n  // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n\n  // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.\n\n  // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.\n  let lexDeclarations = [];\n  for (let s of ast.body) {\n    if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n      lexDeclarations.push(s);\n    }\n  }\n\n  // 16. For each element d in lexDeclarations do\n  for (let d of lexDeclarations) {\n    // a. NOTE Lexically declared names are only instantiated here but not initialized.\n\n    // b. For each element dn of the BoundNames of d do\n    for (let dn of Environment.BoundNames(realm, d)) {\n      // i. If IsConstantDeclaration of d is true, then\n      if (d.kind === \"const\") {\n        // 1. Perform ? envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(dn, true);\n      } else {\n        // ii. Else,\n        // 1. Perform ? envRec.CreateMutableBinding(dn, false).\n        envRec.CreateMutableBinding(dn, false);\n      }\n    }\n  }\n\n  // 17. For each production f in functionsToInitialize, do\n  for (let f of functionsToInitialize) {\n    // a. Let fn be the sole element of the BoundNames of f.\n    let fn = Environment.BoundNames(realm, f)[0];\n\n    // b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.\n    let fo = env.evaluate(f, strictCode);\n    invariant(fo instanceof Value);\n\n    // c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).\n    envRec.CreateGlobalFunctionBinding(fn, fo, false);\n  }\n\n  // 18. For each String vn in declaredVarNames, in list order do\n  for (let vn of declaredVarNames) {\n    // a. Perform ? envRec.CreateGlobalVarBinding(vn, false).\n    envRec.CreateGlobalVarBinding(vn, false);\n  }\n\n  // 19. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n\nexport default function(ast: BabelNodeProgram, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  strictCode = IsStrict(ast);\n\n  GlobalDeclarationInstantiation(realm, ast, env, strictCode);\n\n  let val;\n\n  for (let node of ast.body) {\n    if (node.type !== \"FunctionDeclaration\") {\n      let res = env.evaluateCompletionDeref(node, strictCode);\n      if (res instanceof AbruptCompletion) {\n        if (!realm.useAbstractInterpretation) throw res;\n        let generator = realm.generator;\n        invariant(generator !== undefined);\n        // We are about the leave this program and this presents a join point where all control flows\n        // converge into a single flow using the joined effects as the new state.\n        res = Functions.incorporateSavedCompletion(realm, res);\n        if (res instanceof ForkedAbruptCompletion && res.containsCompletion(ThrowCompletion)) {\n          // The global state is now at the point where the first fork occurred.\n          let joinedEffects = Join.joinNestedEffects(realm, res);\n          realm.applyEffects(joinedEffects);\n          res = joinedEffects.result;\n        } else if (res instanceof ThrowCompletion) {\n          generator.emitThrow(res.value);\n          res = realm.intrinsics.undefined;\n        } else {\n          invariant(false); // other kinds of abrupt completions should not get this far\n        }\n        break;\n      }\n      if (!(res instanceof EmptyValue)) {\n        val = res;\n      }\n    }\n  }\n  let directives = ast.directives;\n  if (!val && directives && directives.length) {\n    let directive = directives[directives.length - 1];\n    val = env.evaluate(directive, strictCode);\n    invariant(val instanceof Value);\n  }\n\n  // We are about to leave this program and this presents a join point where all control flows\n  // converge into a single flow and the joined effects become the final state.\n  if (val instanceof Value) {\n    let res = Functions.incorporateSavedCompletion(realm, val);\n    if (res instanceof PossiblyNormalCompletion) {\n      // Get state to be joined in\n      let e = realm.getCapturedEffects();\n      realm.stopEffectCaptureAndUndoEffects(res);\n      // The global state is now at the point where the last fork occurred.\n      if (res.containsCompletion(ThrowCompletion)) {\n        // Join e with the remaining completions\n        let normalGenerator = e.generator;\n        e.generator = new Generator(realm, \"dummy\", normalGenerator.pathConditions); // This generator comes after everything else.\n        let r = new ThrowCompletion(realm.intrinsics.empty, e);\n        let fc = Join.replacePossiblyNormalCompletionWithForkedAbruptCompletion(realm, res, r, e);\n        let allEffects = Join.extractAndJoinCompletionsOfType(ThrowCompletion, realm, fc);\n        realm.applyEffects(allEffects, \"all code\", true);\n        r = allEffects.result;\n        invariant(r instanceof ThrowCompletion);\n        let generator = realm.generator;\n        invariant(generator !== undefined);\n        generator.emitConditionalThrow(r.value);\n        realm.appendGenerator(normalGenerator);\n      } else {\n        realm.applyEffects(e, \"all code\", true);\n      }\n    }\n  } else {\n    // program was empty. Nothing to do.\n  }\n\n  invariant(val === undefined || val instanceof Value);\n  return val || realm.intrinsics.empty;\n}\n"]}