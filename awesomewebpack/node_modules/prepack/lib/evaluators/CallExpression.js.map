{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","callee","type","arguments","ref","evaluate","previousLoc","setNextExecutionContextLocation","loc","evaluateReference","t","base","mightNotBeObject","isInPureScope","kind","evaluateConditionalReferenceBase","evaluateWithPossibleThrowCompletion","generateRuntimeCall","topVal","func","GetValue","EvaluateCall","condValue","consequentVal","alternateVal","args","evaluateWithAbstractConditional","evaluateForEffects","consequentRef","referencedName","strict","thisValue","alternateRef","callBothFunctionsAndJoinTheirEffects","cond","func1","func2","isTypeCompatibleWith","getType","e1","undefined","e2","joinedEffects","joinForkOrChoose","result","generator","modifiedBindings","modifiedProperties","createdObjects","completion","value","composeWithSavedCompletion","applyEffects","thisArg","propName","push","concat","arg","resultType","functionResultType","createTemporalFromBuildFunction","nodes","callFunc","argStart","fun_args","slice","callExpression","tryToEvaluateCallOrLeaveAsAbstract","tailCall","instantRender","enabled","effects","savedSuppressDiagnostics","suppressDiagnostics","error","property","handleError","IsPropertyReference","GetReferencedName","intrinsics","eval","argList","length","evalText","strictCaller","evalRealm","PerformEval","refEnv","GetBase","WithBaseObject","thisCall"],"mappings":"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","file":"CallExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport { type LexicalEnvironment, type BaseValue, mightBecomeAnObject } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport {\n  AbstractValue,\n  AbstractObjectValue,\n  ConcreteValue,\n  FunctionValue,\n  ObjectValue,\n  Value,\n} from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment, Functions, Havoc, Join } from \"../singletons.js\";\nimport {\n  ArgumentListEvaluation,\n  EvaluateDirectCall,\n  GetThisValue,\n  IsInTailPosition,\n  SameValue,\n} from \"../methods/index.js\";\nimport type { BabelNodeCallExpression, BabelNodeExpression, BabelNodeSpreadElement } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport SuperCall from \"./SuperCall\";\nimport { memberExpressionHelper } from \"../utils/babelhelpers.js\";\n\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.callee.type === \"Super\") {\n    return SuperCall(ast.arguments, strictCode, env, realm);\n  }\n\n  // ECMA262 12.3.4.1\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n\n  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);\n  try {\n    return evaluateReference(ref, ast, strictCode, env, realm);\n  } finally {\n    realm.setNextExecutionContextLocation(previousLoc);\n  }\n}\n\nfunction evaluateReference(\n  ref: Reference | Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (\n    ref instanceof Reference &&\n    ref.base instanceof AbstractValue &&\n    // TODO: what about ref.base conditionals that mightBeObjects?\n    ref.base.mightNotBeObject() &&\n    realm.isInPureScope()\n  ) {\n    let base = ref.base;\n    if (base.kind === \"conditional\") {\n      return evaluateConditionalReferenceBase(ref, ast, strictCode, env, realm);\n    }\n    // avoid explicitly converting ref.base to an object because that will create a generator entry\n    // leading to two object allocations rather than one.\n    return realm.evaluateWithPossibleThrowCompletion(\n      () => generateRuntimeCall(ref, base, ast, strictCode, env, realm),\n      TypesDomain.topVal,\n      ValuesDomain.topVal\n    );\n  }\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  return EvaluateCall(ref, func, ast, strictCode, env, realm);\n}\n\nfunction evaluateConditionalReferenceBase(\n  ref: Reference,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let base = ref.base;\n  invariant(base instanceof AbstractValue);\n  invariant(base.kind === \"conditional\", \"evaluateConditionalReferenceBase expects an abstract conditional\");\n  let [condValue, consequentVal, alternateVal] = base.args;\n  invariant(condValue instanceof AbstractValue);\n\n  return realm.evaluateWithAbstractConditional(\n    condValue,\n    () => {\n      return realm.evaluateForEffects(\n        () => {\n          if (\n            consequentVal instanceof AbstractObjectValue ||\n            consequentVal instanceof ObjectValue ||\n            mightBecomeAnObject(consequentVal)\n          ) {\n            let consequentRef = new Reference(\n              ((consequentVal: any): BaseValue),\n              ref.referencedName,\n              ref.strict,\n              ref.thisValue\n            );\n            return evaluateReference(consequentRef, ast, strictCode, env, realm);\n          }\n          return consequentVal;\n        },\n        null,\n        \"evaluateConditionalReferenceBase consequent\"\n      );\n    },\n    () => {\n      return realm.evaluateForEffects(\n        () => {\n          if (\n            alternateVal instanceof AbstractObjectValue ||\n            alternateVal instanceof ObjectValue ||\n            mightBecomeAnObject(alternateVal)\n          ) {\n            let alternateRef = new Reference(\n              ((alternateVal: any): BaseValue),\n              ref.referencedName,\n              ref.strict,\n              ref.thisValue\n            );\n            return evaluateReference(alternateRef, ast, strictCode, env, realm);\n          }\n          return alternateVal;\n        },\n        null,\n        \"evaluateConditionalReferenceBase alternate\"\n      );\n    }\n  );\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  args: Array<Value>,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let [cond, func1, func2] = args;\n  invariant(cond instanceof AbstractValue);\n  invariant(Value.isTypeCompatibleWith(func1.getType(), FunctionValue));\n  invariant(Value.isTypeCompatibleWith(func2.getType(), FunctionValue));\n\n  const e1 = realm.evaluateForEffects(\n    () => EvaluateCall(func1, func1, ast, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/1\"\n  );\n\n  const e2 = realm.evaluateForEffects(\n    () => EvaluateCall(func2, func2, ast, strictCode, env, realm),\n    undefined,\n    \"callBothFunctionsAndJoinTheirEffects/2\"\n  );\n\n  let joinedEffects = Join.joinForkOrChoose(\n    realm,\n    cond,\n    new Effects(e1.result, e1.generator, e1.modifiedBindings, e1.modifiedProperties, e1.createdObjects),\n    new Effects(e2.result, e2.generator, e2.modifiedBindings, e2.modifiedProperties, e2.createdObjects)\n  );\n  let completion = joinedEffects.result;\n  if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction generateRuntimeCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n) {\n  let args = [func];\n  let [thisArg, propName] = ref instanceof Reference ? [ref.base, ref.referencedName] : [];\n  if (thisArg instanceof Value) args = [thisArg];\n  if (propName !== undefined && typeof propName !== \"string\") args.push(propName);\n  args = args.concat(ArgumentListEvaluation(realm, strictCode, env, ast.arguments));\n  for (let arg of args) {\n    if (arg !== func) {\n      // Since we don't know which function we are calling, we assume that any unfrozen object\n      // passed as an argument has leaked to the environment and is henceforth in an unknown (havoced) state,\n      // as is any other object that is known to be reachable from this object.\n      // NB: Note that this is still optimistic, particularly if the environment exposes the same object\n      // to Prepack via alternative means, thus creating aliasing that is not tracked by Prepack.\n      Havoc.value(realm, arg, ast.loc);\n    }\n  }\n  let resultType = (func instanceof AbstractObjectValue ? func.functionResultType : undefined) || Value;\n  return AbstractValue.createTemporalFromBuildFunction(realm, resultType, args, nodes => {\n    let callFunc;\n    let argStart = 1;\n    if (thisArg instanceof Value) {\n      if (typeof propName === \"string\") {\n        callFunc = memberExpressionHelper(nodes[0], propName);\n      } else {\n        callFunc = memberExpressionHelper(nodes[0], nodes[1]);\n        argStart = 2;\n      }\n    } else {\n      callFunc = nodes[0];\n    }\n    let fun_args = ((nodes.slice(argStart): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n    return t.callExpression(callFunc, fun_args);\n  });\n}\n\nfunction tryToEvaluateCallOrLeaveAsAbstract(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  thisValue: Value,\n  tailCall: boolean\n): Value {\n  invariant(!realm.instantRender.enabled);\n  let effects;\n  let savedSuppressDiagnostics = realm.suppressDiagnostics;\n  try {\n    realm.suppressDiagnostics = true;\n    effects = realm.evaluateForEffects(\n      () => EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall),\n      undefined,\n      \"tryToEvaluateCallOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      realm.suppressDiagnostics = savedSuppressDiagnostics;\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  } finally {\n    realm.suppressDiagnostics = savedSuppressDiagnostics;\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in effects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  let completion = effects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n  invariant(completion instanceof Value);\n  return completion;\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (func instanceof AbstractValue) {\n    let loc = ast.callee.type === \"MemberExpression\" ? ast.callee.property.loc : ast.callee.loc;\n    if (!Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n      if (!realm.isInPureScope()) {\n        // If this is not a function, this call might throw which can change the state of the program.\n        // If this is called from a pure function we handle it using evaluateWithPossiblyAbruptCompletion.\n        let error = new CompilerDiagnostic(\"might not be a function\", loc, \"PP0005\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    } else if (func.kind === \"conditional\") {\n      return callBothFunctionsAndJoinTheirEffects(func.args, ast, strictCode, env, realm);\n    } else {\n      // Assume that it is a safe function. TODO #705: really?\n    }\n    if (realm.isInPureScope()) {\n      // In pure functions we allow abstract functions to throw, which this might.\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    }\n    return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n  }\n  invariant(func instanceof ConcreteValue);\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ast.arguments);\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      if (evalText instanceof AbstractValue) {\n        let loc = ast.arguments[0].loc;\n        let error = new CompilerDiagnostic(\"eval argument must be a known value\", loc, \"PP0006\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.\n        return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n      }\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  if (realm.isInPureScope() && !realm.instantRender.enabled) {\n    return tryToEvaluateCallOrLeaveAsAbstract(ref, func, ast, strictCode, env, realm, thisValue, tailCall);\n  } else {\n    return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);\n  }\n}\n"]}