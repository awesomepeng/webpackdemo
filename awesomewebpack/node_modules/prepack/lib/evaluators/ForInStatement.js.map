{"version":3,"sources":["../../src/evaluators/ForInStatement.js"],"names":["ast","strictCode","env","realm","labelSet","left","right","body","reportErrorAndThrowIfNotConcrete","val","loc","reportError","type","kind","keyResult","isPartialObject","isSimpleObject","emitResidualLoopIfSafe","declarations","id","BoundNames","e","target","intrinsics","undefined","value","t","error","handleError","lh","obexpr","ob","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","NewDeclarativeEnvironment","envRec","environmentRecord","absStr","createFromType","boundName","n","identifier","CreateMutableBinding","InitializeBinding","result","generator","gen","modifiedBindings","modifiedProperties","createdObjects","evaluateNodeForEffects","empty","size","targetObject","sourceObject","forEach","desc","key","map","object","unknownProperty","sourceValue","cond","args","falseVal","mem","condition","o","values","isTop","getElements","oe","makeSimple","makePartial","makeNotPartial","keyValPairs","keyVal","$Get","$Set","emitForInStatement","onDestroyScope"],"mappings":"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","file":"ForInStatement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { BreakCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { ForInOfHeadEvaluation, ForInOfBodyEvaluation } from \"./ForOfStatement.js\";\nimport { EnumerableOwnProperties, UpdateEmpty } from \"../methods/index.js\";\nimport { Environment } from \"../singletons.js\";\nimport { AbstractValue, AbstractObjectValue, ArrayValue, ObjectValue, StringValue, Value } from \"../values/index.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeForInStatement,\n  BabelNodeSourceLocation,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\n// helper func to report error\nfunction reportError(realm: Realm, loc: ?BabelNodeSourceLocation) {\n  let error = new CompilerDiagnostic(\n    \"for in loops over unknown objects are not yet supported\",\n    loc,\n    \"PP0013\",\n    \"FatalError\"\n  );\n  realm.handleError(error);\n  throw new FatalError();\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForInStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  function reportErrorAndThrowIfNotConcrete(val: Value, loc: ?BabelNodeSourceLocation) {\n    if (val instanceof AbstractValue) reportError(realm, loc);\n  }\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding in Expression) Statement\n        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n        if (keyResult.isPartialObject() && keyResult.isSimpleObject()) {\n          return emitResidualLoopIfSafe(ast, strictCode, env, realm, left, right, keyResult, body);\n        }\n        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration in Expression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(\n          realm,\n          env,\n          Environment.BoundNames(realm, left),\n          right,\n          \"enumerate\",\n          strictCode\n        );\n        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression in Expression) Statement\n      // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n      reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n\nfunction emitResidualLoopIfSafe(\n  ast: BabelNodeForInStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  lh: BabelNodeVariableDeclaration,\n  obexpr: BabelNodeExpression,\n  ob: ObjectValue | AbstractObjectValue,\n  body: BabelNodeStatement\n) {\n  invariant(ob.isSimpleObject());\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n  try {\n    let envRec = blockEnv.environmentRecord;\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n    let absStr = AbstractValue.createFromType(realm, StringValue);\n    let boundName;\n    for (let n of Environment.BoundNames(realm, lh)) {\n      invariant(boundName === undefined);\n      boundName = t.identifier(n);\n      envRec.CreateMutableBinding(n, false);\n      envRec.InitializeBinding(n, absStr);\n    }\n    let { result, generator: gen, modifiedBindings, modifiedProperties, createdObjects } = realm.evaluateNodeForEffects(\n      body,\n      strictCode,\n      blockEnv\n    );\n    if (\n      result instanceof SimpleNormalCompletion &&\n      gen.empty() &&\n      modifiedBindings.size === 0 &&\n      modifiedProperties.size === 1\n    ) {\n      invariant(createdObjects.size === 0); // or there will be more than one property\n      let targetObject;\n      let sourceObject;\n      modifiedProperties.forEach((desc, key, map) => {\n        if (key.object.unknownProperty === key) {\n          targetObject = key.object;\n          invariant(desc !== undefined);\n          let sourceValue = desc.value;\n          if (sourceValue instanceof AbstractValue) {\n            // because sourceValue was written to key.object.unknownProperty it must be that\n            let cond = sourceValue.args[0];\n            // and because the write always creates a value of this shape\n            invariant(cond instanceof AbstractValue && cond.kind === \"template for property name condition\");\n            let falseVal = sourceValue.args[2];\n            if (falseVal instanceof AbstractValue && falseVal.kind === \"template for prototype member expression\") {\n              // check that the value that was assigned itself came from\n              // an expression of the form sourceObject[absStr].\n              let mem = sourceValue.args[1];\n              while (mem instanceof AbstractValue) {\n                if (\n                  mem.kind === \"sentinel member expression\" &&\n                  mem.args[0] instanceof ObjectValue &&\n                  mem.args[1] === absStr\n                ) {\n                  sourceObject = mem.args[0];\n                  break;\n                }\n                // check if mem is a test for absStr being equal to a known property\n                // if so skip over it until we get to the expression of the form sourceObject[absStr].\n                let condition = mem.args[0];\n                if (condition instanceof AbstractValue && condition.kind === \"check for known property\") {\n                  if (condition.args[0] === absStr) {\n                    mem = mem.args[2];\n                    continue;\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n      });\n      if (targetObject instanceof ObjectValue && sourceObject !== undefined) {\n        let o = ob;\n        if (ob instanceof AbstractObjectValue && !ob.values.isTop() && ob.values.getElements().size === 1) {\n          // Note that it is not safe, in general, to extract a concrete object from the values domain of\n          // an abstract object. We can get away with it here only because the concrete object does not\n          // escape the code below and is thus never referenced directly in generated code because of this logic.\n          for (let oe of ob.values.getElements()) {\n            invariant(oe instanceof ObjectValue);\n            o = oe;\n          }\n        }\n        let generator = realm.generator;\n        invariant(generator !== undefined);\n        // make target object simple and partial, so that it returns a fully\n        // abstract value for every property it is queried for.\n        targetObject.makeSimple();\n        targetObject.makePartial();\n        if (sourceObject === o) {\n          // Known enumerable properties of sourceObject can become known properties of targetObject.\n          invariant(sourceObject.isPartialObject());\n          sourceObject.makeNotPartial();\n          // EnumerableOwnProperties is sufficient because sourceObject is simple\n          let keyValPairs = EnumerableOwnProperties(realm, sourceObject, \"key+value\");\n          sourceObject.makePartial();\n          for (let keyVal of keyValPairs) {\n            invariant(keyVal instanceof ArrayValue);\n            let key = keyVal.$Get(\"0\", keyVal);\n            let val = keyVal.$Get(\"1\", keyVal);\n            invariant(key instanceof StringValue); // sourceObject is simple\n            targetObject.$Set(key, val, targetObject);\n          }\n        }\n        // add loop to generator\n        invariant(boundName != null);\n        generator.emitForInStatement(o, lh, sourceObject, targetObject, boundName);\n        return realm.intrinsics.undefined;\n      }\n    }\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(blockEnv);\n  }\n\n  reportError(realm, obexpr.loc);\n  invariant(false);\n}\n"]}