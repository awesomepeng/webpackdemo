"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, strictCode, env, realm) {
  // 1. Let array be ArrayCreate(0).
  let array = _singletons.Create.ArrayCreate(realm, 0);

  // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
  let elements = ast.elements || [];
  let len = elements.length;
  let nextIndex = 0;
  for (let i = 0; i < len; i++) {
    let elem = elements[i];
    if (!elem) {
      nextIndex++;
      continue;
    }

    // ECMA262 12.2.5.2
    if (elem.type === "SpreadElement") {
      // 1. Let spreadRef be the result of evaluating AssignmentExpression.
      let spreadRef = env.evaluate(elem.argument, strictCode);

      // 2. Let spreadObj be ? GetValue(spreadRef).
      let spreadObj = _singletons.Environment.GetValue(realm, spreadRef);

      // 3. Let iterator be ? GetIterator(spreadObj).
      let iterator = (0, _index2.GetIterator)(realm, spreadObj);

      // 4. Repeat
      while (true) {
        // a. Let next be ? IteratorStep(iterator).
        let next = (0, _iterator.IteratorStep)(realm, iterator);

        // b. If next is false, return nextIndex.
        if (next === false) break;

        // c. Let nextValue be ? IteratorValue(next).
        let nextValue = (0, _iterator.IteratorValue)(realm, next);

        // d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).
        let status = _singletons.Create.CreateDataProperty(realm, array, new _index.StringValue(realm, nextIndex++ + ""), nextValue);

        // e. Assert: status is true.
        (0, _invariant2.default)(status === true);

        // f. Let nextIndex be nextIndex + 1.
      }
    } else {
      // Redundant steps.
      // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
      // 2. ReturnIfAbrupt(postIndex).
      // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.

      // 4. Let initResult be the result of evaluating AssignmentExpression.
      let initResult = env.evaluate(elem, strictCode);

      // 5. Let initValue be ? GetValue(initResult).
      let initValue = _singletons.Environment.GetValue(realm, initResult);

      // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex+padding)), initValue).
      let created = _singletons.Create.CreateDataProperty(realm, array, new _index.StringValue(realm, nextIndex++ + ""), initValue);

      // 7. Assert: created is true.
      (0, _invariant2.default)(created === true, "expected data property creation");
    }
  }

  // Not necessary since we propagate completions with exceptions.
  // 3. ReturnIfAbrupt(len).

  // 4. Perform Set(array, "length", ToUint32(len), false).
  _singletons.Properties.Set(realm, array, "length", new _index.NumberValue(realm, nextIndex), false);

  // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.

  // 6. Return array.
  return array;
};

var _index = require("../values/index.js");

var _index2 = require("../methods/index.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _iterator = require("../methods/iterator.js");

var _singletons = require("../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=ArrayExpression.js.map