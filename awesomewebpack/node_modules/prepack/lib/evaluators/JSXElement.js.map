{"version":3,"sources":["../../src/evaluators/JSXElement.js"],"names":["ast","strictCode","env","realm","react","enabled","openingElement","type","evaluateJSXIdentifier","name","children","evaluateJSXChildren","config","evaluateJSXAttributes","attributes","cleanJSXElementLiteralChild","child","lines","split","lastNonEmptyLine","i","length","match","str","line","isFirstLine","isLastLine","isLastNonEmptyLine","trimmedLine","replace","evaluateJSXMemberExpression","GetValue","ResolveBinding","evaluate","isTagName","evaluateJSXValue","value","expression","test","undefined","singleChild","text","array","ArrayCreate","dynamicChildrenLength","dynamicIterator","lastChildValue","intrinsics","CreateDataPropertyOrThrow","Set","makeFinal","isObjectEmpty","object","propertyCount","binding","properties","descriptor","enumerable","astAttributes","ObjectCreate","ObjectPrototype","abstractPropsArgs","abstractSpreadCount","safeAbstractSpreadCount","spreadValue","setConfigProperty","astAttribute","argument","isPartialObject","spreadPropKey","ToObject","push"],"mappings":"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","file":"JSXElement.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type {\n  BabelNode,\n  BabelNodeStringLiteral,\n  BabelNodeJSXText,\n  BabelNodeJSXElement,\n  BabelNodeJSXIdentifier,\n  BabelNodeJSXMemberExpression,\n  BabelNodeJSXAttribute,\n  BabelNodeJSXSpreadAttribute,\n  BabelNodeJSXExpressionContainer,\n} from \"babel-types\";\nimport {\n  AbstractObjectValue,\n  ArrayValue,\n  StringValue,\n  Value,\n  NumberValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { convertJSXExpressionToIdentifier } from \"../react/jsx.js\";\nimport { Get } from \"../methods/index.js\";\nimport { Create, Environment, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { createReactElement } from \"../react/elements.js\";\nimport {\n  applyObjectAssignConfigsForReactElement,\n  flagPropsWithNoPartialKeyOrRef,\n  hasNoPartialKeyOrRef,\n} from \"../react/utils.js\";\n\n// taken from Babel\nfunction cleanJSXElementLiteralChild(child: string): null | string {\n  let lines = child.split(/\\r\\n|\\n|\\r/);\n\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = \"\";\n\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i];\n\n    let isFirstLine = i === 0;\n    let isLastLine = i === lines.length - 1;\n    let isLastNonEmptyLine = i === lastNonEmptyLine;\n\n    // replace rendered whitespace tabs with spaces\n    let trimmedLine = line.replace(/\\t/g, \" \");\n\n    // trim whitespace touching a newline\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    // trim whitespace touching an endline\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) {\n    return str;\n  }\n  return null;\n}\n\nfunction evaluateJSXMemberExpression(\n  ast: BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  switch (ast.type) {\n    case \"JSXIdentifier\":\n      return Environment.GetValue(\n        realm,\n        Environment.ResolveBinding(realm, ((ast: any): BabelNodeJSXIdentifier).name, strictCode, env)\n      );\n    case \"JSXMemberExpression\":\n      return Environment.GetValue(\n        realm,\n        env.evaluate(convertJSXExpressionToIdentifier(((ast: any): BabelNodeJSXMemberExpression)), strictCode)\n      );\n    default:\n      invariant(false, \"Unknown JSX Identifier\");\n  }\n}\n\nfunction evaluateJSXIdentifier(ast, strictCode, env, realm): Value {\n  if (isTagName(ast)) {\n    // special cased lower-case and custom elements\n    return new StringValue(realm, ((ast: any): BabelNodeJSXIdentifier).name);\n  }\n  return evaluateJSXMemberExpression(ast, strictCode, env, realm);\n}\n\nfunction evaluateJSXValue(value: BabelNode, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  if (value != null) {\n    switch (value.type) {\n      case \"JSXText\":\n        return new StringValue(realm, ((value: any): BabelNodeJSXText).value);\n      case \"StringLiteral\":\n        return new StringValue(realm, ((value: any): BabelNodeStringLiteral).value);\n      case \"JSXExpressionContainer\":\n        return Environment.GetValue(\n          realm,\n          env.evaluate(((value: any): BabelNodeJSXExpressionContainer).expression, strictCode)\n        );\n      case \"JSXElement\":\n        return Environment.GetValue(realm, env.evaluate(value, strictCode));\n      default:\n        invariant(false, `Unknown JSX value type: ${value.type}`);\n    }\n  }\n  invariant(false, `Null or undefined value passed when trying to evaluate JSX node value`);\n}\n\nfunction isTagName(ast: BabelNode): boolean {\n  return ast.type === \"JSXIdentifier\" && /^[a-z]|\\-/.test(((ast: any): BabelNodeJSXIdentifier).name);\n}\n\nfunction evaluateJSXChildren(\n  children: Array<BabelNode>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ArrayValue | Value | void {\n  if (children.length === 0) {\n    return undefined;\n  }\n  if (children.length === 1) {\n    let singleChild = evaluateJSXValue(children[0], strictCode, env, realm);\n\n    if (singleChild instanceof StringValue) {\n      let text = cleanJSXElementLiteralChild(singleChild.value);\n      if (text !== null) {\n        singleChild.value = text;\n      }\n    }\n    return singleChild;\n  }\n  let array = Create.ArrayCreate(realm, 0);\n  let dynamicChildrenLength = children.length;\n  let dynamicIterator = 0;\n  let lastChildValue = realm.intrinsics.undefined;\n  for (let i = 0; i < children.length; i++) {\n    let value = evaluateJSXValue(children[i], strictCode, env, realm);\n    if (value instanceof StringValue) {\n      let text = cleanJSXElementLiteralChild(value.value);\n      if (text === null) {\n        dynamicChildrenLength--;\n        // this is a space full of whitespace, so let's proceed\n        continue;\n      } else {\n        value.value = text;\n      }\n    }\n    lastChildValue = value;\n    Create.CreateDataPropertyOrThrow(realm, array, \"\" + dynamicIterator, value);\n    dynamicIterator++;\n  }\n  if (dynamicChildrenLength === 1) {\n    return lastChildValue;\n  }\n\n  Properties.Set(realm, array, \"length\", new NumberValue(realm, dynamicChildrenLength), false);\n  array.makeFinal();\n  return array;\n}\n\nfunction isObjectEmpty(object: ObjectValue) {\n  let propertyCount = 0;\n  for (let [, binding] of object.properties) {\n    if (binding && binding.descriptor && binding.descriptor.enumerable) {\n      propertyCount++;\n    }\n  }\n  return propertyCount === 0;\n}\n\nfunction evaluateJSXAttributes(\n  astAttributes: Array<BabelNodeJSXAttribute | BabelNodeJSXSpreadAttribute>,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  let config = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n  let abstractPropsArgs = [];\n  let abstractSpreadCount = 0;\n  let safeAbstractSpreadCount = 0;\n  let spreadValue;\n\n  const setConfigProperty = (name: string, value: Value): void => {\n    invariant(config instanceof ObjectValue);\n    Properties.Set(realm, config, name, value, true);\n  };\n\n  for (let astAttribute of astAttributes) {\n    switch (astAttribute.type) {\n      case \"JSXAttribute\":\n        let { name, value } = astAttribute;\n\n        invariant(name.type === \"JSXIdentifier\", `JSX attribute name type not supported: ${astAttribute.type}`);\n        setConfigProperty(name.name, evaluateJSXValue(((value: any): BabelNodeJSXIdentifier), strictCode, env, realm));\n        break;\n      case \"JSXSpreadAttribute\":\n        spreadValue = Environment.GetValue(realm, env.evaluate(astAttribute.argument, strictCode));\n\n        if (spreadValue instanceof ObjectValue && !spreadValue.isPartialObject()) {\n          for (let [spreadPropKey, binding] of spreadValue.properties) {\n            if (binding && binding.descriptor && binding.descriptor.enumerable) {\n              setConfigProperty(spreadPropKey, Get(realm, spreadValue, spreadPropKey));\n            }\n          }\n        } else {\n          abstractSpreadCount++;\n          if (spreadValue instanceof AbstractValue && !(spreadValue instanceof AbstractObjectValue)) {\n            spreadValue = To.ToObject(realm, spreadValue);\n          }\n          invariant(spreadValue instanceof AbstractObjectValue || spreadValue instanceof ObjectValue);\n\n          if (hasNoPartialKeyOrRef(realm, spreadValue)) {\n            safeAbstractSpreadCount++;\n          }\n          if (!isObjectEmpty(config)) {\n            abstractPropsArgs.push(config);\n          }\n          abstractPropsArgs.push(spreadValue);\n          config = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n        }\n        break;\n      default:\n        invariant(false, `Unknown JSX attribute type: ${astAttribute.type}`);\n    }\n  }\n\n  if (abstractSpreadCount > 0) {\n    // if we only have a single spread config, then use that,\n    // i.e. <div {...something} />  -->  React.createElement(\"div\", something)\n    if (\n      abstractSpreadCount === 1 &&\n      astAttributes.length === 1 &&\n      (spreadValue instanceof ObjectValue || spreadValue instanceof AbstractObjectValue)\n    ) {\n      return spreadValue;\n    }\n    // we create an abstract Object.assign() to deal with the fact that we don't what\n    // the props are because they contain abstract spread attributes that we can't\n    // evaluate ahead of time\n    // push the current config\n    abstractPropsArgs.push(config);\n\n    // create a new config object that will be the target of the Object.assign\n    config = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    applyObjectAssignConfigsForReactElement(realm, config, abstractPropsArgs);\n    if (safeAbstractSpreadCount === abstractSpreadCount) {\n      flagPropsWithNoPartialKeyOrRef(realm, config);\n    }\n  }\n  invariant(config instanceof ObjectValue || config instanceof AbstractObjectValue);\n  return config;\n}\n\nexport default function(ast: BabelNodeJSXElement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  invariant(realm.react.enabled, \"JSXElements can only be evaluated with the reactEnabled option\");\n  let openingElement = ast.openingElement;\n  let type = evaluateJSXIdentifier(openingElement.name, strictCode, env, realm);\n  let children = evaluateJSXChildren(ast.children, strictCode, env, realm);\n  let config = evaluateJSXAttributes(openingElement.attributes, strictCode, env, realm);\n  invariant(type instanceof Value);\n  return createReactElement(realm, type, config, children);\n}\n"]}