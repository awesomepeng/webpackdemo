{"version":3,"sources":["../../src/evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","GetValue","rref","right","rval","computeBinary","operator","loc","getPureBinaryOperationResultType","t","unknownValueOfOrToString","op","lloc","rloc","reportErrorIfNotPure","purityTest","typeIfPure","leftPure","rightPure","error","handleError","ltype","GetToPrimitivePureResultType","rtype","undefined","getType","IsToPrimitivePure","bind","IsToNumberPure","mightNotBeObject","isSimpleObject","useAbstractInterpretation","resultType","compute","createFromBinaryOp","createErrorThrowCompletion","intrinsics","TypeError","result","isInPureScope","previousErrorHandler","errorHandler","isPure","diagnostic","effects","evaluateForEffects","x","applyEffects","completion","composeWithSavedCompletion","value","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","lnode","rnode","binaryExpression","topVal"],"mappings":"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","file":"BinaryExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { Environment, Havoc, To } from \"../singletons.js\";\nimport type {\n  BabelBinaryOperator,\n  BabelNodeBinaryExpression,\n  BabelNodeExpression,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeBinaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // evaluate left\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  // evaluate right\n  let rref = env.evaluate(ast.right, strictCode);\n  let rval = Environment.GetValue(realm, rref);\n\n  return computeBinary(realm, ast.operator, lval, rval, ast.left.loc, ast.right.loc, ast.loc);\n}\n\nlet unknownValueOfOrToString = \"might be an object with an unknown valueOf or toString or Symbol.toPrimitive method\";\n\n// Returns result type if binary operation is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\nexport function getPureBinaryOperationResultType(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation\n): typeof Value {\n  function reportErrorIfNotPure(purityTest: (Realm, Value) => boolean, typeIfPure: typeof Value): typeof Value {\n    let leftPure = purityTest(realm, lval);\n    let rightPure = purityTest(realm, rval);\n    if (leftPure && rightPure) return typeIfPure;\n    let loc = !leftPure ? lloc : rloc;\n    let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that an unknown value is actually a primitive or otherwise a well behaved object.\n      return typeIfPure;\n    }\n    throw new FatalError();\n  }\n  if (op === \"+\") {\n    let ltype = To.GetToPrimitivePureResultType(realm, lval);\n    let rtype = To.GetToPrimitivePureResultType(realm, rval);\n    if (ltype === undefined || rtype === undefined) {\n      let loc = ltype === undefined ? lloc : rloc;\n      let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the unknown value is actually a primitive or otherwise a well behaved object.\n        ltype = lval.getType();\n        rtype = rval.getType();\n        if (ltype === StringValue || rtype === StringValue) return StringValue;\n        if (ltype === IntegralValue && rtype === IntegralValue) return IntegralValue;\n        if ((ltype === NumberValue || ltype === IntegralValue) && (rtype === NumberValue || rtype === IntegralValue))\n          return NumberValue;\n\n        return Value;\n      }\n      throw new FatalError();\n    }\n    if (ltype === StringValue || rtype === StringValue) return StringValue;\n    return NumberValue;\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n    return reportErrorIfNotPure(To.IsToPrimitivePure.bind(To), BooleanValue);\n  } else if (op === \"!=\" || op === \"==\") {\n    let ltype = lval.getType();\n    let rtype = rval.getType();\n    if (ltype === NullValue || ltype === UndefinedValue || rtype === NullValue || rtype === UndefinedValue)\n      return BooleanValue;\n    return reportErrorIfNotPure(To.IsToPrimitivePure.bind(To), BooleanValue);\n  } else if (op === \"===\" || op === \"!==\") {\n    return BooleanValue;\n  } else if (\n    op === \">>>\" ||\n    op === \"<<\" ||\n    op === \">>\" ||\n    op === \"&\" ||\n    op === \"|\" ||\n    op === \"^\" ||\n    op === \"**\" ||\n    op === \"%\" ||\n    op === \"/\" ||\n    op === \"*\" ||\n    op === \"-\"\n  ) {\n    return reportErrorIfNotPure(To.IsToNumberPure.bind(To), NumberValue);\n  } else if (op === \"in\" || op === \"instanceof\") {\n    if (rval.mightNotBeObject()) {\n      let error = new CompilerDiagnostic(\n        `might not be an object, hence the ${op} operator might throw a TypeError`,\n        rloc,\n        \"PP0003\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the object is actually a well behaved object.\n        return BooleanValue;\n      }\n      throw new FatalError();\n    }\n    if (!rval.mightNotBeObject()) {\n      // Simple object won't throw here, aren't proxy objects or typed arrays and do not have @@hasInstance properties.\n      if (rval.isSimpleObject()) return BooleanValue;\n    }\n    let error = new CompilerDiagnostic(\n      `might be an object that behaves badly for the ${op} operator`,\n      rloc,\n      \"PP0004\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that the object is actually a well behaved object.\n      return BooleanValue;\n    }\n    throw new FatalError();\n  }\n  invariant(false, \"unimplemented \" + op);\n}\n\nexport function computeBinary(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation,\n  loc?: ?BabelNodeSourceLocation\n): Value {\n  // partial evaluation shortcut for a particular pattern\n  if (realm.useAbstractInterpretation && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      ((lval instanceof NullValue || lval instanceof UndefinedValue) && !rval.mightNotBeObject())\n    ) {\n      return new BooleanValue(realm, op[0] !== \"=\");\n    }\n  }\n\n  let resultType;\n  const compute = () => {\n    if (lval instanceof AbstractValue || rval instanceof AbstractValue) {\n      // generate error if binary operation might throw or have side effects\n      resultType = getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);\n      return AbstractValue.createFromBinaryOp(realm, op, lval, rval, loc);\n    } else {\n      // ECMA262 12.10.3\n\n      // 5. If Type(rval) is not Object, throw a TypeError exception.\n      if (op === \"in\" && !(rval instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      invariant(lval instanceof ConcreteValue);\n      invariant(rval instanceof ConcreteValue);\n      const result = ValuesDomain.computeBinary(realm, op, lval, rval);\n      resultType = result.getType();\n      return result;\n    }\n  };\n\n  if (realm.isInPureScope()) {\n    // If we're in pure mode we can recover even if this operation might not be pure.\n    // To do that, we'll temporarily override the error handler.\n    const previousErrorHandler = realm.errorHandler;\n    let isPure = true;\n    realm.errorHandler = diagnostic => {\n      isPure = false;\n      return \"Recover\";\n    };\n    let effects;\n    try {\n      effects = realm.evaluateForEffects(compute, undefined, \"computeBinary\");\n    } catch (x) {\n      if (x instanceof FatalError) {\n        isPure = false;\n      } else {\n        throw x;\n      }\n    } finally {\n      realm.errorHandler = previousErrorHandler;\n    }\n\n    if (isPure && effects) {\n      // Note that the effects of (non joining) abrupt branches are not included\n      // in effects, but are tracked separately inside completion.\n      realm.applyEffects(effects);\n      let completion = effects.result;\n      if (completion instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        completion = realm.composeWithSavedCompletion(completion);\n      } else if (completion instanceof SimpleNormalCompletion) {\n        completion = completion.value;\n      }\n      // return or throw completion\n      if (completion instanceof AbruptCompletion) throw completion;\n      invariant(completion instanceof Value);\n      return completion;\n    }\n\n    // If this ended up reporting an error, it might not be pure, so we'll leave it in\n    // as a temporal operation with a known return type.\n    // Some of these values may trigger side-effectful user code such as valueOf.\n    // To be safe, we have to Havoc them.\n    Havoc.value(realm, lval, loc);\n    if (op !== \"in\") {\n      // The \"in\" operator have side-effects on its right val other than throw.\n      Havoc.value(realm, rval, loc);\n    }\n    return realm.evaluateWithPossibleThrowCompletion(\n      () =>\n        AbstractValue.createTemporalFromBuildFunction(\n          realm,\n          resultType,\n          [lval, rval],\n          ([lnode, rnode]: Array<BabelNodeExpression>) => t.binaryExpression(op, lnode, rnode)\n        ),\n      TypesDomain.topVal,\n      ValuesDomain.topVal\n    );\n  }\n  return compute();\n}\n"]}