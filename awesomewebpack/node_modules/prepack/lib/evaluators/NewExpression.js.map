{"version":3,"sources":["../../src/evaluators/NewExpression.js"],"names":["ast","strictCode","env","realm","constructProduction","callee","args","arguments","ref","evaluate","constructor","GetValue","argsList","length","previousLoc","setNextExecutionContextLocation","loc","isInPureScope","tryToEvaluateConstructOrLeaveAsAbstract","createConstruct","t","effects","evaluateForEffects","undefined","error","value","arg","abstractValue","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","constructorNode","argListNodes","newExpression","topVal","applyEffects","completion","result","composeWithSavedCompletion","createErrorThrowCompletion","intrinsics","TypeError"],"mappings":"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","file":"NewExpression.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { ObjectValue, Value, AbstractObjectValue, AbstractValue } from \"../values/index.js\";\nimport { Environment, Havoc } from \"../singletons.js\";\nimport { IsConstructor, ArgumentListEvaluation } from \"../methods/index.js\";\nimport { Construct } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { FatalError } from \"../errors.js\";\nimport * as t from \"babel-types\";\nimport { BabelNodeNewExpression, type BabelNodeExpression } from \"babel-types\";\n\nexport default function(\n  ast: BabelNodeNewExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  // ECMA262 12.3.3.1 We just implement this method inline since it's only called here.\n  // 1. Return ? EvaluateNew(NewExpression, empty).\n\n  // ECMA262 2.3.3.1.1\n\n  let constructProduction = ast.callee;\n  let args = ast.arguments;\n\n  // These steps not necessary due to our AST representation.\n  // 1. Assert: constructProduction is either a NewExpression or a MemberExpression.\n  // 2. Assert: arguments is either empty or an Arguments production.\n\n  // 3. Let ref be the result of evaluating constructProduction.\n  let ref = env.evaluate(constructProduction, strictCode);\n\n  // 4. Let constructor be ? GetValue(ref).\n  let constructor = Environment.GetValue(realm, ref);\n\n  let argsList;\n\n  // 5. If arguments is empty, let argList be a new empty List.\n  if (!args.length) {\n    argsList = [];\n  } else {\n    // 6. Else,\n    // a. Let argList be ArgumentListEvaluation of arguments.\n    argsList = ArgumentListEvaluation(realm, strictCode, env, (args: any)); // BabelNodeNewExpression needs updating\n\n    // This step not necessary since we propagate completions with exceptions.\n    // b. ReturnIfAbrupt(argList).\n  }\n\n  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);\n  try {\n    // If we are in pure scope, attempt to recover from creating the construct if\n    // it fails by creating a temporal abstract\n    if (realm.isInPureScope()) {\n      return tryToEvaluateConstructOrLeaveAsAbstract(constructor, argsList, strictCode, realm);\n    } else {\n      return createConstruct(constructor, argsList, realm);\n    }\n  } finally {\n    realm.setNextExecutionContextLocation(previousLoc);\n  }\n}\n\nfunction tryToEvaluateConstructOrLeaveAsAbstract(\n  constructor: Value,\n  argsList: Array<Value>,\n  strictCode: boolean,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  let effects;\n  try {\n    effects = realm.evaluateForEffects(\n      () => createConstruct(constructor, argsList, realm),\n      undefined,\n      \"tryToEvaluateConstructOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    // if a FatalError occurs when constructing the constructor\n    // then try and recover and create an abstract for this construct\n    if (error instanceof FatalError) {\n      // we need to havoc all the arguments and the constructor\n      Havoc.value(realm, constructor);\n      for (let arg of argsList) {\n        Havoc.value(realm, arg);\n      }\n      let abstractValue = realm.evaluateWithPossibleThrowCompletion(\n        () =>\n          AbstractValue.createTemporalFromBuildFunction(\n            realm,\n            ObjectValue,\n            [constructor, ...argsList],\n            ([constructorNode, ...argListNodes]: Array<BabelNodeExpression>) =>\n              t.newExpression(constructorNode, argListNodes)\n          ),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n      invariant(abstractValue instanceof AbstractObjectValue);\n      return abstractValue;\n    } else {\n      throw error;\n    }\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(effects);\n  let completion = effects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n  invariant(completion instanceof ObjectValue || completion instanceof AbstractObjectValue);\n  return completion;\n}\n\nfunction createConstruct(constructor: Value, argsList: Array<Value>, realm: Realm): ObjectValue {\n  // 7. If IsConstructor(constructor) is false, throw a TypeError exception.\n  if (IsConstructor(realm, constructor) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n  invariant(constructor instanceof ObjectValue);\n\n  // 8. Return ? Construct(constructor, argList).\n  return Construct(realm, constructor, argsList);\n}\n"]}