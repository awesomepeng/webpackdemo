{"version":3,"sources":["../../../src/intrinsics/prepack/utils.js"],"names":["parseTypeNameOrTemplate","createAbstract","throwTemplateSrc","throwTemplate","realm","typeNameOrTemplate","undefined","type","template","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","typeNameString","ToStringPartial","hasFunctionResultType","startsWith","substring","functionResultType","name","options","additionalValues","useAbstractInterpretation","optionsMap","properties","Map","result","locString","loc","executionContext","contextStack","slice","reverse","caller","function","lexicalEnvironment","locVal","kind","makeKind","objectCount","toString","createFromTemplate","get","isNameStringUnique","error","handleError","saveNameString","intrinsicName","values","Set","makePartial","rebuildNestedProperties","length","createAbstractConcreteUnion"],"mappings":"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","file":"utils.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  Value,\n  AbstractValue,\n  ConcreteValue,\n  FunctionValue,\n  StringValue,\n  ObjectValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\nimport { To } from \"../../singletons.js\";\nimport AbstractObjectValue from \"../../values/AbstractObjectValue\";\nimport { CompilerDiagnostic, FatalError } from \"../../errors.js\";\nimport { Utils } from \"../../singletons\";\nimport invariant from \"../../invariant.js\";\n\nconst throwTemplateSrc = \"(function(){throw new global.Error('abstract value defined at ' + A);})()\";\nconst throwTemplate = buildExpressionTemplate(throwTemplateSrc);\n\nexport function parseTypeNameOrTemplate(\n  realm: Realm,\n  typeNameOrTemplate: void | Value | string\n): { type: typeof Value, template: void | ObjectValue, functionResultType?: typeof Value } {\n  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n    return { type: Value, template: undefined };\n  } else if (typeof typeNameOrTemplate === \"string\") {\n    let type = Utils.getTypeFromName(typeNameOrTemplate);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof StringValue) {\n    let typeNameString = To.ToStringPartial(realm, typeNameOrTemplate);\n    let hasFunctionResultType = typeNameString.startsWith(\":\");\n    if (hasFunctionResultType) typeNameString = typeNameString.substring(1);\n    let type = Utils.getTypeFromName(typeNameString);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return hasFunctionResultType\n      ? { type: FunctionValue, template: undefined, functionResultType: type }\n      : { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof FunctionValue) {\n    return { type: FunctionValue, template: typeNameOrTemplate };\n  } else if (typeNameOrTemplate instanceof ObjectValue) {\n    return { type: ObjectValue, template: typeNameOrTemplate };\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n  }\n}\n\nexport function createAbstract(\n  realm: Realm,\n  typeNameOrTemplate?: Value | string,\n  name?: string,\n  options?: ObjectValue,\n  ...additionalValues: Array<ConcreteValue>\n): AbstractValue | AbstractObjectValue {\n  if (!realm.useAbstractInterpretation) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n  }\n\n  let { type, template, functionResultType } = parseTypeNameOrTemplate(realm, typeNameOrTemplate);\n  let optionsMap = options ? options.properties : new Map();\n\n  let result;\n  let locString,\n    loc = null;\n  for (let executionContext of realm.contextStack.slice().reverse()) {\n    let caller = executionContext.caller;\n    loc = executionContext.loc;\n    locString = describeLocation(\n      realm,\n      caller ? caller.function : undefined,\n      caller ? caller.lexicalEnvironment : undefined,\n      loc\n    );\n    if (locString !== undefined) break;\n  }\n  if (name === undefined) {\n    let locVal = new StringValue(realm, locString !== undefined ? locString : \"(unknown location)\");\n    let kind = AbstractValue.makeKind(\"abstractCounted\", (realm.objectCount++).toString()); // need not be an object, but must be unique\n    result = AbstractValue.createFromTemplate(realm, throwTemplate, type, [locVal], kind);\n  } else {\n    let kind = AbstractValue.makeKind(\"abstract\", name);\n    if (!optionsMap.get(\"allowDuplicateNames\") && !realm.isNameStringUnique(name)) {\n      let error = new CompilerDiagnostic(\"An abstract value with the same name exists\", loc, \"PP0019\", \"FatalError\");\n      realm.handleError(error);\n      throw new FatalError();\n    } else {\n      realm.saveNameString(name);\n    }\n    result = AbstractValue.createFromTemplate(realm, buildExpressionTemplate(name), type, [], kind);\n    result.intrinsicName = name;\n  }\n\n  if (template) result.values = new ValuesDomain(new Set([template]));\n  if (template && !(template instanceof FunctionValue)) {\n    // why exclude functions?\n    template.makePartial();\n    if (name !== undefined) realm.rebuildNestedProperties(result, name);\n  }\n  if (functionResultType) {\n    invariant(result instanceof AbstractObjectValue);\n    result.functionResultType = functionResultType;\n  }\n\n  if (additionalValues.length > 0)\n    result = AbstractValue.createAbstractConcreteUnion(realm, result, ...additionalValues);\n  return result;\n}\n"]}