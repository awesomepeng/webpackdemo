{"version":3,"sources":["../../../src/intrinsics/ecma262/Array.js"],"names":["realm","func","context","items","argCount","NewTarget","numberOfArgs","newTarget","undefined","proto","ArrayCreate","array","len","intLen","mightBeNumber","defineStatus","CreateDataProperty","ToUint32","throwIfNotConcreteNumber","value","createErrorThrowCompletion","intrinsics","RangeError","Set","k","Pk","ToString","itemK","length","throwIfNotConcrete","defineNativeMethod","arg","isCompatibleWith","MOBILE_JSC_VERSION","C","A","kValue","CreateDataPropertyOrThrow","arrayFrom","mapfn","thisArg","mapping","T","mightBeUndefined","TypeError","isInPureScope","values","isTop","args","push","createTemporalWithWidenedNumericProperty","methodNode","_args","t","callExpression","thisVal","usingIterator","SymbolIterator","iterator","Math","pow","error","next","nextValue","mappedValue","mappedValueCompletion","completion","arrayLike","ToObject","ToLength","defineNativeGetter","SymbolSpecies"],"mappings":"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","file":"Array.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { AbruptCompletion } from \"../../completions.js\";\nimport {\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  NativeFunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport {\n  Construct,\n  Call,\n  Get,\n  GetPrototypeFromConstructor,\n  GetMethod,\n  IsArray,\n  IsConstructor,\n  IsCallable,\n} from \"../../methods/index.js\";\nimport * as t from \"babel-types\";\nimport { GetIterator, IteratorClose, IteratorStep, IteratorValue } from \"../../methods/iterator.js\";\nimport { Create, Havoc, Properties, To } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"Array\", \"Array\", 1, (context, [...items], argCount, NewTarget) => {\n    if (argCount === 0) {\n      // 1. Let numberOfArgs be the number of arguments passed to this function call.\n      let numberOfArgs = argCount;\n\n      // 2. Assert: numberOfArgs = 0.\n      invariant(numberOfArgs === 0, \"numberOfArgs = 0\");\n\n      // 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n      let newTarget = NewTarget === undefined ? func : NewTarget;\n\n      // 4. Let proto be ? GetPrototypeFromConstructor(newTarget, \"%ArrayPrototype%\").\n      let proto = GetPrototypeFromConstructor(realm, newTarget, \"ArrayPrototype\");\n\n      // 5. Return ArrayCreate(0, proto).\n      return Create.ArrayCreate(realm, 0, proto);\n    } else if (argCount === 1) {\n      // 1. Let numberOfArgs be the number of arguments passed to this function call.\n      let numberOfArgs = argCount;\n\n      // 2. Assert: numberOfArgs = 1.\n      invariant(numberOfArgs === 1, \"numberOfArgs = 1\");\n\n      // 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n      let newTarget = NewTarget === undefined ? func : NewTarget;\n\n      // 4. Let proto be ? GetPrototypeFromConstructor(newTarget, \"%ArrayPrototype%\").\n      let proto = GetPrototypeFromConstructor(realm, newTarget, \"ArrayPrototype\");\n\n      // 5. Let array be ArrayCreate(0, proto).\n      let array = Create.ArrayCreate(realm, 0, proto);\n\n      // 6. If Type(len) is not Number, then\n      let len = items[0];\n      invariant(len !== undefined);\n      let intLen;\n      if (!len.mightBeNumber()) {\n        // a. Let defineStatus be CreateDataProperty(array, \"0\", len).\n        let defineStatus = Create.CreateDataProperty(realm, array, \"0\", len);\n\n        // b. Assert: defineStatus is true.\n        invariant(defineStatus, \"defineStatus is true\");\n\n        // c. Let intLen be 1.\n        intLen = 1;\n      } else {\n        // 7. Else,\n\n        // a. Let intLen be ToUint32(len).\n        intLen = To.ToUint32(realm, len.throwIfNotConcreteNumber());\n        invariant(len instanceof NumberValue);\n\n        // b If intLen ≠ len, throw a RangeError exception.\n        if (intLen !== len.value) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"intLen ≠ len\");\n        }\n      }\n\n      // 8. Perform ! Set(array, \"length\", intLen, true).\n      Properties.Set(realm, array, \"length\", new NumberValue(realm, intLen), true);\n\n      // 9. Return array.\n      return array;\n    } else {\n      // 1. Let numberOfArgs be the number of arguments passed to this function call.\n      let numberOfArgs = argCount;\n\n      // 2. Assert: numberOfArgs ≥ 2.\n      invariant(numberOfArgs >= 2, \"numberOfArgs >= 2\");\n\n      // 3. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n      let newTarget = NewTarget === undefined ? func : NewTarget;\n\n      // 4. Let proto be ? GetPrototypeFromConstructor(newTarget, \"%ArrayPrototype%\").\n      let proto = GetPrototypeFromConstructor(realm, newTarget, \"ArrayPrototype\");\n\n      // 5. Let array be ? ArrayCreate(numberOfArgs, proto).\n      let array = Create.ArrayCreate(realm, numberOfArgs, proto);\n\n      // 6. Let k be 0.\n      let k = 0;\n\n      // 7. Let items be a zero-origined List containing the argument items in order.\n      items;\n\n      // 8. Repeat, while k < numberOfArgs\n      while (k < numberOfArgs) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // b. Let itemK be items[k].\n        let itemK = items[k];\n        invariant(itemK !== undefined);\n\n        // c. Let defineStatus be CreateDataProperty(array, Pk, itemK).\n        let defineStatus = Create.CreateDataProperty(realm, array, Pk, itemK);\n\n        // d. Assert: defineStatus is true.\n        invariant(defineStatus, \"defineStatus is true\");\n\n        // e. Increase k by 1.\n        k += 1;\n      }\n\n      // 9. Assert: the value of array's length property is numberOfArgs.\n      let length = Get(realm, array, \"length\").throwIfNotConcrete();\n      invariant(length instanceof NumberValue);\n      invariant(length.value === numberOfArgs, \"the value of array's length property is numberOfArgs\");\n\n      // 10. Return array.\n      return array;\n    }\n  });\n\n  // ECMA262 22.1.2.2\n  func.defineNativeMethod(\"isArray\", 1, (context, [arg]) => {\n    // 1. Return ? IsArray(arg).\n    return new BooleanValue(realm, IsArray(realm, arg));\n  });\n\n  // ECMA262 22.1.2.3\n  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith(\"mobile\"))\n    func.defineNativeMethod(\"of\", 0, (context, [...items], argCount) => {\n      // 1. Let len be the actual number of arguments passed to this function.\n      let len = argCount;\n\n      // 2. Let items be the List of arguments passed to this function.\n      items;\n\n      // 3. Let C be the this value.\n      let C = context;\n\n      // 4. If IsConstructor(C) is true, then\n      let A;\n      if (IsConstructor(realm, C)) {\n        invariant(C instanceof ObjectValue);\n        // a. Let A be ? Construct(C, « len »).\n        A = Construct(realm, C, [new NumberValue(realm, len)]);\n      } else {\n        // 5. Else,\n        // a. Let A be ? ArrayCreate(len).\n        A = Create.ArrayCreate(realm, len);\n      }\n\n      // 6. Let k be 0.\n      let k = 0;\n\n      // 7. Repeat, while k < len\n      while (k < len) {\n        // a. Let kValue be items[k].\n        let kValue = items[k];\n\n        // b. Let Pk be ! To.ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // c. Perform ? CreateDataPropertyOrThrow(A, Pk, kValue).\n        Create.CreateDataPropertyOrThrow(realm, A, Pk, kValue);\n\n        // d. Increase k by 1.\n        k += 1;\n      }\n\n      // 8. Perform ? Set(A, \"length\", len, true).\n      Properties.Set(realm, A, \"length\", new NumberValue(realm, len), true);\n\n      // 9. Return A.\n      return A;\n    });\n\n  // ECMA262 22.1.2.1\n  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith(\"mobile\")) {\n    let arrayFrom = func.defineNativeMethod(\"from\", 1, (context, [items, mapfn, thisArg], argCount) => {\n      // 1. Let C be the this value.\n      let C = context;\n\n      let mapping, T;\n      // 2. If mapfn is undefined, let mapping be false.\n      if (!mapfn || mapfn instanceof UndefinedValue) {\n        mapping = false;\n      } else if (mapfn.mightBeUndefined()) {\n        invariant(mapfn instanceof AbstractValue);\n        mapfn.throwIfNotConcrete();\n      } else {\n        // 3. Else,\n        // a. If IsCallable(mapfn) is false, throw a TypeError exception.\n        if (IsCallable(realm, mapfn) === false) {\n          mapfn.throwIfNotConcrete();\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(mapfn) is false\");\n        }\n\n        // b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n        T = thisArg !== undefined ? thisArg : realm.intrinsics.undefined;\n\n        // c. Let mapping be true.\n        mapping = true;\n      }\n      // If we're in pure scope and the items are completely abstract,\n      // then create an abstract temporal with an array kind\n      if (realm.isInPureScope() && items instanceof AbstractValue && items.values.isTop()) {\n        let args = [arrayFrom, items];\n        if (mapfn) {\n          args.push(mapfn);\n          if (thisArg) {\n            args.push(thisArg);\n          }\n        }\n        Havoc.value(realm, items);\n        return ArrayValue.createTemporalWithWidenedNumericProperty(\n          realm,\n          args,\n          ([methodNode, ..._args]) => t.callExpression(methodNode, ((_args: any): Array<any>)),\n          { func: mapfn, thisVal: thisArg }\n        );\n      }\n\n      // 4. Let usingIterator be ? GetMethod(items, @@iterator).\n      let usingIterator = GetMethod(realm, items, realm.intrinsics.SymbolIterator);\n\n      // 5. If usingIterator is not undefined, then\n      if (!usingIterator.mightBeUndefined()) {\n        let A;\n        // a. If IsConstructor(C) is true, then\n        if (IsConstructor(realm, C)) {\n          invariant(C instanceof ObjectValue);\n          // i. Let A be ? Construct(C).\n          A = Construct(realm, C);\n        } else {\n          // b. Else,\n          // i. Let A be ArrayCreate(0).\n          A = Create.ArrayCreate(realm, 0);\n        }\n\n        // c. Let iterator be ? GetIterator(items, usingIterator).\n        let iterator = GetIterator(realm, items, usingIterator);\n\n        // d. Let k be 0.\n        let k = 0;\n\n        // e. Repeat\n        while (true) {\n          // i. If k ≥ 2^53-1, then\n          if (k >= Math.pow(2, 53) - 1) {\n            // 1. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\n            let error = realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"k >= 2^53 - 1\");\n\n            // 2. Return ? IteratorClose(iterator, error).\n            throw IteratorClose(realm, iterator, error);\n          }\n\n          // ii. Let Pk be ! ToString(k).\n          let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n          // iii. Let next be ? IteratorStep(iterator).\n          let next = IteratorStep(realm, iterator);\n\n          // iv. If next is false, then\n          if (next === false) {\n            // 1. Perform ? Set(A, \"length\", k, true).\n            Properties.Set(realm, A, \"length\", new NumberValue(realm, k), true);\n\n            // 2. Return A.\n            return A;\n          }\n\n          // v. Let nextValue be ? IteratorValue(next).\n          let nextValue = IteratorValue(realm, next);\n\n          let mappedValue;\n          // vi. If mapping is true, then\n          if (mapping === true) {\n            // 1. Let mappedValue be Call(mapfn, T, « nextValue, k »).\n            try {\n              invariant(T !== undefined);\n              mappedValue = Call(realm, mapfn, T, [nextValue, new NumberValue(realm, k)]);\n            } catch (mappedValueCompletion) {\n              if (mappedValueCompletion instanceof AbruptCompletion) {\n                // 2. If mappedValue is an abrupt completion, return ? IteratorClose(iterator, mappedValue).\n                throw IteratorClose(realm, iterator, mappedValueCompletion);\n              } else {\n                throw mappedValueCompletion;\n              }\n            }\n            // 3. Let mappedValue be mappedValue.[[Value]].\n          } else {\n            // vii. Else, let mappedValue be nextValue.\n            mappedValue = nextValue;\n          }\n\n          // viii. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).\n          try {\n            Create.CreateDataPropertyOrThrow(realm, A, Pk, mappedValue);\n          } catch (completion) {\n            if (completion instanceof AbruptCompletion) {\n              // ix. If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).\n              throw IteratorClose(realm, iterator, completion);\n            } else throw completion;\n          }\n\n          // x. Increase k by 1.\n          k = k + 1;\n        }\n      } else {\n        usingIterator.throwIfNotConcrete();\n      }\n\n      // 6. NOTE: items is not an Iterable so assume it is an array-like object.\n      items = items.throwIfNotConcrete();\n      invariant(items instanceof ObjectValue);\n\n      // 7. Let arrayLike be ! ToObject(items).\n      let arrayLike = To.ToObject(realm, items);\n\n      // 8. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n      let len = To.ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n      let A;\n      // 9. If IsConstructor(C) is true, then\n      if (IsConstructor(realm, C)) {\n        invariant(C instanceof ObjectValue);\n        // a. Let A be ? Construct(C, « len »).\n        A = Construct(realm, C, [new NumberValue(realm, len)]);\n      } else {\n        // 10. Else,\n        // a. Let A be ? ArrayCreate(len).\n        A = Create.ArrayCreate(realm, len);\n      }\n\n      // 11. Let k be 0.\n      let k = 0;\n\n      // 12. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // b. Let kValue be ? Get(arrayLike, Pk).\n        let kValue = Get(realm, arrayLike, Pk);\n\n        let mappedValue;\n        // c. If mapping is true, then\n        if (mapping === true) {\n          // i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n          invariant(T !== undefined);\n          mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n        } else {\n          // d. Else, let mappedValue be kValue.\n          mappedValue = kValue;\n        }\n\n        // e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\n        Create.CreateDataPropertyOrThrow(realm, A, new StringValue(realm, Pk), mappedValue);\n\n        // f. Increase k by 1.\n        k = k + 1;\n      }\n\n      // 13. Perform ? Set(A, \"length\", len, true).\n      Properties.Set(realm, A, \"length\", new NumberValue(realm, len), true);\n\n      // 14. Return A.\n      return A;\n    });\n  }\n\n  // ECMA262 22.1.2.5\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n"]}