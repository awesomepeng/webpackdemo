{"version":3,"sources":["../../../src/intrinsics/ecma262/RegExpPrototype.js"],"names":["realm","obj","defineNativeMethod","context","string","R","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$RegExpMatcher","undefined","S","ToStringPartial","defineNativeGetter","result","global","ToBooleanPartial","ignoreCase","multiline","unicode","sticky","InternalHasFlag","SymbolMatch","rx","fullUnicode","Set","zero","A","ArrayCreate","n","null","matchStr","status","CreateDataProperty","ToString","thisIndex","ToLength","nextIndex","SymbolReplace","_replaceValue","replaceValue","lengthS","length","functionalReplace","results","done","push","accumulatedResult","nextSourcePosition","nCaptures","Math","max","matched","matchLength","position","ToInteger","min","captures","capN","mightBeUndefined","replacement","replacerArgs","capture","concat","replValue","value","substr","SymbolSearch","previousLastIndex","$OriginalSource","RegExpPrototype","$OriginalFlags","src","flags","SymbolSplit","limit","C","RegExp","unicodeMatching","indexOf","newFlags","splitter","lengthA","lim","pow","ToUint32","size","p","z","q","e","T","numberOfCaptures","i","nextCapture","match","pattern","flag","true","false"],"mappings":"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","file":"RegExpPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport invariant from \"../../invariant.js\";\nimport {\n  BooleanValue,\n  StringValue,\n  ObjectValue,\n  NullValue,\n  NumberValue,\n  UndefinedValue,\n  Value,\n} from \"../../values/index.js\";\nimport { SameValue } from \"../../methods/abstract.js\";\nimport { Call } from \"../../methods/call.js\";\nimport { Construct, SpeciesConstructor } from \"../../methods/construct.js\";\nimport { Get, GetSubstitution } from \"../../methods/get.js\";\nimport { Create, Properties, To } from \"../../singletons.js\";\nimport { IsCallable } from \"../../methods/is.js\";\nimport { RegExpBuiltinExec, RegExpExec, EscapeRegExpPattern, AdvanceStringIndex } from \"../../methods/regexp.js\";\n\nfunction InternalHasFlag(realm: Realm, context: Value, flag: string): Value {\n  // 1. Let R be the this value.\n  let R = context.throwIfNotConcrete();\n\n  // 2. If Type(R) is not Object, throw a TypeError exception.\n  if (!(R instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n  }\n\n  // 3. If R does not have an [[OriginalFlags]] internal slot, throw a TypeError exception.\n  if (typeof R.$OriginalFlags !== \"string\") {\n    // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.\n    if (SameValue(realm, R, realm.intrinsics.RegExpPrototype)) {\n      return realm.intrinsics.undefined;\n    } else {\n      // b. Otherwise, throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"R does not have an [[OriginalFlags]] internal slot\"\n      );\n    }\n  }\n\n  // 4. Let flags be the value of R's [[OriginalFlags]] internal slot.\n  let flags = R.$OriginalFlags;\n\n  // 5. If flags contains the code unit \"g\", return true.\n  if (flags.indexOf(flag) >= 0) {\n    return realm.intrinsics.true;\n  }\n\n  // 6. Return false.\n  return realm.intrinsics.false;\n}\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 21.2.5.2\n  obj.defineNativeMethod(\"exec\", 1, (context, [string]) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n    if (R.$RegExpMatcher === undefined) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"R does not have a [[RegExpMatcher]] internal slot\"\n      );\n    }\n\n    // 4. Let S be ? ToString(string).\n    let S = To.ToStringPartial(realm, string);\n\n    // 5. Return ? RegExpBuiltinExec(R, S).\n    return RegExpBuiltinExec(realm, R, S);\n  });\n\n  // ECMA262 21.2.5.3\n  obj.defineNativeGetter(\"flags\", context => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let result be the empty String.\n    let result = \"\";\n\n    // 4. Let global be ToBoolean(? Get(R, \"global\")).\n    let global = To.ToBooleanPartial(realm, Get(realm, R, \"global\"));\n\n    // 5. If global is true, append \"g\" as the last code unit of result.\n    if (global) result += \"g\";\n\n    // 6. Let ignoreCase be ToBoolean(? Get(R, \"ignoreCase\")).\n    let ignoreCase = To.ToBooleanPartial(realm, Get(realm, R, \"ignoreCase\"));\n\n    // 7. If ignoreCase is true, append \"i\" as the last code unit of result.\n    if (ignoreCase) result += \"i\";\n\n    // 8. Let multiline be ToBoolean(? Get(R, \"multiline\")).\n    let multiline = To.ToBooleanPartial(realm, Get(realm, R, \"multiline\"));\n\n    // 9. If multiline is true, append \"m\" as the last code unit of result.\n    if (multiline) result += \"m\";\n\n    // 10. Let unicode be ToBoolean(? Get(R, \"unicode\")).\n    let unicode = To.ToBooleanPartial(realm, Get(realm, R, \"unicode\"));\n\n    // 11. If unicode is true, append \"u\" as the last code unit of result.\n    if (unicode) result += \"u\";\n\n    // 12. Let sticky be ToBoolean(? Get(R, \"sticky\")).\n    let sticky = To.ToBooleanPartial(realm, Get(realm, R, \"sticky\"));\n\n    // 13. If sticky is true, append \"y\" as the last code unit of result.\n    if (sticky) result += \"y\";\n\n    // 14. Return result.\n    return new StringValue(realm, result);\n  });\n\n  // ECMA262 21.2.5.4\n  obj.defineNativeGetter(\"global\", context => {\n    return InternalHasFlag(realm, context, \"g\");\n  });\n\n  // ECMA262 21.2.5.5\n  obj.defineNativeGetter(\"ignoreCase\", context => {\n    return InternalHasFlag(realm, context, \"i\");\n  });\n\n  // ECMA262 21.2.5.6\n  obj.defineNativeMethod(realm.intrinsics.SymbolMatch, 1, (context, [string]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = To.ToStringPartial(realm, string);\n\n    // 4. Let global be ToBoolean(? Get(rx, \"global\")).\n    let global = To.ToBooleanPartial(realm, Get(realm, rx, \"global\"));\n\n    // 5. If global is false, then\n    if (global === false) {\n      // a. Return ? RegExpExec(rx, S).\n      return RegExpExec(realm, rx, S);\n    } else {\n      // 6. Else global is true,\n      // a. Let fullUnicode be ToBoolean(? Get(rx, \"unicode\")).\n      let fullUnicode = To.ToBooleanPartial(realm, Get(realm, rx, \"unicode\"));\n\n      // b. Perform ? Set(rx, \"lastIndex\", 0, true).\n      Properties.Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n\n      // c. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // d. Let n be 0.\n      let n = 0;\n\n      // e. Repeat,\n      while (true) {\n        // i. Let result be ? RegExpExec(rx, S).\n        let result = RegExpExec(realm, rx, S);\n\n        // ii. If result is null, then\n        if (result instanceof NullValue) {\n          // 1. If n=0, return null.\n          if (n === 0) {\n            return realm.intrinsics.null;\n          } else {\n            // 2. Else, return A.\n            return A;\n          }\n        } else {\n          // iii. Else result is not null,\n          // 1. Let matchStr be ? ToString(? Get(result, \"0\")).\n          let matchStr = To.ToStringPartial(realm, Get(realm, result, \"0\"));\n\n          // 2. Let status be CreateDataProperty(A, ! ToString(n), matchStr).\n          let status = Create.CreateDataProperty(\n            realm,\n            A,\n            To.ToString(realm, new NumberValue(realm, n)),\n            new StringValue(realm, matchStr)\n          );\n\n          // 3. Assert: status is true.\n          invariant(status === true, \"status is true\");\n\n          // 4. If matchStr is the empty String, then\n          if (matchStr === \"\") {\n            // a. Let thisIndex be ? ToLength(? Get(rx, \"lastIndex\")).\n            let thisIndex = To.ToLength(realm, Get(realm, rx, \"lastIndex\"));\n\n            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).\n            let nextIndex = AdvanceStringIndex(realm, S, thisIndex, fullUnicode);\n\n            // c .Perform ? Set(rx, \"lastIndex\", nextIndex, true).\n            Properties.Set(realm, rx, \"lastIndex\", new NumberValue(realm, nextIndex), true);\n          }\n\n          // 5. Increment n.\n          n += 1;\n        }\n      }\n\n      invariant(false);\n    }\n  });\n\n  // ECMA262 21.2.5.7\n  obj.defineNativeGetter(\"multiline\", context => {\n    return InternalHasFlag(realm, context, \"m\");\n  });\n\n  // ECMA262 21.2.5.8\n  obj.defineNativeMethod(realm.intrinsics.SymbolReplace, 2, (context, [string, _replaceValue]) => {\n    let replaceValue = _replaceValue;\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = To.ToStringPartial(realm, string);\n\n    // 4. Let lengthS be the number of code unit elements in S.\n    let lengthS = S.length;\n\n    // 5. Let functionalReplace be IsCallable(replaceValue).\n    let functionalReplace = IsCallable(realm, replaceValue);\n\n    // 6. If functionalReplace is false, then\n    if (functionalReplace === false) {\n      // a. Let replaceValue be ? ToString(replaceValue).\n      replaceValue = new StringValue(realm, To.ToStringPartial(realm, replaceValue));\n    }\n\n    // 7. Let global be ToBoolean(? Get(rx, \"global\")).\n    let global = To.ToBooleanPartial(realm, Get(realm, rx, \"global\"));\n\n    let fullUnicode;\n    // 8. If global is true, then\n    if (global === true) {\n      // a. Let fullUnicode be ToBoolean(? Get(rx, \"unicode\")).\n      fullUnicode = To.ToBooleanPartial(realm, Get(realm, rx, \"unicode\"));\n\n      // b. Perform ? Set(rx, \"lastIndex\", 0, true).\n      Properties.Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n    }\n\n    // 9. Let results be a new empty List.\n    let results = [];\n\n    // 10. Let done be false.\n    let done = false;\n\n    // 11. Repeat, while done is false\n    while (done === false) {\n      // a. Let result be ? RegExpExec(rx, S).\n      let result = RegExpExec(realm, rx, S);\n\n      // b. If result is null, set done to true.\n      if (result instanceof NullValue) {\n        done = true;\n      } else {\n        // c. Else result is not null,\n        // i. Append result to the end of results.\n        results.push(result);\n\n        // ii. If global is false, set done to true.\n        if (global === false) {\n          done = true;\n        } else {\n          // iii. Else,\n          invariant(fullUnicode !== undefined);\n\n          // 1. Let matchStr be ? ToString(? Get(result, \"0\")).\n          let matchStr = To.ToStringPartial(realm, Get(realm, result, \"0\"));\n\n          // 2. If matchStr is the empty String, then\n          if (matchStr === \"\") {\n            // a. Let thisIndex be ? ToLength(? Get(rx, \"lastIndex\")).\n            let thisIndex = To.ToLength(realm, Get(realm, rx, \"lastIndex\"));\n\n            // b. Let nextIndex be AdvanceStringIndex(S, thisIndex, fullUnicode).\n            let nextIndex = AdvanceStringIndex(realm, S, thisIndex, fullUnicode);\n\n            // c. Perform ? Set(rx, \"lastIndex\", nextIndex, true).\n            Properties.Set(realm, rx, \"lastIndex\", new NumberValue(realm, nextIndex), true);\n          }\n        }\n      }\n    }\n\n    // 12. Let accumulatedResult be the empty String value.\n    let accumulatedResult = \"\";\n\n    // 13. Let nextSourcePosition be 0.\n    let nextSourcePosition = 0;\n\n    // 14. Repeat, for each result in results,\n    for (let result of results) {\n      // a. Let nCaptures be ? ToLength(? Get(result, \"length\")).\n      let nCaptures = To.ToLength(realm, Get(realm, result, \"length\"));\n\n      // b. Let nCaptures be max(nCaptures - 1, 0).\n      nCaptures = Math.max(nCaptures - 1, 0);\n\n      // c. Let matched be ? ToString(? Get(result, \"0\")).\n      let matched = To.ToStringPartial(realm, Get(realm, result, \"0\"));\n\n      // d. Let matchLength be the number of code units in matched.\n      let matchLength = matched.length;\n\n      // e. Let position be ? ToInteger(? Get(result, \"index\")).\n      let position = To.ToInteger(realm, Get(realm, result, \"index\"));\n\n      // f. Let position be max(min(position, lengthS), 0).\n      position = Math.max(Math.min(position, lengthS), 0);\n\n      // g. Let n be 1.\n      let n = 1;\n\n      // h. Let captures be a new empty List.\n      let captures = [];\n\n      // i. Repeat while n ≤ nCaptures\n      while (n <= nCaptures) {\n        // i. Let capN be ? Get(result, ! ToString(n)).\n        let capN = Get(realm, result, To.ToString(realm, new NumberValue(realm, n)));\n\n        // ii. If capN is not undefined, then\n        if (!capN.mightBeUndefined()) {\n          // 1. Let capN be ? ToString(capN).\n          capN = To.ToStringPartial(realm, capN);\n        } else {\n          capN.throwIfNotConcrete();\n          capN = undefined;\n        }\n\n        // iii. Append capN as the last element of captures.\n        captures.push(capN);\n\n        // iv. Let n be n+1.\n        n = n + 1;\n      }\n\n      let replacement;\n      // j. If functionalReplace is true, then\n      if (functionalReplace) {\n        // i. Let replacerArgs be « matched ».\n        let replacerArgs = [new StringValue(realm, matched)];\n\n        // ii. Append in list order the elements of captures to the end of the List replacerArgs.\n        for (let capture of captures) {\n          replacerArgs.push(capture === undefined ? realm.intrinsics.undefined : new StringValue(realm, capture));\n        }\n\n        // iii. Append position and S as the last two elements of replacerArgs.\n        replacerArgs = replacerArgs.concat([new NumberValue(realm, position), new StringValue(realm, S)]);\n\n        // iv. Let replValue be ? Call(replaceValue, undefined, replacerArgs).\n        let replValue = Call(realm, replaceValue, realm.intrinsics.undefined, replacerArgs);\n\n        // v. Let replacement be ? ToString(replValue).\n        replacement = To.ToStringPartial(realm, replValue);\n      } else {\n        // k. Else,\n        invariant(replaceValue instanceof StringValue);\n        // i. Let replacement be GetSubstitution(matched, S, position, captures, replaceValue).\n        replacement = GetSubstitution(realm, matched, S, position, captures, replaceValue.value);\n      }\n\n      // l. If position ≥ nextSourcePosition, then\n      if (position >= nextSourcePosition) {\n        // i. NOTE position should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of rx. In such cases, the corresponding substitution is ignored.\n        // ii. Let accumulatedResult be the String formed by concatenating the code units of the current value of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up to position (exclusive) and with the code units of replacement.\n        accumulatedResult =\n          accumulatedResult + S.substr(nextSourcePosition, position - nextSourcePosition) + replacement;\n\n        // iii. Let nextSourcePosition be position + matchLength.\n        nextSourcePosition = position + matchLength;\n      }\n    }\n    // 15. If nextSourcePosition ≥ lengthS, return accumulatedResult.\n    if (nextSourcePosition >= lengthS) return new StringValue(realm, accumulatedResult);\n\n    // 16. Return the String formed by concatenating the code units of accumulatedResult with the substring of S consisting of the code units from nextSourcePosition (inclusive) up through the final code unit of S (inclusive).\n    return new StringValue(realm, accumulatedResult + S.substr(nextSourcePosition));\n  });\n\n  // ECMA262 21.2.5.9\n  obj.defineNativeMethod(realm.intrinsics.SymbolSearch, 1, (context, [string]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = To.ToStringPartial(realm, string);\n\n    // 4. Let previousLastIndex be ? Get(rx, \"lastIndex\").\n    let previousLastIndex = Get(realm, rx, \"lastIndex\");\n\n    // 5. Perform ? Set(rx, \"lastIndex\", 0, true).\n    Properties.Set(realm, rx, \"lastIndex\", realm.intrinsics.zero, true);\n\n    // 6. Let result be ? RegExpExec(rx, S).\n    let result = RegExpExec(realm, rx, S);\n\n    // 7. Perform ? Set(rx, \"lastIndex\", previousLastIndex, true).\n    Properties.Set(realm, rx, \"lastIndex\", previousLastIndex, true);\n\n    // 8. If result is null, return -1.\n    if (result instanceof NullValue) return new NumberValue(realm, -1);\n\n    // 9. Return ? Get(result, \"index\").\n    return Get(realm, result, \"index\");\n  });\n\n  // ECMA262 21.2.5.10\n  obj.defineNativeGetter(\"source\", context => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. If R does not have an [[OriginalSource]] internal slot, throw a TypeError exception.\n    if (typeof R.$OriginalSource !== \"string\") {\n      // a. If SameValue(R, %RegExpPrototype%) is true, return undefined.\n      if (SameValue(realm, R, realm.intrinsics.RegExpPrototype)) {\n        return new StringValue(realm, \"(?:)\");\n      } else {\n        // b. Otherwise, throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"R does not have an [[OriginalSource]] internal slot\"\n        );\n      }\n    }\n\n    // 4. Assert: R has an [[OriginalFlags]] internal slot.\n    invariant(R.$OriginalFlags !== undefined, \"R has an [[OriginalFlags]] internal slot\");\n\n    // 5. Let src be R.[[OriginalSource]].\n    let src = R.$OriginalSource;\n    invariant(typeof src === \"string\");\n\n    // 6. Let flags be R.[[OriginalFlags]].\n    let flags = R.$OriginalFlags;\n    invariant(typeof flags === \"string\");\n\n    // 7. Return EscapeRegExpPattern(src, flags).\n    return new StringValue(realm, EscapeRegExpPattern(realm, src, flags));\n  });\n\n  // ECMA262 21.2.5.11\n  obj.defineNativeMethod(realm.intrinsics.SymbolSplit, 2, (context, [string, limit]) => {\n    // 1. Let rx be the this value.\n    let rx = context.throwIfNotConcrete();\n\n    // 2. If Type(rx) is not Object, throw a TypeError exception.\n    if (!(rx instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(rx) is not an object\");\n    }\n\n    // 3. Let S be ? ToString(string).\n    let S = To.ToStringPartial(realm, string);\n\n    // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).\n    let C = SpeciesConstructor(realm, rx, realm.intrinsics.RegExp);\n\n    // 5. Let flags be ? ToString(? Get(rx, \"flags\")).\n    let flags = To.ToStringPartial(realm, Get(realm, rx, \"flags\"));\n\n    let unicodeMatching;\n    // 6. If flags contains \"u\", let unicodeMatching be true.\n    if (flags.indexOf(\"u\") >= 0) {\n      unicodeMatching = true;\n    } else {\n      // 7. Else, let unicodeMatching be false.\n      unicodeMatching = false;\n    }\n\n    let newFlags;\n    // 8. If flags contains \"y\", let newFlags be flags.\n    if (flags.indexOf(\"y\") >= 0) {\n      newFlags = flags;\n    } else {\n      // 9. Else, let newFlags be the string that is the concatenation of flags and \"y\".\n      newFlags = flags + \"y\";\n    }\n\n    // 10. Let splitter be ? Construct(C, « rx, newFlags »).\n    let splitter = Construct(realm, C, [rx, new StringValue(realm, newFlags)]);\n\n    // 11. Let A be ArrayCreate(0).\n    let A = Create.ArrayCreate(realm, 0);\n\n    // 12. Let lengthA be 0.\n    let lengthA = 0;\n\n    // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).\n    let lim = limit instanceof UndefinedValue ? Math.pow(2, 32) - 1 : To.ToUint32(realm, limit.throwIfNotConcrete());\n\n    // 14. Let size be the number of elements in S.\n    let size = S.length;\n\n    // 15. Let p be 0.\n    let p = 0;\n\n    // 16. If lim = 0, return A.\n    if (lim === 0) return A;\n\n    // 17. If size = 0, then\n    if (size === 0) {\n      // a. Let z be ? RegExpExec(splitter, S).\n      let z = RegExpExec(realm, splitter, S);\n\n      // b. If z is not null, return A.\n      if (!(z instanceof NullValue)) return A;\n\n      // c. Perform ! CreateDataProperty(A, \"0\", S).\n      Create.CreateDataProperty(realm, A, \"0\", new StringValue(realm, S));\n\n      // d Return A.\n      return A;\n    }\n\n    // 18. Let q be p.\n    let q = p;\n\n    // 19. Repeat, while q < size\n    while (q < size) {\n      // a. Perform ? Set(splitter, \"lastIndex\", q, true).\n      Properties.Set(realm, splitter, \"lastIndex\", new NumberValue(realm, q), true);\n\n      // b. Let z be ? RegExpExec(splitter, S).\n      let z = RegExpExec(realm, splitter, S);\n\n      // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).\n      if (z instanceof NullValue) {\n        q = AdvanceStringIndex(realm, S, q, unicodeMatching);\n      } else {\n        // d. Else z is not null,\n        // i. Let e be ? ToLength(? Get(splitter, \"lastIndex\")).\n        let e = To.ToLength(realm, Get(realm, splitter, \"lastIndex\"));\n\n        // ii. Let e be min(e, size).\n        e = Math.min(e, size);\n\n        // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).\n        if (e === p) {\n          q = AdvanceStringIndex(realm, S, q, unicodeMatching);\n        } else {\n          // iv. Else e ≠ p,\n          // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).\n          let T = S.substr(p, q - p);\n\n          // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).\n          Create.CreateDataProperty(\n            realm,\n            A,\n            To.ToString(realm, new NumberValue(realm, lengthA)),\n            new StringValue(realm, T)\n          );\n\n          // 3. Let lengthA be lengthA + 1.\n          lengthA = lengthA + 1;\n\n          // 4. If lengthA = lim, return A.\n          if (lengthA === lim) return A;\n\n          // 5. Let p be e.\n          p = e;\n\n          // 6. Let numberOfCaptures be ? ToLength(? Get(z, \"length\")).\n          let numberOfCaptures = To.ToLength(realm, Get(realm, z, \"length\"));\n\n          // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).\n          numberOfCaptures = Math.max(numberOfCaptures - 1, 0);\n\n          // 8. Let i be 1.\n          let i = 1;\n\n          // 9. Repeat, while i ≤ numberOfCaptures,\n          while (i <= numberOfCaptures) {\n            // a. Let nextCapture be ? Get(z, ! ToString(i)).\n            let nextCapture = Get(realm, z, To.ToString(realm, new NumberValue(realm, i)));\n\n            // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).\n            Create.CreateDataProperty(realm, A, To.ToString(realm, new NumberValue(realm, lengthA)), nextCapture);\n\n            // c. Let i be i + 1.\n            i = i + 1;\n\n            // d. Let lengthA be lengthA + 1.\n            lengthA = lengthA + 1;\n\n            // e. If lengthA = lim, return A.\n            if (lengthA === lim) return A;\n          }\n\n          // 10. Let q be p.\n          q = p;\n        }\n      }\n    }\n\n    // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).\n    let T = S.substr(p, size - p);\n\n    // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).\n    Create.CreateDataProperty(realm, A, To.ToString(realm, new NumberValue(realm, lengthA)), new StringValue(realm, T));\n\n    // 22. Return A.\n    return A;\n  });\n\n  // ECMA262 21.2.5.12\n  obj.defineNativeGetter(\"sticky\", context => {\n    return InternalHasFlag(realm, context, \"y\");\n  });\n\n  // ECMA262 21.2.5.13\n  obj.defineNativeMethod(\"test\", 1, (context, [S]) => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let string be ? ToString(S).\n    let string = To.ToStringPartial(realm, S);\n\n    // 4. Let match be ? RegExpExec(R, string).\n    let match = RegExpExec(realm, R, string);\n\n    // 5. If match is not null, return true; else return false.\n    return new BooleanValue(realm, !(match instanceof NullValue) ? true : false);\n  });\n\n  // ECMA262 21.2.5.14\n  obj.defineNativeMethod(\"toString\", 0, context => {\n    // 1. Let R be the this value.\n    let R = context.throwIfNotConcrete();\n\n    // 2. If Type(R) is not Object, throw a TypeError exception.\n    if (!(R instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(R) is not an object\");\n    }\n\n    // 3. Let pattern be ? ToString(? Get(R, \"source\")).\n    let pattern = To.ToStringPartial(realm, Get(realm, R, \"source\"));\n\n    // 4. Let flags be ? ToString(? Get(R, \"flags\")).\n    let flags = To.ToStringPartial(realm, Get(realm, R, \"flags\"));\n\n    // 5. Let result be the String value formed by concatenating \"/\", pattern, \"/\", and flags.\n    let result = \"/\" + pattern + \"/\" + flags;\n\n    // 6. Return result.\n    return new StringValue(realm, result);\n  });\n\n  // ECMA262 21.2.5.15\n  obj.defineNativeGetter(\"unicode\", context => {\n    return InternalHasFlag(realm, context, \"u\");\n  });\n}\n"]}