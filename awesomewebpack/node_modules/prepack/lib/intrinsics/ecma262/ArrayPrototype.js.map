{"version":3,"sources":["../../../src/intrinsics/ecma262/ArrayPrototype.js"],"names":["realm","obj","defineNativeProperty","intrinsics","SymbolIterator","ArrayProto_values","zero","defineNativeMethod","context","args","argCount","O","ToObject","isIntrinsicAndHasWidenedNumericProperty","isInPureScope","$GetOwnProperty","undefined","newArgs","createTemporalWithWidenedNumericProperty","objNode","_args","t","callExpression","memberExpression","identifier","A","ArraySpeciesCreate","throwIfNotConcreteObject","n","items","length","E","shift","spreadable","k","len","ToLength","Math","pow","createErrorThrowCompletion","TypeError","P","exists","subElement","CreateDataPropertyOrThrow","Set","isCompatibleWith","MOBILE_JSC_VERSION","target","start","end","push","createTemporalFromBuildFunction","relativeTarget","ToInteger","to","max","min","relativeStart","from","relativeEnd","throwIfNotConcrete","final","count","direction","fromKey","ToString","toKey","fromPresent","fromVal","DeletePropertyOrThrow","CreateArrayIterator","callbackfn","thisArg","T","Pk","kPresent","kValue","testResult","ToBooleanPartial","false","true","value","func","thisVal","selected","predicate","searchElement","fromIndex","elementK","Object","is","same","separator","sep","ToStringPartial","emptyString","element0","R","S","element","next","lenVal","mightNotBeNumber","values","isTop","getElements","size","a","mapAndJoin","v","createFromBinaryOp","expressionLocation","doMap","val","resultArray","mappedValue","newLen","indx","initialValue","accumulator","middle","floor","lower","upper","upperP","lowerP","lowerExists","lowerValue","upperExists","upperValue","first","frm","comparefn","isSparse","i","elem","toString","ThrowIfMightHaveBeenDeleted","sparse","proto","$GetPrototypeOf","j","Error","prop","configurable","writable","SortCompare","x","y","mightBeUndefined","ToNumber","isNaN","xString","yString","xSmaller","ySmaller","arr","comparefn_","result_","numb","$Get","sort","hasOwnProperty","ok","$Set","deleteCount","argLength","actualStart","insertCount","actualDeleteCount","dc","fromValue","itemCount","array","firstElement","nextElement","ArrayProto_toString","unscopableList","ObjectCreate","null","CreateDataProperty","SymbolUnscopables"],"mappings":";;;;;;kBAyCe,UAASA,KAAT,EAAuBC,GAAvB,EAA+C;AAC5D;AACAA,MAAIC,oBAAJ,CAAyBF,MAAMG,UAAN,CAAiBC,cAA1C,EAA0DJ,MAAMG,UAAN,CAAiBE,iBAA3E;;AAEA;AACAJ,MAAIC,oBAAJ,CAAyB,QAAzB,EAAmCF,MAAMG,UAAN,CAAiBG,IAApD;;AAEA;AACAL,MAAIM,kBAAJ,CAAuB,QAAvB,EAAiC,CAAjC,EAAoC,CAACC,OAAD,EAAUC,IAAV,EAAgBC,QAAhB,KAA6B;AAC/D;AACA,QAAIC,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,QAAlB,MAAgCC,SAHlC,EAIE;AACA,UAAIC,UAAU,CAACN,CAAD,EAAI,GAAGF,IAAP,CAAd;AACA,aAAO,kBAAWS,wCAAX,CAAoDlB,KAApD,EAA2DiB,OAA3D,EAAoE,CAAC,CAACE,OAAD,EAAU,GAAGC,KAAb,CAAD,KACzEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,QAAb,CAA5B,CAAjB,EAAwEJ,KAAxE,CADK,CAAP;AAGD;;AAED;AACA,QAAIK,IAAI,mBAAOC,kBAAP,CAA0B1B,KAA1B,EAAiCW,EAAEgB,wBAAF,EAAjC,EAA+D,CAA/D,CAAR;;AAEA;AACA,QAAIC,IAAI,CAAR;;AAEA;AACA;AACA,QAAIC,QAAQnB,aAAa,CAAb,GAAiB,CAACC,CAAD,CAAjB,GAAuB,CAACA,CAAD,EAAI,GAAGF,IAAP,CAAnC;;AAEA;AACA,WAAOoB,MAAMC,MAAb,EAAqB;AACnB;AACA,UAAIC,IAAIF,MAAMG,KAAN,EAAR;;AAEA;AACA,UAAIC,aAAa,gCAAmBjC,KAAnB,EAA0B+B,CAA1B,CAAjB;;AAEA;AACA,UAAIE,UAAJ,EAAgB;AACdF,YAAIA,EAAEJ,wBAAF,EAAJ;;AAEA;AACA,YAAIO,IAAI,CAAR;;AAEA;AACA,YAAIC,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAW+B,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,YAAIH,IAAIO,GAAJ,GAAUE,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAhC,EAAmC;AACjC,gBAAMtC,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,eAA7D,CAAN;AACD;;AAED;AACA,eAAON,IAAIC,GAAX,EAAgB;AACd;AACA,cAAIM,IAAI,uBAAgBzC,KAAhB,EAAuBkC,IAAI,EAA3B,CAAR;;AAEA;AACA,cAAIQ,SAAS,yBAAY1C,KAAZ,EAAmB+B,CAAnB,EAAsBU,CAAtB,CAAb;;AAEA;AACA,cAAIC,MAAJ,EAAY;AACV;AACA,gBAAIC,aAAa,iBAAI3C,KAAJ,EAAW+B,CAAX,EAAcU,CAAd,CAAjB;;AAEA;AACA,+BAAOG,yBAAP,CAAiC5C,KAAjC,EAAwCyB,CAAxC,EAA2C,uBAAgBzB,KAAhB,EAAuB4B,IAAI,EAA3B,CAA3C,EAA2Ee,UAA3E;AACD;;AAED;AACAf;;AAEA;AACAM;AACD;AACF,OArCD,MAqCO;AACL;AACA;AACA,YAAIN,IAAIS,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAA1B,EAA6B;AAC3B,gBAAMtC,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,eAA7D,CAAN;AACD;;AAED;AACA,2BAAOI,yBAAP,CAAiC5C,KAAjC,EAAwCyB,CAAxC,EAA2C,uBAAgBzB,KAAhB,EAAuB4B,IAAI,EAA3B,CAA3C,EAA2EG,CAA3E;;AAEA;AACAH;AACD;AACF;;AAED;AACA,2BAAWiB,GAAX,CAAe7C,KAAf,EAAsByB,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBzB,KAAhB,EAAuB4B,CAAvB,CAAnC,EAA8D,IAA9D;;AAEA;AACA,WAAOH,CAAP;AACD,GA3FD;;AA6FA;AACA,MAAI,CAACzB,MAAM8C,gBAAN,CAAuB9C,MAAM+C,kBAA7B,CAAD,IAAqD,CAAC/C,MAAM8C,gBAAN,CAAuB,QAAvB,CAA1D,EACE7C,IAAIM,kBAAJ,CAAuB,YAAvB,EAAqC,CAArC,EAAwC,CAACC,OAAD,EAAU,CAACwC,MAAD,EAASC,KAAT,EAAgBC,GAAhB,CAAV,KAAmC;AACzE;AACA,QAAIvC,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,YAAlB,MAAoCC,SAHtC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAIqC,MAAJ,CAAX;AACA,UAAIC,KAAJ,EAAW;AACTxC,aAAK0C,IAAL,CAAUF,KAAV;AACD;AACD,UAAIC,GAAJ,EAAS;AACPzC,aAAK0C,IAAL,CAAUD,GAAV;AACD;AACD,2BAAcE,+BAAd,CAA8CpD,KAA9C,uBAAmES,IAAnE,EAAyE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACvEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,YAAb,CAA5B,CAAjB,EAA4EJ,KAA5E,CADF;AAGA,aAAOT,CAAP;AACD;;AAED;AACA,QAAIwB,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI0C,iBAAiB,eAAGC,SAAH,CAAatD,KAAb,EAAoBgD,MAApB,CAArB;;AAEA;AACA,QAAIO,KAAKF,iBAAiB,CAAjB,GAAqBhB,KAAKmB,GAAL,CAASrB,MAAMkB,cAAf,EAA+B,CAA/B,CAArB,GAAyDhB,KAAKoB,GAAL,CAASJ,cAAT,EAAyBlB,GAAzB,CAAlE;;AAEA;AACA,QAAIuB,gBAAgB,eAAGJ,SAAH,CAAatD,KAAb,EAAoBiD,KAApB,CAApB;;AAEA;AACA,QAAIU,OAAOD,gBAAgB,CAAhB,GAAoBrB,KAAKmB,GAAL,CAASrB,MAAMuB,aAAf,EAA8B,CAA9B,CAApB,GAAuDrB,KAAKoB,GAAL,CAASC,aAAT,EAAwBvB,GAAxB,CAAlE;;AAEA;AACA,QAAIyB,cAAc,CAACV,GAAD,IAAQA,oCAAR,GAAwCf,GAAxC,GAA8C,eAAGmB,SAAH,CAAatD,KAAb,EAAoBkD,IAAIW,kBAAJ,EAApB,CAAhE;;AAEA;AACA,QAAIC,QAAQF,cAAc,CAAd,GAAkBvB,KAAKmB,GAAL,CAASrB,MAAMyB,WAAf,EAA4B,CAA5B,CAAlB,GAAmDvB,KAAKoB,GAAL,CAASG,WAAT,EAAsBzB,GAAtB,CAA/D;;AAEA;AACA,QAAI4B,QAAQ1B,KAAKoB,GAAL,CAASK,QAAQH,IAAjB,EAAuBxB,MAAMoB,EAA7B,CAAZ;;AAEA,QAAIS,SAAJ;AACA;AACA,QAAIL,OAAOJ,EAAP,IAAaA,KAAKI,OAAOI,KAA7B,EAAoC;AAClC;AACAC,kBAAY,CAAC,CAAb;;AAEA;AACAL,aAAOA,OAAOI,KAAP,GAAe,CAAtB;;AAEA;AACAR,WAAKA,KAAKQ,KAAL,GAAa,CAAlB;AACD,KATD,MASO;AACL;AACA;AACAC,kBAAY,CAAZ;AACD;;AAED;AACA,WAAOD,QAAQ,CAAf,EAAkB;AAChB;AACA,UAAIE,UAAU,eAAGC,QAAH,CAAYlE,KAAZ,EAAmB,uBAAgBA,KAAhB,EAAuB2D,IAAvB,CAAnB,CAAd;;AAEA;AACA,UAAIQ,QAAQ,eAAGD,QAAH,CAAYlE,KAAZ,EAAmB,uBAAgBA,KAAhB,EAAuBuD,EAAvB,CAAnB,CAAZ;;AAEA;AACA,UAAIa,cAAc,yBAAYpE,KAAZ,EAAmBW,CAAnB,EAAsBsD,OAAtB,CAAlB;;AAEA;AACA,UAAIG,gBAAgB,IAApB,EAA0B;AACxB;AACA,YAAIC,UAAU,iBAAIrE,KAAJ,EAAWW,CAAX,EAAcsD,OAAd,CAAd;AACA;AACA,+BAAWpB,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyBwD,KAAzB,EAAgCE,OAAhC,EAAyC,IAAzC;AACD,OALD,MAKO;AACL;AACA;AACA,+BAAWC,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsEwC,KAAtE;AACD;;AAED;AACAR,aAAOA,OAAOK,SAAd;;AAEA;AACAT,WAAKA,KAAKS,SAAV;;AAEA;AACAD,cAAQA,QAAQ,CAAhB;AACD;;AAED;AACA,WAAOpD,CAAP;AACD,GArGD;;AAuGF;AACAV,MAAIM,kBAAJ,CAAuB,SAAvB,EAAkC,CAAlC,EAAqCC,WAAW;AAC9C;AACA,QAAIG,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,SAAlB,MAAiCC,SAHnC,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,gBAA4D,CAACW,CAAD,CAA5D,EAAiE,CAAC,CAACQ,OAAD,CAAD,KACtEE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,SAAb,CAA5B,CAAjB,EAAuE,EAAvE,CADK,CAAP;AAGD;;AAED;AACA,WAAO,mBAAO+C,mBAAP,CAA2BvE,KAA3B,EAAkCW,EAAEgB,wBAAF,EAAlC,EAAgE,WAAhE,CAAP;AACD,GAnBD;;AAqBA;AACA1B,MAAIM,kBAAJ,CAAuB,OAAvB,EAAgC,CAAhC,EAAmC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAaC,OAAb,CAAV,KAAoC;AACrE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,OAAlB,MAA+BC,SAHjC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAIC,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,aAAO,qBAAcrB,+BAAd,CAA8CpD,KAA9C,uBAAmES,IAAnE,EAAyE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC9EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,OAAb,CAA5B,CAAjB,EAAuEJ,KAAvE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,YAAMxE,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIkC,IAAID,WAAWzE,MAAMG,UAAN,CAAiBa,SAApC;;AAEA;AACA,QAAIkB,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,YAAIG,aAAa,eAAGC,gBAAH,CAAoB/E,KAApB,EAA2B,kBAAKA,KAAL,EAAYwE,UAAZ,EAAwBE,CAAxB,EAA2B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA3B,CAA3B,CAAjB;;AAEA;AACA,YAAI,CAACmE,UAAL,EAAiB,OAAO9E,MAAMG,UAAN,CAAiB6E,KAAxB;AAClB;;AAED;AACA9C;AACD;;AAED;AACA,WAAOlC,MAAMG,UAAN,CAAiB8E,IAAxB;AACD,GA7DD;;AA+DA;AACAhF,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,CAACC,OAAD,EAAU,CAAC0E,KAAD,EAAQjC,KAAR,EAAeC,GAAf,CAAV,KAAkC;AAClE;AACA,QAAIvC,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAIuE,KAAJ,CAAX;AACA,UAAIjC,KAAJ,EAAW;AACTxC,aAAK0C,IAAL,CAAUF,KAAV;AACD;AACD,UAAIC,GAAJ,EAAS;AACPzC,aAAK0C,IAAL,CAAUD,GAAV;AACD;AACD,2BAAcE,+BAAd,CAA8CpD,KAA9C,gBAA4DS,IAA5D,EAAkE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAChEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAsEJ,KAAtE,CADF;AAGA,aAAOT,CAAP;AACD;;AAED;AACA,QAAIwB,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI+C,gBAAgB,eAAGJ,SAAH,CAAatD,KAAb,EAAoBiD,SAASjD,MAAMG,UAAN,CAAiBa,SAA9C,CAApB;;AAEA;AACA,QAAIkB,IAAIwB,gBAAgB,CAAhB,GAAoBrB,KAAKmB,GAAL,CAASrB,MAAMuB,aAAf,EAA8B,CAA9B,CAApB,GAAuDrB,KAAKoB,GAAL,CAASC,aAAT,EAAwBvB,GAAxB,CAA/D;;AAEA;AACA,QAAIyB,cAAc,CAACV,GAAD,IAAQA,oCAAR,GAAwCf,GAAxC,GAA8C,eAAGmB,SAAH,CAAatD,KAAb,EAAoBkD,IAAIW,kBAAJ,EAApB,CAAhE;;AAEA;AACA,QAAIC,QAAQF,cAAc,CAAd,GAAkBvB,KAAKmB,GAAL,CAASrB,MAAMyB,WAAf,EAA4B,CAA5B,CAAlB,GAAmDvB,KAAKoB,GAAL,CAASG,WAAT,EAAsBzB,GAAtB,CAA/D;;AAEA;AACA,WAAOD,IAAI4B,KAAX,EAAkB;AAChB;AACA,UAAIa,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,6BAAWW,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyBgE,EAAzB,EAA6BO,KAA7B,EAAoC,IAApC;;AAEA;AACAhD;AACD;;AAED;AACA,WAAOvB,CAAP;AACD,GAtDD;;AAwDA;AACAV,MAAIM,kBAAJ,CAAuB,QAAvB,EAAiC,CAAjC,EAAoC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAaC,OAAb,CAAV,KAAoC;AACtE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,QAAlB,MAAgCC,SAHlC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAIC,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,aAAO,kBAAWvD,wCAAX,CACLlB,KADK,EAELS,IAFK,EAGL,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,QAAb,CAA5B,CAAjB,EAAwEJ,KAAxE,CAJG,EAKL,EAAE+D,MAAMX,UAAR,EAAoBY,SAASX,OAA7B,EALK,CAAP;AAOD;;AAED;AACA,QAAItC,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,YAAMxE,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIkC,IAAID,WAAWzE,MAAMG,UAAN,CAAiBa,SAApC;;AAEA;AACA,QAAIS,IAAI,mBAAOC,kBAAP,CAA0B1B,KAA1B,EAAiCW,EAAEgB,wBAAF,EAAjC,EAA+D,CAA/D,CAAR;;AAEA;AACA,QAAIO,IAAI,CAAR;;AAEA;AACA,QAAIqB,KAAK,CAAT;;AAEA;AACA,WAAOrB,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,YAAIU,WAAW,eAAGN,gBAAH,CAAoB/E,KAApB,EAA2B,kBAAKA,KAAL,EAAYwE,UAAZ,EAAwBE,CAAxB,EAA2B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA3B,CAA3B,CAAf;;AAEA;AACA,YAAI0E,QAAJ,EAAc;AACZ;AACA,6BAAOzC,yBAAP,CAAiC5C,KAAjC,EAAwCyB,CAAxC,EAA2C,eAAGyC,QAAH,CAAYlE,KAAZ,EAAmB,uBAAgBA,KAAhB,EAAuBuD,EAAvB,CAAnB,CAA3C,EAA2FsB,MAA3F;;AAEA;AACAtB;AACD;AACF;;AAED;AACArB;AACD;;AAED;AACA,WAAOT,CAAP;AACD,GA1ED;;AA4EA;AACAxB,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,CAACC,OAAD,EAAU,CAAC8E,SAAD,EAAYb,OAAZ,CAAV,KAAmC;AACnE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI2E,SAAJ,CAAX;AACA,UAAIb,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,aAAO,qBAAcrB,+BAAd,CAA8CpD,KAA9C,gBAA4DS,IAA5D,EAAkE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACvEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAsEJ,KAAtE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBsF,SAAlB,CAAL,EAAmC;AACjC,YAAMtF,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIkC,IAAID,WAAWzE,MAAMG,UAAN,CAAiBa,SAApC;;AAEA;AACA,QAAIkB,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI2C,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,UAAIG,aAAa,eAAGC,gBAAH,CAAoB/E,KAApB,EAA2B,kBAAKA,KAAL,EAAYsF,SAAZ,EAAuBZ,CAAvB,EAA0B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA1B,CAA3B,CAAjB;;AAEA;AACA,UAAImE,UAAJ,EAAgB,OAAOD,MAAP;;AAEhB;AACA3C;AACD;;AAED;AACA,WAAOlC,MAAMG,UAAN,CAAiBa,SAAxB;AACD,GAvDD;;AAyDA;AACAf,MAAIM,kBAAJ,CAAuB,WAAvB,EAAoC,CAApC,EAAuC,CAACC,OAAD,EAAU,CAAC8E,SAAD,EAAYb,OAAZ,CAAV,KAAmC;AACxE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,WAAlB,MAAmCC,SAHrC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI2E,SAAJ,CAAX;AACA,UAAIb,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,aAAO,qBAAcrB,+BAAd,CAA8CpD,KAA9C,sBAAkES,IAAlE,EAAwE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC7EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,WAAb,CAA5B,CAAjB,EAA2EJ,KAA3E,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,wBAAWX,KAAX,EAAkBsF,SAAlB,MAAiC,KAArC,EAA4C;AAC1C,YAAMtF,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIkC,IAAID,UAAUA,OAAV,GAAoBzE,MAAMG,UAAN,CAAiBa,SAA7C;;AAEA;AACA,QAAIkB,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,eAAGT,QAAH,CAAYlE,KAAZ,EAAmB,uBAAgBA,KAAhB,EAAuBkC,CAAvB,CAAnB,CAAT;;AAEA;AACA,UAAI2C,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAc,uBAAgBX,KAAhB,EAAuB2E,EAAvB,CAAd,CAAb;;AAEA;AACA,UAAIG,aAAa,eAAGC,gBAAH,CAAoB/E,KAApB,EAA2B,kBAAKA,KAAL,EAAYsF,SAAZ,EAAuBZ,CAAvB,EAA0B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA1B,CAA3B,CAAjB;;AAEA;AACA,UAAImE,eAAe,IAAnB,EAAyB,OAAO,uBAAgB9E,KAAhB,EAAuBkC,CAAvB,CAAP;;AAEzB;AACAA,UAAIA,IAAI,CAAR;AACD;;AAED;AACA,WAAO,uBAAgBlC,KAAhB,EAAuB,CAAC,CAAxB,CAAP;AACD,GAvDD;;AAyDA;AACAC,MAAIM,kBAAJ,CAAuB,SAAvB,EAAkC,CAAlC,EAAqC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAaC,OAAb,CAAV,KAAoC;AACvE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,SAAlB,MAAiCC,SAHnC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAIC,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,2BAAcrB,+BAAd,CAA8CpD,KAA9C,uBAAmES,IAAnE,EAAyE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACvEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,SAAb,CAA5B,CAAjB,EAAyEJ,KAAzE,CADF;AAGA,aAAOpB,MAAMG,UAAN,CAAiBa,SAAxB;AACD;;AAED;AACA,QAAImB,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,YAAMxE,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIkC,IAAID,WAAWzE,MAAMG,UAAN,CAAiBa,SAApC;;AAEA;AACA,QAAIkB,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,0BAAK3E,KAAL,EAAYwE,UAAZ,EAAwBE,CAAxB,EAA2B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA3B;AACD;;AAED;AACAuB;AACD;;AAED;AACA,WAAOlC,MAAMG,UAAN,CAAiBa,SAAxB;AACD,GA3DD;;AA6DA;AACA,MAAI,CAAChB,MAAM8C,gBAAN,CAAuB9C,MAAM+C,kBAA7B,CAAD,IAAqD,CAAC/C,MAAM8C,gBAAN,CAAuB,QAAvB,CAA1D,EACE7C,IAAIM,kBAAJ,CAAuB,UAAvB,EAAmC,CAAnC,EAAsC,CAACC,OAAD,EAAU,CAAC+E,aAAD,EAAgBC,SAAhB,CAAV,KAAyC;AAC7E;AACA,QAAI7E,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,UAAlB,MAAkCC,SAHpC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI4E,aAAJ,CAAX;AACA,UAAIC,SAAJ,EAAe;AACb/E,aAAK0C,IAAL,CAAUqC,SAAV;AACD;AACD,aAAO,qBAAcpC,+BAAd,CAA8CpD,KAA9C,uBAAmES,IAAnE,EAAyE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC9EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,UAAb,CAA5B,CAAjB,EAA0EJ,KAA1E,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAIwB,QAAQ,CAAZ,EAAe,OAAOnC,MAAMG,UAAN,CAAiB6E,KAAxB;;AAEf;AACA,QAAIpD,IAAI,eAAG0B,SAAH,CAAatD,KAAb,EAAoBwF,aAAaxF,MAAMG,UAAN,CAAiBa,SAAlD,CAAR;;AAEA,QAAIkB,CAAJ;AACA;AACA,QAAIN,KAAK,CAAT,EAAY;AACV;AACAM,UAAIN,CAAJ;AACD,KAHD,MAGO;AACL;AACA;AACAM,UAAIC,MAAMP,CAAV;AACA;AACA,UAAIM,IAAI,CAAR,EAAWA,IAAI,CAAJ;AACZ;;AAED;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIsD,WAAW,iBAAIzF,KAAJ,EAAWW,CAAX,EAAc,eAAGuD,QAAH,CAAYlE,KAAZ,EAAmB,uBAAgBA,KAAhB,EAAuBkC,CAAvB,CAAnB,CAAd,CAAf;;AAEA;AACA,UAAI,oCAAqBlC,KAArB,EAA4BuF,aAA5B,EAA2CE,QAA3C,MAAyD,IAA7D,EAAmE,OAAOzF,MAAMG,UAAN,CAAiB8E,IAAxB;;AAEnE;AACA/C,UAAIA,IAAI,CAAR;AACD;;AAED;AACA,WAAOlC,MAAMG,UAAN,CAAiB6E,KAAxB;AACD,GAzDD;;AA2DF;AACA/E,MAAIM,kBAAJ,CAAuB,SAAvB,EAAkC,CAAlC,EAAqC,CAACC,OAAD,EAAU,CAAC+E,aAAD,EAAgBC,SAAhB,CAAV,KAAyC;AAC5E;AACA,QAAI7E,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,SAAlB,MAAiCC,SAHnC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI4E,aAAJ,CAAX;AACA,UAAIC,SAAJ,EAAe;AACb/E,aAAK0C,IAAL,CAAUqC,SAAV;AACD;AACD,aAAO,qBAAcpC,+BAAd,CAA8CpD,KAA9C,sBAAkES,IAAlE,EAAwE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC7EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,SAAb,CAA5B,CAAjB,EAAyEJ,KAAzE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAIwB,QAAQ,CAAZ,EAAe,OAAO,uBAAgBnC,KAAhB,EAAuB,CAAC,CAAxB,CAAP;;AAEf;AACA,QAAI4B,IAAI4D,YAAY,eAAGlC,SAAH,CAAatD,KAAb,EAAoBwF,SAApB,CAAZ,GAA6C,CAArD;;AAEA;AACA,QAAI5D,KAAKO,GAAT,EAAc,OAAO,uBAAgBnC,KAAhB,EAAuB,CAAC,CAAxB,CAAP;;AAEd;AACA,QAAIkC,CAAJ;AACA,QAAIN,KAAK,CAAT,EAAY;AACV;AACAM,UAAIwD,OAAOC,EAAP,CAAU/D,CAAV,EAAa,CAAC,CAAd,IAAmB,CAAC,CAApB,GAAwBA,CAA5B;AACD,KAHD,MAGO;AACL;AACA;AACAM,UAAIC,MAAMP,CAAV;;AAEA;AACA,UAAIM,IAAI,CAAR,EAAWA,IAAI,CAAJ;AACZ;;AAED;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIyC,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBuB,IAAI,EAA1B,CAAf;;AAEA;AACA,UAAI0C,aAAa,IAAjB,EAAuB;AACrB;AACA,YAAIa,WAAW,iBAAIzF,KAAJ,EAAWW,CAAX,EAAcuB,IAAI,EAAlB,CAAf;;AAEA;AACA,YAAI0D,OAAO,6CAAgC5F,KAAhC,EAAuCuF,aAAvC,EAAsDE,QAAtD,CAAX;;AAEA;AACA,YAAIG,IAAJ,EAAU,OAAO,uBAAgB5F,KAAhB,EAAuBkC,CAAvB,CAAP;AACX;;AAED;AACAA;AACD;;AAED;AACA,WAAO,uBAAgBlC,KAAhB,EAAuB,CAAC,CAAxB,CAAP;AACD,GAtED;;AAwEA;AACAC,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,CAACC,OAAD,EAAU,CAACqF,SAAD,CAAV,KAA0B;AAC1D;AACA,QAAIlF,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,CAAX;AACA,UAAIkF,SAAJ,EAAe;AACbpF,aAAK0C,IAAL,CAAU0C,SAAV;AACD;AACD,aAAO,qBAAczC,+BAAd,CAA8CpD,KAA9C,sBAAkES,IAAlE,EAAwE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC7EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAsEJ,KAAtE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAACkF,SAAD,IAAcA,0CAAlB,EAAuDA,YAAY,uBAAgB7F,KAAhB,EAAuB,GAAvB,CAAZ;;AAEvD;AACA,QAAI8F,MAAM,eAAGC,eAAH,CAAmB/F,KAAnB,EAA0B6F,SAA1B,CAAV;;AAEA;AACA,QAAI1D,QAAQ,CAAZ,EAAe,OAAOnC,MAAMG,UAAN,CAAiB6F,WAAxB;;AAEf;AACA,QAAIC,WAAW,iBAAIjG,KAAJ,EAAWW,CAAX,EAAc,GAAd,CAAf;;AAEA;AACA,QAAIuF,CAAJ;AACA,QAAI,mCAAsBD,QAAtB,0CAAJ,EAAgE;AAC9DC,UAAI,EAAJ;AACD,KAFD,MAEO;AACLA,UAAI,eAAGH,eAAH,CAAmB/F,KAAnB,EAA0BiG,QAA1B,CAAJ;AACD;;AAED;AACA,QAAI/D,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIgE,IAAYD,IAAIJ,GAApB;;AAEA;AACA,UAAIM,UAAU,iBAAIpG,KAAJ,EAAWW,CAAX,EAAc,uBAAgBX,KAAhB,EAAuBkC,IAAI,EAA3B,CAAd,CAAd;;AAEA;AACA,UAAImE,IAAJ;AACA,UAAI,mCAAsBD,OAAtB,0CAAJ,EAA+D;AAC7DC,eAAO,EAAP;AACD,OAFD,MAEO;AACLA,eAAO,eAAGN,eAAH,CAAmB/F,KAAnB,EAA0BoG,OAA1B,CAAP;AACD;;AAED;AACAF,UAAIC,IAAIE,IAAR;;AAEA;AACAnE;AACD;;AAED;AACA,WAAO,uBAAgBlC,KAAhB,EAAuBkG,IAAI,EAA3B,CAAP;AACD,GAxED;;AA0EA;AACAjG,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkCC,WAAW;AAC3C;AACA,QAAIG,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,gBAA4D,CAACW,CAAD,CAA5D,EAAiE,CAAC,CAACQ,OAAD,CAAD,KACtEE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAoE,EAApE,CADK,CAAP;AAGD;;AAED;AACA,WAAO,mBAAO+C,mBAAP,CAA2BvE,KAA3B,EAAkCW,EAAEgB,wBAAF,EAAlC,EAAgE,KAAhE,CAAP;AACD,GAnBD;;AAqBA;AACA1B,MAAIM,kBAAJ,CAAuB,aAAvB,EAAsC,CAAtC,EAAyC,CAACC,OAAD,EAAU,CAAC+E,aAAD,EAAgBC,SAAhB,CAAV,KAAyC;AAChF;AACA,QAAI7E,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,aAAlB,MAAqCC,SAHvC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI4E,aAAJ,CAAX;AACA,UAAIC,SAAJ,EAAe;AACb/E,aAAK0C,IAAL,CAAUqC,SAAV;AACD;AACD,aAAO,qBAAcpC,+BAAd,CAA8CpD,KAA9C,sBAAkES,IAAlE,EAAwE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC7EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,aAAb,CAA5B,CAAjB,EAA6EJ,KAA7E,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAIwB,QAAQ,CAAZ,EAAe,OAAO,uBAAgBnC,KAAhB,EAAuB,CAAC,CAAxB,CAAP;;AAEf;AACA,QAAI4B,IAAI4D,YAAY,eAAGlC,SAAH,CAAatD,KAAb,EAAoBwF,SAApB,CAAZ,GAA6CrD,MAAM,CAA3D;;AAEA;AACA,QAAID,CAAJ;AACA,QAAIN,KAAK,CAAT,EAAY;AACV;AACAM,UAAIwD,OAAOC,EAAP,CAAU/D,CAAV,EAAa,CAAC,CAAd,IAAmB,CAAC,CAApB,GAAwBS,KAAKoB,GAAL,CAAS7B,CAAT,EAAYO,MAAM,CAAlB,CAA5B;AACD,KAHD,MAGO;AACL;AACA;AACAD,UAAIC,MAAMP,CAAV;AACD;;AAED;AACA,WAAOM,KAAK,CAAZ,EAAe;AACb;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsB,uBAAgBX,KAAhB,EAAuBkC,IAAI,EAA3B,CAAtB,CAAf;;AAEA;AACA,UAAI0C,QAAJ,EAAc;AACZ;AACA,YAAIa,WAAW,iBAAIzF,KAAJ,EAAWW,CAAX,EAAc,uBAAgBX,KAAhB,EAAuBkC,IAAI,EAA3B,CAAd,CAAf;;AAEA;AACA,YAAI0D,OAAO,6CAAgC5F,KAAhC,EAAuCuF,aAAvC,EAAsDE,QAAtD,CAAX;;AAEA;AACA,YAAIG,IAAJ,EAAU,OAAO,uBAAgB5F,KAAhB,EAAuBkC,CAAvB,CAAP;AACX;;AAED;AACAA;AACD;;AAED;AACA,WAAO,uBAAgBlC,KAAhB,EAAuB,CAAC,CAAxB,CAAP;AACD,GAhED;;AAkEA;AACAC,MAAIM,kBAAJ,CAAuB,KAAvB,EAA8B,CAA9B,EAAiC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAaC,OAAb,CAAV,KAAoC;AACnE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,KAAlB,MAA6BC,SAH/B,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAIC,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,aAAO,kBAAWvD,wCAAX,CACLlB,KADK,EAELS,IAFK,EAGL,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,KAAb,CAA5B,CAAjB,EAAqEJ,KAArE,CAJG,EAKL,EAAE+D,MAAMX,UAAR,EAAoBY,SAASX,OAA7B,EALK,CAAP;AAOD;;AAED;AACA,QAAI6B,SAAS,iBAAItG,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAb;AACA,QAAI2F,0CAAmC,CAACA,OAAOC,gBAAP,EAApC,IAAiE,CAACD,OAAOE,MAAP,CAAcC,KAAd,EAAtE,EAA6F;AAC3F,UAAID,SAASF,OAAOE,MAAP,CAAcE,WAAd,EAAb;AACA,UAAI9E,IAAI4E,OAAOG,IAAf;AACA,UAAI/E,IAAI,CAAJ,IAASA,IAAI,EAAjB,EAAqB;AACnB,YAAIgF,IAAI,mBAAOlF,kBAAP,CAA0B1B,KAA1B,EAAiCW,EAAEgB,wBAAF,EAAjC,EAA+D,CAA/D,CAAR;AACA,eAAO,iBAAKkF,UAAL,CACL7G,KADK,EAELwG,MAFK,EAGLM,KAAK,qBAAcC,kBAAd,CAAiC/G,KAAjC,EAAwC,KAAxC,EAA+C8G,CAA/C,EAAkDR,MAAlD,EAA0DA,OAAOU,kBAAjE,CAHA,EAILF,KAAKG,MAAMH,CAAN,EAASF,CAAT,CAJA,CAAP;AAMD;AACF;AACD,WAAOK,MAAMX,OAAOzC,kBAAP,EAAN,CAAP;;AAEA,aAASoD,KAAT,CAAeC,GAAf,EAAmCC,WAAnC,EAA8D;AAC5D,UAAIhF,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmBkH,GAAnB,CAAV;;AAEA;AACA,UAAI,CAAC,wBAAWlH,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,cAAMxE,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,UAAIkC,IAAID,WAAWzE,MAAMG,UAAN,CAAiBa,SAApC;;AAEA;AACA,UAAIS,CAAJ;AACA,UAAI0F,gBAAgBnG,SAApB,EAA+BS,IAAI,mBAAOC,kBAAP,CAA0B1B,KAA1B,EAAiCW,EAAEgB,wBAAF,EAAjC,EAA+DQ,GAA/D,CAAJ,CAA/B,KACK;AACHV,YAAI0F,WAAJ;AACA,+BAAWtE,GAAX,CAAe7C,KAAf,EAAsByB,CAAtB,EAAyB,QAAzB,EAAmCyF,GAAnC,EAAwC,IAAxC;AACD;;AAED;AACA,UAAIhF,IAAI,CAAR;;AAEA;AACA,aAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,YAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,YAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,YAAIC,QAAJ,EAAc;AACZ;AACA,cAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,cAAIyC,cAAc,kBAAKpH,KAAL,EAAYwE,UAAZ,EAAwBE,CAAxB,EAA2B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA3B,CAAlB;;AAEA;AACA,6BAAOiC,yBAAP,CAAiC5C,KAAjC,EAAwCyB,CAAxC,EAA2CkD,EAA3C,EAA+CyC,WAA/C;AACD;;AAED;AACAlF;AACD;;AAED;AACA,aAAOT,CAAP;AACD;AACF,GAxFD;;AA0FA;AACAxB,MAAIM,kBAAJ,CAAuB,KAAvB,EAA8B,CAA9B,EAAiCC,WAAW;AAC1C;AACA,QAAIG,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,KAAlB,MAA6BC,SAH/B,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,gBAA4D,CAACW,CAAD,CAA5D,EAAiE,CAAC,CAACQ,OAAD,CAAD,KACtEE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,KAAb,CAA5B,CAAjB,EAAmE,EAAnE,CADK,CAAP;AAGD;;AAED;AACA,QAAIW,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAIwB,QAAQ,CAAZ,EAAe;AACb;AACA,6BAAWU,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,QAAzB,EAAmCX,MAAMG,UAAN,CAAiBG,IAApD,EAA0D,IAA1D;;AAEA;AACA,aAAON,MAAMG,UAAN,CAAiBa,SAAxB;AACD,KAND,MAMO;AACL;AACA;AACA,UAAIqG,SAASlF,MAAM,CAAnB;;AAEA;AACA,UAAImF,OAAO,uBAAgBtH,KAAhB,EAAuBqH,SAAS,EAAhC,CAAX;;AAEA;AACA,UAAIjB,UAAU,iBAAIpG,KAAJ,EAAWW,CAAX,EAAc2G,IAAd,CAAd;;AAEA;AACA,6BAAWhD,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE2F,IAAtE;;AAEA;AACA,6BAAWzE,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBX,KAAhB,EAAuBqH,MAAvB,CAAnC,EAAmE,IAAnE;;AAEA;AACA,aAAOjB,OAAP;AACD;AACF,GA/CD;;AAiDA;AACAnG,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,CAACC,OAAD,EAAUC,IAAV,EAAgBC,QAAhB,KAA6B;AAC7D;AACA,QAAIC,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,sBAAkE,CAACW,CAAD,EAAI,GAAGF,IAAP,CAAlE,EAAgF,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACrFC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAsEJ,KAAtE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,uBAAgBX,KAAhB,EAAuB,QAAvB,CAAd,CAAnB,CAAV;;AAEA;AACA,QAAI6B,QAAQnB,WAAW,CAAX,GAAeD,IAAf,GAAsB,EAAlC;;AAEA;AACAC;;AAEA;AACA,QAAIyB,MAAMzB,QAAN,GAAiB2B,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAvC,EAA0C;AACxC,YAAMtC,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,iBAA7D,CAAN;AACD;;AAED;AACA,WAAOX,MAAMC,MAAb,EAAqB;AACnB;AACA,UAAIC,IAAIF,MAAMG,KAAN,EAAR;;AAEA;AACA,6BAAWa,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,uBAAgBX,KAAhB,EAAuBmC,MAAM,EAA7B,CAAzB,EAA2DJ,CAA3D,EAA8D,IAA9D;;AAEA;AACAI;AACD;;AAED;AACA,2BAAWU,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,uBAAgBX,KAAhB,EAAuB,QAAvB,CAAzB,EAA2D,uBAAgBA,KAAhB,EAAuBmC,GAAvB,CAA3D,EAAwF,IAAxF;;AAEA;AACA,WAAO,uBAAgBnC,KAAhB,EAAuBmC,GAAvB,CAAP;AACD,GAhDD;;AAkDA;AACAlC,MAAIM,kBAAJ,CAAuB,QAAvB,EAAiC,CAAjC,EAAoC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAa+C,YAAb,CAAV,KAAyC;AAC3E;AACA,QAAI5G,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,QAAlB,MAAgCC,SAHlC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAI+C,YAAJ,EAAkB;AAChB9G,aAAK0C,IAAL,CAAUoE,YAAV;AACD;AACD,aAAO,qBAAcnE,+BAAd,CAA8CpD,KAA9C,gBAA4DS,IAA5D,EAAkE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACvEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,QAAb,CAA5B,CAAjB,EAAwEJ,KAAxE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,YAAMxE,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIL,QAAQ,CAAR,IAAa,CAACoF,YAAlB,EAAgC;AAC9B,YAAMvH,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,iBAA7D,CAAN;AACD;;AAED;AACA,QAAIN,IAAI,CAAR;;AAEA;AACA,QAAIsF,WAAJ;AACA,QAAID,YAAJ,EAAkB;AAChB;AACAC,oBAAcD,YAAd;AACD,KAHD,MAGO;AACL;AACA;AACA,UAAI3C,WAAW,KAAf;;AAEA;AACA,aAAOA,aAAa,KAAb,IAAsB1C,IAAIC,GAAjC,EAAsC;AACpC;AACA,YAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA0C,mBAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAX;;AAEA;AACA,YAAIC,QAAJ,EAAc;AACZ;AACA4C,wBAAc,iBAAIxH,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAd;AACD;;AAED;AACAzC;AACD;;AAED;AACA,UAAI,CAAC0C,QAAL,EAAe;AACb,cAAM5E,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,mBAA7D,CAAN;AACD;;AAED,+BAAUgF,WAAV;AACD;;AAED;AACA,WAAOtF,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA6C,sBAAc,kBAAKxH,KAAL,EAAYwE,UAAZ,EAAwBxE,MAAMG,UAAN,CAAiBa,SAAzC,EAAoD,CAChEwG,WADgE,EAEhE3C,MAFgE,EAGhE,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAHgE,EAIhEvB,CAJgE,CAApD,CAAd;AAMD;;AAED;AACAuB;AACD;;AAED;AACA,WAAOsF,WAAP;AACD,GArGD;;AAuGA;AACAvH,MAAIM,kBAAJ,CAAuB,aAAvB,EAAsC,CAAtC,EAAyC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAa+C,YAAb,CAAV,KAAyC;AAChF;AACA,QAAI5G,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,aAAlB,MAAqCC,SAHvC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAI+C,YAAJ,EAAkB;AAChB9G,aAAK0C,IAAL,CAAUoE,YAAV;AACD;AACD,aAAO,qBAAcnE,+BAAd,CAA8CpD,KAA9C,gBAA4DS,IAA5D,EAAkE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KACvEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,aAAb,CAA5B,CAAjB,EAA6EJ,KAA7E,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,YAAMxE,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,gBAA7D,CAAN;AACD;;AAED;AACA,QAAIL,QAAQ,CAAR,IAAa,CAACoF,YAAlB,EAAgC;AAC9B,YAAMvH,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,iBAA7D,CAAN;AACD;;AAED;AACA,QAAIN,IAAIC,MAAM,CAAd;;AAEA;AACA,QAAIqF,WAAJ;AACA,QAAID,YAAJ,EAAkB;AAChB;AACAC,oBAAcD,YAAd;AACD,KAHD,MAGO;AACL;AACA;AACA,UAAI3C,WAAW,KAAf;;AAEA;AACA,aAAO,CAACA,QAAD,IAAa1C,KAAK,CAAzB,EAA4B;AAC1B;AACA,YAAIyC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA0C,mBAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAX;;AAEA;AACA,YAAIC,QAAJ,EAAc;AACZ;AACA4C,wBAAc,iBAAIxH,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAd;AACD;;AAED;AACAzC;AACD;;AAED;AACA,UAAI,CAAC0C,QAAD,IAAa,CAAC4C,WAAlB,EAA+B;AAC7B,cAAMxH,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,iBAA7D,CAAN;AACD;AACF;;AAED;AACA,WAAON,KAAK,CAAZ,EAAe;AACb;AACA,UAAIyC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA6C,sBAAc,kBAAKxH,KAAL,EAAYwE,UAAZ,EAAwBxE,MAAMG,UAAN,CAAiBa,SAAzC,EAAoD,CAChEwG,WADgE,EAEhE3C,MAFgE,EAGhE,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAHgE,EAIhEvB,CAJgE,CAApD,CAAd;AAMD;;AAED;AACAuB;AACD;;AAED;AACA,WAAOsF,WAAP;AACD,GAnGD;;AAqGA;AACAvH,MAAIM,kBAAJ,CAAuB,SAAvB,EAAkC,CAAlC,EAAqCC,WAAW;AAC9C;AACA,QAAIG,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,SAAlB,MAAiCC,SAHnC,EAIE;AACA,2BAAcoC,+BAAd,CAA8CpD,KAA9C,qBAAiE,CAACW,CAAD,CAAjE,EAAsE,CAAC,CAACQ,OAAD,CAAD,KACpEE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,SAAb,CAA5B,CAAjB,EAAuE,EAAvE,CADF;AAGA,aAAOb,CAAP;AACD;;AAED;AACA,QAAIwB,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI8G,SAASpF,KAAKqF,KAAL,CAAWvF,MAAM,CAAjB,CAAb;;AAEA;AACA,QAAIwF,QAAQ,CAAZ;;AAEA;AACA,WAAOA,UAAUF,MAAjB,EAAyB;AACvB;AACA,UAAIG,QAAQzF,MAAMwF,KAAN,GAAc,CAA1B;;AAEA;AACA,UAAIE,SAAS,uBAAgB7H,KAAhB,EAAuB4H,QAAQ,EAA/B,CAAb;;AAEA;AACA,UAAIE,SAAS,uBAAgB9H,KAAhB,EAAuB2H,QAAQ,EAA/B,CAAb;;AAEA;AACA,UAAII,cAAc,yBAAY/H,KAAZ,EAAmBW,CAAnB,EAAsBmH,MAAtB,CAAlB;;AAEA;AACA,UAAIE,UAAJ;AACA,UAAID,WAAJ,EAAiB;AACf;AACAC,qBAAa,iBAAIhI,KAAJ,EAAWW,CAAX,EAAcmH,MAAd,CAAb;AACD;;AAED;AACA,UAAIG,cAAc,yBAAYjI,KAAZ,EAAmBW,CAAnB,EAAsBkH,MAAtB,CAAlB;;AAEA;AACA,UAAIK,UAAJ;AACA,UAAID,WAAJ,EAAiB;AACf;AACAC,qBAAa,iBAAIlI,KAAJ,EAAWW,CAAX,EAAckH,MAAd,CAAb;AACD;;AAED;AACA,UAAIE,eAAeE,WAAnB,EAAgC;AAC9B,iCAAUD,UAAV,EAAsB,+BAAtB;AACA,iCAAUE,UAAV,EAAsB,+BAAtB;;AAEA;AACA,+BAAWrF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyBmH,MAAzB,EAAiCI,UAAjC,EAA6C,IAA7C;;AAEA;AACA,+BAAWrF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyBkH,MAAzB,EAAiCG,UAAjC,EAA6C,IAA7C;AACD,OATD,MASO,IAAI,CAACD,WAAD,IAAgBE,WAApB,EAAiC;AACtC;AACA,iCAAUC,UAAV,EAAsB,+BAAtB;;AAEA;AACA,+BAAWrF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyBmH,MAAzB,EAAiCI,UAAjC,EAA6C,IAA7C;;AAEA;AACA,+BAAW5D,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsEkG,MAAtE;AACD,OATM,MASA,IAAIE,eAAe,CAACE,WAApB,EAAiC;AACtC;AACA,iCAAUD,UAAV,EAAsB,+BAAtB;;AAEA;AACA,+BAAW1D,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsEmG,MAAtE;;AAEA;AACA,+BAAWjF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyBkH,MAAzB,EAAiCG,UAAjC,EAA6C,IAA7C;AACD,OATM,MASA,CAGN;AAFC;AACA;;;AAGF;AACAL;AACD;;AAED;AACA,WAAOhH,CAAP;AACD,GAjGD;;AAmGA;AACAV,MAAIM,kBAAJ,CAAuB,OAAvB,EAAgC,CAAhC,EAAmCC,WAAW;AAC5C;AACA,QAAIG,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,OAAlB,MAA+BC,SAHjC,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,gBAA4D,CAACW,CAAD,CAA5D,EAAiE,CAAC,CAACQ,OAAD,CAAD,KACtEE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,OAAb,CAA5B,CAAjB,EAAqE,EAArE,CADK,CAAP;AAGD;;AAED;AACA,QAAIW,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAIwB,QAAQ,CAAZ,EAAe;AACb;AACA,6BAAWU,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,QAAzB,EAAmCX,MAAMG,UAAN,CAAiBG,IAApD,EAA0D,IAA1D;;AAEA;AACA,aAAON,MAAMG,UAAN,CAAiBa,SAAxB;AACD;;AAED;AACA,QAAImH,QAAQ,iBAAInI,KAAJ,EAAWW,CAAX,EAAc,GAAd,CAAZ;;AAEA;AACA,QAAIuB,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIiG,MAAM,uBAAgBpI,KAAhB,EAAuBkC,IAAI,EAA3B,CAAV;;AAEA;AACA,UAAIqB,KAAK,uBAAgBvD,KAAhB,EAAuBkC,IAAI,CAAJ,GAAQ,EAA/B,CAAT;;AAEA;AACA,UAAIkC,cAAc,yBAAYpE,KAAZ,EAAmBW,CAAnB,EAAsByH,GAAtB,CAAlB;;AAEA;AACA,UAAIhE,WAAJ,EAAiB;AACf;AACA,YAAIC,UAAU,iBAAIrE,KAAJ,EAAWW,CAAX,EAAcyH,GAAd,CAAd;;AAEA;AACA,+BAAWvF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB4C,EAAzB,EAA6Bc,OAA7B,EAAsC,IAAtC;AACD,OAND,MAMO;AACL;AACA;AACA,+BAAWC,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE4B,EAAtE;AACD;;AAED;AACArB;AACD;;AAED;AACA,2BAAWoC,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE,uBAAgB3B,KAAhB,EAAuBmC,MAAM,CAAN,GAAU,EAAjC,CAAtE;;AAEA;AACA,2BAAWU,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBX,KAAhB,EAAuBmC,MAAM,CAA7B,CAAnC,EAAoE,IAApE;;AAEA;AACA,WAAOgG,KAAP;AACD,GAvED;;AAyEA;AACAlI,MAAIM,kBAAJ,CAAuB,OAAvB,EAAgC,CAAhC,EAAmC,CAACC,OAAD,EAAU,CAACyC,KAAD,EAAQC,GAAR,CAAV,KAA2B;AAC5D;AACA,QAAIvC,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,OAAlB,MAA+BC,SAHjC,EAIE;AACA,UAAIC,UAAU,CAACN,CAAD,EAAIsC,KAAJ,EAAWC,GAAX,CAAd;AACA,aAAO,kBAAWhC,wCAAX,CAAoDlB,KAApD,EAA2DiB,OAA3D,EAAoE,CAAC,CAACE,OAAD,EAAU,GAAGC,KAAb,CAAD,KACzEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,OAAb,CAA5B,CAAjB,EAAuEJ,KAAvE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI+C,gBAAgB,eAAGJ,SAAH,CAAatD,KAAb,EAAoBiD,KAApB,CAApB;;AAEA;AACA,QAAIf,IAAIwB,gBAAgB,CAAhB,GAAoBrB,KAAKmB,GAAL,CAASrB,MAAMuB,aAAf,EAA8B,CAA9B,CAApB,GAAuDrB,KAAKoB,GAAL,CAASC,aAAT,EAAwBvB,GAAxB,CAA/D;;AAEA;AACA,QAAIyB,cAAc,CAACV,GAAD,IAAQA,oCAAR,GAAwCf,GAAxC,GAA8C,eAAGmB,SAAH,CAAatD,KAAb,EAAoBkD,IAAIW,kBAAJ,EAApB,CAAhE;;AAEA;AACA,QAAIC,QAAQF,cAAc,CAAd,GAAkBvB,KAAKmB,GAAL,CAASrB,MAAMyB,WAAf,EAA4B,CAA5B,CAAlB,GAAmDvB,KAAKoB,GAAL,CAASG,WAAT,EAAsBzB,GAAtB,CAA/D;;AAEA;AACA,QAAI4B,QAAQ1B,KAAKmB,GAAL,CAASM,QAAQ5B,CAAjB,EAAoB,CAApB,CAAZ;;AAEA;AACA,QAAIT,IAAI,mBAAOC,kBAAP,CAA0B1B,KAA1B,EAAiCW,EAAEgB,wBAAF,EAAjC,EAA+DoC,KAA/D,CAAR;;AAEA;AACA,QAAInC,IAAI,CAAR;;AAEA;AACA,WAAOM,IAAI4B,KAAX,EAAkB;AAChB;AACA,UAAIa,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,2BAAO/B,yBAAP,CAAiC5C,KAAjC,EAAwCyB,CAAxC,EAA2C,uBAAgBzB,KAAhB,EAAuB4B,IAAI,EAA3B,CAA3C,EAA2EiD,MAA3E;AACD;;AAED;AACA3C;;AAEA;AACAN;AACD;;AAED;AACA,2BAAWiB,GAAX,CAAe7C,KAAf,EAAsByB,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBzB,KAAhB,EAAuB4B,CAAvB,CAAnC,EAA8D,IAA9D;;AAEA;AACA,WAAOH,CAAP;AACD,GApED;;AAsEA;AACAxB,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,CAACC,OAAD,EAAU,CAACgE,UAAD,EAAaC,OAAb,CAAV,KAAoC;AACpE;AACA,QAAI9D,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI6D,UAAJ,CAAX;AACA,UAAIC,OAAJ,EAAa;AACXhE,aAAK0C,IAAL,CAAUsB,OAAV;AACD;AACD,aAAO,qBAAcrB,+BAAd,CAA8CpD,KAA9C,uBAAmES,IAAnE,EAAyE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC9EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAsEJ,KAAtE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI,CAAC,wBAAWX,KAAX,EAAkBwE,UAAlB,CAAL,EAAoC;AAClC,YAAMxE,MAAMuC,0BAAN,CACJvC,MAAMG,UAAN,CAAiBqC,SADb,EAEJ,wDAFI,CAAN;AAID;;AAED;AACA,QAAIkC,IAAID,WAAWzE,MAAMG,UAAN,CAAiBa,SAApC;;AAEA;AACA,QAAIkB,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIwC,KAAK,uBAAgB3E,KAAhB,EAAuBkC,IAAI,EAA3B,CAAT;;AAEA;AACA,UAAI0C,WAAW,yBAAY5E,KAAZ,EAAmBW,CAAnB,EAAsBgE,EAAtB,CAAf;;AAEA;AACA,UAAIC,QAAJ,EAAc;AACZ;AACA,YAAIC,SAAS,iBAAI7E,KAAJ,EAAWW,CAAX,EAAcgE,EAAd,CAAb;;AAEA;AACA,YAAIG,aAAa,eAAGC,gBAAH,CAAoB/E,KAApB,EAA2B,kBAAKA,KAAL,EAAYwE,UAAZ,EAAwBE,CAAxB,EAA2B,CAACG,MAAD,EAAS,uBAAgB7E,KAAhB,EAAuBkC,CAAvB,CAAT,EAAoCvB,CAApC,CAA3B,CAA3B,CAAjB;;AAEA;AACA,YAAImE,UAAJ,EAAgB,OAAO9E,MAAMG,UAAN,CAAiB8E,IAAxB;AACjB;;AAED;AACA/C;AACD;;AAED;AACA,WAAOlC,MAAMG,UAAN,CAAiB6E,KAAxB;AACD,GAhED;;AAkEA;AACA/E,MAAIM,kBAAJ,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,CAACC,OAAD,EAAU,CAAC6H,SAAD,CAAV,KAA0B;AAC1D;AACA,QAAI1H,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,MAAlB,MAA8BC,SAHhC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAI0H,SAAJ,CAAX;AACA,2BAAcjF,+BAAd,CAA8CpD,KAA9C,gBAA4DS,IAA5D,EAAkE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAChEC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,MAAb,CAA5B,CAAjB,EAAsEJ,KAAtE,CADF;AAGA;AACA;AACA,aAAOZ,OAAP;AACD;;AAED;AACA,QAAI2B,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI2H,WAAW,MAAM;AACnB;AACA,WAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIpG,GAApB,EAAyBoG,GAAzB,EAA8B;AAC5B;AACA,YAAIC,OAAO7H,EAAEI,eAAF,CAAkBwH,EAAEE,QAAF,EAAlB,CAAX;AACA;AACA,YAAID,SAASxH,SAAb,EAAwB,OAAO,IAAP;AACxB,+BAAW0H,2BAAX,CAAuCF,KAAKtD,KAA5C;AACD;AACD;AACA,aAAO,KAAP;AACD,KAXD;AAYA,QAAIyD,SAASL,UAAb;;AAEA;AACA,QAAIM,QAAQjI,EAAEkI,eAAF,EAAZ;;AAEA;AACA,QAAI,EAAED,iCAAF,CAAJ,EAAmC;AACjC;AACA,WAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAI3G,GAApB,EAAyB2G,GAAzB,EAA8B;AAC5B;AACA,YACE,yBAAY9I,KAAZ,EAAmB4I,KAAnB,EAA0BE,EAAEL,QAAF,EAA1B;AACA;AACAE,cAHF;AAKE;AACA,gBAAMI,MAAM,wCAAN,CAAN;AACH;AACF;;AAED;AACA,QAAIJ,MAAJ,EAAY;AACV;AACA,UAAI,CAAC,0BAAa3I,KAAb,EAAoBW,CAApB,CAAL,EAA6B,MAAMoI,MAAM,sEAAN,CAAN;AAC7B;AACA,WAAK,IAAID,IAAI,CAAb,EAAgBA,IAAI3G,GAApB,EAAyB2G,GAAzB,EAA8B;AAC5B;AACA,YAAIE,OAAOrI,EAAEI,eAAF,CAAkB+H,EAAEL,QAAF,EAAlB,CAAX;AACA,YAAIO,SAAShI,SAAT,IAAsB,CAACgI,KAAKC,YAAhC,EAA8C;AAC5C,iCAAWP,2BAAX,CAAuCM,KAAK9D,KAA5C;AACA,gBAAM6D,MACJ,oGADI,CAAN;AAGD;AACF;AACF;;AAED;AACA,SAAK,IAAID,IAAI,CAAb,EAAgBA,IAAI3G,GAApB,EAAyB2G,GAAzB,EAA8B;AAC5B;AACA,UAAIE,OAAOrI,EAAEI,eAAF,CAAkB+H,EAAEL,QAAF,EAAlB,CAAX;AACA,UAAIO,SAAShI,SAAT,IAAsB,CAACgI,KAAKE,QAAhC,EAA0C;AACxC,+BAAWR,2BAAX,CAAuCM,KAAK9D,KAA5C;AACA,cAAM6D,MAAM,gDAAgDD,EAAEL,QAAF,EAAhD,GAA+D,oBAArE,CAAN;AACD;AACF;;AAED;AACA;;AAEA;AACA,QAAIU,cAAc,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAC1BD,UAAIA,EAAEvF,kBAAF,EAAJ;AACAwF,UAAIA,EAAExF,kBAAF,EAAJ;AACA;AACA,UAAIuF,sCAA+BC,kCAAnC,EAAgE;AAC9D,eAAOrJ,MAAMG,UAAN,CAAiBG,IAAxB;AACD;AACD;AACA,UAAI8I,kCAAJ,EAAiC;AAC/B,eAAO,uBAAgBpJ,KAAhB,EAAuB,CAAvB,CAAP;AACD;AACD;AACA,UAAIqJ,kCAAJ,EAAiC;AAC/B,eAAO,uBAAgBrJ,KAAhB,EAAuB,CAAC,CAAxB,CAAP;AACD;AACD;AACA,UAAI,CAACqI,UAAUiB,gBAAV,EAAL,EAAmC;AACjC;AACA,YAAIxC,IAAI,eAAGyC,QAAH,CAAYvJ,KAAZ,EAAmB,kBAAKA,KAAL,EAAYqI,SAAZ,EAAuB,0BAAmBrI,KAAnB,CAAvB,EAAkD,CAACoJ,CAAD,EAAIC,CAAJ,CAAlD,CAAnB,CAAR;AACA;AACA,YAAIG,MAAM1C,CAAN,CAAJ,EAAc,OAAO,uBAAgB9G,KAAhB,EAAuB,CAAC,CAAxB,CAAP;AACd;AACA,eAAO,uBAAgBA,KAAhB,EAAuB8G,CAAvB,CAAP;AACD,OAPD,MAOO;AACLuB,kBAAUxE,kBAAV;AACD;AACD;AACA,UAAI4F,UAAU,uBAAgBzJ,KAAhB,EAAuB,eAAGkE,QAAH,CAAYlE,KAAZ,EAAmBoJ,CAAnB,CAAvB,CAAd;AACA;AACA,UAAIM,UAAU,uBAAgB1J,KAAhB,EAAuB,eAAGkE,QAAH,CAAYlE,KAAZ,EAAmBqJ,CAAnB,CAAvB,CAAd;AACA;AACA,UAAIM,WAAW,4CAA6B3J,KAA7B,EAAoCyJ,OAApC,EAA6CC,OAA7C,EAAsD,IAAtD,EAA4D,GAA5D,CAAf;AACA;AACA,UAAIC,SAASzE,KAAb,EAAoB,OAAO,uBAAgBlF,KAAhB,EAAuB,CAAC,CAAxB,CAAP;AACpB;AACA,UAAI4J,WAAW,4CAA6B5J,KAA7B,EAAoC0J,OAApC,EAA6CD,OAA7C,EAAsD,IAAtD,EAA4D,GAA5D,CAAf;AACA;AACA,UAAIG,SAAS1E,KAAb,EAAoB,OAAO,uBAAgBlF,KAAhB,EAAuB,CAAvB,CAAP;AACpB;AACA,aAAOA,MAAMG,UAAN,CAAiBG,IAAxB;AACD,KAxCD;;AA0CA;AACA;;AAEA;AACA;;AAEA,QAAIuJ,MAAM,EAAV;;AAEA;AACA,QAAIC,aAAa,CAACV,CAAD,EAAIC,CAAJ,KAAU;AACzB,+BAAUD,yBAAV,EAA8B,iBAA9B;AACA,+BAAUC,yBAAV,EAA8B,iBAA9B;;AAEA,UAAIU,UAAUZ,YAAYC,CAAZ,EAAeC,CAAf,CAAd;AACA,UAAIW,OAAO,eAAGT,QAAH,CAAYvJ,KAAZ,EAAmB+J,OAAnB,CAAX;AACA,aAAOC,IAAP;AACD,KAPD;;AASA,SAAK,IAAIlB,IAAI,CAAb,EAAgBA,IAAI3G,GAApB,EAAyB2G,GAAzB,EAA8B;AAC5B;AACA,UAAI,CAAC,4BAAe9I,KAAf,EAAsBW,CAAtB,EAAyBmI,EAAEL,QAAF,EAAzB,CAAL,EAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAIvB,MAAMvG,EAAEsJ,IAAF,CAAOnB,EAAEL,QAAF,EAAP,EAAqB9H,CAArB,CAAV;AACAkJ,UAAIf,CAAJ,IAAS5B,GAAT;AACD;;AAED2C,QAAIK,IAAJ,CAASJ,UAAT;;AAEA;AACA,SAAK,IAAIhB,IAAI,CAAb,EAAgBA,IAAI3G,GAApB,EAAyB2G,GAAzB,EAA8B;AAC5B,UAAIe,IAAIM,cAAJ,CAAmBrB,EAAEL,QAAF,EAAnB,CAAJ,EAAsC;AACpC,YAAI2B,KAAKzJ,EAAE0J,IAAF,CAAOvB,EAAEL,QAAF,EAAP,EAAqBoB,IAAIf,CAAJ,CAArB,EAA6BnI,CAA7B,CAAT;AACA;AACA,YAAI,CAACyJ,EAAL,EAAS,MAAMpK,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,wBAA7D,CAAN;AACV,OAJD,MAIO;AACL;AACA,iCAAUmG,MAAV;AACA,+BAAWrE,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsEmH,EAAEL,QAAF,EAAtE;AACD;AACF;AACD;;AAEA;AACA,WAAOjI,OAAP;AACD,GApLD;;AAsLA;AACAP,MAAIM,kBAAJ,CAAuB,QAAvB,EAAiC,CAAjC,EAAoC,CAACC,OAAD,EAAU,CAACyC,KAAD,EAAQqH,WAAR,EAAqB,GAAGzI,KAAxB,CAAV,EAA0C0I,SAA1C,KAAwD;AAC1F;AACA,QAAI5J,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,QAAlB,MAAgCC,SAHlC,EAIE;AACA,UAAIP,OAAO,CAACE,CAAD,EAAIsC,KAAJ,CAAX;AACA,UAAIqH,WAAJ,EAAiB;AACf7J,aAAK0C,IAAL,CAAUmH,WAAV;AACD;AACD,UAAIzI,SAASA,MAAMC,MAAN,GAAe,CAA5B,EAA+B;AAC7BrB,aAAK0C,IAAL,CAAU,GAAGtB,KAAb;AACD;AACD,aAAO,qBAAcuB,+BAAd,CAA8CpD,KAA9C,qBAAiES,IAAjE,EAAuE,CAAC,CAACU,OAAD,EAAU,GAAGC,KAAb,CAAD,KAC5EC,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,QAAb,CAA5B,CAAjB,EAAwEJ,KAAxE,CADK,CAAP;AAGD;;AAED;AACA,QAAIe,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACA,QAAI+C,gBAAgB,eAAGJ,SAAH,CAAatD,KAAb,EAAoBiD,KAApB,CAApB;;AAEA;AACA,QAAIuH,cAAc9G,gBAAgB,CAAhB,GAAoBrB,KAAKmB,GAAL,CAASrB,MAAMuB,aAAf,EAA8B,CAA9B,CAApB,GAAuDrB,KAAKoB,GAAL,CAASC,aAAT,EAAwBvB,GAAxB,CAAzE;;AAEA,QAAIsI,WAAJ;AACA,QAAIC,iBAAJ;;AAEA;AACA,QAAIH,cAAc,CAAlB,EAAqB;AACnB;AACAE,oBAAc,CAAd;;AAEA;AACAC,0BAAoB,CAApB;AACD,KAND,MAMO,IAAIH,cAAc,CAAlB,EAAqB;AAC1B;AACA;AACAE,oBAAc,CAAd;;AAEA;AACAC,0BAAoBvI,MAAMqI,WAA1B;AACD,KAPM,MAOA;AACL;AACA;AACAC,oBAAcF,YAAY,CAA1B;;AAEA;AACA,UAAII,KAAK,eAAGrH,SAAH,CAAatD,KAAb,EAAoBsK,WAApB,CAAT;;AAEA;AACAI,0BAAoBrI,KAAKoB,GAAL,CAASpB,KAAKmB,GAAL,CAASmH,EAAT,EAAa,CAAb,CAAT,EAA0BxI,MAAMqI,WAAhC,CAApB;AACD;;AAED;AACA,QAAIrI,MAAMsI,WAAN,GAAoBC,iBAApB,GAAwCrI,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAA9D,EAAiE;AAC/D,YAAMtC,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,iCAA7D,CAAN;AACD;;AAED;AACA,QAAIf,IAAI,mBAAOC,kBAAP,CAA0B1B,KAA1B,EAAiCW,EAAEgB,wBAAF,EAAjC,EAA+D+I,iBAA/D,CAAR;;AAEA;AACA,QAAIxI,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIwI,iBAAX,EAA8B;AAC5B;AACA,UAAItC,MAAM,uBAAgBpI,KAAhB,EAAuBwK,cAActI,CAAd,GAAkB,EAAzC,CAAV;;AAEA;AACA,UAAIkC,cAAc,yBAAYpE,KAAZ,EAAmBW,CAAnB,EAAsByH,GAAtB,CAAlB;;AAEA;AACA,UAAIhE,WAAJ,EAAiB;AACf;AACA,YAAIwG,YAAY,iBAAI5K,KAAJ,EAAWW,CAAX,EAAcyH,GAAd,CAAhB;;AAEA;AACA,2BAAOxF,yBAAP,CAAiC5C,KAAjC,EAAwCyB,CAAxC,EAA2C,uBAAgBzB,KAAhB,EAAuBkC,IAAI,EAA3B,CAA3C,EAA2E0I,SAA3E;AACD;;AAED;AACA1I;AACD;;AAED;AACA,2BAAWW,GAAX,CAAe7C,KAAf,EAAsByB,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBzB,KAAhB,EAAuB0K,iBAAvB,CAAnC,EAA8E,IAA9E;;AAEA;AACA;AACA7I;;AAEA;AACA,QAAIgJ,YAAYhJ,MAAMC,MAAtB;;AAEA;AACA,QAAI+I,YAAYH,iBAAhB,EAAmC;AACjC;AACAxI,UAAIsI,WAAJ;;AAEA;AACA,aAAOtI,IAAIC,MAAMuI,iBAAjB,EAAoC;AAClC;AACA,YAAItC,MAAM,uBAAgBpI,KAAhB,EAAuBkC,IAAIwI,iBAAJ,GAAwB,EAA/C,CAAV;;AAEA;AACA,YAAInH,KAAK,uBAAgBvD,KAAhB,EAAuBkC,IAAI2I,SAAJ,GAAgB,EAAvC,CAAT;;AAEA;AACA,YAAIzG,cAAc,yBAAYpE,KAAZ,EAAmBW,CAAnB,EAAsByH,GAAtB,CAAlB;;AAEA;AACA,YAAIhE,WAAJ,EAAiB;AACf;AACA,cAAIwG,YAAY,iBAAI5K,KAAJ,EAAWW,CAAX,EAAcyH,GAAd,CAAhB;;AAEA;AACA,iCAAWvF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB4C,EAAzB,EAA6BqH,SAA7B,EAAwC,IAAxC;AACD,SAND,MAMO;AACL;AACA;AACA,iCAAWtG,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE4B,EAAtE;AACD;;AAED;AACArB;AACD;;AAED;AACAA,UAAIC,GAAJ;;AAEA;AACA,aAAOD,IAAIC,MAAMuI,iBAAN,GAA0BG,SAArC,EAAgD;AAC9C;AACA,+BAAWvG,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE,uBAAgB3B,KAAhB,EAAuBkC,IAAI,CAAJ,GAAQ,EAA/B,CAAtE;;AAEA;AACAA;AACD;AACF,KA3CD,MA2CO,IAAI2I,YAAYH,iBAAhB,EAAmC;AACxC;AACA;AACAxI,UAAIC,MAAMuI,iBAAV;;AAEA;AACA,aAAOxI,IAAIsI,WAAX,EAAwB;AACtB;AACA,YAAIpC,MAAM,uBAAgBpI,KAAhB,EAAuBkC,IAAIwI,iBAAJ,GAAwB,CAAxB,GAA4B,EAAnD,CAAV;;AAEA;AACA,YAAInH,KAAK,uBAAgBvD,KAAhB,EAAuBkC,IAAI2I,SAAJ,GAAgB,CAAhB,GAAoB,EAA3C,CAAT;;AAEA;AACA,YAAIzG,cAAc,yBAAYpE,KAAZ,EAAmBW,CAAnB,EAAsByH,GAAtB,CAAlB;;AAEA;AACA,YAAIhE,WAAJ,EAAiB;AACf;AACA,cAAIwG,YAAY,iBAAI5K,KAAJ,EAAWW,CAAX,EAAcyH,GAAd,CAAhB;;AAEA;AACA,iCAAWvF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB4C,EAAzB,EAA6BqH,SAA7B,EAAwC,IAAxC;AACD,SAND,MAMO;AACL;AACA;AACA,iCAAWtG,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE4B,EAAtE;AACD;;AAED;AACArB;AACD;AACF;;AAED;AACAA,QAAIsI,WAAJ;;AAEA;AACA,WAAO3I,MAAMC,MAAb,EAAqB;AACnB;AACA,UAAIC,IAAIF,MAAMG,KAAN,EAAR;;AAEA;AACA,6BAAWa,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,uBAAgBX,KAAhB,EAAuBkC,IAAI,EAA3B,CAAzB,EAAyDH,CAAzD,EAA4D,IAA5D;;AAEA;AACAG;AACD;;AAED;AACA,2BAAWW,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBX,KAAhB,EAAuBmC,MAAMuI,iBAAN,GAA0BG,SAAjD,CAAnC,EAAgG,IAAhG;;AAEA;AACA,WAAOpJ,CAAP;AACD,GA1MD;;AA4MA;AACAxB,MAAIM,kBAAJ,CAAuB,gBAAvB,EAAyC,CAAzC,EAA4CC,WAAW;AACrD;AACA,QAAIsK,QAAQ,eAAGlK,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAZ;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDiK,KAAnD,KACA9K,MAAMc,aAAN,EADA,IAEAgK,MAAM/J,eAAN,CAAsB,gBAAtB,MAA4CC,SAH9C,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,sBAAkE,CAAC8K,KAAD,CAAlE,EAA2E,CAAC,CAAC3J,OAAD,CAAD,KAChFE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,gBAAb,CAA5B,CAAjB,EAA8E,EAA9E,CADK,CAAP;AAGD;;AAED;AACA,QAAIW,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAW8K,KAAX,EAAkB,QAAlB,CAAnB,CAAV;;AAEA;AACA;AACA,QAAIjF,YAAY,GAAhB;;AAEA;AACA,QAAI1D,QAAQ,CAAZ,EAAe,OAAOnC,MAAMG,UAAN,CAAiB6F,WAAxB;;AAEf;AACA,QAAI+E,eAAe,iBAAI/K,KAAJ,EAAW8K,KAAX,EAAkB,GAAlB,CAAnB;;AAEA;AACA,QAAI5E,CAAJ;AACA,QAAI,mCAAsB6E,YAAtB,0CAAJ,EAAoE;AAClE;AACA7E,UAAI,EAAJ;AACD,KAHD,MAGO;AACL;AACA;AACAA,UAAI,eAAGH,eAAH,CAAmB/F,KAAnB,EAA0B,oBAAOA,KAAP,EAAc+K,YAAd,EAA4B,gBAA5B,CAA1B,CAAJ;AACD;;AAED;AACA,QAAI7I,IAAI,CAAR;;AAEA;AACA,WAAOA,IAAIC,GAAX,EAAgB;AACd;AACA,UAAIgE,IAAYD,IAAIL,SAApB;;AAEA;AACA,UAAImF,cAAc,iBAAIhL,KAAJ,EAAW8K,KAAX,EAAkB,uBAAgB9K,KAAhB,EAAuBkC,IAAI,EAA3B,CAAlB,EAAkD2B,kBAAlD,EAAlB;;AAEA;AACA,UAAI,mCAAsBmH,WAAtB,0CAAJ,EAAmE;AACjE;AACA9E,YAAI,EAAJ;AACD,OAHD,MAGO;AACL;AACA;AACAA,YAAI,eAAGH,eAAH,CAAmB/F,KAAnB,EAA0B,oBAAOA,KAAP,EAAcgL,WAAd,EAA2B,gBAA3B,CAA1B,CAAJ;AACD;;AAED;AACA9E,UAAIC,IAAID,CAAR;;AAEA;AACAhE;AACD;;AAED;AACA,WAAO,uBAAgBlC,KAAhB,EAAuBkG,CAAvB,CAAP;AACD,GAvED;;AAyEA;AACAjG,MAAIC,oBAAJ,CAAyB,UAAzB,EAAqCF,MAAMG,UAAN,CAAiB8K,mBAAtD;;AAEA;AACAhL,MAAIM,kBAAJ,CAAuB,SAAvB,EAAkC,CAAlC,EAAqC,CAACC,OAAD,EAAUqB,KAAV,EAAiBnB,QAAjB,KAA8B;AACjE;AACA,QAAIC,IAAI,eAAGC,QAAH,CAAYZ,KAAZ,EAAmBQ,OAAnB,CAAR;;AAEA;AACA;AACA;AACA,QACE,kBAAWK,uCAAX,CAAmDF,CAAnD,KACAX,MAAMc,aAAN,EADA,IAEAH,EAAEI,eAAF,CAAkB,SAAlB,MAAiCC,SAHnC,EAIE;AACA,aAAO,qBAAcoC,+BAAd,CAA8CpD,KAA9C,sBAAkE,CAACW,CAAD,CAAlE,EAAuE,CAAC,CAACQ,OAAD,CAAD,KAC5EE,EAAEC,cAAF,CAAiBD,EAAEE,gBAAF,CAAmBJ,OAAnB,EAA4BE,EAAEG,UAAF,CAAa,SAAb,CAA5B,CAAjB,EAAuE,EAAvE,CADK,CAAP;AAGD;;AAED;AACA,QAAIW,MAAM,eAAGC,QAAH,CAAYpC,KAAZ,EAAmB,iBAAIA,KAAJ,EAAWW,CAAX,EAAc,QAAd,CAAnB,CAAV;;AAEA;AACAD;;AAEA;AACA,QAAIA,WAAW,CAAf,EAAkB;AAChB;AACA,UAAIyB,MAAMzB,QAAN,GAAiB2B,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAvC,EAA0C;AACxC,cAAMtC,MAAMuC,0BAAN,CAAiCvC,MAAMG,UAAN,CAAiBqC,SAAlD,EAA6D,eAA7D,CAAN;AACD;;AAED;AACA,UAAIN,IAAIC,GAAR;;AAEA;AACA,aAAOD,IAAI,CAAX,EAAc;AACZ;AACA,YAAIkG,MAAM,uBAAgBpI,KAAhB,EAAuBkC,IAAI,CAAJ,GAAQ,EAA/B,CAAV;;AAEA;AACA,YAAIqB,KAAK,uBAAgBvD,KAAhB,EAAuBkC,IAAIxB,QAAJ,GAAe,CAAf,GAAmB,EAA1C,CAAT;;AAEA;AACA,YAAI0D,cAAc,yBAAYpE,KAAZ,EAAmBW,CAAnB,EAAsByH,GAAtB,CAAlB;;AAEA;AACA,YAAIhE,WAAJ,EAAiB;AACf;AACA,cAAIwG,YAAY,iBAAI5K,KAAJ,EAAWW,CAAX,EAAcyH,GAAd,CAAhB;;AAEA;AACA,iCAAWvF,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB4C,EAAzB,EAA6BqH,SAA7B,EAAwC,IAAxC;AACD,SAND,MAMO;AACL;AACA;AACA,iCAAWtG,qBAAX,CAAiCtE,KAAjC,EAAwCW,EAAEgB,wBAAF,EAAxC,EAAsE4B,EAAtE;AACD;;AAED;AACArB;AACD;;AAED;AACA,UAAI4G,IAAI,CAAR;;AAEA;AACA;AACAjH;;AAEA;AACA,aAAOA,MAAMC,MAAb,EAAqB;AACnB;AACA,YAAIC,IAAIF,MAAMG,KAAN,EAAR;;AAEA;AACA,+BAAWa,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,uBAAgBX,KAAhB,EAAuB8I,IAAI,EAA3B,CAAzB,EAAyD/G,CAAzD,EAA4D,IAA5D;;AAEA;AACA+G;AACD;AACF;;AAED;AACA,2BAAWjG,GAAX,CAAe7C,KAAf,EAAsBW,CAAtB,EAAyB,QAAzB,EAAmC,uBAAgBX,KAAhB,EAAuBmC,MAAMzB,QAA7B,CAAnC,EAA2E,IAA3E;;AAEA;AACA,WAAO,uBAAgBV,KAAhB,EAAuBmC,MAAMzB,QAA7B,CAAP;AACD,GAtFD;;AAwFA;AACAT,MAAIC,oBAAJ,CAAyB,QAAzB,EAAmCF,MAAMG,UAAN,CAAiBE,iBAApD;;AAEA;AACA;AACE;AACA,QAAI6K,iBAAiB,mBAAOC,YAAP,CAAoBnL,KAApB,EAA2BA,MAAMG,UAAN,CAAiBiL,IAA5C,CAArB;;AAEA;AACA,uBAAOC,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,YAAjD,EAA+DlL,MAAMG,UAAN,CAAiB8E,IAAhF;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,SAAjD,EAA4DlL,MAAMG,UAAN,CAAiB8E,IAA7E;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,MAAjD,EAAyDlL,MAAMG,UAAN,CAAiB8E,IAA1E;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,MAAjD,EAAyDlL,MAAMG,UAAN,CAAiB8E,IAA1E;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,WAAjD,EAA8DlL,MAAMG,UAAN,CAAiB8E,IAA/E;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,UAAjD,EAA6DlL,MAAMG,UAAN,CAAiB8E,IAA9E;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,MAAjD,EAAyDlL,MAAMG,UAAN,CAAiB8E,IAA1E;;AAEA;AACA,uBAAOoG,kBAAP,CAA0BrL,KAA1B,EAAiCkL,cAAjC,EAAiD,QAAjD,EAA2DlL,MAAMG,UAAN,CAAiB8E,IAA5E;;AAEA;;AAEA;AACAhF,QAAIC,oBAAJ,CAAyBF,MAAMG,UAAN,CAAiBmL,iBAA1C,EAA6DJ,cAA7D,EAA6E;AAC3EhC,gBAAU;AADiE,KAA7E;AAGD;AACF,C;;AA1rED;;AAYA;;;;AACA;;IAAY7H,C;;AACZ;;AACA;;AAYA","file":"ArrayPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../../values/index.js\";\nimport invariant from \"../../invariant.js\";\nimport * as t from \"babel-types\";\nimport { SameValueZeroPartial, AbstractRelationalComparison } from \"../../methods/abstract.js\";\nimport {\n  StrictEqualityComparisonPartial,\n  IsCallable,\n  IsConcatSpreadable,\n  IsExtensible,\n  HasOwnProperty,\n  HasProperty,\n  Call,\n  Invoke,\n  Get,\n  HasSomeCompatibleType,\n} from \"../../methods/index.js\";\nimport { Create, Join, Properties, To } from \"../../singletons.js\";\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 22.1.3.31\n  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.ArrayProto_values);\n\n  // ECMA262 22.1.3\n  obj.defineNativeProperty(\"length\", realm.intrinsics.zero);\n\n  // ECMA262 22.1.3.1\n  obj.defineNativeMethod(\"concat\", 1, (context, args, argCount) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"concat\") === undefined\n    ) {\n      let newArgs = [O, ...args];\n      return ArrayValue.createTemporalWithWidenedNumericProperty(realm, newArgs, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"concat\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let A be ? ArraySpeciesCreate(O, 0).\n    let A = Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. Let items be a List whose first element is O and whose subsequent elements are, in left to right\n    //    order, the arguments that were passed to this function invocation.\n    let items = argCount === 0 ? [O] : [O, ...args];\n\n    // 5. Repeat, while items is not empty\n    while (items.length) {\n      // a. Remove the first element from items and let E be the value of the element.\n      let E = items.shift();\n\n      // b. Let spreadable be ? IsConcatSpreadable(E).\n      let spreadable = IsConcatSpreadable(realm, E);\n\n      // c. If spreadable is true, then\n      if (spreadable) {\n        E = E.throwIfNotConcreteObject();\n\n        // i. Let k be 0.\n        let k = 0;\n\n        // ii. Let len be ? ToLength(? Get(E, \"length\")).\n        let len = To.ToLength(realm, Get(realm, E, \"length\"));\n\n        // ii. If n + len > 2^53-1, throw a TypeError exception.\n        if (n + len > Math.pow(2, 53) - 1) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"too damn high\");\n        }\n\n        // iv. Repeat, while k < len\n        while (k < len) {\n          // 1. Let P be ! ToString(k).\n          let P = new StringValue(realm, k + \"\");\n\n          // 2. Let exists be ? HasProperty(E, P).\n          let exists = HasProperty(realm, E, P);\n\n          // 3. If exists is true, then\n          if (exists) {\n            // a. Let subElement be ? Get(E, P).\n            let subElement = Get(realm, E, P);\n\n            // b. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), subElement).\n            Create.CreateDataPropertyOrThrow(realm, A, new StringValue(realm, n + \"\"), subElement);\n          }\n\n          // 4. Increase n by 1.\n          n++;\n\n          // 5. Increase k by 1.\n          k++;\n        }\n      } else {\n        // d. Else E is added as a single item rather than spread,\n        // i. If n≥2^53-1, throw a TypeError exception.\n        if (n > Math.pow(2, 53) - 1) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"too damn high\");\n        }\n\n        // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), E).\n        Create.CreateDataPropertyOrThrow(realm, A, new StringValue(realm, n + \"\"), E);\n\n        // iii. Increase n by 1.\n        n++;\n      }\n    }\n\n    // 6. Perform ? Set(A, \"length\", n, true).\n    Properties.Set(realm, A, \"length\", new NumberValue(realm, n), true);\n\n    // 7. Return A.\n    return A;\n  });\n\n  // ECMA262 22.1.3.3\n  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith(\"mobile\"))\n    obj.defineNativeMethod(\"copyWithin\", 2, (context, [target, start, end]) => {\n      // 1. Let O be ? ToObject(this value).\n      let O = To.ToObject(realm, context);\n\n      // If we have an object that is an unknown array with numeric properties, then\n      // we can return a temporal here as we know nothing of the array's properties.\n      // This should be safe to do, as we never expose the internals of the array.\n      if (\n        ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n        realm.isInPureScope() &&\n        O.$GetOwnProperty(\"copyWithin\") === undefined\n      ) {\n        let args = [O, target];\n        if (start) {\n          args.push(start);\n        }\n        if (end) {\n          args.push(end);\n        }\n        AbstractValue.createTemporalFromBuildFunction(realm, BooleanValue, args, ([objNode, ..._args]) =>\n          t.callExpression(t.memberExpression(objNode, t.identifier(\"copyWithin\")), ((_args: any): Array<any>))\n        );\n        return O;\n      }\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n      // 3. Let relativeTarget be ? ToInteger(target).\n      let relativeTarget = To.ToInteger(realm, target);\n\n      // 4. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).\n      let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);\n\n      // 5. Let relativeStart be ? ToInteger(start).\n      let relativeStart = To.ToInteger(realm, start);\n\n      // 6. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).\n      let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n      // 7. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n      let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n      // 8. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n      let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n      // 9. Let count be min(final-from, len-to).\n      let count = Math.min(final - from, len - to);\n\n      let direction;\n      // 10. If from<to and to<from+count, then\n      if (from < to && to < from + count) {\n        // a. Let direction be -1.\n        direction = -1;\n\n        // b. Let from be from + count - 1.\n        from = from + count - 1;\n\n        // c. Let to be to + count - 1.\n        to = to + count - 1;\n      } else {\n        // 11. Else,\n        // a. Let direction be 1.\n        direction = 1;\n      }\n\n      // 12. Repeat, while count > 0\n      while (count > 0) {\n        // a. Let fromKey be ! ToString(from).\n        let fromKey = To.ToString(realm, new NumberValue(realm, from));\n\n        // b. Let toKey be ! ToString(to).\n        let toKey = To.ToString(realm, new NumberValue(realm, to));\n\n        // c. Let fromPresent be ? HasProperty(O, fromKey).\n        let fromPresent = HasProperty(realm, O, fromKey);\n\n        // d. If fromPresent is true, then\n        if (fromPresent === true) {\n          // i. Let fromVal be ? Get(O, fromKey).\n          let fromVal = Get(realm, O, fromKey);\n          // ii. Perform ? Set(O, toKey, fromVal, true).\n          Properties.Set(realm, O, toKey, fromVal, true);\n        } else {\n          // e. Else fromPresent is false,\n          // i. Perform ? DeletePropertyOrThrow(O, toKey).\n          Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), toKey);\n        }\n\n        // f. Let from be from + direction.\n        from = from + direction;\n\n        // g. Let to be to + direction.\n        to = to + direction;\n\n        // h. Let count be count - 1.\n        count = count - 1;\n      }\n\n      // 13. Return O.\n      return O;\n    });\n\n  // ECMA262 22.1.3.4\n  obj.defineNativeMethod(\"entries\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"entries\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, [O], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"entries\")), [])\n      );\n    }\n\n    // 2. Return CreateArrayIterator(O, \"key+value\").\n    return Create.CreateArrayIterator(realm, O.throwIfNotConcreteObject(), \"key+value\");\n  });\n\n  // ECMA262 22.1.3.5\n  obj.defineNativeMethod(\"every\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"every\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, BooleanValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"every\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 5. Let k be 0.\n    let k = 0;\n\n    // 6. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is false, return false.\n        if (!testResult) return realm.intrinsics.false;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 7. Return true.\n    return realm.intrinsics.true;\n  });\n\n  // ECMA262 22.1.3.6\n  obj.defineNativeMethod(\"fill\", 1, (context, [value, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"fill\") === undefined\n    ) {\n      let args = [O, value];\n      if (start) {\n        args.push(start);\n      }\n      if (end) {\n        args.push(end);\n      }\n      AbstractValue.createTemporalFromBuildFunction(realm, Value, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"fill\")), ((_args: any): Array<any>))\n      );\n      return O;\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start || realm.intrinsics.undefined);\n\n    // 4. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 5. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 7. Repeat, while k < final\n    while (k < final) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Perform ? Set(O, Pk, value, true).\n      Properties.Set(realm, O, Pk, value, true);\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return O.\n    return O;\n  });\n\n  // ECMA262 22.1.3.7\n  obj.defineNativeMethod(\"filter\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"filter\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      return ArrayValue.createTemporalWithWidenedNumericProperty(\n        realm,\n        args,\n        ([objNode, ..._args]) =>\n          t.callExpression(t.memberExpression(objNode, t.identifier(\"filter\")), ((_args: any): Array<any>)),\n        { func: callbackfn, thisVal: thisArg }\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 5. Let A be ? ArraySpeciesCreate(O, 0).\n    let A = Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), 0);\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Let to be 0.\n    let to = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let selected = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If selected is true, then\n        if (selected) {\n          // 1. Perform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue).\n          Create.CreateDataPropertyOrThrow(realm, A, To.ToString(realm, new NumberValue(realm, to)), kValue);\n\n          // 2. Increase to by 1.\n          to++;\n        }\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return A.\n    return A;\n  });\n\n  // ECMA262 22.1.3.8\n  obj.defineNativeMethod(\"find\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"find\") === undefined\n    ) {\n      let args = [O, predicate];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"find\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (!IsCallable(realm, predicate)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 5. Let k be 0.\n    let k = 0;\n\n    // 6. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = To.ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return kValue.\n      if (testResult) return kValue;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 7. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.1.3.9\n  obj.defineNativeMethod(\"findIndex\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"findIndex\") === undefined\n    ) {\n      let args = [O, predicate];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, NumberValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"findIndex\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (IsCallable(realm, predicate) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 5. Let k be 0.\n    let k = 0;\n\n    // 6. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, new StringValue(realm, Pk));\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = To.ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return k.\n      if (testResult === true) return new NumberValue(realm, k);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 7. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.1.3.10\n  obj.defineNativeMethod(\"forEach\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"forEach\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      AbstractValue.createTemporalFromBuildFunction(realm, BooleanValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"forEach\")), ((_args: any): Array<any>))\n      );\n      return realm.intrinsics.undefined;\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 5. Let k be 0.\n    let k = 0;\n\n    // 6. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! To.ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Perform ? Call(callbackfn, T, « kValue, k, O »).\n        Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 7. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.1.3.11\n  if (!realm.isCompatibleWith(realm.MOBILE_JSC_VERSION) && !realm.isCompatibleWith(\"mobile\"))\n    obj.defineNativeMethod(\"includes\", 1, (context, [searchElement, fromIndex]) => {\n      // 1. Let O be ? ToObject(this value).\n      let O = To.ToObject(realm, context);\n\n      // If we have an object that is an unknown array with numeric properties, then\n      // we can return a temporal here as we know nothing of the array's properties.\n      // This should be safe to do, as we never expose the internals of the array.\n      if (\n        ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n        realm.isInPureScope() &&\n        O.$GetOwnProperty(\"includes\") === undefined\n      ) {\n        let args = [O, searchElement];\n        if (fromIndex) {\n          args.push(fromIndex);\n        }\n        return AbstractValue.createTemporalFromBuildFunction(realm, BooleanValue, args, ([objNode, ..._args]) =>\n          t.callExpression(t.memberExpression(objNode, t.identifier(\"includes\")), ((_args: any): Array<any>))\n        );\n      }\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n      // 3. If len is 0, return false.\n      if (len === 0) return realm.intrinsics.false;\n\n      // 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n      let n = To.ToInteger(realm, fromIndex || realm.intrinsics.undefined);\n\n      let k;\n      // 5. If n ≥ 0, then\n      if (n >= 0) {\n        // a. Let k be n.\n        k = n;\n      } else {\n        // 6. Else n < 0,\n        // a. Let k be len + n.\n        k = len + n;\n        // b. If k < 0, let k be 0.\n        if (k < 0) k = 0;\n      }\n\n      // 7. Repeat, while k < len\n      while (k < len) {\n        // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, To.ToString(realm, new NumberValue(realm, k)));\n\n        // b. If SameValueZero(searchElement, elementK) is true, return true.\n        if (SameValueZeroPartial(realm, searchElement, elementK) === true) return realm.intrinsics.true;\n\n        // c. Increase k by 1.\n        k = k + 1;\n      }\n\n      // 8. Return false.\n      return realm.intrinsics.false;\n    });\n\n  // ECMA262 22.1.3.12\n  obj.defineNativeMethod(\"indexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"indexOf\") === undefined\n    ) {\n      let args = [O, searchElement];\n      if (fromIndex) {\n        args.push(fromIndex);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, NumberValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"indexOf\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 4. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = fromIndex ? To.ToInteger(realm, fromIndex) : 0;\n\n    // 5. If n ≥ len, return -1.\n    if (n >= len) return new NumberValue(realm, -1);\n\n    // 6. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be n.\n      k = Object.is(n, -0) ? +0 : n;\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, k + \"\");\n\n      // b. If kPresent is true, then\n      if (kPresent === true) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, k + \"\");\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.1.3.13\n  obj.defineNativeMethod(\"join\", 1, (context, [separator]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"join\") === undefined\n    ) {\n      let args = [O];\n      if (separator) {\n        args.push(separator);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, StringValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"join\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If separator is undefined, let separator be the single-element String \",\".\n    if (!separator || separator instanceof UndefinedValue) separator = new StringValue(realm, \",\");\n\n    // 4. Let sep be ? ToString(separator).\n    let sep = To.ToStringPartial(realm, separator);\n\n    // 5. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 6. Let element0 be Get(O, \"0\").\n    let element0 = Get(realm, O, \"0\");\n\n    // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).\n    let R: ?string;\n    if (HasSomeCompatibleType(element0, UndefinedValue, NullValue)) {\n      R = \"\";\n    } else {\n      R = To.ToStringPartial(realm, element0);\n    }\n\n    // 8. Let k be 1.\n    let k = 1;\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be the String value produced by concatenating R and sep.\n      let S: string = R + sep;\n\n      // b. Let element be ? Get(O, ! To.ToString(k)).\n      let element = Get(realm, O, new StringValue(realm, k + \"\"));\n\n      // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).\n      let next: ?string;\n      if (HasSomeCompatibleType(element, UndefinedValue, NullValue)) {\n        next = \"\";\n      } else {\n        next = To.ToStringPartial(realm, element);\n      }\n\n      // d. Let R be a String value produced by concatenating S and next.\n      R = S + next;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return R.\n    return new StringValue(realm, R + \"\");\n  });\n\n  // ECMA262 22.1.3.14\n  obj.defineNativeMethod(\"keys\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"keys\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, [O], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"keys\")), [])\n      );\n    }\n\n    // 2. Return CreateArrayIterator(O, \"key\").\n    return Create.CreateArrayIterator(realm, O.throwIfNotConcreteObject(), \"key\");\n  });\n\n  // ECMA262 22.1.3.15\n  obj.defineNativeMethod(\"lastIndexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"lastIndexOf\") === undefined\n    ) {\n      let args = [O, searchElement];\n      if (fromIndex) {\n        args.push(fromIndex);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, NumberValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"lastIndexOf\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 4. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.\n    let n = fromIndex ? To.ToInteger(realm, fromIndex) : len - 1;\n\n    // 5. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be min(n, len - 1).\n      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);\n    } else {\n      // 6. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n    }\n\n    // 7. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, new StringValue(realm, k + \"\"));\n\n      // b. If kPresent is true, then\n      if (kPresent) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, new StringValue(realm, k + \"\"));\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Decrease k by 1.\n      k--;\n    }\n\n    // 8. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.1.3.16\n  obj.defineNativeMethod(\"map\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"map\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      return ArrayValue.createTemporalWithWidenedNumericProperty(\n        realm,\n        args,\n        ([objNode, ..._args]) =>\n          t.callExpression(t.memberExpression(objNode, t.identifier(\"map\")), ((_args: any): Array<any>)),\n        { func: callbackfn, thisVal: thisArg }\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let lenVal = Get(realm, O, \"length\");\n    if (lenVal instanceof AbstractValue && !lenVal.mightNotBeNumber() && !lenVal.values.isTop()) {\n      let values = lenVal.values.getElements();\n      let n = values.size;\n      if (n > 1 && n < 10) {\n        let a = Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), 0);\n        return Join.mapAndJoin(\n          realm,\n          values,\n          v => AbstractValue.createFromBinaryOp(realm, \"===\", v, lenVal, lenVal.expressionLocation),\n          v => doMap(v, a)\n        );\n      }\n    }\n    return doMap(lenVal.throwIfNotConcrete());\n\n    function doMap(val: ConcreteValue, resultArray?: ObjectValue) {\n      let len = To.ToLength(realm, val);\n\n      // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n      if (!IsCallable(realm, callbackfn)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      let T = thisArg || realm.intrinsics.undefined;\n\n      // 5. Let A be ? ArraySpeciesCreate(O, len).\n      let A;\n      if (resultArray === undefined) A = Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), len);\n      else {\n        A = resultArray;\n        Properties.Set(realm, A, \"length\", val, true);\n      }\n\n      // 6. Let k be 0.\n      let k = 0;\n\n      // 7. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! To.ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // b. Let kPresent be ? HasProperty(O, Pk).\n        let kPresent = HasProperty(realm, O, Pk);\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n          // i. Let kValue be ? Get(O, Pk).\n          let kValue = Get(realm, O, Pk);\n\n          // ii. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).\n          let mappedValue = Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n\n          // iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\n          Create.CreateDataPropertyOrThrow(realm, A, Pk, mappedValue);\n        }\n\n        // d. Increase k by 1.\n        k++;\n      }\n\n      // 8. Return A.\n      return A;\n    }\n  });\n\n  // ECMA262 22.1.3.17\n  obj.defineNativeMethod(\"pop\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"pop\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, [O], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"pop\")), [])\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If len is zero, then\n    if (len === 0) {\n      // a. Perform ? Set(O, \"length\", 0, true).\n      Properties.Set(realm, O, \"length\", realm.intrinsics.zero, true);\n\n      // b. Return undefined.\n      return realm.intrinsics.undefined;\n    } else {\n      // 4. Else len > 0,\n      // a. Let newLen be len-1.\n      let newLen = len - 1;\n\n      // b. Let indx be ! ToString(newLen).\n      let indx = new StringValue(realm, newLen + \"\");\n\n      // c. Let element be ? Get(O, indx).\n      let element = Get(realm, O, indx);\n\n      // d. Perform ? DeletePropertyOrThrow(O, indx).\n      Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), indx);\n\n      // e. Perform ? Set(O, \"length\", newLen, true).\n      Properties.Set(realm, O, \"length\", new NumberValue(realm, newLen), true);\n\n      // f. Return element.\n      return element;\n    }\n  });\n\n  // ECMA262 22.1.3.18\n  obj.defineNativeMethod(\"push\", 1, (context, args, argCount) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"push\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, NumberValue, [O, ...args], ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"push\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, new StringValue(realm, \"length\")));\n\n    // 3. Let items be a List whose elements are, in left to right order, the arguments that were passed to realm function invocation.\n    let items = argCount > 0 ? args : [];\n\n    // 4. Let argCount be the number of elements in items.\n    argCount;\n\n    // 5. If len + argCount > 2^53-1, throw a TypeError exception.\n    if (len + argCount > Math.pow(2, 53) - 1) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Repeat, while items is not empty\n    while (items.length) {\n      // a. Remove the first element from items and let E be the value of the element.\n      let E = items.shift();\n\n      // b. Perform ? Set(O, ! ToString(len), E, true).\n      Properties.Set(realm, O, new StringValue(realm, len + \"\"), E, true);\n\n      // c. Let len be len+1.\n      len++;\n    }\n\n    // 7. Perform ? Set(O, \"length\", len, true).\n    Properties.Set(realm, O, new StringValue(realm, \"length\"), new NumberValue(realm, len), true);\n\n    // 8. Return len.\n    return new NumberValue(realm, len);\n  });\n\n  // ECMA262 22.1.3.19\n  obj.defineNativeMethod(\"reduce\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"reduce\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (initialValue) {\n        args.push(initialValue);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"reduce\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 5. Let k be 0.\n    let k = 0;\n\n    // 6. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // a. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 7. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k < len\n      while (kPresent === false && k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iv. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // v. Increase k by 1.\n        k++;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"kPresent is false\");\n      }\n\n      invariant(accumulator);\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.1.3.20\n  obj.defineNativeMethod(\"reduceRight\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"reduceRight\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (initialValue) {\n        args.push(initialValue);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"reduceRight\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 4. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 5. Let k be len-1.\n    let k = len - 1;\n\n    // 6. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // 1. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 7. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k ≥ 0\n      while (!kPresent && k >= 0) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iii. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // iv. Decrease k by 1.\n        k--;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent || !accumulator) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n      }\n    }\n\n    // 8. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Decrease k by 1.\n      k--;\n    }\n\n    // 9. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.1.3.21\n  obj.defineNativeMethod(\"reverse\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"reverse\") === undefined\n    ) {\n      AbstractValue.createTemporalFromBuildFunction(realm, ArrayValue, [O], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"reverse\")), [])\n      );\n      return O;\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. Let middle be floor(len/2).\n    let middle = Math.floor(len / 2);\n\n    // 4. Let lower be 0.\n    let lower = 0;\n\n    // 5. Repeat, while lower ≠ middle\n    while (lower !== middle) {\n      // a. Let upper be len - lower - 1.\n      let upper = len - lower - 1;\n\n      // b. Let upperP be ! ToString(upper).\n      let upperP = new StringValue(realm, upper + \"\");\n\n      // c. Let lowerP be ! ToString(lower).\n      let lowerP = new StringValue(realm, lower + \"\");\n\n      // d. Let lowerExists be ? HasProperty(O, lowerP).\n      let lowerExists = HasProperty(realm, O, lowerP);\n\n      // e. If lowerExists is true, then\n      let lowerValue;\n      if (lowerExists) {\n        // i. Let lowerValue be ? Get(O, lowerP).\n        lowerValue = Get(realm, O, lowerP);\n      }\n\n      // f. Let upperExists be ? HasProperty(O, upperP).\n      let upperExists = HasProperty(realm, O, upperP);\n\n      // g. If upperExists is true, then\n      let upperValue;\n      if (upperExists) {\n        // i. Let upperValue be ? Get(O, upperP).\n        upperValue = Get(realm, O, upperP);\n      }\n\n      // h. If lowerExists is true and upperExists is true, then\n      if (lowerExists && upperExists) {\n        invariant(lowerValue, \"expected lower value to exist\");\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else if (!lowerExists && upperExists) {\n        // i. Else if lowerExists is false and upperExists is true, then\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? DeletePropertyOrThrow(O, upperP).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), upperP);\n      } else if (lowerExists && !upperExists) {\n        // j. Else if lowerExists is true and upperExists is false, then\n        invariant(lowerValue, \"expected lower value to exist\");\n\n        // i. Perform ? DeletePropertyOrThrow(O, lowerP).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), lowerP);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else {\n        // k. Else both lowerExists and upperExists are false,\n        // i. No action is required.\n      }\n\n      // l. Increase lower by 1.\n      lower++;\n    }\n\n    // 6. Return O.\n    return O;\n  });\n\n  // ECMA262 22.1.3.22\n  obj.defineNativeMethod(\"shift\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"shift\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, [O], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"shift\")), [])\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If len is zero, then\n    if (len === 0) {\n      // a. Perform ? Set(O, \"length\", 0, true).\n      Properties.Set(realm, O, \"length\", realm.intrinsics.zero, true);\n\n      // b. Return undefined.\n      return realm.intrinsics.undefined;\n    }\n\n    // 4. Let first be ? Get(O, \"0\").\n    let first = Get(realm, O, \"0\");\n\n    // 5. Let k be 1.\n    let k = 0;\n\n    // 6. Repeat, while k < len\n    while (k < len) {\n      // a. Let from be ! ToString(k).\n      let frm = new StringValue(realm, k + \"\");\n\n      // b. Let to be ! ToString(k-1).\n      let to = new StringValue(realm, k - 1 + \"\");\n\n      // c. Let fromPresent be ? HasProperty(O, from).\n      let fromPresent = HasProperty(realm, O, frm);\n\n      // d. If fromPresent is true, then\n      if (fromPresent) {\n        // i. Let fromVal be ? Get(O, from).\n        let fromVal = Get(realm, O, frm);\n\n        // ii. Perform ? Set(O, to, fromVal, true).\n        Properties.Set(realm, O, to, fromVal, true);\n      } else {\n        // d. Else fromPresent is false,\n        // i. Perform ? DeletePropertyOrThrow(O, to).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);\n      }\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).\n    Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), new StringValue(realm, len - 1 + \"\"));\n\n    // 8. Perform ? Set(O, \"length\", len-1, true).\n    Properties.Set(realm, O, \"length\", new NumberValue(realm, len - 1), true);\n\n    // 9. Return first.\n    return first;\n  });\n\n  // ECMA262 22.1.3.23\n  obj.defineNativeMethod(\"slice\", 2, (context, [start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"slice\") === undefined\n    ) {\n      let newArgs = [O, start, end];\n      return ArrayValue.createTemporalWithWidenedNumericProperty(realm, newArgs, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"slice\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start);\n\n    // 4. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 5. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 7. Let count be max(final - k, 0).\n    let count = Math.max(final - k, 0);\n\n    // 8. Let A be ? ArraySpeciesCreate(O, count).\n    let A = Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), count);\n\n    // 9. Let n be 0.\n    let n = 0;\n\n    // 10. Repeat, while k < final\n    while (k < final) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue).\n        Create.CreateDataPropertyOrThrow(realm, A, new StringValue(realm, n + \"\"), kValue);\n      }\n\n      // d. Increase k by 1.\n      k++;\n\n      // e. Increase n by 1.\n      n++;\n    }\n\n    // 11. Perform ? Set(A, \"length\", n, true).\n    Properties.Set(realm, A, \"length\", new NumberValue(realm, n), true);\n\n    // 12. Return A.\n    return A;\n  });\n\n  // ECMA262 22.1.3.24\n  obj.defineNativeMethod(\"some\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"some\") === undefined\n    ) {\n      let args = [O, callbackfn];\n      if (thisArg) {\n        args.push(thisArg);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, BooleanValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"some\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"callback passed to Array.prototype.some isn't callable\"\n      );\n    }\n\n    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 5. Let k be 0.\n    let k = 0;\n\n    // 6. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is true, return true.\n        if (testResult) return realm.intrinsics.true;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 7. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.1.3.25\n  obj.defineNativeMethod(\"sort\", 1, (context, [comparefn]) => {\n    // 1. Let obj be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"sort\") === undefined\n    ) {\n      let args = [O, comparefn];\n      AbstractValue.createTemporalFromBuildFunction(realm, Value, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"sort\")), ((_args: any): Array<any>))\n      );\n      // context is returned instead of O at the end of this method\n      // so we do the same here\n      return context;\n    }\n\n    // 2. Let len be ? ToLength(? Get(obj, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // Within this specification of the sort method, an object, obj, is said to be sparse if the following algorithm returns true:\n    let isSparse = () => {\n      // 1.For each integer i in the range 0≤i< len\n      for (let i = 0; i < len; i++) {\n        // a.Let elem be obj.[[GetOwnProperty]](! ToString(i)).\n        let elem = O.$GetOwnProperty(i.toString());\n        // b.If elem is undefined, return true.\n        if (elem === undefined) return true;\n        Properties.ThrowIfMightHaveBeenDeleted(elem.value);\n      }\n      // 2.Return false.\n      return false;\n    };\n    let sparse = isSparse();\n\n    // Let proto be obj.[[GetPrototypeOf]]().\n    let proto = O.$GetPrototypeOf();\n\n    // If proto is not null\n    if (!(proto instanceof NullValue)) {\n      // and there exists an integer j such that all of the conditions below are satisfied then the sort order is implementation-defined:\n      for (let j = 0; j < len; j++) {\n        // HasProperty(proto, ToString(j)) is true.\n        if (\n          HasProperty(realm, proto, j.toString()) &&\n          // obj is sparse\n          sparse\n        )\n          // We abord when the result of the sort is implementation defined.\n          throw Error(\"Implentation defined behavior detected\");\n      }\n    }\n\n    // The sort order is also implementation defined if obj is sparse and any of the following conditions are true:\n    if (sparse) {\n      // IsExtensible(obj) is false.\n      if (!IsExtensible(realm, O)) throw Error(\"Implementation defined behavior, Array is both sparse and extensible\");\n      // Any integer index property of obj whose name is a nonnegative integer less than len\n      for (let j = 0; j < len; j++) {\n        // is a data property whose [[Configurable]] attribute is false.\n        let prop = O.$GetOwnProperty(j.toString());\n        if (prop !== undefined && !prop.configurable) {\n          Properties.ThrowIfMightHaveBeenDeleted(prop.value);\n          throw Error(\n            \"Implementation defined behavior :  Array is sparse and it's prototype has some numbered properties\"\n          );\n        }\n      }\n    }\n\n    // Any integer index property of obj whose name is a nonnegative integer less than len\n    for (let j = 0; j < len; j++) {\n      //is a data property whose [[writable]] attribute is false.\n      let prop = O.$GetOwnProperty(j.toString());\n      if (prop !== undefined && !prop.writable) {\n        Properties.ThrowIfMightHaveBeenDeleted(prop.value);\n        throw Error(\"Implementation defined behavior : property \" + j.toString() + \"is non writable : \");\n      }\n    }\n\n    // The SortCompare abstract operation is called with two arguments x and y. It also has access to the comparefn\n    // argument passed to the current invocation of the sort method. The following steps are taken:\n\n    // 22.1.3.25.1 Runtime Semantics: SortCompare( x, y )#\n    let SortCompare = (x, y) => {\n      x = x.throwIfNotConcrete();\n      y = y.throwIfNotConcrete();\n      // 1. If x and y are both undefined, return +0.\n      if (x instanceof UndefinedValue && y instanceof UndefinedValue) {\n        return realm.intrinsics.zero;\n      }\n      // 2. If x is undefined, return 1.\n      if (x instanceof UndefinedValue) {\n        return new NumberValue(realm, 1);\n      }\n      // 3. If y is undefined, return -1.\n      if (y instanceof UndefinedValue) {\n        return new NumberValue(realm, -1);\n      }\n      // 4. If the argument comparefn is not undefined, then\n      if (!comparefn.mightBeUndefined()) {\n        // a. Let v be ? ToNumber(? Call(comparefn, undefined, « x, y »)).\n        let v = To.ToNumber(realm, Call(realm, comparefn, new UndefinedValue(realm), [x, y]));\n        // b. If v is NaN, return +0.\n        if (isNaN(v)) return new NumberValue(realm, +0);\n        // c. Return v.\n        return new NumberValue(realm, v);\n      } else {\n        comparefn.throwIfNotConcrete();\n      }\n      // 5. Let xString be ? ToString(x).\n      let xString = new StringValue(realm, To.ToString(realm, x));\n      // 6. Let yString be ? ToString(y).\n      let yString = new StringValue(realm, To.ToString(realm, y));\n      // 7. Let xSmaller be the result of performing Abstract Relational Comparison xString < yString.\n      let xSmaller = AbstractRelationalComparison(realm, xString, yString, true, \"<\");\n      // 8. If xSmaller is true, return -1.\n      if (xSmaller.value) return new NumberValue(realm, -1);\n      // 9. Let ySmaller be the result of performing Abstract Relational Comparison yString < xString.\n      let ySmaller = AbstractRelationalComparison(realm, yString, xString, true, \"<\");\n      // 10. If ySmaller is true, return 1.\n      if (ySmaller.value) return new NumberValue(realm, 1);\n      // 11. Return +0.\n      return realm.intrinsics.zero;\n    };\n\n    //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:\n    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.\n\n    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and\n    // transfering back the value inside the our array.\n\n    let arr = [];\n\n    // We need to adapt the comparefn function to match the expected types\n    let comparefn_ = (x, y) => {\n      invariant(x instanceof Value, \"Unexpected type\");\n      invariant(y instanceof Value, \"Unexpected type\");\n\n      let result_ = SortCompare(x, y);\n      let numb = To.ToNumber(realm, result_);\n      return numb;\n    };\n\n    for (let j = 0; j < len; j++) {\n      // The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.\n      if (!HasOwnProperty(realm, O, j.toString())) continue;\n      // The arguments for calls to SortCompare are values returned by a previous call to the [[Get]] internal method,\n      // unless the properties accessed by those previous calls did not exist according to HasOwnProperty.\n\n      // -- Important : We rely on the fact that the underlying sort implementation respect the standard for the following 3 properties\n      // If both perspective arguments to SortCompare correspond to non-existent properties,\n      // use +0 instead of calling SortCompare. If only the first perspective argument is non-existent use +1.\n      // If only the second perspective argument is non-existent use -1.\n      let val = O.$Get(j.toString(), O);\n      arr[j] = val;\n    }\n\n    arr.sort(comparefn_);\n\n    //Apply the permutation back to the original array.\n    for (let j = 0; j < len; j++) {\n      if (arr.hasOwnProperty(j.toString())) {\n        let ok = O.$Set(j.toString(), arr[j], O);\n        // If any [[Set]] call returns false a TypeError exception is thrown.\n        if (!ok) throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"[[Set]] returned false\");\n      } else {\n        // If obj is not sparse then DeletePropertyOrThrow must not be called.\n        invariant(sparse);\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), j.toString());\n      }\n    }\n    // If an abrupt completion is returned from any of these operations, it is immediately returned as the value of this function.\n\n    // 2. Return obj;\n    return context;\n  });\n\n  // ECMA262 22.1.3.26\n  obj.defineNativeMethod(\"splice\", 2, (context, [start, deleteCount, ...items], argLength) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"splice\") === undefined\n    ) {\n      let args = [O, start];\n      if (deleteCount) {\n        args.push(deleteCount);\n      }\n      if (items && items.length > 0) {\n        args.push(...items);\n      }\n      return AbstractValue.createTemporalFromBuildFunction(realm, ArrayValue, args, ([objNode, ..._args]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"splice\")), ((_args: any): Array<any>))\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start);\n\n    // 4. If relativeStart < 0, let actualStart be max((len + relativeStart), 0); else let actualStart be min(relativeStart, len).\n    let actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    let insertCount;\n    let actualDeleteCount;\n\n    // 5. If the number of actual arguments is 0, then\n    if (argLength === 0) {\n      // a. Let insertCount be 0.\n      insertCount = 0;\n\n      // b. Let actualDeleteCount be 0.\n      actualDeleteCount = 0;\n    } else if (argLength === 1) {\n      // 6. Else if the number of actual arguments is 1, then\n      // a. Let insertCount be 0.\n      insertCount = 0;\n\n      // b. Let actualDeleteCount be len - actualStart.\n      actualDeleteCount = len - actualStart;\n    } else {\n      // 7. Else,\n      // a. Let insertCount be the number of actual arguments minus 2.\n      insertCount = argLength - 2;\n\n      // b. Let dc be ? ToInteger(deleteCount).\n      let dc = To.ToInteger(realm, deleteCount);\n\n      // c. Let actualDeleteCount be min(max(dc, 0), len - actualStart).\n      actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);\n    }\n\n    // 8. If len+insertCount-actualDeleteCount > 2^53-1, throw a TypeError exception.\n    if (len + insertCount - actualDeleteCount > Math.pow(2, 53) - 1) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"the item count is too damn high\");\n    }\n\n    // 9. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).\n    let A = Create.ArraySpeciesCreate(realm, O.throwIfNotConcreteObject(), actualDeleteCount);\n\n    // 10. Let k be 0.\n    let k = 0;\n\n    // 11. Repeat, while k < actualDeleteCount\n    while (k < actualDeleteCount) {\n      // a. Let from be ! ToString(actualStart+k).\n      let frm = new StringValue(realm, actualStart + k + \"\");\n\n      // b. Let fromPresent be ? HasProperty(O, from).\n      let fromPresent = HasProperty(realm, O, frm);\n\n      // c. If fromPresent is true, then\n      if (fromPresent) {\n        // i. Let fromValue be ? Get(O, from).\n        let fromValue = Get(realm, O, frm);\n\n        // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).\n        Create.CreateDataPropertyOrThrow(realm, A, new StringValue(realm, k + \"\"), fromValue);\n      }\n\n      // d. Increment k by 1.\n      k++;\n    }\n\n    // 12. Perform ? Set(A, \"length\", actualDeleteCount, true).\n    Properties.Set(realm, A, \"length\", new NumberValue(realm, actualDeleteCount), true);\n\n    // 13. Let items be a List whose elements are, in left to right order, the portion of the actual argument\n    //     list starting with the third argument. The list is empty if fewer than three arguments were passed.\n    items;\n\n    // 14. Let itemCount be the number of elements in items.\n    let itemCount = items.length;\n\n    // 15. If itemCount < actualDeleteCount, then\n    if (itemCount < actualDeleteCount) {\n      // a. Let k be actualStart.\n      k = actualStart;\n\n      // b. Repeat, while k < (len - actualDeleteCount)\n      while (k < len - actualDeleteCount) {\n        // i. Let from be ! ToString(k+actualDeleteCount).\n        let frm = new StringValue(realm, k + actualDeleteCount + \"\");\n\n        // ii. Let to be ! ToString(k+itemCount).\n        let to = new StringValue(realm, k + itemCount + \"\");\n\n        // iii. Let fromPresent be ? HasProperty(O, from).\n        let fromPresent = HasProperty(realm, O, frm);\n\n        // iv. If fromPresent is true, then\n        if (fromPresent) {\n          // 1. Let fromValue be ? Get(O, from).\n          let fromValue = Get(realm, O, frm);\n\n          // 2. Perform ? Set(O, to, fromValue, true).\n          Properties.Set(realm, O, to, fromValue, true);\n        } else {\n          // v. Else fromPresent is false,\n          // 1. Perform ? DeletePropertyOrThrow(O, to).\n          Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);\n        }\n\n        // vi. Increase k by 1.\n        k++;\n      }\n\n      // c. Let k be len.\n      k = len;\n\n      // d. Repeat, while k > (len - actualDeleteCount + itemCount)\n      while (k > len - actualDeleteCount + itemCount) {\n        // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), new StringValue(realm, k - 1 + \"\"));\n\n        // ii. Decrease k by 1.\n        k--;\n      }\n    } else if (itemCount > actualDeleteCount) {\n      // 16. Else if itemCount > actualDeleteCount, then\n      // a. Let k be (len - actualDeleteCount).\n      k = len - actualDeleteCount;\n\n      // b. Repeat, while k > actualStart\n      while (k > actualStart) {\n        // i. Let from be ! ToString(k + actualDeleteCount - 1).\n        let frm = new StringValue(realm, k + actualDeleteCount - 1 + \"\");\n\n        // ii. Let to be ! ToString(k + itemCount - 1).\n        let to = new StringValue(realm, k + itemCount - 1 + \"\");\n\n        // iii. Let fromPresent be ? HasProperty(O, from).\n        let fromPresent = HasProperty(realm, O, frm);\n\n        // iv. If fromPresent is true, then\n        if (fromPresent) {\n          // 1. Let fromValue be ? Get(O, from).\n          let fromValue = Get(realm, O, frm);\n\n          // 2. Perform ? Set(O, to, fromValue, true).\n          Properties.Set(realm, O, to, fromValue, true);\n        } else {\n          // v. Else fromPresent is false,\n          // 1. Perform ? DeletePropertyOrThrow(O, to).\n          Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);\n        }\n\n        // vi. Decrease k by 1.\n        k--;\n      }\n    }\n\n    // 17. Let k be actualStart.\n    k = actualStart;\n\n    // 18. Repeat, while items is not empty\n    while (items.length) {\n      // a. Remove the first element from items and let E be the value of that element.\n      let E = items.shift();\n\n      // b. Perform ? Set(O, ! ToString(k), E, true).\n      Properties.Set(realm, O, new StringValue(realm, k + \"\"), E, true);\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 19. Perform ? Set(O, \"length\", len - actualDeleteCount + itemCount, true).\n    Properties.Set(realm, O, \"length\", new NumberValue(realm, len - actualDeleteCount + itemCount), true);\n\n    // 20. Return A.\n    return A;\n  });\n\n  // ECMA262 22.1.3.27\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    // 1. Let array be ? ToObject(this value).\n    let array = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(array) &&\n      realm.isInPureScope() &&\n      array.$GetOwnProperty(\"toLocaleString\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, StringValue, [array], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"toLocaleString\")), [])\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(array, \"length\")).\n    let len = To.ToLength(realm, Get(realm, array, \"length\"));\n\n    // 3. Let separator be the String value for the list-separator String appropriate for the host environment's\n    //    current locale (this is derived in an implementation-defined way).\n    let separator = \",\";\n\n    // 4. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 5. Let firstElement be ? Get(array, \"0\").\n    let firstElement = Get(realm, array, \"0\");\n\n    // 6. If firstElement is undefined or null, then\n    let R: ?string;\n    if (HasSomeCompatibleType(firstElement, UndefinedValue, NullValue)) {\n      // a. Let R be the empty String.\n      R = \"\";\n    } else {\n      // 7. Else,\n      // a. Let R be ? ToString(? Invoke(firstElement, \"toLocaleString\")).\n      R = To.ToStringPartial(realm, Invoke(realm, firstElement, \"toLocaleString\"));\n    }\n\n    // 8. Let k be 1.\n    let k = 1;\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be a String value produced by concatenating R and separator.\n      let S: string = R + separator;\n\n      // b. Let nextElement be ? Get(array, ! ToString(k)).\n      let nextElement = Get(realm, array, new StringValue(realm, k + \"\")).throwIfNotConcrete();\n\n      // c. If nextElement is undefined or null, then\n      if (HasSomeCompatibleType(nextElement, UndefinedValue, NullValue)) {\n        // i. Let R be the empty String.\n        R = \"\";\n      } else {\n        // d. Else,\n        // i. Let R be ? ToString(? Invoke(nextElement, \"toLocaleString\")).\n        R = To.ToStringPartial(realm, Invoke(realm, nextElement, \"toLocaleString\"));\n      }\n\n      // e. Let R be a String value produced by concatenating S and R.\n      R = S + R;\n\n      // f. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return R.\n    return new StringValue(realm, R);\n  });\n\n  // ECMA262 22.1.3.28\n  obj.defineNativeProperty(\"toString\", realm.intrinsics.ArrayProto_toString);\n\n  // ECMA262 22.1.3.29\n  obj.defineNativeMethod(\"unshift\", 1, (context, items, argCount) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // If we have an object that is an unknown array with numeric properties, then\n    // we can return a temporal here as we know nothing of the array's properties.\n    // This should be safe to do, as we never expose the internals of the array.\n    if (\n      ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O) &&\n      realm.isInPureScope() &&\n      O.$GetOwnProperty(\"unshift\") === undefined\n    ) {\n      return AbstractValue.createTemporalFromBuildFunction(realm, NumberValue, [O], ([objNode]) =>\n        t.callExpression(t.memberExpression(objNode, t.identifier(\"unshift\")), [])\n      );\n    }\n\n    // 2. Let len be ? ToLength(? Get(O, \"length\")).\n    let len = To.ToLength(realm, Get(realm, O, \"length\"));\n\n    // 3. Let argCount be the number of actual arguments.\n    argCount;\n\n    // 4. If argCount > 0, then\n    if (argCount > 0) {\n      // a. If len+argCount > 2^53-1, throw a TypeError exception.\n      if (len + argCount > Math.pow(2, 53) - 1) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"too damn high\");\n      }\n\n      // b. Let k be len.\n      let k = len;\n\n      // c. Repeat, while k > 0,\n      while (k > 0) {\n        // i. Let from be ! ToString(k-1).\n        let frm = new StringValue(realm, k - 1 + \"\");\n\n        // ii. Let to be ! ToString(k+argCount-1).\n        let to = new StringValue(realm, k + argCount - 1 + \"\");\n\n        // iv. Let fromPresent be ? HasProperty(O, from).\n        let fromPresent = HasProperty(realm, O, frm);\n\n        // v. If fromPresent is true, then\n        if (fromPresent) {\n          // 1. Let fromValue be ? Get(O, from).\n          let fromValue = Get(realm, O, frm);\n\n          // 2. Perform ? Set(O, to, fromValue, true).\n          Properties.Set(realm, O, to, fromValue, true);\n        } else {\n          // vi. Else fromPresent is false,\n          // 1. Perform ? DeletePropertyOrThrow(O, to).\n          Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), to);\n        }\n\n        // vii. Decrease k by 1.\n        k--;\n      }\n\n      // e. Let j be 0.\n      let j = 0;\n\n      // f. Let items be a List whose elements are, in left to right order, the arguments that were passed to\n      //    this function invocation.\n      items;\n\n      // g. Repeat, while items is not empty\n      while (items.length) {\n        // i. Remove the first element from items and let E be the value of that element.\n        let E = items.shift();\n\n        // ii. Perform ? Set(O, ! ToString(j), E, true).\n        Properties.Set(realm, O, new StringValue(realm, j + \"\"), E, true);\n\n        // iii. Increase j by 1.\n        j++;\n      }\n    }\n\n    // 5. Perform ? Set(O, \"length\", len+argCount, true).\n    Properties.Set(realm, O, \"length\", new NumberValue(realm, len + argCount), true);\n\n    // 6. Return len+argCount.\n    return new NumberValue(realm, len + argCount);\n  });\n\n  // ECMA262 22.1.3.30\n  obj.defineNativeProperty(\"values\", realm.intrinsics.ArrayProto_values);\n\n  // ECMA262 22.1.3.32\n  {\n    // 1. Let unscopableList be ObjectCreate(null).\n    let unscopableList = Create.ObjectCreate(realm, realm.intrinsics.null);\n\n    // 2. Perform CreateDataProperty(unscopableList, \"copyWithin\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"copyWithin\", realm.intrinsics.true);\n\n    // 3. Perform CreateDataProperty(unscopableList, \"entries\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"entries\", realm.intrinsics.true);\n\n    // 4. Perform CreateDataProperty(unscopableList, \"fill\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"fill\", realm.intrinsics.true);\n\n    // 5. Perform CreateDataProperty(unscopableList, \"find\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"find\", realm.intrinsics.true);\n\n    // 6. Perform CreateDataProperty(unscopableList, \"findIndex\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"findIndex\", realm.intrinsics.true);\n\n    // 7. Perform CreateDataProperty(unscopableList, \"includes\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"includes\", realm.intrinsics.true);\n\n    // 8. Perform CreateDataProperty(unscopableList, \"keys\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"keys\", realm.intrinsics.true);\n\n    // 9. Perform CreateDataProperty(unscopableList, \"values\", true).\n    Create.CreateDataProperty(realm, unscopableList, \"values\", realm.intrinsics.true);\n\n    // 10. Assert: Each of the above calls will return true.\n\n    // 11. Return unscopableList.\n    obj.defineNativeProperty(realm.intrinsics.SymbolUnscopables, unscopableList, {\n      writable: false,\n    });\n  }\n}\n"]}