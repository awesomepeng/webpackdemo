"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (realm) {
  let func = new _index.NativeFunctionValue(realm, "RegExp", "RegExp", 2, (context, [pattern, flags], argCount, NewTarget) => {
    // 1. Let patternIsRegExp be ? IsRegExp(pattern).
    let patternIsRegExp = (0, _is.IsRegExp)(realm, pattern);
    let newTarget;
    // 2. If NewTarget is not undefined, let newTarget be NewTarget.
    if (NewTarget) {
      newTarget = NewTarget;
    } else {
      // 3. Else,
      // a. Let newTarget be the active function object.
      newTarget = func;

      // b. If patternIsRegExp is true and flags is undefined, then
      if (patternIsRegExp && flags instanceof _index.UndefinedValue) {
        (0, _invariant2.default)(pattern instanceof _index.ObjectValue);
        // i. Let patternConstructor be ? Get(pattern, "constructor").
        let patternConstructor = (0, _get.Get)(realm, pattern, "constructor");

        // ii. If SameValue(newTarget, patternConstructor) is true, return pattern.
        if ((0, _abstract.SameValuePartial)(realm, newTarget, patternConstructor)) {
          return pattern;
        }
      }
    }

    let P, F;
    // 4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then
    if (pattern instanceof _index.ObjectValue && pattern.$RegExpMatcher) {
      // a. Let P be the value of pattern's [[OriginalSource]] internal slot.
      (0, _invariant2.default)(typeof pattern.$OriginalSource === "string");
      P = new _index.StringValue(realm, pattern.$OriginalSource);

      // b. If flags is undefined, let F be the value of pattern's [[OriginalFlags]] internal slot.
      if (flags instanceof _index.UndefinedValue) {
        (0, _invariant2.default)(typeof pattern.$OriginalFlags === "string");
        F = new _index.StringValue(realm, pattern.$OriginalFlags);
      } else {
        // c. Else, let F be flags.
        F = flags.throwIfNotConcrete();
      }
    } else if (patternIsRegExp) {
      // 5. Else if patternIsRegExp is true, then
      (0, _invariant2.default)(pattern instanceof _index.ObjectValue);
      // a. Let P be ? Get(pattern, "source").
      P = (0, _get.Get)(realm, pattern, "source");

      // b. If flags is undefined, then
      if (flags instanceof _index.UndefinedValue) {
        // i. Let F be ? Get(pattern, "flags").
        F = (0, _get.Get)(realm, pattern, "flags");
      } else {
        // c. Else, let F be flags.
        F = flags.throwIfNotConcrete();
      }
    } else {
      // 6. Else,
      // a. Let P be pattern.
      P = pattern.throwIfNotConcrete();
      // b. Let F be flags.
      F = flags.throwIfNotConcrete();
    }

    // 7. Let O be ? RegExpAlloc(newTarget).
    let O = (0, _regexp.RegExpAlloc)(realm, newTarget);

    // 8. Return ? RegExpInitialize(O, P, F).
    return (0, _regexp.RegExpInitialize)(realm, O, P, F);
  });

  // ECMA262 21.2.4.2
  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });

  return func;
};

var _index = require("../../values/index.js");

var _is = require("../../methods/is.js");

var _get = require("../../methods/get.js");

var _abstract = require("../../methods/abstract.js");

var _regexp = require("../../methods/regexp.js");

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=RegExp.js.map