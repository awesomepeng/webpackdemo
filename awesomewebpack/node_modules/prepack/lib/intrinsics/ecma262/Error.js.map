{"version":3,"sources":["../../../src/intrinsics/ecma262/Error.js"],"names":["realm","build","describeLocation","callerFn","env","loc","locString","displayName","key","alreadyDescribedLocations","has","get","set","undefined","name","_SafeGetDataPropertyValue","mightBeUndefined","ToStringPartial","throwIfNotConcrete","environmentRecord","$NewTarget","start","line","column","source","location","buildStack","context","$ErrorData","stack","contextStack","intrinsics","lines","header","msg","executionContext","reverse","caller","function","lexicalEnvironment","push","join","inheritError","func","message","argLength","NewTarget","newTarget","O","OrdinaryCreateFromConstructor","slice","locationData","stackDesc","value","enumerable","configurable","writable","DefinePropertyOrThrow","getType","ToStringValue","msgDesc","$Prototype","Error"],"mappings":"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","file":"Error.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { LexicalEnvironment } from \"../../environment.js\";\nimport { ObjectValue, FunctionValue, NativeFunctionValue, StringValue } from \"../../values/index.js\";\nimport { Get } from \"../../methods/index.js\";\nimport { Create, Properties, To } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  return build(\"Error\", realm, false);\n}\n\nexport function describeLocation(\n  realm: Realm,\n  callerFn: ?FunctionValue,\n  env: ?LexicalEnvironment,\n  loc: ?BabelNodeSourceLocation\n): void | string {\n  let locString = \"\";\n  let displayName = \"\";\n  let key = loc || callerFn;\n\n  // check if we've already encountered the callFn and if so\n  // re-use that described location. plus we may get stuck trying\n  // to get the location by recursively checking the same fun\n  // so this also prevents a stack overflow\n  if (key) {\n    if (realm.alreadyDescribedLocations.has(key)) {\n      return realm.alreadyDescribedLocations.get(key);\n    }\n    realm.alreadyDescribedLocations.set(key, undefined);\n  }\n\n  if (callerFn) {\n    if (callerFn instanceof NativeFunctionValue) {\n      locString = \"native\";\n    }\n\n    let name = callerFn._SafeGetDataPropertyValue(\"name\");\n    if (!name.mightBeUndefined()) displayName = To.ToStringPartial(realm, name);\n    else name.throwIfNotConcrete();\n\n    if (env && env.environmentRecord.$NewTarget) displayName = `new ${displayName}`;\n  }\n\n  if (!locString) {\n    if (loc) {\n      locString = `${loc.start.line}:${loc.start.column + 1}`;\n      if (loc.source) locString = `${loc.source}:${locString}`;\n    } else {\n      locString = (loc ? loc.source : undefined) || \"unknown\";\n      if (!displayName) return undefined;\n    }\n  }\n\n  let location;\n  if (displayName) {\n    location = `at ${displayName} (${locString})`;\n  } else {\n    location = `at ${locString}`;\n  }\n  if (key) {\n    realm.alreadyDescribedLocations.set(key, location);\n  }\n  return location;\n}\n\nfunction buildStack(realm: Realm, context: ObjectValue) {\n  invariant(context.$ErrorData);\n\n  let stack = context.$ErrorData.contextStack;\n  if (!stack) return realm.intrinsics.undefined;\n\n  let lines = [];\n  let header = \"\";\n\n  header += To.ToStringPartial(realm, Get(realm, context, \"name\"));\n\n  let msg = Get(realm, context, \"message\");\n  if (!msg.mightBeUndefined()) {\n    msg = To.ToStringPartial(realm, msg);\n    if (msg) header += `: ${msg}`;\n  } else {\n    msg.throwIfNotConcrete();\n  }\n\n  for (let executionContext of stack.reverse()) {\n    let caller = executionContext.caller;\n    if (!executionContext.loc) continue; // compiler generated helper for destructuring arguments\n    let locString = describeLocation(\n      realm,\n      caller ? caller.function : undefined,\n      caller ? caller.lexicalEnvironment : undefined,\n      executionContext.loc\n    );\n    if (locString !== undefined) lines.push(locString);\n  }\n\n  return new StringValue(realm, `${header}\\n    ${lines.join(\"\\n    \")}`);\n}\n\nexport function build(name: string, realm: Realm, inheritError?: boolean = true): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, name, name, 1, (context, [message], argLength, NewTarget) => {\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    let newTarget = NewTarget || func;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%ErrorPrototype%\", « [[ErrorData]] »).\n    let O = Create.OrdinaryCreateFromConstructor(realm, newTarget, `${name}Prototype`, { $ErrorData: undefined });\n    O.$ErrorData = {\n      contextStack: realm.contextStack.slice(1),\n      locationData: undefined,\n    };\n\n    // Build a text description of the stack.\n    let stackDesc = {\n      value: buildStack(realm, O),\n      enumerable: false,\n      configurable: true,\n      writable: true,\n    };\n    Properties.DefinePropertyOrThrow(realm, O, \"stack\", stackDesc);\n\n    // 3. If message is not undefined, then\n    if (!message.mightBeUndefined()) {\n      // a. Let msg be ? ToString(message).\n      let msg = message.getType() === StringValue ? message : To.ToStringValue(realm, message);\n\n      // b. Let msgDesc be the PropertyDescriptor{[[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.\n      let msgDesc = {\n        value: msg,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      };\n\n      // c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      Properties.DefinePropertyOrThrow(realm, O, \"message\", msgDesc);\n    } else {\n      message.throwIfNotConcrete();\n    }\n\n    // 4. Return O.\n    return O;\n  });\n\n  if (inheritError) {\n    func.$Prototype = realm.intrinsics.Error;\n  }\n\n  return func;\n}\n"]}