"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (realm, obj) {
  // ECMA262 19.1.3.2
  const ObjectPrototypeHasOwnPrototype = obj.defineNativeMethod("hasOwnProperty", 1, (context, [V]) => {
    // 1. Let P be ? ToPropertyKey(V).
    let P = _singletons.To.ToPropertyKey(realm, V.throwIfNotConcrete());

    // The pure parts are wrapped with a recovery mode.
    try {
      // 2. Let O be ? ToObject(this value).
      let O = _singletons.To.ToObject(realm, context);

      // 3. Return ? HasOwnProperty(O, P).
      return new _index.BooleanValue(realm, (0, _has.HasOwnProperty)(realm, O, P));
    } catch (x) {
      if (realm.isInPureScope() && x instanceof _errors.FatalError) {
        // If we're in pure scope we can try to recover from any fatals by
        // leaving the call in place which we do by default, but we don't
        // have to havoc the state of any arguments since this function is pure.
        // This also lets us define the return type properly.
        const key = typeof P === "string" ? new _index.StringValue(realm, P) : P;
        return realm.evaluateWithPossibleThrowCompletion(() => _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, [ObjectPrototypeHasOwnPrototype, context, key], ([methodNode, objectNode, nameNode]) => {
          return t.callExpression(t.memberExpression(methodNode, t.identifier("call")), [objectNode, nameNode]);
        }), _index2.TypesDomain.topVal, _index2.ValuesDomain.topVal);
      }
      throw x;
    }
  });

  // ECMA262 19.1.3.3
  obj.defineNativeMethod("isPrototypeOf", 1, (context, [V]) => {
    // 1. If Type(V) is not Object, return false.
    if (!V.mightBeObject()) return realm.intrinsics.false;
    V = V.throwIfNotConcreteObject();

    // 2. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context);

    // 3. Repeat
    while (true) {
      // a. Let V be ? V.[[GetPrototypeOf]]().
      V = V.$GetPrototypeOf();

      // b. If V is null, return false.
      if (V instanceof _index.NullValue) return realm.intrinsics.false;

      // c. If SameValue(O, V) is true, return true.
      if ((0, _abstract.SameValuePartial)(realm, O, V) === true) return realm.intrinsics.true;
    }

    (0, _invariant2.default)(false);
  });

  // ECMA262 19.1.3.4
  obj.defineNativeMethod("propertyIsEnumerable", 1, (context, [V]) => {
    // 1. Let P be ? ToPropertyKey(V).
    let P = _singletons.To.ToPropertyKey(realm, V.throwIfNotConcrete());

    // 2. Let O be ? ToObject(this value).
    let O = _singletons.To.ToObject(realm, context);

    // 3. Let desc be ? O.[[GetOwnProperty]](P).
    let desc = O.$GetOwnProperty(P);

    // 4. If desc is undefined, return false.
    if (!desc) return realm.intrinsics.false;
    _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc.value);

    // 5. Return the value of desc.[[Enumerable]].
    return desc.enumerable === undefined ? realm.intrinsics.undefined : new _index.BooleanValue(realm, desc.enumerable);
  });

  // ECMA262 19.1.3.5
  obj.defineNativeMethod("toLocaleString", 0, context => {
    // 1. Let O be the this value.
    let O = context;

    // 2. Return ? Invoke(O, "toString").
    return (0, _call.Invoke)(realm, O, "toString");
  });

  // ECMA262 19.1.3.6
  obj.defineNativeProperty("toString", realm.intrinsics.ObjectProto_toString);

  // ECMA262 19.1.3.7
  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? ToObject(this value).
    return _singletons.To.ToObject(realm, context);
  });

  obj.$DefineOwnProperty("__proto__", {
    // B.2.2.1.1
    get: new _index.NativeFunctionValue(realm, undefined, "get __proto__", 0, context => {
      // 1. Let O be ? ToObject(this value).
      let O = _singletons.To.ToObject(realm, context);

      // 2. Return ? O.[[GetPrototypeOf]]().
      return O.$GetPrototypeOf();
    }),

    // B.2.2.1.2
    set: new _index.NativeFunctionValue(realm, undefined, "set __proto__", 1, (context, [proto]) => {
      // 1. Let O be ? RequireObjectCoercible(this value).
      let O = (0, _abstract.RequireObjectCoercible)(realm, context);

      // 2. If Type(proto) is neither Object nor Null, return undefined.
      if (!(0, _has.HasSomeCompatibleType)(proto, _index.ObjectValue, _index.NullValue)) return realm.intrinsics.undefined;

      // 3. If Type(O) is not Object, return undefined.
      if (!O.mightBeObject()) return realm.intrinsics.undefined;
      O = O.throwIfNotConcreteObject();

      // 4. Let status be ? O.[[SetPrototypeOf]](proto).
      let status = O.$SetPrototypeOf(proto.throwIfNotConcrete());

      // 5. If status is false, throw a TypeError exception.
      if (!status) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "couldn't set proto");
      }

      // 6. Return undefined.
      return realm.intrinsics.undefined;
    })
  });
};

var _index = require("../../values/index.js");

var _abstract = require("../../methods/abstract.js");

var _has = require("../../methods/has.js");

var _call = require("../../methods/call.js");

var _singletons = require("../../singletons.js");

var _errors = require("../../errors.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _index2 = require("../../domains/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
//# sourceMappingURL=ObjectPrototype.js.map