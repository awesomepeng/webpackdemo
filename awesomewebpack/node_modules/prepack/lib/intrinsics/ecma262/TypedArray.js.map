{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArray.js"],"names":["realm","func","context","createErrorThrowCompletion","intrinsics","TypeError","defineNativeMethod","source","mapfn","thisArg","C","mapping","undefined","mightBeUndefined","throwIfNotConcrete","T","usingIterator","SymbolIterator","values","len","length","targetObj","k","Pk","ToString","kValue","shift","mappedValue","Set","arrayLike","ToObject","ToLength","items","argCount","newObj","defineNativeGetter","SymbolSpecies","build","getConstructorName","type","args","NewTarget","constructorName","elementLength","ToIndexPartial","typedArray","$TypedArrayName","O","srcArray","srcData","$ViewedArrayBuffer","elementType","$ArrayLength","srcName","srcType","srcElementSize","srcByteOffset","$ByteOffset","elementSize","byteLength","data","bufferConstructor","ArrayBuffer","srcByteIndex","targetByteIndex","count","value","$ByteLength","object","$ArrayBufferData","buffer","byteOffset","offset","RangeError","bufferByteLength","$ArrayBufferByteLength","newByteLength","newLength","$Prototype","TypedArray","defineNativeConstant"],"mappings":"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","file":"TypedArray.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType, TypedArrayKind } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { NumberValue, NativeFunctionValue, ObjectValue, StringValue, UndefinedValue } from \"../../values/index.js\";\nimport {\n  ArrayElementSize,\n  ArrayElementType,\n  AllocateTypedArray,\n  AllocateTypedArrayBuffer,\n  TypedArrayCreate,\n} from \"../../methods/typedarray.js\";\nimport { SpeciesConstructor } from \"../../methods/construct.js\";\nimport { Get, GetMethod } from \"../../methods/get.js\";\nimport { Properties, To } from \"../../singletons.js\";\nimport { IterableToList } from \"../../methods/iterator.js\";\nimport { IsDetachedBuffer, IsConstructor, IsCallable } from \"../../methods/is.js\";\nimport { Call } from \"../../methods/call.js\";\nimport {\n  CloneArrayBuffer,\n  AllocateArrayBuffer,\n  GetValueFromBuffer,\n  SetValueInBuffer,\n} from \"../../methods/arraybuffer.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"TypedArray\", \"TypedArray\", 0, context => {\n    // 1. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"TypedArray\");\n  });\n\n  // ECMA262 22.2.2.1\n  func.defineNativeMethod(\"from\", 1, (context, [source, mapfn, thisArg]) => {\n    // 1. Let C be the this value.\n    let C = context;\n\n    // 2. If IsConstructor(C) is false, throw a TypeError exception.\n    if (IsConstructor(realm, C) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n    }\n    invariant(C instanceof ObjectValue);\n\n    let mapping;\n    // 3. If mapfn was supplied and mapfn is not undefined, then\n    if (mapfn !== undefined && !mapfn.mightBeUndefined()) {\n      // a. If IsCallable(mapfn) is false, throw a TypeError exception.\n      if (IsCallable(realm, mapfn) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n      }\n\n      // b. Let mapping be true.\n      mapping = true;\n    } else {\n      // 4. Else, let mapping be false.\n      mapfn === undefined || mapfn.throwIfNotConcrete();\n      mapping = false;\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg !== undefined ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let usingIterator be ? GetMethod(source, @@iterator).\n    let usingIterator = GetMethod(realm, source, realm.intrinsics.SymbolIterator);\n\n    // 7. If usingIterator is not undefined, then\n    if (!(usingIterator instanceof UndefinedValue)) {\n      // a. Let values be ? IterableToList(source, usingIterator).\n      let values = IterableToList(realm, source, usingIterator);\n\n      // b. Let len be the number of elements in values.\n      let len = values.length;\n\n      // c. Let targetObj be ? TypedArrayCreate(C, «len»).\n      let targetObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n      // d. Let k be 0.\n      let k = 0;\n\n      // e. Repeat, while k < len\n      while (k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be the first element of values and remove that element from values.\n        let kValue = values.shift();\n\n        let mappedValue;\n        // iii. If mapping is true, then\n        if (mapping === true) {\n          // 1. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n          mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n        } else {\n          // iv. Else, let mappedValue be kValue.\n          mappedValue = kValue;\n        }\n\n        // v. Perform ? Set(targetObj, Pk, mappedValue, true).\n        Properties.Set(realm, targetObj, Pk, mappedValue, true);\n\n        // vi. Increase k by 1.\n        k = k + 1;\n      }\n\n      // f. Assert: values is now an empty List.\n      invariant(values.length === 0, \"values is not an empty List\");\n\n      // g. Return targetObj.\n      return targetObj;\n    }\n\n    // 8. NOTE: source is not an Iterable so assume it is already an array-like object.\n\n    // 9. Let arrayLike be ! ToObject(source).\n    let arrayLike = To.ToObject(realm, source);\n\n    // 10. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n    let len = To.ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n    // 11. Let targetObj be ? TypedArrayCreate(C, « len »).\n    let targetObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n    // 12. Let k be 0.\n    let k = 0;\n\n    // 13. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(arrayLike, Pk).\n      let kValue = Get(realm, arrayLike, Pk);\n\n      let mappedValue;\n      // c. If mapping is true, then\n      if (mapping === true) {\n        // i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).\n        mappedValue = Call(realm, mapfn, T, [kValue, new NumberValue(realm, k)]);\n      } else {\n        // d. Else, let mappedValue be kValue.\n        mappedValue = kValue;\n      }\n\n      // e. Perform ? Set(targetObj, Pk, mappedValue, true).\n      Properties.Set(realm, targetObj, Pk, mappedValue, true);\n\n      // f. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 14. Return targetObj.\n    return targetObj;\n  });\n\n  // ECMA262 22.2.2.2\n  func.defineNativeMethod(\"of\", 0, (context, items, argCount) => {\n    // 1. Let len be the actual number of arguments passed to this function.\n    let len = argCount;\n\n    // 2. Let items be the List of arguments passed to this function.\n    items;\n\n    // 3. Let C be the this value.\n    let C = context;\n\n    // 4. If IsConstructor(C) is false, throw a TypeError exception.\n    if (IsConstructor(realm, C) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n    }\n    invariant(C instanceof ObjectValue);\n\n    // 5. Let newObj be ? TypedArrayCreate(C, « len »).\n    let newObj = TypedArrayCreate(realm, C, [new NumberValue(realm, len)]);\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let kValue be items[k].\n      let kValue = items[k];\n\n      // b. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // c. Perform ? Set(newObj, Pk, kValue, true).\n      Properties.Set(realm, newObj, Pk, kValue, true);\n\n      // d. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return newObj.\n    return newObj;\n  });\n\n  // ECMA262 22.2.2.4\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n\n// ECMA262 22.2 Table 50\nfunction getConstructorName(type: ElementType): TypedArrayKind {\n  switch (type) {\n    case \"Float32\":\n      return \"Float32Array\";\n    case \"Float64\":\n      return \"Float64Array\";\n    case \"Int8\":\n      return \"Int8Array\";\n    case \"Int16\":\n      return \"Int16Array\";\n    case \"Int32\":\n      return \"Int32Array\";\n    case \"Uint8\":\n      return \"Uint8Array\";\n    case \"Uint16\":\n      return \"Uint16Array\";\n    case \"Uint32\":\n      return \"Uint32Array\";\n    case \"Uint8Clamped\":\n      return \"Uint8ClampedArray\";\n    default:\n      invariant(false);\n  }\n}\n\nexport function build(realm: Realm, type: ElementType): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, `${type}Array`, `${type}Array`, 3, (context, args, argCount, NewTarget) => {\n    if (argCount === 0) {\n      // ECMA262 22.2.4.1\n\n      // 1. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 2. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 3. Return ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", 0).\n      return AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`, 0);\n    } else if (!(args[0] instanceof ObjectValue)) {\n      // ECMA262 22.2.4.2\n      let length = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(length) is not Object.\n      invariant(!(length instanceof ObjectValue), \"Type(length) is not Object\");\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let elementLength be ? ToIndex(length).\n      let elementLength = To.ToIndexPartial(realm, length);\n\n      // 4. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 5. Return ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\", elementLength).\n      return AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`, elementLength);\n    } else if (\"$TypedArrayName\" in args[0]) {\n      // ECMA262 22.2.4.3\n      let typedArray = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(typedArray) is Object and typedArray has a [[TypedArrayName]] internal slot.\n      invariant(typedArray instanceof ObjectValue && typeof typedArray.$TypedArrayName === \"string\");\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let srcArray be typedArray.\n      let srcArray = typedArray;\n\n      // 6. Let srcData be srcArray.[[ViewedArrayBuffer]].\n      let srcData = srcArray.$ViewedArrayBuffer;\n      invariant(srcData);\n\n      // 7. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcData) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcData) is true\");\n      }\n\n      // 8. Let constructorName be the String value of O.[[TypedArrayName]].\n      constructorName = O.$TypedArrayName;\n      invariant(typeof constructorName === \"string\");\n\n      // 9. Let elementType be the String value of the Element Type value in Table 50 for constructorName.\n      let elementType = ArrayElementType[constructorName];\n\n      // 10. Let elementLength be srcArray.[[ArrayLength]].\n      let elementLength = srcArray.$ArrayLength;\n      invariant(typeof elementLength === \"number\");\n\n      // 11. Let srcName be the String value of srcArray.[[TypedArrayName]].\n      let srcName = srcArray.$TypedArrayName;\n      invariant(typeof srcName === \"string\");\n\n      // 12. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 13. Let srcElementSize be the Element Size value in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 14. Let srcByteOffset be srcArray.[[ByteOffset]].\n      let srcByteOffset = srcArray.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // 15. Let elementSize be the Element Size value in Table 50 for constructorName.\n      let elementSize = ArrayElementSize[constructorName];\n\n      // 16. Let byteLength be elementSize × elementLength.\n      let byteLength = elementSize * elementLength;\n\n      let data;\n      // 17. If SameValue(elementType, srcType) is true, then\n      if (elementType === srcType) {\n        // a. Let data be ? CloneArrayBuffer(srcData, srcByteOffset).\n        data = CloneArrayBuffer(realm, srcData, srcByteOffset);\n      } else {\n        // 18. Else,\n        // a. Let bufferConstructor be ? SpeciesConstructor(srcData, %ArrayBuffer%).\n        let bufferConstructor = SpeciesConstructor(realm, srcData, realm.intrinsics.ArrayBuffer);\n\n        // b. Let data be ? AllocateArrayBuffer(bufferConstructor, byteLength).\n        data = AllocateArrayBuffer(realm, bufferConstructor, byteLength);\n\n        // c. If IsDetachedBuffer(srcData) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, srcData) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcData) is true\");\n        }\n\n        // d. Let srcByteIndex be srcByteOffset.\n        let srcByteIndex = srcByteOffset;\n\n        // e. Let targetByteIndex be 0.\n        let targetByteIndex = 0;\n\n        // f. Let count be elementLength.\n        let count = elementLength;\n\n        // g. Repeat, while count > 0\n        while (count > 0) {\n          // i. Let value be GetValueFromBuffer(srcData, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcData, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(data, targetByteIndex, elementType, value).\n          SetValueInBuffer(realm, data, targetByteIndex, elementType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + elementSize.\n          targetByteIndex = targetByteIndex + elementSize;\n\n          // v. Decrement count by 1.\n          count -= 1;\n        }\n      }\n\n      // 19. Set O.[[ViewedArrayBuffer]] to data.\n      O.$ViewedArrayBuffer = data;\n\n      // 20. Set O.[[ByteLength]] to byteLength.\n      O.$ByteLength = byteLength;\n\n      // 21. Set O.[[ByteOffset]] to 0.\n      O.$ByteOffset = 0;\n\n      // 22. Set O.[[ArrayLength]] to elementLength.\n      O.$ArrayLength = elementLength;\n\n      // 23. Return O.\n      return O;\n    } else if (!(\"$ArrayBufferData\" in args[0]) && !(\"$TypedArrayName\" in args[0])) {\n      // ECMA262 22.2.4.4\n      let object = args[0].throwIfNotConcrete();\n\n      // 1. Assert: Type(object) is Object and object does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.\n      invariant(object instanceof ObjectValue && typeof object.$TypedArrayName && !object.$ArrayBufferData);\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let usingIterator be ? GetMethod(object, @@iterator).\n      let usingIterator = GetMethod(realm, object, realm.intrinsics.SymbolIterator);\n\n      // 6. If usingIterator is not undefined, then\n      if (!(usingIterator instanceof UndefinedValue)) {\n        // a. Let values be ? IterableToList(object, usingIterator).\n        let values = IterableToList(realm, object, usingIterator);\n\n        // b. Let len be the number of elements in values.\n        let len = values.length;\n\n        // c. Perform ? AllocateTypedArrayBuffer(O, len).\n        AllocateTypedArrayBuffer(realm, O, len);\n\n        // d. Let k be 0.\n        let k = 0;\n\n        // e. Repeat, while k < len\n        while (k < len) {\n          // i. Let Pk be ! ToString(k).\n          let Pk = new StringValue(realm, To.ToString(realm, new NumberValue(realm, k)));\n\n          // ii. Let kValue be the first element of values and remove that element from values.\n          let kValue = values.shift();\n\n          // iii. Perform ? Set(O, Pk, kValue, true).\n          Properties.Set(realm, O, Pk, kValue, true);\n\n          // iv. Increase k by 1.\n          k = k + 1;\n        }\n\n        // f. Assert: values is now an empty List.\n        invariant(values.length === 0);\n\n        // g. Return O.\n        return O;\n      }\n\n      // 7. NOTE: object is not an Iterable so assume it is already an array-like object.\n\n      // 8. Let arrayLike be object.\n      let arrayLike = object;\n\n      // 9. Let len be ? ToLength(? Get(arrayLike, \"length\")).\n      let len = To.ToLength(realm, Get(realm, arrayLike, \"length\"));\n\n      // 10. Perform ? AllocateTypedArrayBuffer(O, len).\n      AllocateTypedArrayBuffer(realm, O, len);\n\n      // 11. Let k be 0.\n      let k = 0;\n\n      // 12. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, To.ToString(realm, new NumberValue(realm, k)));\n\n        // b. Let kValue be ? Get(arrayLike, Pk).\n        let kValue = Get(realm, arrayLike, Pk);\n\n        // c. Perform ? Set(O, Pk, kValue, true).\n        Properties.Set(realm, O, Pk, kValue, true);\n\n        // d. Increase k by 1.\n        k += 1;\n      }\n\n      // 13. Return O.\n      return O;\n    } else {\n      // ECMA262 22.2.4.5\n      let buffer = args[0].throwIfNotConcrete(),\n        byteOffset = args[1],\n        length = args[2];\n\n      // 1. Assert: Type(buffer) is Object and buffer has an [[ArrayBufferData]] internal slot.\n      invariant(buffer instanceof ObjectValue && \"$ArrayBufferData\" in buffer);\n\n      // 2. If NewTarget is undefined, throw a TypeError exception.\n      if (!NewTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"NewTarget is undefined\");\n      }\n\n      // 3. Let constructorName be the String value of the Constructor Name value specified in Table 50 for this TypedArray constructor.\n      let constructorName = getConstructorName(type);\n\n      // 4. Let O be ? AllocateTypedArray(constructorName, NewTarget, \"%TypedArrayPrototype%\").\n      let O = AllocateTypedArray(realm, constructorName, NewTarget, `${type}ArrayPrototype`);\n\n      // 5. Let constructorName be the String value of O.[[TypedArrayName]].\n      constructorName = O.$TypedArrayName;\n      invariant(constructorName);\n\n      // 6. Let elementSize be the Number value of the Element Size value in Table 50 for constructorName.\n      let elementSize = ArrayElementSize[constructorName];\n\n      // 7. Let offset be ? ToIndex(byteOffset).\n      let offset = To.ToIndexPartial(realm, byteOffset);\n\n      // 8. If offset modulo elementSize ≠ 0, throw a RangeError exception.\n      if (offset % elementSize !== 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"offset modulo elementSize ≠ 0\");\n      }\n\n      // 9. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, buffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(buffer) is true\");\n      }\n\n      // 10. Let bufferByteLength be buffer.[[ArrayBufferByteLength]].\n      let bufferByteLength = buffer.$ArrayBufferByteLength;\n      invariant(typeof bufferByteLength === \"number\");\n\n      let newByteLength;\n      // 11. If length is either not present or undefined, then\n      if (!length || length instanceof UndefinedValue) {\n        // a. If bufferByteLength modulo elementSize ≠ 0, throw a RangeError exception.\n        if (bufferByteLength % elementSize !== 0) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.RangeError,\n            \"bufferByteLength modulo elementSize ≠ 0\"\n          );\n        }\n        // b. Let newByteLength be bufferByteLength - offset.\n        newByteLength = bufferByteLength - offset;\n\n        // c. If newByteLength < 0, throw a RangeError exception.\n        if (newByteLength < 0) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"newByteLength < 0\");\n        }\n      } else {\n        // 12. Else,\n        // a. Let newLength be ? ToIndex(length).\n        let newLength = To.ToIndexPartial(realm, length);\n\n        // b. Let newByteLength be newLength × elementSize.\n        newByteLength = newLength * elementSize;\n\n        // c. If offset+newByteLength > bufferByteLength, throw a RangeError exception.\n        if (offset + newByteLength > bufferByteLength) {\n          throw realm.createErrorThrowCompletion(\n            realm.intrinsics.RangeError,\n            \"offset+newByteLength > bufferByteLength\"\n          );\n        }\n      }\n\n      // 13. Set O.[[ViewedArrayBuffer]] to buffer.\n      O.$ViewedArrayBuffer = buffer;\n\n      // 14. Set O.[[ByteLength]] to newByteLength.\n      O.$ByteLength = newByteLength;\n\n      // 15. Set O.[[ByteOffset]] to offset.\n      O.$ByteOffset = offset;\n\n      // 16. Set O.[[ArrayLength]] to newByteLength / elementSize.\n      O.$ArrayLength = newByteLength / elementSize;\n\n      // 17. Return O.\n      return O;\n    }\n  });\n\n  // ECMA262 22.2.5\n  func.$Prototype = realm.intrinsics.TypedArray;\n\n  // ECMA262 22.2.5.1\n  func.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n\n  return func;\n}\n"]}