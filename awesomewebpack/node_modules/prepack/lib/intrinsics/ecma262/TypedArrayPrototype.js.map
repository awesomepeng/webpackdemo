{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArrayPrototype.js"],"names":["realm","obj","defineNativeGetter","context","O","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","$ViewedArrayBuffer","buffer","zero","size","$ByteLength","offset","$ByteOffset","defineNativeMethod","target","start","end","ToObject","len","throwIfNotConcreteObject","$ArrayLength","relativeTarget","ToInteger","to","Math","max","min","relativeStart","from","relativeEnd","final","count","direction","fromKey","ToString","toKey","fromPresent","fromVal","Set","DeletePropertyOrThrow","CreateArrayIterator","callbackfn","thisArg","T","undefined","k","Pk","kPresent","kValue","testResult","ToBooleanPartial","false","true","value","kept","captured","selected","push","A","n","e","predicate","searchElement","fromIndex","elementK","Object","is","same","_separator","separator","sep","ToStringPartial","emptyString","element0","R","S","element","next","length","mappedValue","initialValue","accumulator","middle","floor","lower","upper","upperP","lowerP","lowerExists","lowerValue","upperExists","upperValue","overloaded","$TypedArrayName","array","targetOffset","RangeError","targetBuffer","targetLength","targetName","targetElementSize","targetType","targetByteOffset","src","srcLength","ToLength","targetByteIndex","limit","kNumber","ToNumber","typedArray","srcBuffer","srcName","srcType","srcElementSize","srcByteOffset","srcByteIndex","ArrayBuffer","elementSize","comparefn","SortCompare","x","y","mightBeUndefined","v","isNaN","comparefn_","result_","numb","arr","j","val","sort","begin","relativeBegin","beginIndex","endIndex","newLength","constructorName","beginByteOffset","argumentsList","firstElement","nextElement","defineNativeProperty","ArrayProto_toString","TypedArrayProto_values","SymbolIterator","SymbolToStringTag","name","build","type","$Prototype","TypedArrayPrototype","defineNativeConstant"],"mappings":"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","file":"TypedArrayPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { ObjectValue, StringValue, NumberValue, UndefinedValue, NullValue } from \"../../values/index.js\";\nimport { Call, Invoke } from \"../../methods/call.js\";\nimport { Get } from \"../../methods/get.js\";\nimport { HasProperty, HasSomeCompatibleType } from \"../../methods/has.js\";\nimport { IsDetachedBuffer, IsCallable } from \"../../methods/is.js\";\nimport {\n  ArrayElementSize,\n  ArrayElementType,\n  ValidateTypedArray,\n  TypedArraySpeciesCreate,\n  IntegerIndexedElementSet,\n  IntegerIndexedElementGet,\n} from \"../../methods/typedarray.js\";\nimport { SetValueInBuffer, GetValueFromBuffer, CloneArrayBuffer } from \"../../methods/arraybuffer.js\";\nimport { SameValue, SameValueZeroPartial, StrictEqualityComparisonPartial } from \"../../methods/abstract.js\";\nimport { Create, Properties, To } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 22.2.3.1\n  obj.defineNativeGetter(\"buffer\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]]\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n\n    // 6. Return buffer.\n    return buffer;\n  });\n\n  // ECMA262 22.2.3.2\n  obj.defineNativeGetter(\"byteLength\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let size be O.[[ByteLength]].\n    let size = O.$ByteLength;\n    invariant(typeof size === \"number\");\n\n    // 8. Return size.\n    return new NumberValue(realm, size);\n  });\n\n  // ECMA262 22.2.3.3\n  obj.defineNativeGetter(\"byteOffset\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let offset be O.[[ByteOffset]].\n    let offset = O.$ByteOffset;\n    invariant(typeof offset === \"number\");\n\n    // 8. Return offset.\n    return new NumberValue(realm, offset);\n  });\n\n  // ECMA262 22.2.3.5\n  obj.defineNativeMethod(\"copyWithin\", 2, (context, [target, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeTarget be ? ToInteger(target).\n    let relativeTarget = To.ToInteger(realm, target);\n\n    // 5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).\n    let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);\n\n    // 6. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start);\n\n    // 7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).\n    let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 10. Let count be min(final-from, len-to).\n    let count = Math.min(final - from, len - to);\n\n    let direction;\n    // 11. If from<to and to<from+count, then\n    if (from < to && to < from + count) {\n      // a. Let direction be -1.\n      direction = -1;\n\n      // b. Let from be from + count - 1.\n      from = from + count - 1;\n\n      // c. Let to be to + count - 1.\n      to = to + count - 1;\n    } else {\n      // 12. Else,\n      // a. Let direction be 1.\n      direction = 1;\n    }\n\n    // 13. Repeat, while count > 0\n    while (count > 0) {\n      // a. Let fromKey be ! ToString(from).\n      let fromKey = To.ToString(realm, new NumberValue(realm, from));\n\n      // b. Let toKey be ! ToString(to).\n      let toKey = To.ToString(realm, new NumberValue(realm, to));\n\n      // c. Let fromPresent be ? HasProperty(O, fromKey).\n      let fromPresent = HasProperty(realm, O, fromKey);\n\n      // d. If fromPresent is true, then\n      if (fromPresent === true) {\n        // i. Let fromVal be ? Get(O, fromKey).\n        let fromVal = Get(realm, O, fromKey);\n        // ii. Perform ? Set(O, toKey, fromVal, true).\n        Properties.Set(realm, O, toKey, fromVal, true);\n      } else {\n        // e. Else fromPresent is false,\n        // i. Perform ? DeletePropertyOrThrow(O, toKey).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), toKey);\n      }\n\n      // f. Let from be from + direction.\n      from = from + direction;\n\n      // g. Let to be to + direction.\n      to = to + direction;\n\n      // h. Let count be count - 1.\n      count = count - 1;\n    }\n\n    // 14. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.6\n  obj.defineNativeMethod(\"entries\", 0, context => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key+value\").\n    return Create.CreateArrayIterator(realm, O, \"key+value\");\n  });\n\n  // ECMA262 22.2.3.7\n  obj.defineNativeMethod(\"every\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is false, return false.\n        if (!testResult) return realm.intrinsics.false;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return true.\n    return realm.intrinsics.true;\n  });\n\n  // ECMA262 22.2.3.8\n  obj.defineNativeMethod(\"fill\", 1, (context, [value, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start || realm.intrinsics.undefined);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Repeat, while k < final\n    while (k < final) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Perform ? Set(O, Pk, value, true).\n      Properties.Set(realm, O, Pk, value, true);\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.9\n  obj.defineNativeMethod(\"filter\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let kept be a new empty List.\n    let kept = [];\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Let captured be 0.\n    let captured = 0;\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let selected be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n      let selected = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If selected is true, then\n      if (selected === true) {\n        // i. Append kValue to the end of kept.\n        kept.push(kValue);\n\n        // ii. Increase captured by 1.\n        captured += 1;\n      }\n\n      // e. Increase k by 1.\n      k += 1;\n    }\n\n    // 10. Let A be ? TypedArraySpeciesCreate(O, « captured »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, captured)]);\n\n    // 11. Let n be 0.\n    let n = 0;\n\n    // 12. For each element e of kept\n    for (let e of kept) {\n      // a. Perform ! Set(A, ! ToString(n), e, true).\n      Properties.Set(realm, A, new StringValue(realm, To.ToString(realm, new NumberValue(realm, n))), e, true);\n\n      // b. Increment n by 1.\n      n = n + 1;\n    }\n\n    // 13. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.10\n  obj.defineNativeMethod(\"find\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (!IsCallable(realm, predicate)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = To.ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return kValue.\n      if (testResult) return kValue;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.11\n  obj.defineNativeMethod(\"findIndex\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (IsCallable(realm, predicate) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, new StringValue(realm, Pk));\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n      let testResult = To.ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return k.\n      if (testResult === true) return new NumberValue(realm, k);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.12\n  obj.defineNativeMethod(\"forEach\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Perform ? Call(callbackfn, T, « kValue, k, O »).\n        Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"includes\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return false.\n    if (len === 0) return realm.intrinsics.false;\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = To.ToInteger(realm, fromIndex || realm.intrinsics.undefined);\n\n    let k;\n    // 6. If n ≥ 0, then\n    if (n >= 0) {\n      // a. Let k be n.\n      k = n;\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n      let elementK = Get(realm, O, To.ToString(realm, new NumberValue(realm, k)));\n\n      // b. If SameValueZero(searchElement, elementK) is true, return true.\n      if (SameValueZeroPartial(realm, searchElement, elementK) === true) return realm.intrinsics.true;\n\n      // c. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"indexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = fromIndex ? To.ToInteger(realm, fromIndex) : 0;\n\n    // 6. If n ≥ len, return -1.\n    if (n >= len) return new NumberValue(realm, -1);\n\n    // 7. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be n.\n      k = Object.is(n, -0) ? +0 : n;\n    } else {\n      // 8. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, k + \"\");\n\n      // b. If kPresent is true, then\n      if (kPresent === true) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, k + \"\");\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.15\n  obj.defineNativeMethod(\"join\", 1, (context, [_separator]) => {\n    let separator = _separator;\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If separator is undefined, let separator be the single-element String \",\".\n    if (!separator || separator instanceof UndefinedValue) separator = new StringValue(realm, \",\");\n\n    // 5. Let sep be ? ToString(separator).\n    let sep = To.ToStringPartial(realm, separator);\n\n    // 6. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 7. Let element0 be Get(O, \"0\").\n    let element0 = Get(realm, O, \"0\");\n\n    // 8. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).\n    let R: ?string;\n    if (HasSomeCompatibleType(element0, UndefinedValue, NullValue)) {\n      R = \"\";\n    } else {\n      R = To.ToStringPartial(realm, element0);\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be the String value produced by concatenating R and sep.\n      let S: string = R + sep;\n\n      // b. Let element be ? Get(O, ! ToString(k)).\n      let element = Get(realm, O, new StringValue(realm, k + \"\"));\n\n      // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).\n      let next: ?string;\n      if (HasSomeCompatibleType(element, UndefinedValue, NullValue)) {\n        next = \"\";\n      } else {\n        next = To.ToStringPartial(realm, element);\n      }\n\n      // d. Let R be a String value produced by concatenating S and next.\n      R = S + next;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R + \"\");\n  });\n\n  // ECMA262 22.2.3.16\n  obj.defineNativeMethod(\"keys\", 0, context => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key\").\n    return Create.CreateArrayIterator(realm, O, \"key\");\n  });\n\n  // ECMA262 22.2.3.17\n  obj.defineNativeMethod(\"lastIndexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.\n    let n = fromIndex ? To.ToInteger(realm, fromIndex) : len - 1;\n\n    // 6. If n ≥ 0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be min(n, len - 1).\n      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n    }\n\n    // 8. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, new StringValue(realm, k + \"\"));\n\n      // b. If kPresent is true, then\n      if (kPresent) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, new StringValue(realm, k + \"\"));\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Decrease k by 1.\n      k--;\n    }\n\n    // 9. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.18\n  obj.defineNativeGetter(\"length\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let length be O.[[ArrayLength]].\n    let length = O.$ArrayLength;\n    invariant(typeof length === \"number\");\n\n    // 8. Return length.\n    return new NumberValue(realm, length);\n  });\n\n  // ECMA262 22.2.3.19\n  obj.defineNativeMethod(\"map\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let A be ? TypedArraySpeciesCreate(O, « len »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, len)]);\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).\n      let mappedValue = Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n\n      // d. Perform ? Set(A, Pk, mappedValue, true).\n      Properties.Set(realm, A, Pk, mappedValue, true);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.20\n  obj.defineNativeMethod(\"reduce\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // a. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k < len\n      while (kPresent === false && k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iv. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // v. Increase k by 1.\n        k++;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"kPresent is false\");\n      }\n\n      invariant(accumulator);\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reduceRight\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be len-1.\n    let k = len - 1;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // 1. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k ≥ 0\n      while (!kPresent && k >= 0) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iii. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // iv. Decrease k by 1.\n        k--;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent || !accumulator) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n      }\n    }\n\n    // 9. Repeat, while k ≥ 0\n    while (k >= 0) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Decrease k by 1.\n      k--;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reverse\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let middle be floor(len/2).\n    let middle = Math.floor(len / 2);\n\n    // 5. Let lower be 0.\n    let lower = 0;\n\n    // 6. Repeat, while lower ≠ middle\n    while (lower !== middle) {\n      // a. Let upper be len - lower - 1.\n      let upper = len - lower - 1;\n\n      // b. Let upperP be ! ToString(upper).\n      let upperP = new StringValue(realm, upper + \"\");\n\n      // c. Let lowerP be ! ToString(lower).\n      let lowerP = new StringValue(realm, lower + \"\");\n\n      // d. Let lowerExists be ? HasProperty(O, lowerP).\n      let lowerExists = HasProperty(realm, O, lowerP);\n\n      // e. If lowerExists is true, then\n      let lowerValue;\n      if (lowerExists) {\n        // i. Let lowerValue be ? Get(O, lowerP).\n        lowerValue = Get(realm, O, lowerP);\n      }\n\n      // f. Let upperExists be ? HasProperty(O, upperP).\n      let upperExists = HasProperty(realm, O, upperP);\n\n      // g. If upperExists is true, then\n      let upperValue;\n      if (upperExists) {\n        // i. Let upperValue be ? Get(O, upperP).\n        upperValue = Get(realm, O, upperP);\n      }\n\n      // h. If lowerExists is true and upperExists is true, then\n      if (lowerExists && upperExists) {\n        invariant(lowerValue, \"expected lower value to exist\");\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else if (!lowerExists && upperExists) {\n        // i. Else if lowerExists is false and upperExists is true, then\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? DeletePropertyOrThrow(O, upperP).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), upperP);\n      } else if (lowerExists && !upperExists) {\n        // j. Else if lowerExists is true and upperExists is false, then\n        invariant(lowerValue, \"expected lower value to exist\");\n\n        // i. Perform ? DeletePropertyOrThrow(O, lowerP).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), lowerP);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else {\n        // k. Else both lowerExists and upperExists are false,\n        // i. No action is required.\n      }\n\n      // l. Increase lower by 1.\n      lower++;\n    }\n\n    // 7. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.23\n  obj.defineNativeMethod(\"set\", 1, (context, [overloaded, offset]) => {\n    if (!overloaded.$TypedArrayName) {\n      let array = overloaded;\n\n      // 1. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.\n      invariant(!(overloaded instanceof ObjectValue && overloaded.$TypedArrayName));\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"target does not have a [[TypedArrayName]] internal slot\"\n        );\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer, \"target has a [[ViewedArrayBuffer]] internal slot\");\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = To.ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength;\n      invariant(typeof targetLength === \"number\");\n\n      // 11. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 12. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 14. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset;\n      invariant(typeof targetByteOffset === \"number\");\n\n      // 15. Let src be ? ToObject(array).\n      let src = To.ToObject(realm, array);\n\n      // 16. Let srcLength be ? ToLength(? Get(src, \"length\")).\n      let srcLength = To.ToLength(realm, Get(realm, src, \"length\"));\n\n      // 17. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      // 18. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 19. Let k be 0.\n      let k = 0;\n\n      // 20. Let limit be targetByteIndex + targetElementSize × srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 21. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // b. Let kNumber be ? ToNumber(? Get(src, Pk)).\n        let kNumber = To.ToNumber(realm, Get(realm, src, Pk));\n\n        // c. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, targetBuffer) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n        }\n\n        // d. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, kNumber);\n\n        // e. Set k to k + 1.\n        k = k + 1;\n\n        // f. Set targetByteIndex to targetByteIndex + targetElementSize.\n        targetByteIndex = targetByteIndex + targetElementSize;\n      }\n\n      // 22. Return undefined.\n      return realm.intrinsics.undefined;\n    } else {\n      let typedArray = overloaded;\n\n      // 1. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.\n      invariant(typedArray instanceof ObjectValue && typedArray.$TypedArrayName);\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"target does not have a [[TypedArrayName]] internal slot\"\n        );\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer);\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = To.ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength;\n      invariant(typeof targetLength === \"number\");\n\n      // 11. Let srcBuffer be typedArray.[[ViewedArrayBuffer]].\n      let srcBuffer = typedArray.$ViewedArrayBuffer;\n      invariant(srcBuffer);\n\n      // 12. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // 13. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 14. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 15. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 16. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset;\n      invariant(typeof targetByteOffset === \"number\");\n\n      // 17. Let srcName be the String value of typedArray.[[TypedArrayName]].\n      let srcName = typedArray.$TypedArrayName;\n      invariant(typeof srcName === \"string\");\n\n      // 18. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 19. Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 20. Let srcLength be typedArray.[[ArrayLength]].\n      let srcLength = typedArray.$ArrayLength;\n      invariant(typeof srcLength === \"number\");\n\n      // 21. Let srcByteOffset be typedArray.[[ByteOffset]].\n      let srcByteOffset = typedArray.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // 22. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      let srcByteIndex;\n      // 23. If SameValue(srcBuffer, targetBuffer) is true, then\n      if (SameValue(realm, srcBuffer, targetBuffer) === true) {\n        // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset, %ArrayBuffer%).\n        srcBuffer = CloneArrayBuffer(realm, targetBuffer, srcByteOffset, realm.intrinsics.ArrayBuffer);\n\n        // b. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.\n\n        // c. Let srcByteIndex be 0.\n        srcByteIndex = 0;\n      } else {\n        // 24. Else, let srcByteIndex be srcByteOffset.\n        srcByteIndex = srcByteOffset;\n      }\n\n      // 25. Let targetByteIndex be targetOffset × targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 26. Let limit be targetByteIndex + targetElementSize × srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 27. If SameValue(srcType, targetType) is true, then\n      if (srcType === targetType) {\n        // a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n        // b. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + 1.\n          srcByteIndex += 1;\n\n          // iv. Set targetByteIndex to targetByteIndex + 1.\n          targetByteIndex += 1;\n        }\n      } else {\n        // 28. Else,\n        // a. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + targetElementSize.\n          targetByteIndex = targetByteIndex + targetElementSize;\n        }\n      }\n\n      // 29. Return undefined.\n      return realm.intrinsics.undefined;\n    }\n  });\n\n  // ECMA262 22.2.3.24\n  obj.defineNativeMethod(\"slice\", 2, (context, [start, end]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Let count be max(final - k, 0).\n    let count = Math.max(final - k, 0);\n\n    // 9. Let A be ? TypedArraySpeciesCreate(O, « count »).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, count)]);\n\n    // 10. Let srcName be the String value of O.[[TypedArrayName]].\n    let srcName = O.$TypedArrayName;\n    invariant(typeof srcName === \"string\");\n\n    // 11. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n    let srcType = ArrayElementType[srcName];\n\n    // 12. Let targetName be the String value of A.[[TypedArrayName]].\n    let targetName = A.$TypedArrayName;\n    invariant(typeof targetName === \"string\");\n\n    // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n    let targetType = ArrayElementType[targetName];\n\n    // 14. If SameValue(srcType, targetType) is false, then\n    if (srcType !== targetType) {\n      // a. Let n be 0.\n      let n = 0;\n\n      // b. Repeat, while k < final\n      while (k < final) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // iii. Perform ! Set(A, ! ToString(n), kValue).\n        Properties.Set(realm, A, To.ToString(realm, new NumberValue(realm, n)), kValue, true);\n\n        // iv. Increase k by 1.\n        k += 1;\n\n        // v. Increase n by 1.\n        n += 1;\n      }\n    } else if (count > 0) {\n      // 15. Else if count > 0, then\n      // a. Let srcBuffer be O.[[ViewedArrayBuffer]].\n      let srcBuffer = O.$ViewedArrayBuffer;\n      invariant(srcBuffer);\n\n      // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // c. Let targetBuffer be A.[[ViewedArrayBuffer]].\n      let targetBuffer = A.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // d. Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.\n      let elementSize = ElementSize[srcType];\n\n      // e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n      // f. Let srcByteOffset be O.[[ByteOffset]].\n      let srcByteOffset = O.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // g. Let targetByteIndex be A.[[ByteOffset]].\n      let targetByteIndex = A.$ByteOffset;\n      invariant(typeof targetByteIndex === \"number\");\n\n      // h. Let srcByteIndex be (k × elementSize) + srcByteOffset.\n      let srcByteIndex = k * elementSize + srcByteOffset;\n\n      // i. Let limit be targetByteIndex + count × elementSize.\n      let limit = targetByteIndex + count * elementSize;\n\n      // j. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n        let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n        // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n        // iii. Increase srcByteIndex by 1.\n        srcByteIndex += 1;\n\n        // iv. Increase targetByteIndex by 1.\n        targetByteIndex += 1;\n      }\n    }\n\n    // 16. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.25\n  obj.defineNativeMethod(\"some\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"callback passed to Array.prototype.some isn't callable\"\n      );\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).\n        let testResult = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is true, return true.\n        if (testResult) return realm.intrinsics.true;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.26\n  obj.defineNativeMethod(\"sort\", 1, (context, [comparefn]) => {\n    // 1. Let obj be the this value.\n    let O = To.ToObject(realm, context);\n\n    // 2. Let buffer be ? ValidateTypedArray(obj).\n    let buffer = ValidateTypedArray(realm, O);\n\n    // 3. Let len be the value of obj's [[ArrayLength]] internal slot.\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 22.2.3.26 Runtime Semantics: SortCompare( x, y )#\n    let SortCompare = (x, y) => {\n      // 1. Assert: Both Type(x) and Type(y) is Number.\n      invariant(x instanceof NumberValue);\n      invariant(y instanceof NumberValue);\n\n      // 2. If the argument comparefn is not undefined, then\n      if (!comparefn.mightBeUndefined()) {\n        // a. Let v be ? Call(comparefn, undefined, « x, y »).\n        let v = Call(realm, comparefn, realm.intrinsics.undefined, [x, y]);\n\n        // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, buffer) === true)\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"array buffer has been detached\");\n\n        // c. If v is NaN, return +0.\n        if (v instanceof NumberValue && isNaN(v.value)) return realm.intrinsics.zero;\n\n        // d. Return v.\n        return v;\n      }\n      comparefn.throwIfNotConcrete();\n\n      // If x and y are both NaN, return +0.\n      // If x is NaN, return 1.\n      if (isNaN(x.value)) {\n        if (isNaN(y.value)) return realm.intrinsics.zero;\n        return new NumberValue(realm, 1);\n      }\n\n      // If y is NaN, return -1.\n      if (isNaN(y.value)) return new NumberValue(realm, -1);\n\n      // If x < y, return -1.\n      if (x.value < y.value) return new NumberValue(realm, -1);\n\n      // If x > y, return 1.\n      if (x.value > y.value) return new NumberValue(realm, +1);\n\n      // If x is -0 and y is +0, return -1.\n      if (Object.is(x.value, -0) && Object.is(y.value, +0)) return new NumberValue(realm, -1);\n\n      // If x is +0 and y is -0, return 1.\n      if (Object.is(x.value, +0) && Object.is(y.value, -0)) return new NumberValue(realm, 1);\n\n      // Return +0.\n      return realm.intrinsics.zero;\n    };\n\n    //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:\n    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.\n\n    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and\n    // transfering back the value inside the our array.\n\n    // We need to adapt the comparefn function to match the expected types\n    let comparefn_ = (x, y) => {\n      invariant(x instanceof NumberValue, \"Unexpected type\");\n      invariant(y instanceof NumberValue, \"Unexpected type\");\n\n      let result_ = SortCompare(x, y);\n      let numb = To.ToNumber(realm, result_);\n      return numb;\n    };\n\n    let arr = [];\n    for (let j = 0; j < len; j++) {\n      let val = IntegerIndexedElementGet(realm, O.throwIfNotConcreteObject(), j);\n      arr[j] = val;\n    }\n\n    arr.sort(comparefn_);\n\n    //Apply the permutation back to the original array.\n    for (let j = 0; j < len; j++) {\n      IntegerIndexedElementSet(realm, O.throwIfNotConcreteObject(), j, arr[j]);\n    }\n\n    // 2. Return obj;\n    return context;\n  });\n\n  // ECMA262 22.2.3.27\n  obj.defineNativeMethod(\"subarray\", 2, (context, [begin, end]) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. Let srcLength be O.[[ArrayLength]].\n    let srcLength = O.$ArrayLength;\n    invariant(typeof srcLength === \"number\");\n\n    // 7. Let relativeBegin be ? ToInteger(begin).\n    let relativeBegin = To.ToInteger(realm, begin);\n\n    // 8. If relativeBegin < 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).\n    let beginIndex = relativeBegin < 0 ? Math.max(srcLength + relativeBegin, 0) : Math.min(relativeBegin, srcLength);\n\n    // 9. If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? srcLength : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 10. If relativeEnd < 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).\n    let endIndex = relativeEnd < 0 ? Math.max(srcLength + relativeEnd, 0) : Math.min(relativeEnd, srcLength);\n\n    // 11. Let newLength be max(endIndex - beginIndex, 0).\n    let newLength = Math.max(endIndex - beginIndex, 0);\n\n    // 12. Let constructorName be the String value of O.[[TypedArrayName]].\n    let constructorName = O.$TypedArrayName;\n    invariant(typeof constructorName === \"string\");\n\n    // 13. Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.\n    let elementSize = ArrayElementSize[constructorName];\n\n    // 14. Let srcByteOffset be O.[[ByteOffset]].\n    let srcByteOffset = O.$ByteOffset;\n    invariant(typeof srcByteOffset === \"number\");\n\n    // 15. Let beginByteOffset be srcByteOffset + beginIndex × elementSize.\n    let beginByteOffset = srcByteOffset + beginIndex * elementSize;\n\n    // 16. Let argumentsList be « buffer, beginByteOffset, newLength ».\n    let argumentsList = [buffer, new NumberValue(realm, beginByteOffset), new NumberValue(realm, newLength)];\n\n    // 17. Return ? TypedArraySpeciesCreate(O, argumentsList).\n    return TypedArraySpeciesCreate(realm, O, argumentsList);\n  });\n\n  // ECMA262 22.2.3.28\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    // 1. Let array be ? ToObject(this value).\n    let array = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(array).\n    ValidateTypedArray(realm, array);\n\n    // 3. Let len be array.[[ArrayLength]].\n    let len = array.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let separator be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).\n    let separator = \",\";\n\n    // 5. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 6. Let firstElement be ? Get(array, \"0\").\n    let firstElement = Get(realm, array, \"0\");\n\n    // 7. If firstElement is undefined or null, then\n    let R: ?string;\n    if (HasSomeCompatibleType(firstElement, UndefinedValue, NullValue)) {\n      // a. Let R be the empty String.\n      R = \"\";\n    } else {\n      // 8. Else,\n      // a. Let R be ? ToString(? Invoke(firstElement, \"toLocaleString\")).\n      R = To.ToStringPartial(realm, Invoke(realm, firstElement, \"toLocaleString\"));\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be a String value produced by concatenating R and separator.\n      let S: string = R + separator;\n\n      // b. Let nextElement be ? Get(array, ! ToString(k)).\n      let nextElement = Get(realm, array, new StringValue(realm, k + \"\"));\n\n      // c. If nextElement is undefined or null, then\n      if (HasSomeCompatibleType(nextElement, UndefinedValue, NullValue)) {\n        // i. Let R be the empty String.\n        R = \"\";\n      } else {\n        // d. Else,\n        // i. Let R be ? ToString(? Invoke(nextElement, \"toLocaleString\")).\n        R = To.ToStringPartial(realm, Invoke(realm, nextElement, \"toLocaleString\"));\n      }\n\n      // e. Let R be a String value produced by concatenating S and R.\n      R = S + R;\n\n      // f. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R);\n  });\n\n  // ECMA262 22.2.3.29\n  obj.defineNativeProperty(\"toString\", realm.intrinsics.ArrayProto_toString);\n\n  // ECMA262 22.2.3.30\n  obj.defineNativeProperty(\"values\", realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.31\n  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.32\n  obj.defineNativeGetter(realm.intrinsics.SymbolToStringTag, context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) return realm.intrinsics.undefined;\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.\n    if (!(\"$TypedArrayName\" in O)) return realm.intrinsics.undefined;\n\n    // 4. Let name be O.[[TypedArrayName]].\n    let name = O.$TypedArrayName;\n\n    // 5. Assert: name is a String value.\n    invariant(typeof name === \"string\", \"name is a String value\");\n\n    // 6. Return name.\n    return new StringValue(realm, name);\n  });\n}\n\nexport function build(realm: Realm, obj: ObjectValue, type: ElementType): void {\n  // ECMA262 22.2.6\n  obj.$Prototype = realm.intrinsics.TypedArrayPrototype;\n\n  // ECMA262 22.2.6.1\n  obj.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n}\n"]}