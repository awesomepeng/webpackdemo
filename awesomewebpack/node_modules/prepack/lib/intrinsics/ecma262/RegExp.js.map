{"version":3,"sources":["../../../src/intrinsics/ecma262/RegExp.js"],"names":["realm","func","context","pattern","flags","argCount","NewTarget","patternIsRegExp","newTarget","patternConstructor","P","F","$RegExpMatcher","$OriginalSource","$OriginalFlags","throwIfNotConcrete","O","defineNativeGetter","intrinsics","SymbolSpecies"],"mappings":";;;;;;kBAmBe,UAASA,KAAT,EAA4C;AACzD,MAAIC,OAAO,+BAAwBD,KAAxB,EAA+B,QAA/B,EAAyC,QAAzC,EAAmD,CAAnD,EAAsD,CAACE,OAAD,EAAU,CAACC,OAAD,EAAUC,KAAV,CAAV,EAA4BC,QAA5B,EAAsCC,SAAtC,KAAoD;AACnH;AACA,QAAIC,kBAAkB,kBAASP,KAAT,EAAgBG,OAAhB,CAAtB;AACA,QAAIK,SAAJ;AACA;AACA,QAAIF,SAAJ,EAAe;AACbE,kBAAYF,SAAZ;AACD,KAFD,MAEO;AACL;AACA;AACAE,kBAAYP,IAAZ;;AAEA;AACA,UAAIM,mBAAmBH,sCAAvB,EAAwD;AACtD,iCAAUD,qCAAV;AACA;AACA,YAAIM,qBAAqB,cAAIT,KAAJ,EAAWG,OAAX,EAAoB,aAApB,CAAzB;;AAEA;AACA,YAAI,gCAAiBH,KAAjB,EAAwBQ,SAAxB,EAAmCC,kBAAnC,CAAJ,EAA4D;AAC1D,iBAAON,OAAP;AACD;AACF;AACF;;AAED,QAAIO,CAAJ,EAAOC,CAAP;AACA;AACA,QAAIR,yCAAkCA,QAAQS,cAA9C,EAA8D;AAC5D;AACA,+BAAU,OAAOT,QAAQU,eAAf,KAAmC,QAA7C;AACAH,UAAI,uBAAgBV,KAAhB,EAAuBG,QAAQU,eAA/B,CAAJ;;AAEA;AACA,UAAIT,sCAAJ,EAAqC;AACnC,iCAAU,OAAOD,QAAQW,cAAf,KAAkC,QAA5C;AACAH,YAAI,uBAAgBX,KAAhB,EAAuBG,QAAQW,cAA/B,CAAJ;AACD,OAHD,MAGO;AACL;AACAH,YAAIP,MAAMW,kBAAN,EAAJ;AACD;AACF,KAbD,MAaO,IAAIR,eAAJ,EAAqB;AAC1B;AACA,+BAAUJ,qCAAV;AACA;AACAO,UAAI,cAAIV,KAAJ,EAAWG,OAAX,EAAoB,QAApB,CAAJ;;AAEA;AACA,UAAIC,sCAAJ,EAAqC;AACnC;AACAO,YAAI,cAAIX,KAAJ,EAAWG,OAAX,EAAoB,OAApB,CAAJ;AACD,OAHD,MAGO;AACL;AACAQ,YAAIP,MAAMW,kBAAN,EAAJ;AACD;AACF,KAdM,MAcA;AACL;AACA;AACAL,UAAIP,QAAQY,kBAAR,EAAJ;AACA;AACAJ,UAAIP,MAAMW,kBAAN,EAAJ;AACD;;AAED;AACA,QAAIC,IAAI,yBAAYhB,KAAZ,EAAmBQ,SAAnB,CAAR;;AAEA;AACA,WAAO,8BAAiBR,KAAjB,EAAwBgB,CAAxB,EAA2BN,CAA3B,EAA8BC,CAA9B,CAAP;AACD,GAnEU,CAAX;;AAqEA;AACAV,OAAKgB,kBAAL,CAAwBjB,MAAMkB,UAAN,CAAiBC,aAAzC,EAAwDjB,WAAW;AACjE;AACA,WAAOA,OAAP;AACD,GAHD;;AAKA,SAAOD,IAAP;AACD,C;;AApFD;;AACA;;AACA;;AACA;;AACA;;AACA","file":"RegExp.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport { StringValue, NativeFunctionValue, UndefinedValue, ObjectValue } from \"../../values/index.js\";\nimport { IsRegExp } from \"../../methods/is.js\";\nimport { Get } from \"../../methods/get.js\";\nimport { SameValuePartial } from \"../../methods/abstract.js\";\nimport { RegExpAlloc, RegExpInitialize } from \"../../methods/regexp.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"RegExp\", \"RegExp\", 2, (context, [pattern, flags], argCount, NewTarget) => {\n    // 1. Let patternIsRegExp be ? IsRegExp(pattern).\n    let patternIsRegExp = IsRegExp(realm, pattern);\n    let newTarget;\n    // 2. If NewTarget is not undefined, let newTarget be NewTarget.\n    if (NewTarget) {\n      newTarget = NewTarget;\n    } else {\n      // 3. Else,\n      // a. Let newTarget be the active function object.\n      newTarget = func;\n\n      // b. If patternIsRegExp is true and flags is undefined, then\n      if (patternIsRegExp && flags instanceof UndefinedValue) {\n        invariant(pattern instanceof ObjectValue);\n        // i. Let patternConstructor be ? Get(pattern, \"constructor\").\n        let patternConstructor = Get(realm, pattern, \"constructor\");\n\n        // ii. If SameValue(newTarget, patternConstructor) is true, return pattern.\n        if (SameValuePartial(realm, newTarget, patternConstructor)) {\n          return pattern;\n        }\n      }\n    }\n\n    let P, F;\n    // 4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then\n    if (pattern instanceof ObjectValue && pattern.$RegExpMatcher) {\n      // a. Let P be the value of pattern's [[OriginalSource]] internal slot.\n      invariant(typeof pattern.$OriginalSource === \"string\");\n      P = new StringValue(realm, pattern.$OriginalSource);\n\n      // b. If flags is undefined, let F be the value of pattern's [[OriginalFlags]] internal slot.\n      if (flags instanceof UndefinedValue) {\n        invariant(typeof pattern.$OriginalFlags === \"string\");\n        F = new StringValue(realm, pattern.$OriginalFlags);\n      } else {\n        // c. Else, let F be flags.\n        F = flags.throwIfNotConcrete();\n      }\n    } else if (patternIsRegExp) {\n      // 5. Else if patternIsRegExp is true, then\n      invariant(pattern instanceof ObjectValue);\n      // a. Let P be ? Get(pattern, \"source\").\n      P = Get(realm, pattern, \"source\");\n\n      // b. If flags is undefined, then\n      if (flags instanceof UndefinedValue) {\n        // i. Let F be ? Get(pattern, \"flags\").\n        F = Get(realm, pattern, \"flags\");\n      } else {\n        // c. Else, let F be flags.\n        F = flags.throwIfNotConcrete();\n      }\n    } else {\n      // 6. Else,\n      // a. Let P be pattern.\n      P = pattern.throwIfNotConcrete();\n      // b. Let F be flags.\n      F = flags.throwIfNotConcrete();\n    }\n\n    // 7. Let O be ? RegExpAlloc(newTarget).\n    let O = RegExpAlloc(realm, newTarget);\n\n    // 8. Return ? RegExpInitialize(O, P, F).\n    return RegExpInitialize(realm, O, P, F);\n  });\n\n  // ECMA262 21.2.4.2\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n"]}