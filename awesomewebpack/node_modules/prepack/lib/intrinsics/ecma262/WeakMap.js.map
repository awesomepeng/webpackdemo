{"version":3,"sources":["../../../src/intrinsics/ecma262/WeakMap.js"],"names":["realm","func","args","iterable","argCount","NewTarget","createErrorThrowCompletion","intrinsics","TypeError","map","OrdinaryCreateFromConstructor","$WeakMapData","undefined","isCompatibleWith","MOBILE_JSC_VERSION","iter","adder","next","nextItem","throwIfNotConcrete","error","k","kCompletion","v","vCompletion","status","statusCompletion"],"mappings":"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","file":"WeakMap.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../../realm.js\";\nimport { NativeFunctionValue, ObjectValue, NullValue, UndefinedValue } from \"../../values/index.js\";\nimport { AbruptCompletion } from \"../../completions.js\";\nimport { Get, IsCallable, IteratorClose, IteratorValue, GetIterator, IteratorStep, Call } from \"../../methods/index.js\";\nimport { Create } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"WeakMap\", \"WeakMap\", 0, (args, [iterable], argCount, NewTarget) => {\n    // 1. If NewTarget is undefined, throw a TypeError exception.\n    if (!NewTarget) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, \"%WeakMapPrototype%\", « [[WeakMapData]] »).\n    let map = Create.OrdinaryCreateFromConstructor(realm, NewTarget, \"WeakMapPrototype\", {\n      $WeakMapData: undefined,\n    });\n\n    // 3. Set map's [[WeakMapData]] internal slot to a new empty List.\n    map.$WeakMapData = [];\n\n    // 4. If iterable is not present, let iterable be undefined.\n    if (iterable && realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"the weak map constructor doesn't take arguments\"\n      );\n    }\n    if (!iterable) iterable = realm.intrinsics.undefined;\n\n    // 5. If iterable is either undefined or null, let iter be undefined.\n    let iter, adder;\n    if ((iterable: any) instanceof UndefinedValue || (iterable: any) instanceof NullValue) {\n      adder = realm.intrinsics.undefined;\n      iter = realm.intrinsics.undefined;\n    } else {\n      // 6. Else,\n      // a. Let adder be ? Get(map, \"set\").\n      adder = Get(realm, map, \"set\");\n\n      // b. If IsCallable(adder) is false, throw a TypeError exception.\n      if (!IsCallable(realm, adder)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // c. Let iter be ? GetIterator(iterable).\n      iter = GetIterator(realm, iterable);\n    }\n\n    // 7. If iter is undefined, return map.\n    if (iter instanceof UndefinedValue) {\n      return map;\n    }\n\n    // 8. Repeat\n    while (true) {\n      // a. Let next be ? IteratorStep(iter).\n      let next = IteratorStep(realm, iter);\n\n      // b. If next is false, return map.\n      if (!next) return map;\n\n      // c. Let nextItem be ? IteratorValue(next).\n      let nextItem = IteratorValue(realm, next).throwIfNotConcrete();\n\n      // d. If Type(nextItem) is not Object, then\n      if (!(nextItem instanceof ObjectValue)) {\n        // i. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\n        let error = realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n\n        // ii. Return ? IteratorClose(iter, error).\n        throw IteratorClose(realm, iter, error);\n      }\n\n      // e. Let k be Get(nextItem, \"0\").\n      let k;\n      try {\n        k = Get(realm, nextItem, \"0\");\n      } catch (kCompletion) {\n        if (kCompletion instanceof AbruptCompletion) {\n          // f. If k is an abrupt completion, return ? IteratorClose(iter, k).\n          throw IteratorClose(realm, iter, kCompletion);\n        } else throw kCompletion;\n      }\n\n      // g. Let v be Get(nextItem, \"1\").\n      let v;\n      try {\n        v = Get(realm, nextItem, \"1\");\n      } catch (vCompletion) {\n        if (vCompletion instanceof AbruptCompletion) {\n          // h. If v is an abrupt completion, return ? IteratorClose(iter, v).\n          throw IteratorClose(realm, iter, vCompletion);\n        } else throw vCompletion;\n      }\n\n      // i. Let status be Call(adder, map, « k.[[Value]], v.[[Value]] »).\n      let status;\n      try {\n        status = Call(realm, adder, map, [k, v]);\n      } catch (statusCompletion) {\n        if (statusCompletion instanceof AbruptCompletion) {\n          // j. If status is an abrupt completion, return ? IteratorClose(iter, status).\n          throw IteratorClose(realm, iter, statusCompletion);\n        } else throw statusCompletion;\n      }\n      status;\n    }\n\n    invariant(false);\n  });\n\n  return func;\n}\n"]}