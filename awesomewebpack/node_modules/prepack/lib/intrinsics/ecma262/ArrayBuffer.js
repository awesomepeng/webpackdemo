"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (realm) {
  // ECMA262 24.1.2.1
  let func = new _index.NativeFunctionValue(realm, "ArrayBuffer", "ArrayBuffer", 1, (context, [length], argCount, NewTarget) => {
    // 1. If NewTarget is undefined, throw a TypeError exception.
    if (!NewTarget) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    }

    // 2. Let byteLength be ToIndex(numberLength).
    let byteLength = _singletons.To.ToIndexPartial(realm, length);

    // 3. Return ? AllocateArrayBuffer(NewTarget, byteLength).
    return (0, _arraybuffer.AllocateArrayBuffer)(realm, NewTarget, byteLength);
  });

  // ECMA262 24.1.3.1
  func.defineNativeMethod("isView", 1, (context, [_arg]) => {
    let arg = _arg;
    // 1. If Type(arg) is not Object, return false.
    if (!arg.mightBeObject()) return realm.intrinsics.false;

    // 2. If arg has a [[ViewedArrayBuffer]] internal slot, return true.
    arg = arg.throwIfNotConcreteObject();
    if ("$ViewedArrayBuffer" in arg) return realm.intrinsics.true;

    // 3. Return false.
    return realm.intrinsics.false;
  });

  // ECMA262 24.1.3.3
  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {
    // 1. Return the this value
    return context;
  });

  return func;
};

var _index = require("../../values/index.js");

var _singletons = require("../../singletons.js");

var _arraybuffer = require("../../methods/arraybuffer.js");
//# sourceMappingURL=ArrayBuffer.js.map