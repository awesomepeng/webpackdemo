{"version":3,"sources":["../../../src/intrinsics/ecma262/NumberPrototype.js"],"names":["realm","obj","$NumberData","intrinsics","zero","defineNativeMethod","context","_fractionDigits","fractionDigits","x","thisNumberValue","value","throwIfNotConcrete","f","ToInteger","isNaN","s","Infinity","createErrorThrowCompletion","RangeError","positiveResultString","toExponential","undefined","toFixed","toLocaleStringSrc","toLocaleString","useAbstractInterpretation","createTemporalFromTemplate","precision","num","ToString","p","toPrecision","tsTemplateSrc","tsTemplate","radix","target","getType","createFromTemplate","radixNumber","TypeError","toString"],"mappings":"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","file":"NumberPrototype.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  AbstractValue,\n  NumberValue,\n  IntegralValue,\n} from \"../../values/index.js\";\nimport { To } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\nimport buildExpressionTemplate from \"../../utils/builder.js\";\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 20.1.3\n  obj.$NumberData = realm.intrinsics.zero;\n\n  // ECMA262 20.1.3.2\n  obj.defineNativeMethod(\"toExponential\", 1, (context, [_fractionDigits]) => {\n    let fractionDigits = _fractionDigits;\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = To.thisNumberValue(realm, context).value;\n\n    // 2. Let f be ? ToInteger(fractionDigits).\n    fractionDigits = fractionDigits.throwIfNotConcrete();\n    let f = To.ToInteger(realm, fractionDigits);\n\n    // 3. Assert: f is 0, when fractionDigits is undefined.\n    invariant(f === 0 || !(fractionDigits instanceof UndefinedValue));\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    // 5. Let s be the empty String.\n    let s = \"\";\n\n    // 6. If x < 0, then\n    if (x < 0) {\n      // 6a. Let s be \"-\".\n      s = \"-\";\n\n      // 6b. Let x be -x.\n      x = -x;\n    }\n\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // 7a. Return the concatenation of the Strings s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n\n    // 8. If f < 0 or f > 20, throw a RangeError exception. However, an implementation is permitted to extend the behaviour of toExponential for values of f less than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such values.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    let positiveResultString = x.toExponential(fractionDigits instanceof UndefinedValue ? undefined : f);\n    return new StringValue(realm, s + positiveResultString);\n  });\n\n  // ECMA262 20.1.3.3\n  obj.defineNativeMethod(\"toFixed\", 1, (context, [fractionDigits]) => {\n    // 1. Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0).\n    let f = To.ToInteger(realm, fractionDigits);\n\n    // 2. If f < 0 or f > 20, throw a RangeError exception.\n    if (f < 0 || f > 20) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"f < 0 || f > 20\");\n    }\n\n    // 3. Let x be this Number value.\n    let x = To.thisNumberValue(realm, context).value;\n\n    // 4. If x is NaN, return the String \"NaN\".\n    if (isNaN(x)) return new StringValue(realm, \"NaN\");\n\n    return new StringValue(realm, x.toFixed(f));\n  });\n\n  let toLocaleStringSrc = \"(A).toLocaleString()\";\n  let toLocaleString = buildExpressionTemplate(toLocaleStringSrc);\n\n  // ECMA262 20.1.3.4\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    let x = To.thisNumberValue(realm, context);\n    if (realm.useAbstractInterpretation) {\n      // The locale is environment-dependent and may also be time-dependent\n      // so do this at runtime and at this point in time\n      return AbstractValue.createTemporalFromTemplate(realm, toLocaleString, StringValue, [x]);\n    } else {\n      return new StringValue(realm, x.toLocaleString());\n    }\n  });\n\n  // ECMA262 20.1.3.5\n  obj.defineNativeMethod(\"toPrecision\", 1, (context, [precision]) => {\n    // 1. Let x be ? thisNumberValue(this value).\n    // 2. If precision is undefined, return ! ToString(x).\n    let num = To.thisNumberValue(realm, context);\n    if (precision instanceof UndefinedValue) {\n      return new StringValue(realm, To.ToString(realm, num));\n    }\n    // 3. Let p be ? ToInteger(precision).\n    let p = To.ToInteger(realm, precision.throwIfNotConcrete());\n    // 4. If x is NaN, return the String \"NaN\".\n    let x = num.value;\n    if (isNaN(x)) {\n      return new StringValue(realm, \"NaN\");\n    }\n    // 5. Let s be the empty String.\n    let s = \"\";\n    // 6. If x < 0, then\n    if (x < 0) {\n      // a. Let s be code unit 0x002D (HYPHEN-MINUS).\n      s = \"-\";\n      // b. Let x be -x.\n      x = -x;\n    }\n    // 7. If x = +∞, then\n    if (x === +Infinity) {\n      // a. Return the String that is the concatenation of s and \"Infinity\".\n      return new StringValue(realm, s + \"Infinity\");\n    }\n    // 8. If p < 1 or p > 21, throw a RangeError exception.\n    // However, an implementation is permitted to extend the behaviour of\n    // toPrecision for values of p less than 1 or greater than 21.\n    // In this case toPrecision would not necessarily throw RangeError for such\n    // values.\n    if (p < 1 || p > 21) {\n      // for simplicity, throw the error\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"p should be in between 1 and 21 inclusive\");\n    }\n    return new StringValue(realm, s + x.toPrecision(p));\n  });\n\n  const tsTemplateSrc = \"(A).toString()\";\n  const tsTemplate = buildExpressionTemplate(tsTemplateSrc);\n\n  // ECMA262 20.1.3.6\n  obj.defineNativeMethod(\"toString\", 1, (context, [radix]) => {\n    if (radix instanceof UndefinedValue) {\n      const target = context instanceof ObjectValue ? context.$NumberData : context;\n      if (target instanceof AbstractValue && (target.getType() === NumberValue || target.getType() === IntegralValue)) {\n        return AbstractValue.createFromTemplate(realm, tsTemplate, StringValue, [target], tsTemplateSrc);\n      }\n    }\n    // 1. Let x be ? thisNumberValue(this value).\n    let x = To.thisNumberValue(realm, context);\n\n    // 2. If radix is not present, let radixNumber be 10.\n    // 3. Else if radix is undefined, let radixNumber be 10.\n    let radixNumber;\n    if (!radix || radix instanceof UndefinedValue) {\n      radixNumber = 10;\n    } else {\n      // 4. Else let radixNumber be ? ToInteger(radix).\n      radixNumber = To.ToInteger(realm, radix.throwIfNotConcrete());\n    }\n\n    // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.\n    if (radixNumber < 2 || radixNumber > 36) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If radixNumber = 10, return ! ToString(x).\n    if (radixNumber === 10) return new StringValue(realm, To.ToString(realm, x));\n\n    // 7. Return the String representation of this Number value using the radix specified by radixNumber.\n    //    Letters a-z are used for digits with values 10 through 35. The precise algorithm is\n    //    implementation-dependent, however the algorithm should be a generalization of that specified in\n    //    7.1.12.1.\n    return new StringValue(realm, x.value.toString(radixNumber));\n  });\n\n  // ECMA262 20.1.3.7\n  obj.defineNativeMethod(\"valueOf\", 0, context => {\n    // 1. Return ? thisNumberValue(this value).\n    return To.thisNumberValue(realm, context);\n  });\n}\n"]}