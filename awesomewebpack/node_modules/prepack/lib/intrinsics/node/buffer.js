"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (realm) {
  let nativeBuffer = process.binding("buffer");
  let nativeBufferPrototype = require("buffer").Buffer.prototype;

  let intrinsicName = 'process.binding("buffer")';
  let obj = new _index.ObjectValue(realm, realm.intrinsics.ObjectPrototype, intrinsicName);

  // Buffer

  let setupBufferJS = new _index.NativeFunctionValue(realm, intrinsicName + ".setupBufferJS", "setupBufferJS", 0, (setupContext, setupArgs) => {
    (0, _invariant2.default)(setupArgs.length === 2);
    (0, _invariant2.default)(setupArgs[0] instanceof _index.ObjectValue);
    (0, _invariant2.default)(setupArgs[1] instanceof _index.ObjectValue);
    // TODO: Mutate the second argument by setting one of the properties to
    // Buffer prototype just like the native implementation does.
    let [proto] = setupArgs;

    let simpleWrapperNames = ["asciiSlice", "base64Slice", "latin1Slice", "hexSlice", "ucs2Slice", "asciiWrite", "base64Write", "latin1Write", "hexWrite", "ucs2Write", "utf8Write"];

    for (let name of simpleWrapperNames) {
      let wrapper = new _index.NativeFunctionValue(realm, "Buffer.prototype." + name, name, 0, (context, args) => {
        throw new _errors.FatalError("TODO: " + name);
      });
      _singletons.Properties.Set(realm, proto, name, wrapper, true);
    }

    // utf8Slice is used to read source code.
    let utf8Slice = new _index.NativeFunctionValue(realm, "Buffer.prototype.utf8Slice", "utf8Slice", 0, (context, args) => {
      (0, _invariant2.default)(context instanceof _index.ObjectValue);
      let self = (0, _utils.getNodeBufferFromTypedArray)(realm, context);
      let decodedArgs = args.map((arg, i) => _singletons.To.ToInteger(realm, arg));
      let utf8String = nativeBufferPrototype.utf8Slice.apply(self, decodedArgs);
      return new _index.StringValue(realm, utf8String);
    });
    _singletons.Properties.Set(realm, proto, "utf8Slice", utf8Slice, true);

    // copy has recently moved from the prototype to the instance upstream.
    let copy = new _index.NativeFunctionValue(realm, "Buffer.prototype.copy", "copy", 0, (context, args) => {
      (0, _invariant2.default)(context instanceof _index.ObjectValue);
      let self = (0, _utils.getNodeBufferFromTypedArray)(realm, context);
      let decodedArgs = args.map((arg, i) => {
        if (i === 0) {
          (0, _invariant2.default)(arg instanceof _index.ObjectValue);
          return (0, _utils.getNodeBufferFromTypedArray)(realm, arg);
        } else {
          return _singletons.To.ToInteger(realm, arg);
        }
      });
      let bytesCopied = nativeBufferPrototype.copy.apply(self, decodedArgs);
      return new _index.NumberValue(realm, bytesCopied);
    });
    _singletons.Properties.Set(realm, proto, "copy", copy, true);

    // TODO: Set up more methods on the prototype and bindingObject
    return realm.intrinsics.undefined;
  });
  _singletons.Properties.Set(realm, obj, "setupBufferJS", setupBufferJS, true);

  let createFromString = new _index.NativeFunctionValue(realm, intrinsicName + ".createFromString", "createFromString", 0, (context, args) => {
    throw new _errors.FatalError("TODO");
  });
  _singletons.Properties.Set(realm, obj, "createFromString", createFromString, true);

  let simpleWrapperNames = ["byteLengthUtf8", "copy", "compare", "compareOffset", "fill", "indexOfBuffer", "indexOfNumber", "indexOfString", "readDoubleBE", "readDoubleLE", "readFloatBE", "readFloatLE", "writeDoubleBE", "writeDoubleLE", "writeFloatBE", "writeFloatLE", "swap16", "swap32", "swap64"];

  for (let name of simpleWrapperNames) {
    let wrapper = new _index.NativeFunctionValue(realm, intrinsicName + "." + name, name, 0, (context, args) => {
      throw new _errors.FatalError("TODO");
    });
    _singletons.Properties.Set(realm, obj, name, wrapper, true);
  }

  _singletons.Properties.Set(realm, obj, "kMaxLength", new _index.NumberValue(realm, nativeBuffer.kMaxLength), true);
  _singletons.Properties.Set(realm, obj, "kStringMaxLength", new _index.NumberValue(realm, nativeBuffer.kStringMaxLength), true);

  return obj;
};

var _invariant = require("../../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _errors = require("../../errors.js");

var _realm = require("../../realm.js");

var _index = require("../../values/index.js");

var _utils = require("./utils.js");

var _singletons = require("../../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
//# sourceMappingURL=buffer.js.map