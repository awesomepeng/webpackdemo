{"version":3,"sources":["../../src/utils/babelhelpers.js"],"names":["getAsPropertyNameExpression","memberExpressionHelper","stringOfLocation","t","voidExpression","unaryExpression","numericLiteral","nullExpression","nullLiteral","emptyExpression","identifier","constructorExpression","protoExpression","key","canBeIdentifier","index","Number","parseInt","toString","keyIsAscii","test","isValidIdentifier","stringLiteral","object","property","propertyExpression","computed","isIdentifier","isStringLiteral","value","memberExpression","location","start","line","column","end"],"mappings":";;;;;;QA0BgBA,2B,GAAAA,2B;QAgBAC,sB,GAAAA,sB;QAmBAC,gB,GAAAA,gB;;AA3ChB;;IAAYC,C;;;;AAlBZ;;;;;;;;;AAoBO,MAAMC,0CAAsCD,EAAEE,eAAF,CAAkB,MAAlB,EAA0BF,EAAEG,cAAF,CAAiB,CAAjB,CAA1B,EAA+C,IAA/C,CAA5C;AACA,MAAMC,0CAAsCJ,EAAEK,WAAF,EAA5C;AACA,MAAMC,4CAAuCN,EAAEO,UAAF,CAAa,SAAb,CAA7C;AACA,MAAMC,wDAA6CR,EAAEO,UAAF,CAAa,eAAb,CAAnD;AACA,MAAME,4CAAuCT,EAAEO,UAAF,CAAa,WAAb,CAA7C;;AAEA,SAASV,2BAAT,CAAqCa,GAArC,EAAkDC,kBAA2B,IAA7E,EAAwG;AAC7G;AACA,MAAIC,QAAQC,OAAOC,QAAP,CAAgBJ,GAAhB,EAAqB,EAArB,CAAZ;AACA,MAAIE,SAAS,CAAT,IAAcA,MAAMG,QAAN,OAAqBL,GAAvC,EAA4C;AAC1C,WAAOV,EAAEG,cAAF,CAAiBS,KAAjB,CAAP;AACD;;AAED,MAAID,eAAJ,EAAqB;AACnB;AACA,QAAIK,aAAa,qBAAqBC,IAArB,CAA0BP,GAA1B,CAAjB;AACA,QAAIV,EAAEkB,iBAAF,CAAoBR,GAApB,KAA4BM,UAAhC,EAA4C,OAAOhB,EAAEO,UAAF,CAAaG,GAAb,CAAP;AAC7C;;AAED,SAAOV,EAAEmB,aAAF,CAAgBT,GAAhB,CAAP;AACD;;AAEM,SAASZ,sBAAT,CACLsB,MADK,EAELC,QAFK,EAGsB;AAC3B,MAAIC,kBAAJ;AACA,MAAIC,QAAJ;AACA,MAAI,OAAOF,QAAP,KAAoB,QAAxB,EAAkC;AAChCC,yBAAqBzB,4BAA4BwB,QAA5B,CAArB;AACAE,eAAW,CAACvB,EAAEwB,YAAF,CAAeF,kBAAf,CAAZ;AACD,GAHD,MAGO,IAAItB,EAAEyB,eAAF,CAAkBJ,QAAlB,CAAJ,EAAiC;AACtCC,yBAAqBzB,4BAA8BwB,QAAF,CAA0CK,KAAtE,CAArB;AACAH,eAAW,CAACvB,EAAEwB,YAAF,CAAeF,kBAAf,CAAZ;AACD,GAHM,MAGA;AACLA,yBAAqBD,QAArB;AACAE,eAAW,IAAX;AACD;AACD,SAAOvB,EAAE2B,gBAAF,CAAmBP,MAAnB,EAA2BE,kBAA3B,EAA+CC,QAA/C,CAAP;AACD;;AAEM,SAASxB,gBAAT,CAA0B6B,QAA1B,EAAqE;AAC1E,SAAQ,GAAEA,SAASC,KAAT,CAAeC,IAAK,IAAGF,SAASC,KAAT,CAAeE,MAAO,IAAGH,SAASI,GAAT,CAAaF,IAAK,IAAGF,SAASI,GAAT,CAAaF,IAAK,EAAjG;AACD","file":"babelhelpers.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNodeExpression,\n  BabelNodeMemberExpression,\n  BabelNodeStringLiteral,\n  BabelNodeIdentifier,\n  BabelNodeSourceLocation,\n} from \"babel-types\";\nimport * as t from \"babel-types\";\n\nexport const voidExpression: BabelNodeExpression = t.unaryExpression(\"void\", t.numericLiteral(0), true);\nexport const nullExpression: BabelNodeExpression = t.nullLiteral();\nexport const emptyExpression: BabelNodeIdentifier = t.identifier(\"__empty\");\nexport const constructorExpression: BabelNodeIdentifier = t.identifier(\"__constructor\");\nexport const protoExpression: BabelNodeIdentifier = t.identifier(\"__proto__\");\n\nexport function getAsPropertyNameExpression(key: string, canBeIdentifier: boolean = true): BabelNodeExpression {\n  // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.\n  let index = Number.parseInt(key, 10);\n  if (index >= 0 && index.toString() === key) {\n    return t.numericLiteral(index);\n  }\n\n  if (canBeIdentifier) {\n    // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines\n    let keyIsAscii = /^[\\u0000-\\u007f]*$/.test(key);\n    if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);\n  }\n\n  return t.stringLiteral(key);\n}\n\nexport function memberExpressionHelper(\n  object: BabelNodeExpression,\n  property: string | BabelNodeExpression\n): BabelNodeMemberExpression {\n  let propertyExpression: BabelNodeExpression;\n  let computed;\n  if (typeof property === \"string\") {\n    propertyExpression = getAsPropertyNameExpression(property);\n    computed = !t.isIdentifier(propertyExpression);\n  } else if (t.isStringLiteral(property)) {\n    propertyExpression = getAsPropertyNameExpression(((property: any): BabelNodeStringLiteral).value);\n    computed = !t.isIdentifier(propertyExpression);\n  } else {\n    propertyExpression = property;\n    computed = true;\n  }\n  return t.memberExpression(object, propertyExpression, computed);\n}\n\nexport function stringOfLocation(location: BabelNodeSourceLocation): string {\n  return `${location.start.line}:${location.start.column} ${location.end.line}:${location.end.line}`;\n}\n"]}