{"version":3,"sources":["../../src/utils/modules.js"],"names":["t","downgradeErrorsToWarnings","realm","f","savedHandler","errorHandler","handler","e","severity","handleError","ModuleTracer","constructor","modules","logModules","evaluateForEffectsNesting","requireStack","requireSequence","uninitializedModuleIdsRequiredInEvaluateForEffects","Set","getStatistics","log","message","console","map","_","join","beginEvaluateForEffects","state","push","undefined","endEvaluateForEffects","effects","popped","pop","_callRequireAndRecord","moduleIdValue","performCall","length","value","moduleIds","has","recordModuleInitialized","_callRequireAndAccelerate","isTopLevelRequire","acceleratedModuleIds","evaluateForEffects","result","nestedModuleId","nestedEffects","tryInitializeModule","accelerateUnsupportedRequires","isModuleInitialized","clear","acceleratedModules","_callRequireAndDelayIfNeeded","diagnostic","currentLocation","add","requireSequenceStart","previousNumDelayedModules","delayedModules","nestedModulesIds","i","createTemporalFromBuildFunction","callExpression","identifier","valueToNode","applyEffects","warning","location","_tryExtractDependencies","lengthValue","dependencies","logger","elementValue","tryQuery","intrinsics","detourCall","F","thisArgument","argumentsList","newTarget","getRequire","disallowDelayingRequiresOverride","moduleId","delayUnsupportedRequires","logError","getDefine","factoryFunction","previousDependencies","factoryFunctionDependencies","get","moduleString","previousDependenciesSet","forEach","dependency","set","Modules","_require","_define","Map","initializedModules","tracers","moduleTracer","statistics","resolveInitializedModules","globalInitializedModulesMap","_getGlobalProperty","properties","keys","property","moduleValue","descriptor","mightHaveBeenDeleted","size","totalModules","name","active","$GlobalObject","getGetModuleIdIfNodeIsRequireFunction","formalParameters","functions","scope","node","isIdentifier","callee","arguments","argument","isNumericLiteral","isStringLiteral","isMemberExpression","innerName","updateModuleId","newModuleId","getModuleId","memberExpression","object","scopedBinding","getBinding","path","dependencyIndex","Number","isInteger","kind","doesNotMatter","reference","ResolveBinding","$Environment","IsUnresolvableReference","referencedBase","base","referencedName","binding","bindings","initialized","assignToGlobal","previousDisallowDelayingRequiresOverride","evaluateNodeForEffectsInGlobalEnv","err","initializeMoreModules","count","oldReadOnly","setReadOnly","oldDisallowDelayingRequiresOverride","generator","modifiedBindings","modifiedProperties","createdObjects","empty","escapes"],"mappings":"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","file":"modules.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { Get } from \"../methods/index.js\";\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { Environment } from \"../singletons.js\";\nimport {\n  AbstractValue,\n  Value,\n  FunctionValue,\n  ObjectValue,\n  NumberValue,\n  StringValue,\n  ArrayValue,\n  UndefinedValue,\n  NullValue,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNodeIdentifier,\n  BabelNodeLVal,\n  BabelNodeCallExpression,\n  BabelNodeNumericLiteral,\n  BabelNodeStringLiteral,\n  BabelNodeMemberExpression,\n} from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"./logger.js\";\nimport { SerializerStatistics } from \"../serializer/statistics.js\";\n\nfunction downgradeErrorsToWarnings(realm: Realm, f: () => any) {\n  let savedHandler = realm.errorHandler;\n  function handler(e) {\n    e.severity = \"Warning\";\n    realm.errorHandler = savedHandler;\n    try {\n      return realm.handleError(e);\n    } finally {\n      realm.errorHandler = handler;\n    }\n  }\n  realm.errorHandler = handler;\n  try {\n    return f();\n  } finally {\n    realm.errorHandler = savedHandler;\n  }\n}\n\nexport class ModuleTracer extends Tracer {\n  constructor(modules: Modules, logModules: boolean) {\n    super();\n    this.modules = modules;\n    this.evaluateForEffectsNesting = 0;\n    this.requireStack = [];\n    this.requireSequence = [];\n    this.logModules = logModules;\n    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();\n  }\n\n  modules: Modules;\n  evaluateForEffectsNesting: number;\n  requireStack: Array<number | string | void>;\n  requireSequence: Array<number | string>;\n  uninitializedModuleIdsRequiredInEvaluateForEffects: Set<number | string>;\n  // We can't say that a module has been initialized if it was initialized in a\n  // evaluate for effects context until we know the effects are applied.\n  logModules: boolean;\n\n  getStatistics(): SerializerStatistics {\n    return this.modules.getStatistics();\n  }\n\n  log(message: string): void {\n    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any): void {\n    if (state !== this) {\n      this.log(\">evaluate for effects\");\n      this.evaluateForEffectsNesting++;\n      this.requireStack.push(undefined);\n    }\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects): void {\n    if (state !== this) {\n      let popped = this.requireStack.pop();\n      invariant(popped === undefined);\n      this.evaluateForEffectsNesting--;\n      this.log(\"<evaluate for effects\");\n    }\n  }\n\n  // If we don't delay unsupported requires, we simply want to record here\n  // when a module gets initialized, and then we return.\n  _callRequireAndRecord(moduleIdValue: number | string, performCall: () => Value): void | Value {\n    if (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) {\n      this.requireStack.push(moduleIdValue);\n      try {\n        let value = performCall();\n        if (this.modules.moduleIds.has(moduleIdValue)) this.modules.recordModuleInitialized(moduleIdValue, value);\n        return value;\n      } finally {\n        invariant(this.requireStack.pop() === moduleIdValue);\n      }\n    }\n    return undefined;\n  }\n\n  _callRequireAndAccelerate(\n    isTopLevelRequire: boolean,\n    moduleIdValue: number | string,\n    performCall: () => Value\n  ): void | Effects {\n    let realm = this.modules.realm;\n    let acceleratedModuleIds, effects;\n    do {\n      try {\n        effects = realm.evaluateForEffects(() => performCall(), this, \"_callRequireAndAccelerate\");\n      } catch (e) {\n        e;\n      }\n\n      acceleratedModuleIds = [];\n      if (isTopLevelRequire && effects !== undefined && !(effects.result instanceof AbruptCompletion)) {\n        // We gathered all effects, but didn't apply them yet.\n        // Let's check if there was any call to `require` in a\n        // evaluate-for-effects context. If so, try to initialize\n        // that module right now. Acceleration module initialization in this\n        // way might not actually be desirable, but it works around\n        // general prepack-limitations around joined abstract values involving\n        // conditionals. Long term, Prepack needs to implement a notion of refinement\n        // of conditional abstract values under the known path condition.\n        // Example:\n        //   if (*) require(1); else require(2);\n        //   let x = require(1).X;\n        // =>\n        //   require(1);\n        //   require(2);\n        //   if (*) require(1); else require(2);\n        //   let x = require(1).X;\n\n        for (let nestedModuleId of this.uninitializedModuleIdsRequiredInEvaluateForEffects) {\n          let nestedEffects = this.modules.tryInitializeModule(\n            nestedModuleId,\n            `accelerated initialization of conditional module ${nestedModuleId} as it's required in an evaluate-for-effects context by module ${moduleIdValue}`\n          );\n          if (\n            this.modules.accelerateUnsupportedRequires &&\n            nestedEffects !== undefined &&\n            nestedEffects.result instanceof Value &&\n            this.modules.isModuleInitialized(nestedModuleId)\n          ) {\n            acceleratedModuleIds.push(nestedModuleId);\n          }\n        }\n        this.uninitializedModuleIdsRequiredInEvaluateForEffects.clear();\n        // Keep restarting for as long as we find additional modules to accelerate.\n        if (acceleratedModuleIds.length > 0) {\n          console.log(\n            `restarting require(${moduleIdValue}) after accelerating conditional require calls for ${acceleratedModuleIds.join()}`\n          );\n          this.getStatistics().acceleratedModules += acceleratedModuleIds.length;\n        }\n      }\n    } while (acceleratedModuleIds.length > 0);\n\n    return effects;\n  }\n\n  // If a require fails, recover from it and delay the factory call until runtime\n  // Also, only in this mode, consider \"accelerating\" require calls, see below.\n  _callRequireAndDelayIfNeeded(moduleIdValue: number | string, performCall: () => Value): void | Value {\n    let realm = this.modules.realm;\n    this.log(`>require(${moduleIdValue})`);\n    let isTopLevelRequire = this.requireStack.length === 0;\n    if (this.evaluateForEffectsNesting > 0) {\n      if (isTopLevelRequire) {\n        let diagnostic = new CompilerDiagnostic(\n          \"Non-deterministically conditional top-level require not currently supported\",\n          realm.currentLocation,\n          \"PP0017\",\n          \"FatalError\"\n        );\n        realm.handleError(diagnostic);\n        throw new FatalError();\n      } else if (!this.modules.isModuleInitialized(moduleIdValue))\n        // Nested require call: We record that this happened. Just so that\n        // if we discover later this this require call needs to get delayed,\n        // then we still know (some of) which modules it in turn required,\n        // and then we'll later \"accelerate\" requiring them to preserve the\n        // require ordering. See below for more details on acceleration.\n        this.uninitializedModuleIdsRequiredInEvaluateForEffects.add(moduleIdValue);\n\n      return undefined;\n    } else {\n      return downgradeErrorsToWarnings(realm, () => {\n        let result;\n        try {\n          this.requireStack.push(moduleIdValue);\n          let requireSequenceStart = this.requireSequence.length;\n          this.requireSequence.push(moduleIdValue);\n          const previousNumDelayedModules = this.getStatistics().delayedModules;\n          let effects = this._callRequireAndAccelerate(isTopLevelRequire, moduleIdValue, performCall);\n          if (effects === undefined || effects.result instanceof AbruptCompletion) {\n            console.log(`delaying require(${moduleIdValue})`);\n            this.getStatistics().delayedModules = previousNumDelayedModules + 1;\n            // So we are about to emit a delayed require(...) call.\n            // However, before we do that, let's try to require all modules that we\n            // know this delayed require call will require.\n            // This way, we ensure that those modules will be fully initialized\n            // before the require call executes.\n            // TODO #690: More needs to be done to make the delayUnsupportedRequires\n            // feature completely safe. Open issues are:\n            // 1) Side-effects on the heap of delayed factory functions are not discovered or rejected.\n            // 2) While we do process an appropriate list of transitively required modules here,\n            //    it's likely just a subset / prefix of all transivitely required modules, as\n            //    more modules would have been required if the Introspection exception had not been thrown.\n            //    To be correct, those modules would have to be prepacked here as well.\n            //    TODO #798: Watch out for an upcoming change to the __d module declaration where the statically known\n            //    list of dependencies will be announced, so we'll no longer have to guess.\n            let nestedModulesIds = new Set();\n            for (let i = requireSequenceStart; i < this.requireSequence.length; i++) {\n              let nestedModuleId = this.requireSequence[i];\n              if (nestedModulesIds.has(nestedModuleId)) continue;\n              nestedModulesIds.add(nestedModuleId);\n              this.modules.tryInitializeModule(\n                nestedModuleId,\n                `initialization of module ${nestedModuleId} as it's required by module ${moduleIdValue}`\n              );\n            }\n\n            result = AbstractValue.createTemporalFromBuildFunction(realm, Value, [], ([]) =>\n              t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleIdValue)])\n            );\n          } else {\n            result = effects.result;\n            if (result instanceof SimpleNormalCompletion) {\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n              this.modules.recordModuleInitialized(moduleIdValue, result.value);\n            } else if (result instanceof PossiblyNormalCompletion) {\n              let warning = new CompilerDiagnostic(\n                \"Module import may fail with an exception\",\n                result.location,\n                \"PP0018\",\n                \"Warning\"\n              );\n              realm.handleError(warning);\n              result = result.value;\n              realm.applyEffects(effects, `initialization of module ${moduleIdValue}`);\n            } else {\n              invariant(false);\n            }\n          }\n        } finally {\n          let popped = this.requireStack.pop();\n          invariant(popped === moduleIdValue);\n          this.log(`<require(${moduleIdValue})`);\n        }\n        if (result instanceof SimpleNormalCompletion) result = result.value;\n        invariant(result instanceof Value);\n        return result;\n      });\n    }\n  }\n\n  _tryExtractDependencies(value: void | Value): void | Array<Value> {\n    if (value === undefined || value instanceof NullValue || value instanceof UndefinedValue) return [];\n    if (value instanceof ArrayValue) {\n      const realm = this.modules.realm;\n      const lengthValue = Get(realm, value, \"length\");\n      if (lengthValue instanceof NumberValue) {\n        const dependencies = [];\n        const logger = this.modules.logger;\n        for (let i = 0; i < lengthValue.value; i++) {\n          const elementValue = logger.tryQuery(\n            () => Get(realm, ((value: any): ArrayValue), \"\" + i),\n            realm.intrinsics.undefined\n          );\n          dependencies.push(elementValue);\n        }\n        return dependencies;\n      }\n    }\n    return undefined;\n  }\n\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {\n    if (\n      F === this.modules.getRequire() &&\n      !this.modules.disallowDelayingRequiresOverride &&\n      argumentsList.length === 1\n    ) {\n      // Here, we handle calls of the form\n      //   require(42)\n\n      let moduleId = argumentsList[0];\n      let moduleIdValue;\n      // Do some sanity checks and request require(...) calls with bad arguments\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) {\n        moduleIdValue = moduleId.value;\n        if (!this.modules.moduleIds.has(moduleIdValue) && this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"Module referenced by require call has not been defined.\");\n        }\n      } else {\n        if (this.modules.delayUnsupportedRequires) {\n          this.modules.logger.logError(moduleId, \"First argument to require function is not a number or string value.\");\n        }\n        return undefined;\n      }\n\n      if (this.modules.delayUnsupportedRequires) return this._callRequireAndDelayIfNeeded(moduleIdValue, performCall);\n      else return this._callRequireAndRecord(moduleIdValue, performCall);\n    } else if (F === this.modules.getDefine()) {\n      // Here, we handle calls of the form\n      //   __d(factoryFunction, moduleId, dependencyArray)\n\n      let factoryFunction = argumentsList[0];\n      if (factoryFunction instanceof FunctionValue) {\n        let dependencies = this._tryExtractDependencies(argumentsList[2]);\n        if (dependencies !== undefined) {\n          let previousDependencies = this.modules.factoryFunctionDependencies.get(factoryFunction);\n          if (previousDependencies) {\n            // Verify that they are the same\n            let logError = () => {\n              let moduleId = argumentsList[1];\n              let moduleString =\n                moduleId instanceof StringValue || moduleId instanceof NumberValue ? moduleId.value : \"unknown\";\n              this.modules.logger.logError(\n                factoryFunction,\n                `Called define on the same module ${moduleString} twice with different dependencies each time.`\n              );\n            };\n            if (previousDependencies.length !== dependencies.length) {\n              logError();\n            } else {\n              let previousDependenciesSet = new Set(previousDependencies);\n              dependencies.forEach(dependency => {\n                if (!previousDependenciesSet.has(dependency)) logError();\n              });\n            }\n          } else {\n            this.modules.factoryFunctionDependencies.set(factoryFunction, dependencies);\n          }\n        } else\n          this.modules.logger.logError(\n            argumentsList[2],\n            \"Third argument to define function is present but not a concrete array.\"\n          );\n      } else\n        this.modules.logger.logError(factoryFunction, \"First argument to define function is not a function value.\");\n      let moduleId = argumentsList[1];\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue)\n        this.modules.moduleIds.add(moduleId.value);\n      else\n        this.modules.logger.logError(moduleId, \"Second argument to define function is not a number or string value.\");\n    }\n    return undefined;\n  }\n}\n\nexport class Modules {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    logModules: boolean,\n    delayUnsupportedRequires: boolean,\n    accelerateUnsupportedRequires: boolean\n  ) {\n    this.realm = realm;\n    this.logger = logger;\n    this._require = realm.intrinsics.undefined;\n    this._define = realm.intrinsics.undefined;\n    this.factoryFunctionDependencies = new Map();\n    this.moduleIds = new Set();\n    this.initializedModules = new Map();\n    realm.tracers.push((this.moduleTracer = new ModuleTracer(this, logModules)));\n    this.delayUnsupportedRequires = delayUnsupportedRequires;\n    this.accelerateUnsupportedRequires = accelerateUnsupportedRequires;\n    this.disallowDelayingRequiresOverride = false;\n  }\n\n  realm: Realm;\n  logger: Logger;\n  _require: Value;\n  _define: Value;\n  factoryFunctionDependencies: Map<FunctionValue, Array<Value>>;\n  moduleIds: Set<number | string>;\n  initializedModules: Map<number | string, Value>;\n  active: boolean;\n  delayUnsupportedRequires: boolean;\n  accelerateUnsupportedRequires: boolean;\n  disallowDelayingRequiresOverride: boolean;\n  moduleTracer: ModuleTracer;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  resolveInitializedModules(): void {\n    let globalInitializedModulesMap = this._getGlobalProperty(\"__initializedModules\");\n    invariant(globalInitializedModulesMap instanceof ObjectValue);\n    for (let moduleId of globalInitializedModulesMap.properties.keys()) {\n      let property = globalInitializedModulesMap.properties.get(moduleId);\n      invariant(property);\n      let moduleValue = property.descriptor && property.descriptor.value;\n      if (moduleValue instanceof Value && !moduleValue.mightHaveBeenDeleted()) {\n        this.initializedModules.set(moduleId, moduleValue);\n      }\n    }\n    this.getStatistics().initializedModules = this.initializedModules.size;\n    this.getStatistics().totalModules = this.moduleIds.size;\n  }\n\n  _getGlobalProperty(name: string): Value {\n    if (this.active) return this.realm.intrinsics.undefined;\n    this.active = true;\n    try {\n      let realm = this.realm;\n      return this.logger.tryQuery(() => Get(realm, realm.$GlobalObject, name), realm.intrinsics.undefined);\n    } finally {\n      this.active = false;\n    }\n  }\n\n  getRequire(): Value {\n    if (!(this._require instanceof FunctionValue)) this._require = this._getGlobalProperty(\"require\");\n    return this._require;\n  }\n\n  getDefine(): Value {\n    if (!(this._define instanceof FunctionValue)) this._define = this._getGlobalProperty(\"__d\");\n    return this._define;\n  }\n\n  // Returns a function that checks if a call node represents a call to a\n  // known require function, and if so, what module id that call indicates.\n  // A known require function call is either of the form\n  //   ... require(42) ...\n  // where require resolves to the global require function, or\n  //   factoryFunction(, require, , , dependencies) {\n  //     ...\n  //       ... require(dependencies[3]) ...\n  // where factoryFunction and dependencies were announced as part of the\n  // global code execution via a global module declaration call such as\n  //   global.__d(factoryFunction, , [0,2,4,6,8])\n  getGetModuleIdIfNodeIsRequireFunction(\n    formalParameters: Array<BabelNodeLVal>,\n    functions: Array<FunctionValue>\n  ): (scope: any, node: BabelNodeCallExpression) => void | number | string {\n    let realm = this.realm;\n    let logger = this.logger;\n    let modules = this;\n    return (scope: any, node: BabelNodeCallExpression) => {\n      // Are we calling a function that has a single name and a single argument?\n      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1) return undefined;\n      let argument = node.arguments[0];\n      if (!argument) return undefined;\n\n      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument) && !t.isMemberExpression(argument))\n        return undefined;\n\n      invariant(node.callee);\n      let innerName = ((node.callee: any): BabelNodeIdentifier).name;\n\n      let moduleId;\n\n      // Helper function used to give up if we ever come up with different module ids for different functions\n      let updateModuleId = newModuleId => {\n        if (moduleId !== undefined && moduleId !== newModuleId) return false;\n        moduleId = newModuleId;\n        return true;\n      };\n\n      // Helper function that retrieves module id from call argument, possibly chasing dependency array indirection\n      const getModuleId = (dependencies?: Array<Value>): void | number | string => {\n        if (t.isMemberExpression(argument)) {\n          if (dependencies !== undefined) {\n            let memberExpression = ((argument: any): BabelNodeMemberExpression);\n            if (t.isIdentifier(memberExpression.object)) {\n              let scopedBinding = scope.getBinding(((memberExpression.object: any): BabelNodeIdentifier).name);\n              if (scopedBinding && formalParameters[4] === scopedBinding.path.node) {\n                if (t.isNumericLiteral(memberExpression.property)) {\n                  let dependencyIndex = memberExpression.property.value;\n                  if (\n                    Number.isInteger(dependencyIndex) &&\n                    dependencyIndex >= 0 &&\n                    dependencyIndex < dependencies.length\n                  ) {\n                    let dependency = dependencies[dependencyIndex];\n                    if (dependency instanceof NumberValue || dependency instanceof StringValue) return dependency.value;\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          return ((argument: any): BabelNodeNumericLiteral | BabelNodeStringLiteral).value;\n        }\n      };\n\n      // Let's consider each of the function instances (closures for the same code)\n      for (let f of functions) {\n        // 1. Let's check if we have a match for a factory function like\n        //      factoryFunction(, require, , , [dependencies])\n        //    which is used with the Metro bundler\n        let scopedBinding = scope.getBinding(innerName);\n        if (scopedBinding) {\n          let dependencies = modules.factoryFunctionDependencies.get(f);\n          if (dependencies !== undefined && formalParameters[1] === scopedBinding.path.node) {\n            invariant(scopedBinding.kind === \"param\");\n            let newModuleId = getModuleId(dependencies);\n            if (newModuleId !== undefined && !updateModuleId(newModuleId)) return undefined;\n            continue;\n          }\n\n          // The name binds to some local entity, but nothing we'd know what exactly it is\n          return undefined;\n        }\n\n        // 2. Let's check if we can resolve the called function just by looking at the\n        //    function instance environment.\n        //    TODO: We should not do this if the current node is in a nested function!\n\n        // We won't have a dependency map here, so this only works for literal arguments.\n        if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return undefined;\n\n        let doesNotMatter = true;\n        let reference = logger.tryQuery(\n          () => Environment.ResolveBinding(realm, innerName, doesNotMatter, f.$Environment),\n          undefined\n        );\n        if (reference === undefined) {\n          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly\n          return undefined;\n        }\n        if (Environment.IsUnresolvableReference(realm, reference)) return undefined;\n        let referencedBase = reference.base;\n        let referencedName: string = (reference.referencedName: any);\n        if (typeof referencedName !== \"string\") return undefined;\n        let value;\n        if (reference.base instanceof GlobalEnvironmentRecord) {\n          value = logger.tryQuery(() => Get(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined);\n        } else {\n          invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n          let binding = referencedBase.bindings[referencedName];\n          if (!binding.initialized) return undefined;\n          value = binding.value;\n        }\n        if (value !== modules.getRequire()) return undefined;\n        const newModuleId = getModuleId();\n        invariant(newModuleId !== undefined);\n        if (!updateModuleId(newModuleId)) return undefined;\n      }\n\n      return moduleId;\n    };\n  }\n\n  recordModuleInitialized(moduleId: number | string, value: Value): void {\n    this.realm.assignToGlobal(\n      t.memberExpression(\n        t.memberExpression(t.identifier(\"global\"), t.identifier(\"__initializedModules\")),\n        t.identifier(\"\" + moduleId)\n      ),\n      value\n    );\n  }\n\n  tryInitializeModule(moduleId: number | string, message: string): void | Effects {\n    let realm = this.realm;\n    let previousDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    return downgradeErrorsToWarnings(realm, () => {\n      try {\n        let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);\n        realm.applyEffects(effects, message);\n        return effects;\n      } catch (err) {\n        if (err instanceof FatalError) return undefined;\n        else throw err;\n      } finally {\n        this.disallowDelayingRequiresOverride = previousDisallowDelayingRequiresOverride;\n      }\n    });\n  }\n\n  initializeMoreModules(): void {\n    // partially evaluate all factory methods by calling require\n    let count = 0;\n    for (let moduleId of this.moduleIds) {\n      if (this.initializedModules.has(moduleId)) continue;\n      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);\n      if (effects === undefined) continue;\n      let result = effects.result;\n      if (!(result instanceof Value)) continue; // module might throw\n      count++;\n      this.initializedModules.set(moduleId, result);\n    }\n    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);\n  }\n\n  isModuleInitialized(moduleId: number | string): void | Value {\n    let realm = this.realm;\n    let oldReadOnly = realm.setReadOnly(true);\n    let oldDisallowDelayingRequiresOverride = this.disallowDelayingRequiresOverride;\n    this.disallowDelayingRequiresOverride = true;\n    try {\n      let node = t.callExpression(t.identifier(\"require\"), [t.valueToNode(moduleId)]);\n\n      let {\n        result,\n        generator,\n        modifiedBindings,\n        modifiedProperties,\n        createdObjects,\n      } = realm.evaluateNodeForEffectsInGlobalEnv(node);\n      // for lint unused\n      invariant(modifiedBindings);\n\n      if (result instanceof AbruptCompletion) return undefined;\n      if (result instanceof SimpleNormalCompletion) result = result.value;\n      invariant(result instanceof Value);\n\n      if (!generator.empty() || (result instanceof ObjectValue && createdObjects.has(result))) return undefined;\n      // Check for escaping property assignments, if none escape, we got an existing object\n      let escapes = false;\n      for (let [binding] of modifiedProperties) {\n        let object = binding.object;\n        invariant(object instanceof ObjectValue);\n        if (!createdObjects.has(object)) escapes = true;\n      }\n      if (escapes) return undefined;\n\n      return result;\n    } catch (err) {\n      if (err instanceof FatalError) return undefined;\n      throw err;\n    } finally {\n      realm.setReadOnly(oldReadOnly);\n      this.disallowDelayingRequiresOverride = oldDisallowDelayingRequiresOverride;\n    }\n  }\n}\n"]}