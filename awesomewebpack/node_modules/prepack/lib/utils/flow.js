"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stripFlowTypeAnnotations = stripFlowTypeAnnotations;

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Taken directly from Babel:
// https://github.com/babel/babel/blob/cde005422701a69ff21044c138c29a5ad23b6d0a/packages/babel-plugin-transform-flow-strip-types/src/index.js#L32-L107
// Copyright 2015-present Sebastian McKenzie / Babel project (https://github.com/babel)
// only the lines reflected in the above were used
function stripFlowTypeAnnotations(ast) {
  (0, _babelTraverse2.default)(ast, {
    ImportDeclaration(path) {
      if (!path.node.specifiers.length) return;
      let typeCount = 0;
      path.node.specifiers.forEach(({ importKind }) => {
        if (importKind === "type" || importKind === "typeof") {
          typeCount++;
        }
      });
      if (typeCount === path.node.specifiers.length) {
        path.remove();
      }
    },
    Flow(path) {
      path.remove();
    },
    ClassProperty(path) {
      path.node.variance = null;
      path.node.typeAnnotation = null;
      if (!path.node.value) path.remove();
    },
    Class(path) {
      path.node.implements = null;
      path.get("body.body").forEach(child => {
        if (child.isClassProperty()) {
          child.node.typeAnnotation = null;
          if (!child.node.value) child.remove();
        }
      });
    },
    AssignmentPattern({ node }) {
      node.left.optional = false;
    },
    Function({ node }) {
      for (let i = 0; i < node.params.length; i++) {
        const param = node.params[i];
        param.optional = false;
        if (param.type === "AssignmentPattern") {
          param.left.optional = false;
        }
      }
      node.predicate = null;
    },
    TypeCastExpression(path) {
      let { node } = path;
      do {
        node = node.expression;
      } while (t.isTypeCastExpression(node));
      path.replaceWith(node);
    }
  }, undefined, {}, undefined);
  _babelTraverse2.default.clearCache();
} /**
   * Copyright (c) 2017-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

/*  strict */
//# sourceMappingURL=flow.js.map