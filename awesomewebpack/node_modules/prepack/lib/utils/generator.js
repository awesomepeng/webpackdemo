"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreludeGenerator = exports.NameGenerator = exports.Generator = exports.TemporalObjectAssignEntry = exports.TemporalBuildNodeEntry = exports.GeneratorEntry = undefined;
exports.attemptToMergeEquivalentObjectAssigns = attemptToMergeEquivalentObjectAssigns;

var _index = require("../values/index.js");

var _errors = require("../errors.js");

var _index2 = require("../domains/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _completions = require("../completions.js");

var _babelhelpers = require("./babelhelpers.js");

var _singletons = require("../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

class GeneratorEntry {
  constructor(realm) {
    // We increment the index of every TemporalBuildNodeEntry created.
    // This should match up as a form of timeline value due to the tree-like
    // structure we use to create entries during evaluation. For example,
    // if all AST nodes in a BlockStatement resulted in a temporal build node
    // for each AST node, then each would have a sequential index as to its
    // position of how it was evaluated in the BlockSstatement.
    this.index = realm.temporalEntryCounter++;
  }

  visit(callbacks, containingGenerator) {
    (0, _invariant2.default)(false, "GeneratorEntry is an abstract base class");
  }

  serialize(context) {
    (0, _invariant2.default)(false, "GeneratorEntry is an abstract base class");
  }

  getDependencies() {
    (0, _invariant2.default)(false, "GeneratorEntry is an abstract base class");
  }

  notEqualToAndDoesNotHappenBefore(entry) {
    return this.index > entry.index;
  }

  notEqualToAndDoesNotHappenAfter(entry) {
    return this.index < entry.index;
  }

}

exports.GeneratorEntry = GeneratorEntry;
class TemporalBuildNodeEntry extends GeneratorEntry {
  constructor(realm, args) {
    super(realm);
    Object.assign(this, args);
    if (this.mutatesOnly !== undefined) {
      (0, _invariant2.default)(!this.isPure);
      for (let arg of this.mutatesOnly) {
        (0, _invariant2.default)(this.args.includes(arg));
      }
    }
  }
  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.


  visit(callbacks, containingGenerator) {
    let omit = this.isPure && this.declared && callbacks.canOmit(this.declared);

    if (!omit && this.declared && this.mutatesOnly !== undefined) {
      omit = true;
      for (let arg of this.mutatesOnly) {
        if (!callbacks.canOmit(arg)) {
          omit = false;
        }
      }
    }
    if (omit) {
      callbacks.recordDelayedEntry(containingGenerator, this);
      return false;
    } else {
      if (this.declared) callbacks.recordDeclaration(this.declared);
      for (let i = 0, n = this.args.length; i < n; i++) this.args[i] = callbacks.visitEquivalentValue(this.args[i]);
      if (this.dependencies) for (let dependency of this.dependencies) callbacks.visitGenerator(dependency, containingGenerator);
      return true;
    }
  }

  serialize(context) {
    let omit = this.isPure && this.declared && context.canOmit(this.declared);

    if (!omit && this.declared && this.mutatesOnly !== undefined) {
      omit = true;
      for (let arg of this.mutatesOnly) {
        if (!context.canOmit(arg)) {
          omit = false;
        }
      }
    }
    if (!omit) {
      let nodes = this.args.map((boundArg, i) => context.serializeValue(boundArg));
      if (this.buildNode) {
        let valuesToProcess = new Set();
        let node = this.buildNode(nodes, context, valuesToProcess);
        if (node.type === "BlockStatement") {
          let block = node;
          let statements = block.body;
          if (statements.length === 0) return;
          if (statements.length === 1) {
            node = statements[0];
          }
        }
        let declared = this.declared;
        if (declared !== undefined && context.options.debugScopes) {
          let s = t.emptyStatement();
          s.leadingComments = [{ type: "BlockComment", value: `declaring ${declared.intrinsicName || "?"}` }];
          context.emit(s);
        }
        context.emit(node);
        context.processValues(valuesToProcess);
      }
      if (this.declared !== undefined) context.declare(this.declared);
    }
  }

  getDependencies() {
    return this.dependencies;
  }
}

exports.TemporalBuildNodeEntry = TemporalBuildNodeEntry;
class TemporalObjectAssignEntry extends TemporalBuildNodeEntry {
  visit(callbacks, containingGenerator) {
    let declared = this.declared;
    if (!(declared instanceof _index.AbstractObjectValue || declared instanceof _index.ObjectValue)) {
      return false;
    }
    let realm = declared.$Realm;
    // The only optimization we attempt to do to Object.assign for now is merging of multiple entries
    // into a new generator entry.
    let result = attemptToMergeEquivalentObjectAssigns(realm, callbacks, this);

    if (result instanceof TemporalObjectAssignEntry) {
      let nextResult = result;
      while (nextResult instanceof TemporalObjectAssignEntry) {
        nextResult = attemptToMergeEquivalentObjectAssigns(realm, callbacks, result);
        // If we get back a TemporalObjectAssignEntry, then we have successfully merged a single
        // Object.assign, but we may be able to merge more. So repeat the process.
        if (nextResult instanceof TemporalObjectAssignEntry) {
          result = nextResult;
        }
      }
      // We have an optimized temporal entry, so replace the current temporal
      // entry and visit that entry instead.
      this.args = result.args;
    } else if (result === "POSSIBLE_OPTIMIZATION") {
      callbacks.recordDelayedEntry(containingGenerator, this);
      return false;
    }
    return super.visit(callbacks, containingGenerator);
  }
}

exports.TemporalObjectAssignEntry = TemporalObjectAssignEntry;


class ModifiedPropertyEntry extends GeneratorEntry {
  constructor(realm, args) {
    super(realm);
    Object.assign(this, args);
  }

  serialize(context) {
    let desc = this.propertyBinding.descriptor;
    (0, _invariant2.default)(desc === this.newDescriptor);
    context.emitPropertyModification(this.propertyBinding);
  }

  visit(context, containingGenerator) {
    (0, _invariant2.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    let desc = this.propertyBinding.descriptor;
    (0, _invariant2.default)(desc === this.newDescriptor);
    context.visitModifiedObjectProperty(this.propertyBinding);
    return true;
  }

  getDependencies() {
    return undefined;
  }
}

class ModifiedBindingEntry extends GeneratorEntry {
  constructor(realm, args) {
    super(realm);
    Object.assign(this, args);
  }

  serialize(context) {
    let residualFunctionBinding = this.residualFunctionBinding;
    (0, _invariant2.default)(residualFunctionBinding !== undefined);
    (0, _invariant2.default)(residualFunctionBinding.referentialized);
    (0, _invariant2.default)(residualFunctionBinding.serializedValue, "ResidualFunctionBinding must be referentialized before serializing a mutation to it.");
    let newValue = this.newValue;
    (0, _invariant2.default)(newValue);
    let bindingReference = residualFunctionBinding.serializedValue;
    (0, _invariant2.default)(t.isLVal(bindingReference), "Referentialized values must be LVals even though serializedValues may be any Expression");
    let serializedNewValue = context.serializeValue(newValue);
    context.emit(t.expressionStatement(t.assignmentExpression("=", bindingReference, serializedNewValue)));
  }

  visit(context, containingGenerator) {
    (0, _invariant2.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    (0, _invariant2.default)(this.modifiedBinding.value === this.newValue, "ModifiedBinding's value has been changed since last visit.");
    let [residualBinding, newValue] = context.visitModifiedBinding(this.modifiedBinding);
    (0, _invariant2.default)(this.residualFunctionBinding === undefined || this.residualFunctionBinding === residualBinding, "ResidualFunctionBinding has been changed since last visit.");
    this.residualFunctionBinding = residualBinding;
    this.newValue = newValue;
    return true;
  }

  getDependencies() {
    return undefined;
  }
}

class ReturnValueEntry extends GeneratorEntry {
  constructor(realm, generator, returnValue) {
    super(realm);
    this.returnValue = returnValue.promoteEmptyToUndefined();
    this.containingGenerator = generator;
  }

  visit(context, containingGenerator) {
    (0, _invariant2.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    this.returnValue = context.visitEquivalentValue(this.returnValue);
    return true;
  }

  serialize(context) {
    let result = context.serializeValue(this.returnValue);
    context.emit(t.returnStatement(result));
  }

  getDependencies() {
    return undefined;
  }
}

class IfThenElseEntry extends GeneratorEntry {
  constructor(generator, completion, realm) {
    super(realm);
    this.completion = completion;
    this.containingGenerator = generator;
    this.condition = completion.joinCondition;

    this.consequentGenerator = Generator.fromEffects(completion.consequentEffects, realm, "ConsequentEffects");
    this.alternateGenerator = Generator.fromEffects(completion.alternateEffects, realm, "AlternateEffects");
  }

  visit(context, containingGenerator) {
    (0, _invariant2.default)(containingGenerator === this.containingGenerator, "This entry requires effects to be applied and may not be moved");
    this.condition = context.visitEquivalentValue(this.condition);
    context.visitGenerator(this.consequentGenerator, containingGenerator);
    context.visitGenerator(this.alternateGenerator, containingGenerator);
    return true;
  }

  serialize(context) {
    let condition = context.serializeValue(this.condition);
    let valuesToProcess = new Set();
    let consequentBody = context.serializeGenerator(this.consequentGenerator, valuesToProcess);
    let alternateBody = context.serializeGenerator(this.alternateGenerator, valuesToProcess);
    context.emit(t.ifStatement(condition, t.blockStatement(consequentBody), t.blockStatement(alternateBody)));
    context.processValues(valuesToProcess);
  }

  getDependencies() {
    return [this.consequentGenerator, this.alternateGenerator];
  }
}

class BindingAssignmentEntry extends GeneratorEntry {
  constructor(realm, binding, value) {
    super(realm);
    this.binding = binding;
    this.value = value;
  }

  serialize(context) {
    context.emit(t.expressionStatement(t.assignmentExpression("=", context.serializeBinding(this.binding), context.serializeValue(this.value))));
  }

  visit(context, containingGenerator) {
    this.value = context.visitBindingAssignment(this.binding, this.value);
    return true;
  }

  getDependencies() {
    return undefined;
  }
}

function serializeBody(generator, context, valuesToProcess) {
  let statements = context.serializeGenerator(generator, valuesToProcess);
  if (statements.length === 1 && statements[0].type === "BlockStatement") return statements[0];
  return t.blockStatement(statements);
}

class Generator {
  constructor(realm, name, pathConditions, effects) {
    (0, _invariant2.default)(realm.useAbstractInterpretation);
    let realmPreludeGenerator = realm.preludeGenerator;
    (0, _invariant2.default)(realmPreludeGenerator);
    this.preludeGenerator = realmPreludeGenerator;
    this.realm = realm;
    this._entries = [];
    this.id = realm.nextGeneratorId++;
    this._name = name;
    this.effectsToApply = effects;
    this.pathConditions = pathConditions;
  }

  static _generatorOfEffects(realm, name, environmentRecordIdAfterGlobalCode, effects) {
    let { result, generator, modifiedBindings, modifiedProperties, createdObjects } = effects;

    let output = new Generator(realm, name, generator.pathConditions, effects);
    output.appendGenerator(generator, generator._name);

    for (let propertyBinding of modifiedProperties.keys()) {
      let object = propertyBinding.object;
      if (createdObjects.has(object)) continue; // Created Object's binding
      if (object.refuseSerialization) continue; // modification to internal state
      // modifications to intrinsic objects are tracked in the generator
      if (object.isIntrinsic()) continue;
      output.emitPropertyModification(propertyBinding);
    }

    for (let modifiedBinding of modifiedBindings.keys()) {
      // TODO: Instead of looking at the environment ids, keep instead track of a createdEnvironmentRecords set,
      // and only consider bindings here from environment records that already existed, or even better,
      // ensure upstream that only such bindings are ever added to the modified-bindings set.
      if (modifiedBinding.environment.id >= environmentRecordIdAfterGlobalCode) continue;

      output.emitBindingModification(modifiedBinding);
    }

    if (result instanceof _index.UndefinedValue) return output;
    if (result instanceof _completions.SimpleNormalCompletion || result instanceof _completions.ReturnCompletion) {
      output.emitReturnValue(result.value);
    } else if (result instanceof _completions.PossiblyNormalCompletion || result instanceof _completions.ForkedAbruptCompletion) {
      output.emitIfThenElse(result, realm);
    } else if (result instanceof _completions.ThrowCompletion) {
      output.emitThrow(result.value);
    } else if (result instanceof _completions.AbruptCompletion) {
      // no-op
    } else {
      (0, _invariant2.default)(false);
    }
    return output;
  }

  // Make sure to to fixup
  // how to apply things around sets of things
  static fromEffects(effects, realm, name, environmentRecordIdAfterGlobalCode = 0) {
    return realm.withEffectsAppliedInGlobalEnv(this._generatorOfEffects.bind(this, realm, name, environmentRecordIdAfterGlobalCode), effects);
  }

  emitPropertyModification(propertyBinding) {
    (0, _invariant2.default)(this.effectsToApply !== undefined);
    let desc = propertyBinding.descriptor;
    if (desc !== undefined) {
      let value = desc.value;
      if (value instanceof _index.AbstractValue) {
        if (value.kind === "conditional") {
          let [c, x, y] = value.args;
          if (c instanceof _index.AbstractValue && c.kind === "template for property name condition") {
            let ydesc = Object.assign({}, desc, { value: y });
            let yprop = Object.assign({}, propertyBinding, { descriptor: ydesc });
            this.emitPropertyModification(yprop);
            let xdesc = Object.assign({}, desc, { value: x });
            let key = c.args[0];
            (0, _invariant2.default)(key instanceof _index.AbstractValue);
            let xprop = Object.assign({}, propertyBinding, { key, descriptor: xdesc });
            this.emitPropertyModification(xprop);
            return;
          }
        } else if (value.kind === "template for prototype member expression") {
          return;
        }
      }
    }
    this._entries.push(new ModifiedPropertyEntry(this.realm, {
      propertyBinding,
      newDescriptor: desc,
      containingGenerator: this
    }));
  }

  emitBindingModification(modifiedBinding) {
    (0, _invariant2.default)(this.effectsToApply !== undefined);
    this._entries.push(new ModifiedBindingEntry(this.realm, {
      modifiedBinding,
      newValue: modifiedBinding.value,
      containingGenerator: this
    }));
  }

  emitReturnValue(result) {
    this._entries.push(new ReturnValueEntry(this.realm, this, result));
  }

  emitIfThenElse(result, realm) {
    this._entries.push(new IfThenElseEntry(this, result, realm));
  }

  getName() {
    return `${this._name}(#${this.id})`;
  }

  empty() {
    return this._entries.length === 0;
  }

  emitGlobalDeclaration(key, value) {
    this.preludeGenerator.declaredGlobals.add(key);
    if (!(value instanceof _index.UndefinedValue)) this.emitGlobalAssignment(key, value);
  }

  emitGlobalAssignment(key, value) {
    this._addEntry({
      args: [value],
      buildNode: ([valueNode]) => t.expressionStatement(t.assignmentExpression("=", this.preludeGenerator.globalReference(key, false), valueNode))
    });
  }

  emitConcreteModel(key, value) {
    this._addEntry({
      args: [(0, _singletons.concretize)(this.realm, value)],
      buildNode: ([valueNode]) => t.expressionStatement(t.assignmentExpression("=", this.preludeGenerator.globalReference(key, false), valueNode))
    });
  }

  emitGlobalDelete(key) {
    this._addEntry({
      args: [],
      buildNode: ([]) => t.expressionStatement(t.unaryExpression("delete", this.preludeGenerator.globalReference(key, false)))
    });
  }

  emitBindingAssignment(binding, value) {
    this._entries.push(new BindingAssignmentEntry(this.realm, binding, value));
  }

  emitPropertyAssignment(object, key, value) {
    if (object.refuseSerialization) return;
    this._addEntry({
      args: [object, value],
      buildNode: ([objectNode, valueNode], context) => context.getPropertyAssignmentStatement((0, _babelhelpers.memberExpressionHelper)(objectNode, key), value, value.mightHaveBeenDeleted(),
      /* deleteIfMightHaveBeenDeleted */true)
    });
  }

  emitDefineProperty(object, key, desc, isDescChanged = true) {
    if (object.refuseSerialization) return;
    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {
      let descValue = desc.value;
      (0, _invariant2.default)(descValue instanceof _index.Value);
      this.emitPropertyAssignment(object, key, descValue);
    } else {
      desc = Object.assign({}, desc);
      let descValue = desc.value || object.$Realm.intrinsics.undefined;
      (0, _invariant2.default)(descValue instanceof _index.Value);
      this._addEntry({
        args: [object, descValue, desc.get || object.$Realm.intrinsics.undefined, desc.set || object.$Realm.intrinsics.undefined],
        buildNode: (_, context) => context.emitDefinePropertyBody(object, key, desc)
      });
    }
  }

  emitPropertyDelete(object, key) {
    if (object.refuseSerialization) return;
    this._addEntry({
      args: [object],
      buildNode: ([objectNode]) => t.expressionStatement(t.unaryExpression("delete", (0, _babelhelpers.memberExpressionHelper)(objectNode, key)))
    });
  }

  emitCall(createCallee, args) {
    this._addEntry({
      args,
      buildNode: values => t.expressionStatement(t.callExpression(createCallee(), [...values]))
    });
  }

  emitConsoleLog(method, args) {
    this.emitCall(() => t.memberExpression(t.identifier("console"), t.identifier(method)), args.map(v => typeof v === "string" ? new _index.StringValue(this.realm, v) : v));
  }

  // test must be a temporal value, which means that it must have a defined intrinsicName
  emitDoWhileStatement(test, body) {
    this._addEntry({
      args: [],
      buildNode: function ([], context, valuesToProcess) {
        let testId = test.intrinsicName;
        (0, _invariant2.default)(testId !== undefined);
        let statements = context.serializeGenerator(body, valuesToProcess);
        let block = t.blockStatement(statements);
        return t.doWhileStatement(t.identifier(testId), block);
      },
      dependencies: [body]
    });
  }

  emitConditionalThrow(value) {
    function createStatement(val, context) {
      if (!(val instanceof _index.AbstractValue) || val.kind !== "conditional") {
        return t.throwStatement(context.serializeValue(val));
      }
      let [cond, trueVal, falseVal] = val.args;
      let condVal = context.serializeValue(cond);
      let trueStat, falseStat;
      if (trueVal instanceof _index.EmptyValue) trueStat = t.blockStatement([]);else trueStat = createStatement(trueVal, context);
      if (falseVal instanceof _index.EmptyValue) falseStat = t.blockStatement([]);else falseStat = createStatement(falseVal, context);
      return t.ifStatement(condVal, trueStat, falseStat);
    }
    this._addEntry({
      args: [value],
      buildNode: function ([argument], context) {
        return createStatement(value, context);
      }
    });
  }

  _issueThrowCompilerDiagnostic(value) {
    let message = "Program may terminate with exception";
    if (value instanceof _index.ObjectValue) {
      let object = value;
      let objectMessage = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue("message"));
      if (objectMessage instanceof _index.StringValue) message += `: ${objectMessage.value}`;
      const objectStack = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue("stack"));
      if (objectStack instanceof _index.StringValue) message += `
  ${objectStack.value}`;
    }
    const diagnostic = new _errors.CompilerDiagnostic(message, value.expressionLocation, "PP0023", "Warning");
    this.realm.handleError(diagnostic);
  }

  emitThrow(value) {
    this._issueThrowCompilerDiagnostic(value);
    this.emitStatement([value], ([argument]) => t.throwStatement(argument));
  }

  // Checks the full set of possible concrete values as well as typeof
  // for any AbstractValues
  // e.g: (obj.property !== undefined && typeof obj.property !== "object")
  // NB: if the type of the AbstractValue is top, skips the invariant
  emitFullInvariant(object, key, value) {
    if (object.refuseSerialization) return;
    let accessedPropertyOf = objectNode => (0, _babelhelpers.memberExpressionHelper)(objectNode, key);
    let condition;
    if (value instanceof _index.AbstractValue) {
      let isTop = false;
      let concreteComparisons = [];
      let typeComparisons = new Set();

      function populateComparisonsLists(absValue) {
        if (absValue.kind === "abstractConcreteUnion") {
          // recurse
          for (let nestedValue of absValue.args) if (nestedValue instanceof _index.ConcreteValue) {
            concreteComparisons.push(nestedValue);
          } else {
            (0, _invariant2.default)(nestedValue instanceof _index.AbstractValue);
            populateComparisonsLists(nestedValue);
          }
        } else if (absValue.getType() === _index.Value) {
          isTop = true;
        } else {
          typeComparisons.add(absValue.getType());
        }
      }
      populateComparisonsLists(value);

      // No point in doing the invariant if we don't know the type
      // of one of the nested abstract values
      if (isTop) {
        return;
      } else {
        condition = ([valueNode]) => {
          // Create `object.property !== concreteValue`
          let checks = concreteComparisons.map(concreteValue => t.binaryExpression("!==", valueNode, t.valueToNode(concreteValue.serialize())));
          // Create `typeof object.property !== typeValue`
          checks = checks.concat([...typeComparisons].map(typeValue => {
            let typeString = _singletons.Utils.typeToString(typeValue);
            (0, _invariant2.default)(typeString !== undefined, typeValue);
            return t.binaryExpression("!==", t.unaryExpression("typeof", valueNode, true), t.stringLiteral(typeString));
          }));
          return checks.reduce((expr, newCondition) => t.logicalExpression("&&", expr, newCondition));
        };
        this._emitInvariant([value, value], condition, valueNode => valueNode);
      }
    } else if (value instanceof _index.FunctionValue) {
      // We do a special case for functions,
      // as we like to use concrete functions in the model to model abstract behaviors.
      // These concrete functions do not have the right identity.
      condition = ([objectNode]) => t.binaryExpression("!==", t.unaryExpression("typeof", accessedPropertyOf(objectNode), true), t.stringLiteral("function"));
      this._emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));
    } else {
      condition = ([objectNode, valueNode]) => t.binaryExpression("!==", accessedPropertyOf(objectNode), valueNode);
      this._emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));
    }
  }

  getErrorStatement(message) {
    if (this.realm.invariantMode === "throw") return t.throwStatement(t.newExpression(this.preludeGenerator.memoizeReference("Error"), [message]));else {
      let targetReference = this.realm.invariantMode;
      let args = [message];
      let i = targetReference.indexOf("+");
      if (i !== -1) {
        let s = targetReference.substr(i + 1);
        let x = Number.parseInt(s, 10);
        args.push(isNaN(x) ? t.stringLiteral(s) : t.numericLiteral(x));
        targetReference = targetReference.substr(0, i);
      }
      return t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference(targetReference), args));
    }
  }

  emitPropertyInvariant(object, key, state) {
    if (object.refuseSerialization) return;
    let accessedPropertyOf = objectNode => (0, _babelhelpers.memberExpressionHelper)(objectNode, key);
    let condition = ([objectNode]) => {
      let n = t.callExpression(t.memberExpression(this.preludeGenerator.memoizeReference("Object.prototype.hasOwnProperty"), t.identifier("call")), [objectNode, t.stringLiteral(key)]);
      if (state !== "MISSING") {
        n = t.unaryExpression("!", n, true);
        if (state === "DEFINED") n = t.logicalExpression("||", n, t.binaryExpression("===", accessedPropertyOf(objectNode), t.valueToNode(undefined)));
      }
      return n;
    };

    this._emitInvariant([object, object], condition, objnode => accessedPropertyOf(objnode));
  }

  _emitInvariant(args, violationConditionFn, appendLastToInvariantFn) {
    (0, _invariant2.default)(this.realm.invariantLevel > 0);
    this._addEntry({
      args,
      buildNode: nodes => {
        let messageComponents = [t.stringLiteral("Prepack model invariant violation ("), t.numericLiteral(this.preludeGenerator.nextInvariantId++)];
        if (appendLastToInvariantFn) {
          let last = nodes.pop();
          messageComponents.push(t.stringLiteral("): "));
          messageComponents.push(appendLastToInvariantFn(last));
        } else messageComponents.push(t.stringLiteral(")"));
        let throwString = messageComponents[0];
        for (let i = 1; i < messageComponents.length; i++) throwString = t.binaryExpression("+", throwString, messageComponents[i]);
        let condition = violationConditionFn(nodes);
        let consequent = this.getErrorStatement(throwString);
        return t.ifStatement(condition, consequent);
      }
    });
  }

  emitCallAndCaptureResult(types, values, createCallee, args, kind) {
    return this.deriveAbstract(types, values, args, nodes => t.callExpression(createCallee(), nodes), { kind });
  }

  emitStatement(args, buildNode_) {
    this._addEntry({
      args,
      buildNode: buildNode_
    });
  }

  emitVoidExpression(types, values, args, buildNode_) {
    this._addEntry({
      args,
      buildNode: nodes => t.expressionStatement(buildNode_ instanceof Function ? buildNode_(nodes) : buildNode_)
    });
    return this.realm.intrinsics.undefined;
  }

  emitForInStatement(o, lh, sourceObject, targetObject, boundName) {
    this._addEntry({
      // duplicate args to ensure refcount > 1
      args: [o, targetObject, sourceObject, targetObject, sourceObject],
      buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {
        return t.forInStatement(lh, obj, t.blockStatement([t.expressionStatement(t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(tgt, boundName), (0, _babelhelpers.memberExpressionHelper)(src, boundName)))]));
      }
    });
  }

  deriveConcreteObject(buildValue, args, buildNode_, optionalArgs) {
    (0, _invariant2.default)(buildNode_ instanceof Function || args.length === 0);
    let id = t.identifier(this.preludeGenerator.nameGenerator.generate("derived"));
    let value = buildValue(id.name);
    value.intrinsicNameGenerated = true;
    value._isScopedTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope
    this._addDerivedEntry(id.name, {
      isPure: optionalArgs ? optionalArgs.isPure : undefined,
      declared: value,
      args,
      buildNode: (nodes, context, valuesToProcess) => {
        return t.variableDeclaration("var", [t.variableDeclarator(id, buildNode_ instanceof Function ? buildNode_(nodes, context, valuesToProcess) : buildNode_)]);
      }
    });
    return value;
  }

  deriveAbstract(types, values, args, buildNode_, optionalArgs) {
    (0, _invariant2.default)(buildNode_ instanceof Function || args.length === 0);
    let id = t.identifier(this.preludeGenerator.nameGenerator.generate("derived"));
    let options = {};
    if (optionalArgs && optionalArgs.kind) options.kind = optionalArgs.kind;
    let Constructor = _index.Value.isTypeCompatibleWith(types.getType(), _index.ObjectValue) ? _index.AbstractObjectValue : _index.AbstractValue;
    let res = new Constructor(this.realm, types, values, 1735003607742176 + this.realm.derivedIds.size, [], id, options);
    this._addDerivedEntry(id.name, {
      isPure: optionalArgs ? optionalArgs.isPure : undefined,
      declared: res,
      args,
      buildNode: (nodes, context, valuesToProcess) => {
        return t.variableDeclaration("var", [t.variableDeclarator(id, buildNode_ instanceof Function ? buildNode_(nodes, context, valuesToProcess) : buildNode_)]);
      },
      mutatesOnly: optionalArgs ? optionalArgs.mutatesOnly : undefined,
      temporalType: optionalArgs ? optionalArgs.temporalType : undefined
    });
    let type = types.getType();
    res.intrinsicName = id.name;
    if (optionalArgs && optionalArgs.skipInvariant) return res;
    let typeofString;
    if (type instanceof _index.FunctionValue) typeofString = "function";else if (type === _index.UndefinedValue) (0, _invariant2.default)(false);else if (type === _index.NullValue) (0, _invariant2.default)(false);else if (type === _index.StringValue) typeofString = "string";else if (type === _index.BooleanValue) typeofString = "boolean";else if (type === _index.NumberValue) typeofString = "number";else if (type === _index.IntegralValue) typeofString = "number";else if (type === _index.SymbolValue) typeofString = "symbol";else if (type === _index.ObjectValue) typeofString = "object";
    if (typeofString !== undefined && this.realm.invariantLevel >= 1) {
      // Verify that the types are as expected, a failure of this invariant
      // should mean the model is wrong.
      this._emitInvariant([res, res], nodes => {
        (0, _invariant2.default)(typeofString !== undefined);
        let condition = t.binaryExpression("!==", t.unaryExpression("typeof", nodes[0]), t.stringLiteral(typeofString));
        if (typeofString === "object") {
          condition = t.logicalExpression("&&", condition, t.binaryExpression("!==", t.unaryExpression("typeof", nodes[0]), t.stringLiteral("function")));
          condition = t.logicalExpression("||", condition, t.binaryExpression("===", nodes[0], _babelhelpers.nullExpression));
        }
        return condition;
      }, node => node);
    }

    return res;
  }

  visit(callbacks) {
    let visitFn = () => {
      for (let entry of this._entries) entry.visit(callbacks, this);
      return null;
    };
    if (this.effectsToApply) {
      this.realm.withEffectsAppliedInGlobalEnv(visitFn, this.effectsToApply);
    } else {
      visitFn();
    }
  }

  serialize(context) {
    let serializeFn = () => {
      context.initGenerator(this);
      for (let entry of this._entries) entry.serialize(context);
      context.finalizeGenerator(this);
      return null;
    };
    if (this.effectsToApply) {
      this.realm.withEffectsAppliedInGlobalEnv(serializeFn, this.effectsToApply);
    } else {
      serializeFn();
    }
  }

  getDependencies() {
    let res = [];
    for (let entry of this._entries) {
      let dependencies = entry.getDependencies();
      if (dependencies !== undefined) res.push(...dependencies);
    }
    return res;
  }

  _addEntry(entryArgs) {
    let entry;
    if (entryArgs.temporalType === "OBJECT_ASSIGN") {
      entry = new TemporalObjectAssignEntry(this.realm, entryArgs);
    } else {
      entry = new TemporalBuildNodeEntry(this.realm, entryArgs);
    }
    this.realm.saveTemporalGeneratorEntryArgs(entry);
    this._entries.push(entry);
    return entry;
  }

  _addDerivedEntry(id, entryArgs) {
    let entry = this._addEntry(entryArgs);
    this.realm.derivedIds.set(id, entry);
  }

  appendGenerator(other, leadingComment) {
    (0, _invariant2.default)(other !== this);
    (0, _invariant2.default)(other.realm === this.realm);
    (0, _invariant2.default)(other.preludeGenerator === this.preludeGenerator);

    if (other.empty()) return;
    if (other.effectsToApply === undefined) {
      this._entries.push(...other._entries);
    } else {
      this._addEntry({
        args: [],
        buildNode: function (args, context, valuesToProcess) {
          let statements = context.serializeGenerator(other, valuesToProcess);
          if (statements.length === 1) {
            let statement = statements[0];
            if (leadingComment.length > 0) statement.leadingComments = [{ type: "BlockComment", value: leadingComment }];
            return statement;
          }
          let block = t.blockStatement(statements);
          if (leadingComment.length > 0) block.leadingComments = [{ type: "BlockComment", value: leadingComment }];
          return block;
        },
        dependencies: [other]
      });
    }
  }

  joinGenerators(joinCondition, generator1, generator2) {
    (0, _invariant2.default)(generator1 !== this && generator2 !== this && generator1 !== generator2);
    if (generator1.empty() && generator2.empty()) return;
    this._addEntry({
      args: [joinCondition],
      buildNode: function ([cond], context, valuesToProcess) {
        let block1 = generator1.empty() ? null : serializeBody(generator1, context, valuesToProcess);
        let block2 = generator2.empty() ? null : serializeBody(generator2, context, valuesToProcess);
        if (block1) return t.ifStatement(cond, block1, block2);
        (0, _invariant2.default)(block2);
        return t.ifStatement(t.unaryExpression("!", cond), block2);
      },
      dependencies: [generator1, generator2]
    });
  }
}

exports.Generator = Generator;
function escapeInvalidIdentifierCharacters(s) {
  let res = "";
  for (let c of s) if (c >= "0" && c <= "9" || c >= "a" && c <= "z" || c >= "A" && c <= "Z") res += c;else res += "_" + c.charCodeAt(0);
  return res;
}

const base62characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function base62encode(n) {
  (0, _invariant2.default)((n | 0) === n && n >= 0);
  if (n === 0) return "0";
  let s = "";
  while (n > 0) {
    let f = n % base62characters.length;
    s = base62characters[f] + s;
    n = (n - f) / base62characters.length;
  }
  return s;
}

class NameGenerator {
  constructor(forbiddenNames, debugNames, uniqueSuffix, prefix) {
    this.prefix = prefix;
    this.uidCounter = 0;
    this.debugNames = debugNames;
    this.forbiddenNames = forbiddenNames;
    this.uniqueSuffix = uniqueSuffix;
  }

  generate(debugSuffix) {
    let id;
    do {
      id = this.prefix + base62encode(this.uidCounter++);
      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;
      if (this.debugNames) {
        if (debugSuffix) id += "_" + escapeInvalidIdentifierCharacters(debugSuffix);else id += "_";
      }
    } while (this.forbiddenNames.has(id));
    return id;
  }
}

exports.NameGenerator = NameGenerator;
class PreludeGenerator {
  constructor(debugNames, uniqueSuffix) {
    this.prelude = [];
    this.memoizedRefs = new Map();
    this.nameGenerator = new NameGenerator(new Set(), !!debugNames, uniqueSuffix || "", "_$");
    this.usesThis = false;
    this.declaredGlobals = new Set();
    this.nextInvariantId = 0;
  }

  createNameGenerator(prefix) {
    return new NameGenerator(this.nameGenerator.forbiddenNames, this.nameGenerator.debugNames, this.nameGenerator.uniqueSuffix, prefix);
  }

  convertStringToMember(str) {
    return str.split(".").map(name => {
      if (name === "global") {
        return this.memoizeReference(name);
      } else if (name === "this") {
        return t.thisExpression();
      } else {
        return t.identifier(name);
      }
    }).reduce((obj, prop) => t.memberExpression(obj, prop));
  }

  globalReference(key, globalScope = false) {
    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);
    return (0, _babelhelpers.memberExpressionHelper)(this.memoizeReference("global"), key);
  }

  memoizeReference(key) {
    let ref = this.memoizedRefs.get(key);
    if (ref) return ref;

    let init;
    if (key.includes("(") || key.includes("[")) {
      // Horrible but effective hack:
      // Some internal object have intrinsic names such as
      //    ([][Symbol.iterator]().__proto__.__proto__)
      // and
      //    RegExp.prototype[Symbol.match]
      // which get turned into a babel node here.
      // TODO: We should properly parse such a string, and memoize all references in it separately.
      // Instead, we just turn it into a funky identifier, which Babel seems to accept.
      init = t.identifier(key);
    } else if (key === "global") {
      this.usesThis = true;
      init = t.thisExpression();
    } else {
      let i = key.lastIndexOf(".");
      if (i === -1) {
        init = t.memberExpression(this.memoizeReference("global"), t.identifier(key));
      } else {
        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));
      }
    }
    ref = t.identifier(this.nameGenerator.generate(key));
    this.prelude.push(t.variableDeclaration("var", [t.variableDeclarator(ref, init)]));
    this.memoizedRefs.set(key, ref);
    return ref;
  }
}

exports.PreludeGenerator = PreludeGenerator;


// This function attempts to optimize Object.assign calls, by merging mulitple
// calls into one another where possible. For example:
//
// var a = Object.assign({}, someAbstact);
// var b = Object.assign({}, a);
//
// Becomes:
// var b = Object.assign({}, someAbstract, a);
//
function attemptToMergeEquivalentObjectAssigns(realm, callbacks, temporalBuildNodeEntry) {
  let args = temporalBuildNodeEntry.args;
  // If we are Object.assigning 2 or more args
  if (args.length < 2) {
    return "NO_OPTIMIZATION";
  }
  let to = args[0];
  // Then scan through the args after the "to" of this Object.assign, to see if any
  // other sources are the "to" of a previous Object.assign call
  loopThroughArgs: for (let i = 1; i < args.length; i++) {
    let possibleOtherObjectAssignTo = args[i];
    // Ensure that the "to" value can be omitted
    // Note: this check is still somewhat fragile and depends on the visiting order
    // but it's not a functional problem right now and can be better addressed at a
    // later point.
    if (!callbacks.canOmit(possibleOtherObjectAssignTo)) {
      continue;
    }
    // Check if the "to" was definitely an Object.assign, it should
    // be a snapshot AbstractObjectValue
    if (possibleOtherObjectAssignTo instanceof _index.AbstractObjectValue) {
      let otherTemporalBuildNodeEntry = realm.getTemporalBuildNodeEntryFromDerivedValue(possibleOtherObjectAssignTo);
      if (!(otherTemporalBuildNodeEntry instanceof TemporalObjectAssignEntry)) {
        continue;
      }
      let otherArgs = otherTemporalBuildNodeEntry.args;
      // Object.assign has at least 1 arg
      if (otherArgs.length < 2) {
        continue;
      }
      let otherArgsToUse = [];
      for (let x = 1; x < otherArgs.length; x++) {
        let arg = otherArgs[x];
        // The arg might have been havoced, so ensure we do not continue in this case
        if (arg instanceof _index.ObjectValue && arg.mightBeHavocedObject()) {
          continue loopThroughArgs;
        }
        if (arg instanceof _index.ObjectValue || arg instanceof _index.AbstractValue) {
          let temporalGeneratorEntries = realm.getTemporalGeneratorEntriesReferencingArg(arg);
          // We need to now check if there are any other temporal entries that exist
          // between the Object.assign TemporalObjectAssignEntry that we're trying to
          // merge and the current TemporalObjectAssignEntry we're going to merge into.
          if (temporalGeneratorEntries !== undefined) {
            for (let temporalGeneratorEntry of temporalGeneratorEntries) {
              // If the entry is that of another Object.assign, then
              // we know that this entry isn't going to cause issues
              // with merging the TemporalObjectAssignEntry.
              if (temporalGeneratorEntry instanceof TemporalObjectAssignEntry) {
                continue;
              }
              // TODO: what if the temporalGeneratorEntry can be omitted and not needed?

              // If the index of this entry exists between start and end indexes,
              // then we cannot optimize and merge the TemporalObjectAssignEntry
              // because another generator entry may have a dependency on the Object.assign
              // TemporalObjectAssignEntry we're trying to merge.
              if (temporalGeneratorEntry.notEqualToAndDoesNotHappenBefore(otherTemporalBuildNodeEntry) && temporalGeneratorEntry.notEqualToAndDoesNotHappenAfter(temporalBuildNodeEntry)) {
                continue loopThroughArgs;
              }
            }
          }
        }
        otherArgsToUse.push(arg);
      }
      // If we cannot omit the "to" value that means it's being used, so we shall not try to
      // optimize this Object.assign.
      if (!callbacks.canOmit(to)) {
        let newArgs = [to, ...otherArgsToUse];

        for (let x = 2; x < args.length; x++) {
          let arg = args[x];
          // We don't want to add the "to" that we're merging with!
          if (arg !== possibleOtherObjectAssignTo) {
            newArgs.push(arg);
          }
        }
        // We now create a new TemporalObjectAssignEntry, without mutating the existing
        // entry at this point. This new entry is essentially a TemporalObjectAssignEntry
        // that contains two Object.assign call TemporalObjectAssignEntry entries that have
        // been merged into a single entry. The previous Object.assign TemporalObjectAssignEntry
        // should dead-code eliminate away once we replace the original TemporalObjectAssignEntry
        // we started with with the new merged on as they will no longer be referenced.
        let newTemporalObjectAssignEntryArgs = Object.assign({}, temporalBuildNodeEntry, {
          args: newArgs
        });
        return new TemporalObjectAssignEntry(realm, newTemporalObjectAssignEntryArgs);
      }
      // We might be able to optimize, but we are not sure because "to" can still omit.
      // So we return possible optimization status and wait until "to" does get visited.
      // It may never get visited, but that's okay as we'll skip the optimization all
      // together.
      return "POSSIBLE_OPTIMIZATION";
    }
  }
  return "NO_OPTIMIZATION";
}
//# sourceMappingURL=generator.js.map