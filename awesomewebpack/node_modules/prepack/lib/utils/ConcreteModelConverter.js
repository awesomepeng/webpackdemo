"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concretize = concretize;

var _index = require("../values/index.js");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _errors = require("../errors.js");

var _index2 = require("../methods/index.js");

var _singletons = require("../singletons.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * This file contains code that converts abstract models into concrete values.
 */

function reportCompileError(realm, message, loc) {
  let error = new _errors.CompilerDiagnostic(message, loc, "PP9000", "RecoverableError");
  realm.handleError(error);
}

function createEmptyFunction(realm) {
  const concreteFunction = new _index.ECMAScriptSourceFunctionValue(realm);
  concreteFunction.$ECMAScriptCode = t.blockStatement([]);
  concreteFunction.$FormalParameters = [];
  concreteFunction.$ECMAScriptCode.uniqueOrderedTag = realm.functionBodyUniqueTagSeed++;
  return concreteFunction;
}

/**
 * Convert abstract model value into concrete value.
 */
function concretize(realm, val) {
  if (val instanceof _index.ConcreteValue) {
    return val;
  }
  (0, _invariant2.default)(val instanceof _index.AbstractValue);
  if (val.kind === "abstractConcreteUnion") {
    (0, _invariant2.default)(val.args.length > 0);
    return concretize(realm, val.args[0]);
  }
  const type = val.types.getType();
  if (val.types.isTop()) {
    return new _index.UndefinedValue(realm);
  } else if (type.prototype instanceof _index.PrimitiveValue) {
    if (val.values.isTop()) {
      switch (type) {
        case _index.StringValue:
          return new _index.StringValue(realm, "__concreteModel");
        case _index.NumberValue:
          return new _index.NumberValue(realm, 42);
        case _index.SymbolValue:
          return new _index.SymbolValue(realm, new _index.StringValue(realm, "__concreteModel"));
        case _index.BooleanValue:
          return new _index.BooleanValue(realm, true);
        case _index.NullValue:
          return new _index.NullValue(realm);
        case _index.UndefinedValue:
          return new _index.UndefinedValue(realm);
        default:
          (0, _invariant2.default)(false, "Not yet implemented");
      }
    } else {
      // TODO: This was broken. Is this actually used?
      const values = val.values.getElements();
      (0, _invariant2.default)(values.size === 1, "Concrete model should only have one value");
      for (let value in values) {
        (0, _invariant2.default)(value instanceof _index.ConcreteValue, "Concrete model should only contain one concrete value");
        return value;
      }
      (0, _invariant2.default)(false);
    }
  } else if (type === _index.FunctionValue) {
    return createEmptyFunction(realm);
  } else if (type === _index.ArrayValue) {
    reportCompileError(realm, "Emitting a concrete model for abstract array value is not supported yet.", val.expressionLocation);
  } else if (val instanceof _index.AbstractObjectValue) {
    if (val.values.isTop()) {
      return new _index.ObjectValue(realm);
    } else {
      let template = val.getTemplate();
      let valIsPartial = false;
      if (val.isPartialObject()) {
        valIsPartial = true;
        val.makeNotPartial();
      }
      let concreteObj = _singletons.Create.ObjectCreate(realm, template.$GetPrototypeOf());
      try {
        let keys = (0, _index2.EnumerableOwnProperties)(realm, template, "key");
        for (let P of keys) {
          (0, _invariant2.default)(P instanceof _index.StringValue);
          let newElement = (0, _index2.Get)(realm, template, P);
          _singletons.Create.CreateDataProperty(realm, concreteObj, P, concretize(realm, newElement));
        }
      } finally {
        if (valIsPartial) {
          val.makePartial();
        }
      }
      return concreteObj;
    }
  }
  reportCompileError(realm, "Emitting a concrete model for this abstract value is not supported yet.", val.expressionLocation);
  // Return undefined to make flow happy.
  return new _index.UndefinedValue(realm);
}
//# sourceMappingURL=ConcreteModelConverter.js.map