{"version":3,"sources":["../../src/utils/havoc.js"],"names":["t","visitName","path","state","name","read","write","scope","hasBinding","unboundReads","add","unboundWrites","ignorePath","parent","isLabeledStatement","isBreakStatement","isContinueStatement","HavocedClosureRefVisitor","ReferencedIdentifier","innerName","node","doesRead","operator","getBindingIdentifiers","getHavocedFunctionInfo","value","constructor","functionInfo","Set","formalParameters","$FormalParameters","code","$ECMAScriptCode","file","program","expressionStatement","functionExpression","clearCache","ObjectValueHavocingVisitor","realm","objectsTrackedForHavoc","visitedValues","getHeapInspector","_heapInspector","undefined","mustVisit","val","has","visitObjectProperty","binding","desc","descriptor","visitDescriptor","visitObjectProperties","obj","kind","propertyBindingValue","symbols","properties","unknownProperty","visitObjectPropertiesWithComputedNames","visitObjectPrototype","mightNotBeHavocedObject","havoc","size","realmGenerator","generator","propertyBinding","canIgnoreProperty","emitPropertyDelete","targetDescriptor","getTargetIntegrityDescriptor","writable","configurable","emitDefineProperty","emitPropertyAssignment","proto","$Prototype","visitValue","absVal","cond","args","P","V","earlier_props","consequent","alternate","get","set","visitDeclarativeEnvironmentRecordBinding","record","remainingHavocedBindings","bindings","bindingName","Object","keys","isRead","delete","isWritten","visitValueMap","getKind","entries","$MapData","$WeakMapData","len","length","i","entry","key","$Key","$Value","visitValueSet","$SetData","$WeakSetData","visitValueFunction","$BoundTargetFunction","$BoundThis","boundArg","$BoundArguments","environment","$Environment","environmentRecord","object","fn","$FunctionObject","visitValueObject","dateValue","$DateValue","buf","$ViewedArrayBuffer","$ParameterMap","visitValueProxy","$ProxyTarget","$ProxyHandler","visitAbstractValue","mightBeObject","values","isTop","whitelistedKind","startsWith","intrinsicName","n","element","getElements","isIntrinsic","isIntrinsicAndHasWidenedNumericProperty","ensureFrozenValue","loc","diag","currentLocation","handleError","HavocImplementation","instantRender","enabled","createdObjectsTrackedForLeaks","visitor"],"mappings":"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","file":"havoc.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport {\n  havocBinding,\n  DeclarativeEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"../environment.js\";\nimport {\n  AbstractValue,\n  ArrayValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  PrimitiveValue,\n  ProxyValue,\n  Value,\n} from \"../values/index.js\";\nimport { TestIntegrityLevel } from \"../methods/index.js\";\nimport * as t from \"babel-types\";\nimport traverse from \"babel-traverse\";\nimport type { BabelTraversePath } from \"babel-traverse\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { isReactElement } from \"../react/utils.js\";\n\ntype HavocedFunctionInfo = {\n  unboundReads: Set<string>,\n  unboundWrites: Set<string>,\n};\n\nfunction visitName(\n  path: BabelTraversePath,\n  state: HavocedFunctionInfo,\n  name: string,\n  read: boolean,\n  write: boolean\n): void {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  if (read) state.unboundReads.add(name);\n  if (write) state.unboundWrites.add(name);\n}\n\nfunction ignorePath(path: BabelTraversePath): boolean {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nlet HavocedClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: HavocedFunctionInfo): void {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      return;\n    }\n    visitName(path, state, innerName, true, false);\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: HavocedFunctionInfo): void {\n    let doesRead = path.node.operator !== \"=\";\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, doesRead, true);\n    }\n  },\n};\n\nfunction getHavocedFunctionInfo(value: FunctionValue) {\n  // TODO: This should really be cached on a per AST basis in case we have\n  // many uses of the same closure. It should ideally share this cache\n  // and data with ResidualHeapVisitor.\n  invariant(value instanceof ECMAScriptSourceFunctionValue);\n  invariant(value.constructor === ECMAScriptSourceFunctionValue);\n  let functionInfo = {\n    unboundReads: new Set(),\n    unboundWrites: new Set(),\n  };\n  let formalParameters = value.$FormalParameters;\n  invariant(formalParameters != null);\n  let code = value.$ECMAScriptCode;\n  invariant(code != null);\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n    HavocedClosureRefVisitor,\n    null,\n    functionInfo\n  );\n  traverse.clearCache();\n  return functionInfo;\n}\n\nclass ObjectValueHavocingVisitor {\n  realm: Realm;\n  // ObjectValues to visit if they're reachable.\n  objectsTrackedForHavoc: Set<ObjectValue>;\n  // Values that has been visited.\n  visitedValues: Set<Value>;\n  _heapInspector: HeapInspector;\n\n  constructor(realm: Realm, objectsTrackedForHavoc: Set<ObjectValue>) {\n    this.realm = realm;\n    this.objectsTrackedForHavoc = objectsTrackedForHavoc;\n    this.visitedValues = new Set();\n  }\n\n  getHeapInspector(): HeapInspector {\n    if (this._heapInspector === undefined)\n      this._heapInspector = new HeapInspector(this.realm, new Logger(this.realm, /*internalDebug*/ false));\n    return this._heapInspector;\n  }\n\n  mustVisit(val: Value): boolean {\n    if (val instanceof ObjectValue) {\n      // For Objects we only need to visit it if it is tracked\n      // as a newly created object that might still be mutated.\n      // Abstract values gets their arguments visited.\n      if (!this.objectsTrackedForHavoc.has(val)) return false;\n    }\n    if (this.visitedValues.has(val)) return false;\n    this.visitedValues.add(val);\n    return true;\n  }\n\n  visitObjectProperty(binding: PropertyBinding): void {\n    let desc = binding.descriptor;\n    if (desc === undefined) return; //deleted\n    this.visitDescriptor(desc);\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    // visit symbol properties\n    for (let [, propertyBindingValue] of obj.symbols) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // visit string properties\n    for (let [, propertyBindingValue] of obj.properties) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      if (desc !== undefined) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      }\n    }\n\n    // prototype\n    this.visitObjectPrototype(obj);\n\n    if (TestIntegrityLevel(this.realm, obj, \"frozen\")) return;\n\n    // if this object wasn't already havoced, we need mark it as havoced\n    // so that any mutation and property access get tracked after this.\n    if (obj.mightNotBeHavocedObject()) {\n      obj.havoc();\n      if (obj.symbols.size > 0) {\n        throw new FatalError(\"TODO: Support havocing objects with symbols\");\n      }\n      if (obj.unknownProperty !== undefined) {\n        // TODO: Support unknown properties, or throw FatalError.\n        // We have repros, e.g. test/serializer/additional-functions/ArrayConcat.js.\n      }\n      // TODO: We should emit current value and then reset value for all *internal slots*; this will require deep serializer support; or throw FatalError when we detect any non-initial values in internal slots.\n      let realmGenerator = this.realm.generator;\n      for (let [name, propertyBinding] of obj.properties) {\n        // ignore properties with their correct default values\n        if (this.getHeapInspector().canIgnoreProperty(obj, name)) continue;\n\n        let descriptor = propertyBinding.descriptor;\n        if (descriptor === undefined) {\n          // TODO: This happens, e.g. test/serializer/pure-functions/ObjectAssign2.js\n          // If it indeed means deleted binding, should we initialize descriptor with a deleted value?\n          if (realmGenerator !== undefined) realmGenerator.emitPropertyDelete(obj, name);\n        } else {\n          let value = descriptor.value;\n          invariant(\n            value === undefined || value instanceof Value,\n            \"cannot be an array because we are not dealing with intrinsics here\"\n          );\n          if (value === undefined) {\n            // TODO: Deal with accessor properties\n            // We have repros, e.g. test/serializer/pure-functions/AbstractPropertyObjectKeyAssignment.js\n          } else {\n            invariant(value instanceof Value);\n            if (value instanceof EmptyValue) {\n              if (realmGenerator !== undefined) realmGenerator.emitPropertyDelete(obj, name);\n            } else {\n              if (realmGenerator !== undefined) {\n                let targetDescriptor = this.getHeapInspector().getTargetIntegrityDescriptor(obj);\n                if (!isReactElement(obj)) {\n                  if (\n                    descriptor.writable !== targetDescriptor.writable ||\n                    descriptor.configurable !== targetDescriptor.configurable\n                  ) {\n                    realmGenerator.emitDefineProperty(obj, name, descriptor);\n                  } else {\n                    realmGenerator.emitPropertyAssignment(obj, name, value);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue): void {\n    let proto = obj.$Prototype;\n    this.visitValue(proto);\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    if (absVal.kind === \"widened property\") return;\n    if (absVal.kind === \"template for prototype member expression\") return;\n    if (absVal.kind === \"conditional\") {\n      let cond = absVal.args[0];\n      invariant(cond instanceof AbstractValue);\n      if (cond.kind === \"template for property name condition\") {\n        let P = cond.args[0];\n        invariant(P instanceof AbstractValue);\n        let V = absVal.args[1];\n        let earlier_props = absVal.args[2];\n        if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n        this.visitValue(P);\n        this.visitValue(V);\n      } else {\n        // conditional assignment\n        this.visitValue(cond);\n        let consequent = absVal.args[1];\n        if (consequent instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(consequent);\n        }\n        let alternate = absVal.args[2];\n        if (alternate instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(alternate);\n        }\n      }\n    } else {\n      this.visitValue(absVal);\n    }\n  }\n\n  visitDescriptor(desc: Descriptor): void {\n    invariant(desc.value === undefined || desc.value instanceof Value);\n    if (desc.value !== undefined) this.visitValue(desc.value);\n    if (desc.get !== undefined) this.visitValue(desc.get);\n    if (desc.set !== undefined) this.visitValue(desc.set);\n  }\n\n  visitDeclarativeEnvironmentRecordBinding(\n    record: DeclarativeEnvironmentRecord,\n    remainingHavocedBindings: HavocedFunctionInfo\n  ): void {\n    let bindings = record.bindings;\n    for (let bindingName of Object.keys(bindings)) {\n      let binding = bindings[bindingName];\n      // Check if this binding is referenced, and if so delete it from the set.\n      let isRead = remainingHavocedBindings.unboundReads.delete(bindingName);\n      let isWritten = remainingHavocedBindings.unboundWrites.delete(bindingName);\n      if (isRead) {\n        // If this binding can be read from the closure, its value has now havoced.\n        let value = binding.value;\n        if (value) {\n          this.visitValue(value);\n        }\n      }\n      if (isWritten || isRead) {\n        // If this binding could have been mutated from the closure, then the\n        // binding itself has now leaked, but not necessarily the value in it.\n        // TODO: We could tag a leaked binding as read and/or write. That way\n        // we don't have to havoc values written to this binding if only the binding\n        // has been written to. We also don't have to havoc reads from this binding\n        // if it is only read from.\n        havocBinding(binding);\n      }\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueFunction(val: FunctionValue): void {\n    if (!val.mightNotBeHavocedObject()) {\n      return;\n    }\n    this.visitObjectProperties(val);\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(\n      !(val instanceof NativeFunctionValue),\n      \"all native function values should have already been created outside this pure function\"\n    );\n\n    let remainingHavocedBindings = getHavocedFunctionInfo(val);\n\n    let environment = val.$Environment;\n    while (environment) {\n      let record = environment.environmentRecord;\n      if (record instanceof ObjectEnvironmentRecord) {\n        this.visitValue(record.object);\n        continue;\n      }\n      if (record instanceof GlobalEnvironmentRecord) {\n        break;\n      }\n\n      invariant(record instanceof DeclarativeEnvironmentRecord);\n      this.visitDeclarativeEnvironmentRecordBinding(record, remainingHavocedBindings);\n\n      if (record instanceof FunctionEnvironmentRecord) {\n        // If this is a function environment, which is not tracked for havocs,\n        // we can bail out because its bindings should not be mutated in a\n        // pure function.\n        let fn = record.$FunctionObject;\n        if (!this.objectsTrackedForHavoc.has(fn)) {\n          break;\n        }\n      }\n      environment = environment.parent;\n    }\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    if (!val.mightNotBeHavocedObject()) {\n      return;\n    }\n\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ReactElement\":\n      case \"ArrayBuffer\":\n      case \"Array\":\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        this.visitValueMap(val);\n        return;\n      case \"Set\":\n      case \"WeakSet\":\n        this.visitValueSet(val);\n        return;\n      default:\n        invariant(kind === \"Object\", `Object of kind ${kind} is not supported in calls to abstract functions.`);\n        invariant(val.$ParameterMap === undefined, `Arguments object is not supported in calls to abstract functions.`);\n        return;\n    }\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    if (!val.mightBeObject()) {\n      // Only objects need to be havoced.\n      return;\n    }\n    if (val.values.isTop()) {\n      // If we don't know which object instances it might be,\n      // then it might be one of the arguments that created\n      // this value. See #2179.\n\n      if (val.kind === \"conditional\") {\n        // For a conditional, we only have to visit each case. Not the condition itself.\n        this.visitValue(val.args[1]);\n        this.visitValue(val.args[2]);\n        return;\n      }\n\n      // To ensure that we don't forget to provide arguments\n      // that can be havoced, we require at least one argument.\n      let whitelistedKind =\n        val.kind &&\n        (val.kind === \"widened numeric property\" || // TODO: Widened properties needs to be havocable.\n          val.kind.startsWith(\"abstractCounted\"));\n      invariant(\n        whitelistedKind || val.intrinsicName || val.args.length > 0,\n        \"Havoced unknown object requires havocable arguments\"\n      );\n\n      // TODO: This is overly conservative. We recursively havoc all the inputs\n      // to this operation whether or not they can possible be part of the\n      // result value or not.\n      for (let i = 0, n = val.args.length; i < n; i++) {\n        this.visitValue(val.args[i]);\n      }\n      return;\n    }\n    // If we know which objects this might be, then havoc each of them.\n    for (let element of val.values.getElements()) {\n      this.visitValue(element);\n    }\n  }\n\n  visitValue(val: Value): void {\n    if (val instanceof AbstractValue) {\n      if (this.mustVisit(val)) this.visitAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time (except unknown arrays)...\n      // ...except for a few that come into existance as templates for abstract objects.\n      if (val instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(val)) {\n        if (this.mustVisit(val)) this.visitValueObject(val);\n      } else {\n        this.mustVisit(val);\n      }\n    } else if (val instanceof EmptyValue) {\n      this.mustVisit(val);\n    } else if (val instanceof PrimitiveValue) {\n      this.mustVisit(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.mustVisit(val)) this.visitValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      invariant(val instanceof FunctionValue);\n      if (this.mustVisit(val)) this.visitValueFunction(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n      if (this.mustVisit(val)) this.visitValueObject(val);\n    }\n  }\n}\n\nfunction ensureFrozenValue(realm, value, loc): void {\n  // TODO: This should really check if it is recursively immutability.\n  if (value instanceof ObjectValue && !TestIntegrityLevel(realm, value, \"frozen\")) {\n    let diag = new CompilerDiagnostic(\n      \"Unfrozen object leaked before end of global code\",\n      loc || realm.currentLocation,\n      \"PP0017\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(diag) !== \"Recover\") throw new FatalError();\n  }\n}\n\n// Ensure that a value is immutable. If it is not, set all its properties to abstract values\n// and all reachable bindings to abstract values.\nexport class HavocImplementation {\n  value(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation): void {\n    if (realm.instantRender.enabled) {\n      // TODO: For InstantRender...\n      // - For declarative bindings, we do want proper materialization/leaking/havocing\n      // - For object properties, we conceptually want materialization\n      //   (however, not via statements that mutate the objects,\n      //   but only as part of the initial object literals),\n      //   but actual no leaking or havocing as there should be a way to annotate/enforce\n      //   that external/abstract functions are pure with regards to heap objects\n      return;\n    }\n    let objectsTrackedForHavoc = realm.createdObjectsTrackedForLeaks;\n    if (objectsTrackedForHavoc === undefined) {\n      // We're not tracking a pure function. That means that we would track\n      // everything as havoced. We'll assume that any object argument\n      // is invalid unless it's frozen.\n      ensureFrozenValue(realm, value, loc);\n    } else {\n      // If we're tracking a pure function, we can assume that only newly\n      // created objects and bindings, within it, are mutable. Any other\n      // object can safely be assumed to be deeply immutable as far as this\n      // pure function is concerned. However, any mutable object needs to\n      // be tainted as possibly having changed to anything.\n      let visitor = new ObjectValueHavocingVisitor(realm, objectsTrackedForHavoc);\n      visitor.visitValue(value);\n    }\n  }\n}\n"]}