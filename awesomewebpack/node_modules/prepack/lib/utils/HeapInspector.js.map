{"version":3,"sources":["../../src/utils/HeapInspector.js"],"names":["HeapInspector","constructor","realm","logger","ignoredProperties","Map","_targetIntegrityCommands","getTargetIntegrityCommand","val","command","get","undefined","extensible","$Extensible","logError","value","anyWritable","anyConfigurable","propertyBinding","properties","values","desc","descriptor","configurable","writable","set","getTargetIntegrityDescriptor","_integrityDescriptors","isLeaf","hasIdentifier","$Realm","instantRender","enabled","intrinsicName","startsWith","isIntrinsic","canIgnoreProperty","key","_getIgnoredProperties","has","Set","_canIgnoreProperty","add","targetDescriptor","enumerable","hasDefaultLength","isCompatibleWith","MOBILE_JSC_VERSION","__originalName","ToString","$Strict","$FunctionKind","originalConstructor","kind","getKind","v","getPropertyValue","name","prototypeBinding","prototypeDesc","isDefaultPrototype","prototype","symbols","size","$Prototype","intrinsics","ObjectPrototype","mightNotBeTrue","foundConstructor","keys","preventExtensions","seal","freeze"],"mappings":"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","file":"HeapInspector.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { Realm } from \"../realm.js\";\nimport type { Descriptor } from \"../types.js\";\nimport { IsArray } from \"../methods/index.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  ProxyValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"../utils/logger.js\";\n\ntype TargetIntegrityCommand = \"freeze\" | \"seal\" | \"preventExtensions\" | \"\";\n\nexport class HeapInspector {\n  constructor(realm: Realm, logger: Logger) {\n    this.realm = realm;\n    this.logger = logger;\n    this.ignoredProperties = new Map();\n    this._targetIntegrityCommands = new Map();\n  }\n\n  realm: Realm;\n  logger: Logger;\n  ignoredProperties: Map<ObjectValue, Set<string>>;\n  _targetIntegrityCommands: Map<ObjectValue, TargetIntegrityCommand>;\n\n  getTargetIntegrityCommand(val: ObjectValue): TargetIntegrityCommand {\n    let command = this._targetIntegrityCommands.get(val);\n    if (command === undefined) {\n      command = \"\";\n      if (val instanceof ProxyValue) {\n        // proxies don't participate in regular object freezing/sealing,\n        // only their underlying proxied objects do\n      } else {\n        let extensible = val.$Extensible;\n        if (!(extensible instanceof BooleanValue)) {\n          this.logger.logError(\n            val,\n            \"Object that might or might not be sealed or frozen are not supported in residual heap.\"\n          );\n        } else if (!extensible.value) {\n          let anyWritable = false,\n            anyConfigurable = false;\n          for (let propertyBinding of val.properties.values()) {\n            let desc = propertyBinding.descriptor;\n            if (desc === undefined) continue; //deleted\n            if (desc.configurable) anyConfigurable = true;\n            else if (desc.value !== undefined && desc.writable) anyWritable = true;\n          }\n          command = anyConfigurable ? \"preventExtensions\" : anyWritable ? \"seal\" : \"freeze\";\n        }\n      }\n      this._targetIntegrityCommands.set(val, command);\n    }\n    return command;\n  }\n\n  static _integrityDescriptors = {\n    \"\": { writable: true, configurable: true },\n    preventExtensions: { writable: true, configurable: true },\n    seal: { writable: true, configurable: false },\n    freeze: { writable: false, configurable: false },\n  };\n\n  getTargetIntegrityDescriptor(val: ObjectValue): { writable: boolean, configurable: boolean } {\n    return HeapInspector._integrityDescriptors[this.getTargetIntegrityCommand(val)];\n  }\n\n  static isLeaf(val: Value): boolean {\n    if (val instanceof SymbolValue) {\n      return false;\n    }\n\n    if (val instanceof AbstractValue) {\n      if (val.hasIdentifier()) {\n        return true;\n      }\n\n      if (\n        val.$Realm.instantRender.enabled &&\n        val.intrinsicName !== undefined &&\n        val.intrinsicName.startsWith(\"__native\")\n      ) {\n        // Never factor out multiple occurrences of InstantRender's __native... abstract functions.\n        return true;\n      }\n    }\n\n    if (val.isIntrinsic()) {\n      return false;\n    }\n\n    return val instanceof PrimitiveValue;\n  }\n\n  // Object properties which have the default value can be ignored by the serializer.\n  canIgnoreProperty(val: ObjectValue, key: string): boolean {\n    let set = this.ignoredProperties.get(val);\n    if (!set) {\n      this.ignoredProperties.set(val, (set = this._getIgnoredProperties(val)));\n    }\n    return set.has(key);\n  }\n\n  _getIgnoredProperties(val: ObjectValue): Set<string> {\n    let set: Set<string> = new Set();\n    for (let [key, propertyBinding] of val.properties) {\n      invariant(propertyBinding);\n      let desc = propertyBinding.descriptor;\n      if (desc === undefined) continue; //deleted\n      if (this._canIgnoreProperty(val, key, desc)) set.add(key);\n    }\n    return set;\n  }\n\n  _canIgnoreProperty(val: ObjectValue, key: string, desc: Descriptor): boolean {\n    let targetDescriptor = this.getTargetIntegrityDescriptor(val);\n\n    if (IsArray(this.realm, val)) {\n      if (key === \"length\" && desc.writable === targetDescriptor.writable && !desc.enumerable && !desc.configurable) {\n        // length property has the correct descriptor values\n        return true;\n      }\n    } else if (val instanceof FunctionValue) {\n      if (key === \"length\") {\n        if (desc.value === undefined) {\n          this.logger.logError(val, \"Functions with length accessor properties are not supported in residual heap.\");\n          // Rationale: .bind() would call the accessor, which might throw, mutate state, or do whatever...\n        }\n        // length property will be inferred already by the amount of parameters\n        return (\n          !desc.writable &&\n          !desc.enumerable &&\n          desc.configurable === targetDescriptor.configurable &&\n          val.hasDefaultLength()\n        );\n      }\n\n      if (key === \"name\") {\n        // TODO #474: Make sure that we retain original function names. Or set name property.\n        // Or ensure that nothing references the name property.\n        // NOTE: with some old runtimes notably JSC, function names are not configurable\n        // For now don't ignore the property if it is different from the function name.\n        // I.e. if it was set explicitly in the code, retain it.\n        if (\n          desc.value !== undefined &&\n          !this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) &&\n          !this.realm.isCompatibleWith(\"mobile\") &&\n          (desc.value instanceof AbstractValue ||\n            (desc.value instanceof ConcreteValue &&\n              val.__originalName &&\n              val.__originalName !== \"\" &&\n              To.ToString(this.realm, desc.value) !== val.__originalName))\n        )\n          return false;\n        return true;\n      }\n\n      // Properties `caller` and `arguments` are added to normal functions in non-strict mode to prevent TypeErrors.\n      // Because they are autogenerated, they should be ignored.\n      if (key === \"arguments\" || key === \"caller\") {\n        invariant(val instanceof ECMAScriptSourceFunctionValue);\n        if (\n          !val.$Strict &&\n          desc.writable === (!val.$Strict && targetDescriptor.writable) &&\n          !desc.enumerable &&\n          desc.configurable === targetDescriptor.configurable &&\n          desc.value instanceof UndefinedValue &&\n          val.$FunctionKind === \"normal\"\n        )\n          return true;\n      }\n\n      // ignore the `prototype` property when it's the right one\n      if (key === \"prototype\") {\n        if (\n          !desc.configurable &&\n          !desc.enumerable &&\n          desc.writable === targetDescriptor.writable &&\n          desc.value instanceof ObjectValue &&\n          desc.value.originalConstructor === val\n        ) {\n          return true;\n        }\n      }\n    } else {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"RegExp\":\n          if (\n            key === \"lastIndex\" &&\n            desc.writable === targetDescriptor.writable &&\n            !desc.enumerable &&\n            !desc.configurable\n          ) {\n            // length property has the correct descriptor values\n            let v = desc.value;\n            return v instanceof NumberValue && v.value === 0;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (key === \"constructor\") {\n      if (\n        desc.configurable === targetDescriptor.configurable &&\n        !desc.enumerable &&\n        desc.writable === targetDescriptor.writable &&\n        desc.value === val.originalConstructor\n      )\n        return true;\n    }\n\n    return false;\n  }\n\n  static getPropertyValue(val: ObjectValue, name: string): void | Value {\n    let prototypeBinding = val.properties.get(name);\n    if (prototypeBinding === undefined) return undefined;\n    let prototypeDesc = prototypeBinding.descriptor;\n    if (prototypeDesc === undefined) return undefined;\n    invariant(prototypeDesc.value === undefined || prototypeDesc.value instanceof Value);\n    return prototypeDesc.value;\n  }\n\n  isDefaultPrototype(prototype: ObjectValue): boolean {\n    if (\n      prototype.symbols.size !== 0 ||\n      prototype.$Prototype !== this.realm.intrinsics.ObjectPrototype ||\n      prototype.$Extensible.mightNotBeTrue()\n    ) {\n      return false;\n    }\n    let foundConstructor = false;\n    for (let name of prototype.properties.keys())\n      if (name === \"constructor\" && HeapInspector.getPropertyValue(prototype, name) === prototype.originalConstructor)\n        foundConstructor = true;\n      else return false;\n    return foundConstructor;\n  }\n}\n"]}