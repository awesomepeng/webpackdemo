{"version":3,"sources":["../../src/utils/ConcreteModelConverter.js"],"names":["concretize","t","reportCompileError","realm","message","loc","error","handleError","createEmptyFunction","concreteFunction","$ECMAScriptCode","blockStatement","$FormalParameters","uniqueOrderedTag","functionBodyUniqueTagSeed","val","kind","args","length","type","types","getType","isTop","prototype","values","getElements","size","value","expressionLocation","template","getTemplate","valIsPartial","isPartialObject","makeNotPartial","concreteObj","ObjectCreate","$GetPrototypeOf","keys","P","newElement","CreateDataProperty","makePartial"],"mappings":";;;;;QAyDgBA,U,GAAAA,U;;AAxChB;;AAiBA;;IAAYC,C;;AACZ;;;;AAEA;;AACA;;AACA;;;;;;AAvCA;;;;;;;;;AAWA;;;;AA8BA,SAASC,kBAAT,CAA4BC,KAA5B,EAA0CC,OAA1C,EAA2DC,GAA3D,EAA0F;AACxF,MAAIC,QAAQ,+BAAuBF,OAAvB,EAAgCC,GAAhC,EAAqC,QAArC,EAA+C,kBAA/C,CAAZ;AACAF,QAAMI,WAAN,CAAkBD,KAAlB;AACD;;AAED,SAASE,mBAAT,CAA6BL,KAA7B,EAA2C;AACzC,QAAMM,mBAAmB,yCAAkCN,KAAlC,CAAzB;AACAM,mBAAiBC,eAAjB,GAAmCT,EAAEU,cAAF,CAAiB,EAAjB,CAAnC;AACAF,mBAAiBG,iBAAjB,GAAqC,EAArC;AACEH,mBAAiBC,eAAnB,CAA+DG,gBAA/D,GAAkFV,MAAMW,yBAAN,EAAlF;AACA,SAAOL,gBAAP;AACD;;AAED;;;AAGO,SAAST,UAAT,CAAoBG,KAApB,EAAkCY,GAAlC,EAA6D;AAClE,MAAIA,mCAAJ,EAAkC;AAChC,WAAOA,GAAP;AACD;AACD,2BAAUA,mCAAV;AACA,MAAIA,IAAIC,IAAJ,KAAa,uBAAjB,EAA0C;AACxC,6BAAUD,IAAIE,IAAJ,CAASC,MAAT,GAAkB,CAA5B;AACA,WAAOlB,WAAWG,KAAX,EAAkBY,IAAIE,IAAJ,CAAS,CAAT,CAAlB,CAAP;AACD;AACD,QAAME,OAAOJ,IAAIK,KAAJ,CAAUC,OAAV,EAAb;AACA,MAAIN,IAAIK,KAAJ,CAAUE,KAAV,EAAJ,EAAuB;AACrB,WAAO,0BAAmBnB,KAAnB,CAAP;AACD,GAFD,MAEO,IAAKgB,IAAD,CAAYI,SAAZ,iCAAJ,EAAqD;AAC1D,QAAIR,IAAIS,MAAJ,CAAWF,KAAX,EAAJ,EAAwB;AACtB,cAAQH,IAAR;AACE;AACE,iBAAO,uBAAgBhB,KAAhB,EAAuB,iBAAvB,CAAP;AACF;AACE,iBAAO,uBAAgBA,KAAhB,EAAuB,EAAvB,CAAP;AACF;AACE,iBAAO,uBAAgBA,KAAhB,EAAuB,uBAAgBA,KAAhB,EAAuB,iBAAvB,CAAvB,CAAP;AACF;AACE,iBAAO,wBAAiBA,KAAjB,EAAwB,IAAxB,CAAP;AACF;AACE,iBAAO,qBAAcA,KAAd,CAAP;AACF;AACE,iBAAO,0BAAmBA,KAAnB,CAAP;AACF;AACE,mCAAU,KAAV,EAAiB,qBAAjB;AAdJ;AAgBD,KAjBD,MAiBO;AACL;AACA,YAAMqB,SAAST,IAAIS,MAAJ,CAAWC,WAAX,EAAf;AACA,+BAAUD,OAAOE,IAAP,KAAgB,CAA1B,EAA6B,2CAA7B;AACA,WAAK,IAAIC,KAAT,IAAkBH,MAAlB,EAA0B;AACxB,iCAAUG,qCAAV,EAA0C,uDAA1C;AACA,eAAOA,KAAP;AACD;AACD,+BAAU,KAAV;AACD;AACF,GA5BM,MA4BA,IAAIR,6BAAJ,EAA4B;AACjC,WAAOX,oBAAoBL,KAApB,CAAP;AACD,GAFM,MAEA,IAAIgB,0BAAJ,EAAyB;AAC9BjB,uBACEC,KADF,EAEE,0EAFF,EAGEY,IAAIa,kBAHN;AAKD,GANM,MAMA,IAAIb,yCAAJ,EAAwC;AAC7C,QAAIA,IAAIS,MAAJ,CAAWF,KAAX,EAAJ,EAAwB;AACtB,aAAO,uBAAgBnB,KAAhB,CAAP;AACD,KAFD,MAEO;AACL,UAAI0B,WAAWd,IAAIe,WAAJ,EAAf;AACA,UAAIC,eAAe,KAAnB;AACA,UAAIhB,IAAIiB,eAAJ,EAAJ,EAA2B;AACzBD,uBAAe,IAAf;AACAhB,YAAIkB,cAAJ;AACD;AACD,UAAIC,cAAc,mBAAOC,YAAP,CAAoBhC,KAApB,EAA2B0B,SAASO,eAAT,EAA3B,CAAlB;AACA,UAAI;AACF,YAAIC,OAAO,qCAAwBlC,KAAxB,EAA+B0B,QAA/B,EAAyC,KAAzC,CAAX;AACA,aAAK,IAAIS,CAAT,IAAcD,IAAd,EAAoB;AAClB,mCAAUC,+BAAV;AACA,cAAIC,aAAa,iBAAIpC,KAAJ,EAAW0B,QAAX,EAAqBS,CAArB,CAAjB;AACA,6BAAOE,kBAAP,CAA0BrC,KAA1B,EAAiC+B,WAAjC,EAA8CI,CAA9C,EAAiDtC,WAAWG,KAAX,EAAkBoC,UAAlB,CAAjD;AACD;AACF,OAPD,SAOU;AACR,YAAIR,YAAJ,EAAkB;AAChBhB,cAAI0B,WAAJ;AACD;AACF;AACD,aAAOP,WAAP;AACD;AACF;AACDhC,qBACEC,KADF,EAEE,yEAFF,EAGEY,IAAIa,kBAHN;AAKA;AACA,SAAO,0BAAmBzB,KAAnB,CAAP;AACD","file":"ConcreteModelConverter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\n/**\n * This file contains code that converts abstract models into concrete values.\n */\n\nimport type { Realm } from \"../realm.js\";\nimport type { BabelNodeSourceLocation } from \"babel-types\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  PrimitiveValue,\n  ArrayValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n} from \"../values/index.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport { CompilerDiagnostic } from \"../errors.js\";\nimport { EnumerableOwnProperties, Get } from \"../methods/index.js\";\nimport { Create } from \"../singletons.js\";\n\nfunction reportCompileError(realm: Realm, message: string, loc: ?BabelNodeSourceLocation) {\n  let error = new CompilerDiagnostic(message, loc, \"PP9000\", \"RecoverableError\");\n  realm.handleError(error);\n}\n\nfunction createEmptyFunction(realm: Realm) {\n  const concreteFunction = new ECMAScriptSourceFunctionValue(realm);\n  concreteFunction.$ECMAScriptCode = t.blockStatement([]);\n  concreteFunction.$FormalParameters = [];\n  ((concreteFunction.$ECMAScriptCode: any): FunctionBodyAstNode).uniqueOrderedTag = realm.functionBodyUniqueTagSeed++;\n  return concreteFunction;\n}\n\n/**\n * Convert abstract model value into concrete value.\n */\nexport function concretize(realm: Realm, val: Value): ConcreteValue {\n  if (val instanceof ConcreteValue) {\n    return val;\n  }\n  invariant(val instanceof AbstractValue);\n  if (val.kind === \"abstractConcreteUnion\") {\n    invariant(val.args.length > 0);\n    return concretize(realm, val.args[0]);\n  }\n  const type = val.types.getType();\n  if (val.types.isTop()) {\n    return new UndefinedValue(realm);\n  } else if ((type: any).prototype instanceof PrimitiveValue) {\n    if (val.values.isTop()) {\n      switch (type) {\n        case StringValue:\n          return new StringValue(realm, \"__concreteModel\");\n        case NumberValue:\n          return new NumberValue(realm, 42);\n        case SymbolValue:\n          return new SymbolValue(realm, new StringValue(realm, \"__concreteModel\"));\n        case BooleanValue:\n          return new BooleanValue(realm, true);\n        case NullValue:\n          return new NullValue(realm);\n        case UndefinedValue:\n          return new UndefinedValue(realm);\n        default:\n          invariant(false, \"Not yet implemented\");\n      }\n    } else {\n      // TODO: This was broken. Is this actually used?\n      const values = val.values.getElements();\n      invariant(values.size === 1, \"Concrete model should only have one value\");\n      for (let value in values) {\n        invariant(value instanceof ConcreteValue, \"Concrete model should only contain one concrete value\");\n        return value;\n      }\n      invariant(false);\n    }\n  } else if (type === FunctionValue) {\n    return createEmptyFunction(realm);\n  } else if (type === ArrayValue) {\n    reportCompileError(\n      realm,\n      \"Emitting a concrete model for abstract array value is not supported yet.\",\n      val.expressionLocation\n    );\n  } else if (val instanceof AbstractObjectValue) {\n    if (val.values.isTop()) {\n      return new ObjectValue(realm);\n    } else {\n      let template = val.getTemplate();\n      let valIsPartial = false;\n      if (val.isPartialObject()) {\n        valIsPartial = true;\n        val.makeNotPartial();\n      }\n      let concreteObj = Create.ObjectCreate(realm, template.$GetPrototypeOf());\n      try {\n        let keys = EnumerableOwnProperties(realm, template, \"key\");\n        for (let P of keys) {\n          invariant(P instanceof StringValue);\n          let newElement = Get(realm, template, P);\n          Create.CreateDataProperty(realm, concreteObj, P, concretize(realm, newElement));\n        }\n      } finally {\n        if (valIsPartial) {\n          val.makePartial();\n        }\n      }\n      return concreteObj;\n    }\n  }\n  reportCompileError(\n    realm,\n    \"Emitting a concrete model for this abstract value is not supported yet.\",\n    val.expressionLocation\n  );\n  // Return undefined to make flow happy.\n  return new UndefinedValue(realm);\n}\n"]}