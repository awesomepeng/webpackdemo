{"version":3,"sources":["../../src/utils/flow.js"],"names":["stripFlowTypeAnnotations","t","ast","ImportDeclaration","path","node","specifiers","length","typeCount","forEach","importKind","remove","Flow","ClassProperty","variance","typeAnnotation","value","Class","implements","get","child","isClassProperty","AssignmentPattern","left","optional","Function","i","params","param","type","predicate","TypeCastExpression","expression","isTypeCastExpression","replaceWith","undefined","clearCache"],"mappings":";;;;;QAmBgBA,wB,GAAAA,wB;;AARhB;;;;AACA;;IACYC,C;;;;;;AAEZ;AACA;AACA;AACA;AACO,SAASD,wBAAT,CAAkCE,GAAlC,EAAwD;AAC7D,+BACEA,GADF,EAEE;AACEC,sBAAkBC,IAAlB,EAAwB;AACtB,UAAI,CAACA,KAAKC,IAAL,CAAUC,UAAV,CAAqBC,MAA1B,EAAkC;AAClC,UAAIC,YAAY,CAAhB;AACAJ,WAAKC,IAAL,CAAUC,UAAV,CAAqBG,OAArB,CAA6B,CAAC,EAAEC,UAAF,EAAD,KAAoB;AAC/C,YAAIA,eAAe,MAAf,IAAyBA,eAAe,QAA5C,EAAsD;AACpDF;AACD;AACF,OAJD;AAKA,UAAIA,cAAcJ,KAAKC,IAAL,CAAUC,UAAV,CAAqBC,MAAvC,EAA+C;AAC7CH,aAAKO,MAAL;AACD;AACF,KAZH;AAaEC,SAAKR,IAAL,EAAW;AACTA,WAAKO,MAAL;AACD,KAfH;AAgBEE,kBAAcT,IAAd,EAAoB;AAClBA,WAAKC,IAAL,CAAUS,QAAV,GAAqB,IAArB;AACAV,WAAKC,IAAL,CAAUU,cAAV,GAA2B,IAA3B;AACA,UAAI,CAACX,KAAKC,IAAL,CAAUW,KAAf,EAAsBZ,KAAKO,MAAL;AACvB,KApBH;AAqBEM,UAAMb,IAAN,EAAY;AACVA,WAAKC,IAAL,CAAUa,UAAV,GAAuB,IAAvB;AACAd,WAAKe,GAAL,CAAS,WAAT,EAAsBV,OAAtB,CAA8BW,SAAS;AACrC,YAAIA,MAAMC,eAAN,EAAJ,EAA6B;AAC3BD,gBAAMf,IAAN,CAAWU,cAAX,GAA4B,IAA5B;AACA,cAAI,CAACK,MAAMf,IAAN,CAAWW,KAAhB,EAAuBI,MAAMT,MAAN;AACxB;AACF,OALD;AAMD,KA7BH;AA8BEW,sBAAkB,EAAEjB,IAAF,EAAlB,EAA4B;AAC1BA,WAAKkB,IAAL,CAAUC,QAAV,GAAqB,KAArB;AACD,KAhCH;AAiCEC,aAAS,EAAEpB,IAAF,EAAT,EAAmB;AACjB,WAAK,IAAIqB,IAAI,CAAb,EAAgBA,IAAIrB,KAAKsB,MAAL,CAAYpB,MAAhC,EAAwCmB,GAAxC,EAA6C;AAC3C,cAAME,QAAQvB,KAAKsB,MAAL,CAAYD,CAAZ,CAAd;AACAE,cAAMJ,QAAN,GAAiB,KAAjB;AACA,YAAII,MAAMC,IAAN,KAAe,mBAAnB,EAAwC;AACtCD,gBAAML,IAAN,CAAWC,QAAX,GAAsB,KAAtB;AACD;AACF;AACDnB,WAAKyB,SAAL,GAAiB,IAAjB;AACD,KA1CH;AA2CEC,uBAAmB3B,IAAnB,EAAyB;AACvB,UAAI,EAAEC,IAAF,KAAWD,IAAf;AACA,SAAG;AACDC,eAAOA,KAAK2B,UAAZ;AACD,OAFD,QAES/B,EAAEgC,oBAAF,CAAuB5B,IAAvB,CAFT;AAGAD,WAAK8B,WAAL,CAAiB7B,IAAjB;AACD;AAjDH,GAFF,EAqDE8B,SArDF,EAsDE,EAtDF,EAuDEA,SAvDF;AAyDA,0BAASC,UAAT;AACD,C,CA9ED;;;;;;;;;AASA","file":"flow.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict */\n\nimport traverse from \"babel-traverse\";\nimport { BabelNode } from \"babel-types\";\nimport * as t from \"babel-types\";\n\n// Taken directly from Babel:\n// https://github.com/babel/babel/blob/cde005422701a69ff21044c138c29a5ad23b6d0a/packages/babel-plugin-transform-flow-strip-types/src/index.js#L32-L107\n// Copyright 2015-present Sebastian McKenzie / Babel project (https://github.com/babel)\n// only the lines reflected in the above were used\nexport function stripFlowTypeAnnotations(ast: BabelNode): void {\n  traverse(\n    ast,\n    {\n      ImportDeclaration(path) {\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({ importKind }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n      Flow(path) {\n        path.remove();\n      },\n      ClassProperty(path) {\n        path.node.variance = null;\n        path.node.typeAnnotation = null;\n        if (!path.node.value) path.remove();\n      },\n      Class(path) {\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            child.node.typeAnnotation = null;\n            if (!child.node.value) child.remove();\n          }\n        });\n      },\n      AssignmentPattern({ node }) {\n        node.left.optional = false;\n      },\n      Function({ node }) {\n        for (let i = 0; i < node.params.length; i++) {\n          const param = node.params[i];\n          param.optional = false;\n          if (param.type === \"AssignmentPattern\") {\n            param.left.optional = false;\n          }\n        }\n        node.predicate = null;\n      },\n      TypeCastExpression(path) {\n        let { node } = path;\n        do {\n          node = node.expression;\n        } while (t.isTypeCastExpression(node));\n        path.replaceWith(node);\n      },\n    },\n    undefined,\n    {},\n    undefined\n  );\n  traverse.clearCache();\n}\n"]}