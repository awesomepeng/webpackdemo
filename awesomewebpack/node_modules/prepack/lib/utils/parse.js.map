{"version":3,"sources":["../../src/utils/parse.js"],"names":["realm","code","filename","sourceType","startLine","plugins","react","enabled","push","stripFlow","ast","node","loc","source","e","SyntaxError","referenceErrors","error","some","msg","message","indexOf","intrinsics","ReferenceError","$ErrorData","locationData","sourceCode","stackDecorated","undefined"],"mappings":";;;;;;kBAqBe,UACbA,KADa,EAEbC,IAFa,EAGbC,QAHa,EAIbC,aAAyB,QAJZ,EAKbC,YAAoB,CALP,EAME;AACf,MAAI;AACF,QAAIC,UAAU,CAAC,kBAAD,CAAd;AACA,QAAIL,MAAMM,KAAN,CAAYC,OAAhB,EAAyB;AACvBF,cAAQG,IAAR,CAAa,KAAb;AACD;AACD,QAAIR,MAAMS,SAAV,EAAqB;AACnBJ,cAAQG,IAAR,CAAa,MAAb;AACD;AACD,QAAIE,MAAM,oBAAMT,IAAN,EAAY,EAAEC,QAAF,EAAYC,UAAZ,EAAwBC,SAAxB,EAAmCC,OAAnC,EAAZ,CAAV;AACA,gCAAaK,GAAb,EAAkBC,QAAQ;AACxB,+BAAUA,KAAKC,GAAf;AACAD,WAAKC,GAAL,CAASC,MAAT,GAAkBX,QAAlB;AACA,aAAO,KAAP;AACD,KAJD;AAKA,WAAOQ,GAAP;AACD,GAfD,CAeE,OAAOI,CAAP,EAAU;AACV,QAAIA,aAAaC,WAAjB,EAA8B;AAC5B;AACA;AACA,UAAIC,kBAAkB,CACpB,6CADoB,EAEpB,4CAFoB,EAGpB,iDAHoB,CAAtB;;AAMA,UAAIC,KAAJ;AACA,UAAID,gBAAgBE,IAAhB,CAAqBC,OAAOL,EAAEM,OAAF,CAAUC,OAAV,CAAkBF,GAAlB,KAA0B,CAAtD,CAAJ,EAA8D;AAC5DF,gBAAQ,0BAAUjB,KAAV,EAAiBA,MAAMsB,UAAN,CAAiBC,cAAlC,EAAkD,CAAC,uBAAgBvB,KAAhB,EAAuBc,EAAEM,OAAzB,CAAD,CAAlD,CAAR;AACD,OAFD,MAEO;AACLH,gBAAQ,0BAAUjB,KAAV,EAAiBA,MAAMsB,UAAN,CAAiBP,WAAlC,EAA+C,CAAC,uBAAgBf,KAAhB,EAAuBc,EAAEM,OAAzB,CAAD,CAA/C,CAAR;AACD;AACD;AACA;AACA;AACA,+BAAUH,MAAMO,UAAhB;AACAP,YAAMO,UAAN,CAAiBC,YAAjB,GAAgC;AAC9BvB,kBAAUA,QADoB;AAE9BwB,oBAAYzB,IAFkB;AAG9BW,aAAKE,EAAEF,GAHuB;AAI9Be,wBAAgB;AAJc,OAAhC;AAMA,YAAM,iCAAoBV,KAApB,EAA2BW,SAA3B,EAAsCd,EAAEF,GAAxC,CAAN;AACD,KA1BD,MA0BO;AACL,YAAME,CAAN;AACD;AACF;AACF,C;;AA/DD;;;;AAGA;;AACA;;AACA;;AACA;;;;AACA","file":"parse.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport invariant from \"../invariant.js\";\nimport type { SourceType } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { ThrowCompletion } from \"../completions.js\";\nimport { StringValue } from \"../values/index.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport { parse } from \"babylon\";\nimport type { BabelNodeFile } from \"babel-types\";\n\nexport default function(\n  realm: Realm,\n  code: string,\n  filename: string,\n  sourceType: SourceType = \"script\",\n  startLine: number = 1\n): BabelNodeFile {\n  try {\n    let plugins = [\"objectRestSpread\"];\n    if (realm.react.enabled) {\n      plugins.push(\"jsx\");\n    }\n    if (realm.stripFlow) {\n      plugins.push(\"flow\");\n    }\n    let ast = parse(code, { filename, sourceType, startLine, plugins });\n    traverseFast(ast, node => {\n      invariant(node.loc);\n      node.loc.source = filename;\n      return false;\n    });\n    return ast;\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Babel reports all errors as syntax errors, even if a ReferenceError should be thrown.\n      // What we do here is a totally robust way to address that issue.\n      let referenceErrors = [\n        \"Invalid left-hand side in postfix operation\",\n        \"Invalid left-hand side in prefix operation\",\n        \"Invalid left-hand side in assignment expression\",\n      ];\n\n      let error;\n      if (referenceErrors.some(msg => e.message.indexOf(msg) >= 0)) {\n        error = Construct(realm, realm.intrinsics.ReferenceError, [new StringValue(realm, e.message)]);\n      } else {\n        error = Construct(realm, realm.intrinsics.SyntaxError, [new StringValue(realm, e.message)]);\n      }\n      // These constructors are currently guaranteed to produce an object with\n      // built-in error data. Append location information about the syntax error\n      // and the source code to it so that we can use it to print nicer errors.\n      invariant(error.$ErrorData);\n      error.$ErrorData.locationData = {\n        filename: filename,\n        sourceCode: code,\n        loc: e.loc,\n        stackDecorated: false,\n      };\n      throw new ThrowCompletion(error, undefined, e.loc);\n    } else {\n      throw e;\n    }\n  }\n}\n"]}