{"version":3,"sources":["../../src/utils/generator.js"],"names":["attemptToMergeEquivalentObjectAssigns","t","GeneratorEntry","constructor","realm","index","temporalEntryCounter","visit","callbacks","containingGenerator","serialize","context","getDependencies","notEqualToAndDoesNotHappenBefore","entry","notEqualToAndDoesNotHappenAfter","TemporalBuildNodeEntry","args","Object","assign","mutatesOnly","undefined","isPure","arg","includes","omit","declared","canOmit","recordDelayedEntry","recordDeclaration","i","n","length","visitEquivalentValue","dependencies","dependency","visitGenerator","nodes","map","boundArg","serializeValue","buildNode","valuesToProcess","Set","node","type","block","statements","body","options","debugScopes","s","emptyStatement","leadingComments","value","intrinsicName","emit","processValues","declare","TemporalObjectAssignEntry","$Realm","result","nextResult","ModifiedPropertyEntry","desc","propertyBinding","descriptor","newDescriptor","emitPropertyModification","visitModifiedObjectProperty","ModifiedBindingEntry","residualFunctionBinding","referentialized","serializedValue","newValue","bindingReference","isLVal","serializedNewValue","expressionStatement","assignmentExpression","modifiedBinding","residualBinding","visitModifiedBinding","ReturnValueEntry","generator","returnValue","promoteEmptyToUndefined","returnStatement","IfThenElseEntry","completion","condition","joinCondition","consequentGenerator","Generator","fromEffects","consequentEffects","alternateGenerator","alternateEffects","consequentBody","serializeGenerator","alternateBody","ifStatement","blockStatement","BindingAssignmentEntry","binding","serializeBinding","visitBindingAssignment","serializeBody","name","pathConditions","effects","useAbstractInterpretation","realmPreludeGenerator","preludeGenerator","_entries","id","nextGeneratorId","_name","effectsToApply","_generatorOfEffects","environmentRecordIdAfterGlobalCode","modifiedBindings","modifiedProperties","createdObjects","output","appendGenerator","keys","object","has","refuseSerialization","isIntrinsic","environment","emitBindingModification","emitReturnValue","emitIfThenElse","emitThrow","withEffectsAppliedInGlobalEnv","bind","kind","c","x","y","ydesc","yprop","xdesc","key","xprop","push","getName","empty","emitGlobalDeclaration","declaredGlobals","add","emitGlobalAssignment","_addEntry","valueNode","globalReference","emitConcreteModel","emitGlobalDelete","unaryExpression","emitBindingAssignment","emitPropertyAssignment","objectNode","getPropertyAssignmentStatement","mightHaveBeenDeleted","emitDefineProperty","isDescChanged","enumerable","configurable","writable","descValue","intrinsics","get","set","_","emitDefinePropertyBody","emitPropertyDelete","emitCall","createCallee","values","callExpression","emitConsoleLog","method","memberExpression","identifier","v","emitDoWhileStatement","test","testId","doWhileStatement","emitConditionalThrow","createStatement","val","throwStatement","cond","trueVal","falseVal","condVal","trueStat","falseStat","argument","_issueThrowCompilerDiagnostic","message","objectMessage","evaluateWithUndo","_SafeGetDataPropertyValue","objectStack","diagnostic","expressionLocation","handleError","emitStatement","emitFullInvariant","accessedPropertyOf","isTop","concreteComparisons","typeComparisons","populateComparisonsLists","absValue","nestedValue","getType","checks","concreteValue","binaryExpression","valueToNode","concat","typeValue","typeString","typeToString","stringLiteral","reduce","expr","newCondition","logicalExpression","_emitInvariant","objnode","getErrorStatement","invariantMode","newExpression","memoizeReference","targetReference","indexOf","substr","Number","parseInt","isNaN","numericLiteral","emitPropertyInvariant","state","violationConditionFn","appendLastToInvariantFn","invariantLevel","messageComponents","nextInvariantId","last","pop","throwString","consequent","emitCallAndCaptureResult","types","deriveAbstract","buildNode_","emitVoidExpression","Function","emitForInStatement","o","lh","sourceObject","targetObject","boundName","obj","tgt","src","obj1","tgt1","src1","forInStatement","deriveConcreteObject","buildValue","optionalArgs","nameGenerator","generate","intrinsicNameGenerated","_isScopedTemplate","_addDerivedEntry","variableDeclaration","variableDeclarator","Constructor","isTypeCompatibleWith","res","derivedIds","size","temporalType","skipInvariant","typeofString","visitFn","serializeFn","initGenerator","finalizeGenerator","entryArgs","saveTemporalGeneratorEntryArgs","other","leadingComment","statement","joinGenerators","generator1","generator2","block1","block2","escapeInvalidIdentifierCharacters","charCodeAt","base62characters","base62encode","f","NameGenerator","forbiddenNames","debugNames","uniqueSuffix","prefix","uidCounter","debugSuffix","PreludeGenerator","prelude","memoizedRefs","Map","usesThis","createNameGenerator","convertStringToMember","str","split","thisExpression","prop","globalScope","isValidIdentifier","ref","init","lastIndexOf","temporalBuildNodeEntry","to","loopThroughArgs","possibleOtherObjectAssignTo","otherTemporalBuildNodeEntry","getTemporalBuildNodeEntryFromDerivedValue","otherArgs","otherArgsToUse","mightBeHavocedObject","temporalGeneratorEntries","getTemporalGeneratorEntriesReferencingArg","temporalGeneratorEntry","newArgs","newTemporalObjectAssignEntryArgs"],"mappings":"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","file":"generator.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Effects, Realm } from \"../realm.js\";\nimport type { ConsoleMethodTypes, Descriptor, PropertyBinding } from \"../types.js\";\nimport type { ResidualFunctionBinding } from \"../serializer/types.js\";\nimport type { Binding } from \"../environment.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  type AbstractValueKind,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { CompilerDiagnostic } from \"../errors.js\";\nimport type { AbstractValueBuildNodeFunction } from \"../values/AbstractValue.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport {\n  AbruptCompletion,\n  ForkedAbruptCompletion,\n  ThrowCompletion,\n  ReturnCompletion,\n  PossiblyNormalCompletion,\n  SimpleNormalCompletion,\n} from \"../completions.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeThisExpression,\n  BabelNodeStatement,\n  BabelNodeMemberExpression,\n  BabelNodeVariableDeclaration,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n} from \"babel-types\";\nimport { nullExpression, memberExpressionHelper } from \"./babelhelpers.js\";\nimport { Utils, concretize } from \"../singletons.js\";\nimport type { SerializerOptions } from \"../options.js\";\n\nexport type SerializationContext = {|\n  serializeValue: Value => BabelNodeExpression,\n  serializeBinding: Binding => BabelNodeIdentifier | BabelNodeMemberExpression,\n  getPropertyAssignmentStatement: (\n    location: BabelNodeLVal,\n    value: Value,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean\n  ) => BabelNodeStatement,\n  serializeGenerator: (Generator, Set<AbstractValue | ObjectValue>) => Array<BabelNodeStatement>,\n  initGenerator: Generator => void,\n  finalizeGenerator: Generator => void,\n  emitDefinePropertyBody: (ObjectValue, string | SymbolValue, Descriptor) => BabelNodeStatement,\n  emit: BabelNodeStatement => void,\n  processValues: (Set<AbstractValue | ObjectValue>) => void,\n  canOmit: Value => boolean,\n  declare: (AbstractValue | ObjectValue) => void,\n  emitPropertyModification: PropertyBinding => void,\n  options: SerializerOptions,\n|};\n\nexport type VisitEntryCallbacks = {|\n  visitEquivalentValue: Value => Value,\n  visitGenerator: (Generator, Generator) => void,\n  canOmit: Value => boolean,\n  recordDeclaration: (AbstractValue | ObjectValue) => void,\n  recordDelayedEntry: (Generator, GeneratorEntry) => void,\n  visitModifiedObjectProperty: PropertyBinding => void,\n  visitModifiedBinding: Binding => [ResidualFunctionBinding, Value],\n  visitBindingAssignment: (Binding, Value) => Value,\n|};\n\nexport type TemporalBuildNodeType = \"OBJECT_ASSIGN\";\n\nexport type DerivedExpressionBuildNodeFunction = (\n  Array<BabelNodeExpression>,\n  SerializationContext,\n  Set<AbstractValue | ObjectValue>\n) => BabelNodeExpression;\n\nexport type GeneratorBuildNodeFunction = (\n  Array<BabelNodeExpression>,\n  SerializationContext,\n  Set<AbstractValue | ObjectValue>\n) => BabelNodeStatement;\n\nexport class GeneratorEntry {\n  constructor(realm: Realm) {\n    // We increment the index of every TemporalBuildNodeEntry created.\n    // This should match up as a form of timeline value due to the tree-like\n    // structure we use to create entries during evaluation. For example,\n    // if all AST nodes in a BlockStatement resulted in a temporal build node\n    // for each AST node, then each would have a sequential index as to its\n    // position of how it was evaluated in the BlockSstatement.\n    this.index = realm.temporalEntryCounter++;\n  }\n\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  serialize(context: SerializationContext) {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  getDependencies(): void | Array<Generator> {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  notEqualToAndDoesNotHappenBefore(entry: GeneratorEntry): boolean {\n    return this.index > entry.index;\n  }\n\n  notEqualToAndDoesNotHappenAfter(entry: GeneratorEntry): boolean {\n    return this.index < entry.index;\n  }\n\n  index: number;\n}\n\nexport type TemporalBuildNodeEntryArgs = {\n  declared?: AbstractValue | ObjectValue,\n  args: Array<Value>,\n  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.\n  buildNode?: GeneratorBuildNodeFunction,\n  dependencies?: Array<Generator>,\n  isPure?: boolean,\n  mutatesOnly?: Array<Value>,\n  temporalType?: TemporalBuildNodeType,\n};\n\nexport class TemporalBuildNodeEntry extends GeneratorEntry {\n  constructor(realm: Realm, args: TemporalBuildNodeEntryArgs) {\n    super(realm);\n    Object.assign(this, args);\n    if (this.mutatesOnly !== undefined) {\n      invariant(!this.isPure);\n      for (let arg of this.mutatesOnly) {\n        invariant(this.args.includes(arg));\n      }\n    }\n  }\n\n  declared: void | AbstractValue | ObjectValue;\n  args: Array<Value>;\n  // If we're just trying to add roots for the serializer to notice, we don't need a buildNode.\n  buildNode: void | GeneratorBuildNodeFunction;\n  dependencies: void | Array<Generator>;\n  isPure: void | boolean;\n  mutatesOnly: void | Array<Value>;\n  temporalType: void | TemporalBuildNodeType;\n\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    let omit = this.isPure && this.declared && callbacks.canOmit(this.declared);\n\n    if (!omit && this.declared && this.mutatesOnly !== undefined) {\n      omit = true;\n      for (let arg of this.mutatesOnly) {\n        if (!callbacks.canOmit(arg)) {\n          omit = false;\n        }\n      }\n    }\n    if (omit) {\n      callbacks.recordDelayedEntry(containingGenerator, this);\n      return false;\n    } else {\n      if (this.declared) callbacks.recordDeclaration(this.declared);\n      for (let i = 0, n = this.args.length; i < n; i++) this.args[i] = callbacks.visitEquivalentValue(this.args[i]);\n      if (this.dependencies)\n        for (let dependency of this.dependencies) callbacks.visitGenerator(dependency, containingGenerator);\n      return true;\n    }\n  }\n\n  serialize(context: SerializationContext): void {\n    let omit = this.isPure && this.declared && context.canOmit(this.declared);\n\n    if (!omit && this.declared && this.mutatesOnly !== undefined) {\n      omit = true;\n      for (let arg of this.mutatesOnly) {\n        if (!context.canOmit(arg)) {\n          omit = false;\n        }\n      }\n    }\n    if (!omit) {\n      let nodes = this.args.map((boundArg, i) => context.serializeValue(boundArg));\n      if (this.buildNode) {\n        let valuesToProcess = new Set();\n        let node = this.buildNode(nodes, context, valuesToProcess);\n        if (node.type === \"BlockStatement\") {\n          let block: BabelNodeBlockStatement = (node: any);\n          let statements = block.body;\n          if (statements.length === 0) return;\n          if (statements.length === 1) {\n            node = statements[0];\n          }\n        }\n        let declared = this.declared;\n        if (declared !== undefined && context.options.debugScopes) {\n          let s = t.emptyStatement();\n          s.leadingComments = [({ type: \"BlockComment\", value: `declaring ${declared.intrinsicName || \"?\"}` }: any)];\n          context.emit(s);\n        }\n        context.emit(node);\n        context.processValues(valuesToProcess);\n      }\n      if (this.declared !== undefined) context.declare(this.declared);\n    }\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return this.dependencies;\n  }\n}\n\nexport class TemporalObjectAssignEntry extends TemporalBuildNodeEntry {\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    let declared = this.declared;\n    if (!(declared instanceof AbstractObjectValue || declared instanceof ObjectValue)) {\n      return false;\n    }\n    let realm = declared.$Realm;\n    // The only optimization we attempt to do to Object.assign for now is merging of multiple entries\n    // into a new generator entry.\n    let result = attemptToMergeEquivalentObjectAssigns(realm, callbacks, this);\n\n    if (result instanceof TemporalObjectAssignEntry) {\n      let nextResult = result;\n      while (nextResult instanceof TemporalObjectAssignEntry) {\n        nextResult = attemptToMergeEquivalentObjectAssigns(realm, callbacks, result);\n        // If we get back a TemporalObjectAssignEntry, then we have successfully merged a single\n        // Object.assign, but we may be able to merge more. So repeat the process.\n        if (nextResult instanceof TemporalObjectAssignEntry) {\n          result = nextResult;\n        }\n      }\n      // We have an optimized temporal entry, so replace the current temporal\n      // entry and visit that entry instead.\n      this.args = result.args;\n    } else if (result === \"POSSIBLE_OPTIMIZATION\") {\n      callbacks.recordDelayedEntry(containingGenerator, this);\n      return false;\n    }\n    return super.visit(callbacks, containingGenerator);\n  }\n}\n\ntype ModifiedPropertyEntryArgs = {|\n  propertyBinding: PropertyBinding,\n  newDescriptor: void | Descriptor,\n  containingGenerator: Generator,\n|};\n\nclass ModifiedPropertyEntry extends GeneratorEntry {\n  constructor(realm: Realm, args: ModifiedPropertyEntryArgs) {\n    super(realm);\n    Object.assign(this, args);\n  }\n\n  containingGenerator: Generator;\n  propertyBinding: PropertyBinding;\n  newDescriptor: void | Descriptor;\n\n  serialize(context: SerializationContext): void {\n    let desc = this.propertyBinding.descriptor;\n    invariant(desc === this.newDescriptor);\n    context.emitPropertyModification(this.propertyBinding);\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    let desc = this.propertyBinding.descriptor;\n    invariant(desc === this.newDescriptor);\n    context.visitModifiedObjectProperty(this.propertyBinding);\n    return true;\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\ntype ModifiedBindingEntryArgs = {|\n  modifiedBinding: Binding,\n  newValue: void | Value,\n  containingGenerator: Generator,\n|};\n\nclass ModifiedBindingEntry extends GeneratorEntry {\n  constructor(realm: Realm, args: ModifiedBindingEntryArgs) {\n    super(realm);\n    Object.assign(this, args);\n  }\n\n  containingGenerator: Generator;\n  modifiedBinding: Binding;\n  newValue: void | Value;\n  residualFunctionBinding: void | ResidualFunctionBinding;\n\n  serialize(context: SerializationContext): void {\n    let residualFunctionBinding = this.residualFunctionBinding;\n    invariant(residualFunctionBinding !== undefined);\n    invariant(residualFunctionBinding.referentialized);\n    invariant(\n      residualFunctionBinding.serializedValue,\n      \"ResidualFunctionBinding must be referentialized before serializing a mutation to it.\"\n    );\n    let newValue = this.newValue;\n    invariant(newValue);\n    let bindingReference = ((residualFunctionBinding.serializedValue: any): BabelNodeLVal);\n    invariant(\n      t.isLVal(bindingReference),\n      \"Referentialized values must be LVals even though serializedValues may be any Expression\"\n    );\n    let serializedNewValue = context.serializeValue(newValue);\n    context.emit(t.expressionStatement(t.assignmentExpression(\"=\", bindingReference, serializedNewValue)));\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    invariant(\n      this.modifiedBinding.value === this.newValue,\n      \"ModifiedBinding's value has been changed since last visit.\"\n    );\n    let [residualBinding, newValue] = context.visitModifiedBinding(this.modifiedBinding);\n    invariant(\n      this.residualFunctionBinding === undefined || this.residualFunctionBinding === residualBinding,\n      \"ResidualFunctionBinding has been changed since last visit.\"\n    );\n    this.residualFunctionBinding = residualBinding;\n    this.newValue = newValue;\n    return true;\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\nclass ReturnValueEntry extends GeneratorEntry {\n  constructor(realm: Realm, generator: Generator, returnValue: Value) {\n    super(realm);\n    this.returnValue = returnValue.promoteEmptyToUndefined();\n    this.containingGenerator = generator;\n  }\n\n  returnValue: Value;\n  containingGenerator: Generator;\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    this.returnValue = context.visitEquivalentValue(this.returnValue);\n    return true;\n  }\n\n  serialize(context: SerializationContext): void {\n    let result = context.serializeValue(this.returnValue);\n    context.emit(t.returnStatement(result));\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\nclass IfThenElseEntry extends GeneratorEntry {\n  constructor(generator: Generator, completion: PossiblyNormalCompletion | ForkedAbruptCompletion, realm: Realm) {\n    super(realm);\n    this.completion = completion;\n    this.containingGenerator = generator;\n    this.condition = completion.joinCondition;\n\n    this.consequentGenerator = Generator.fromEffects(completion.consequentEffects, realm, \"ConsequentEffects\");\n    this.alternateGenerator = Generator.fromEffects(completion.alternateEffects, realm, \"AlternateEffects\");\n  }\n\n  completion: PossiblyNormalCompletion | ForkedAbruptCompletion;\n  containingGenerator: Generator;\n\n  condition: Value;\n  consequentGenerator: Generator;\n  alternateGenerator: Generator;\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    this.condition = context.visitEquivalentValue(this.condition);\n    context.visitGenerator(this.consequentGenerator, containingGenerator);\n    context.visitGenerator(this.alternateGenerator, containingGenerator);\n    return true;\n  }\n\n  serialize(context: SerializationContext): void {\n    let condition = context.serializeValue(this.condition);\n    let valuesToProcess = new Set();\n    let consequentBody = context.serializeGenerator(this.consequentGenerator, valuesToProcess);\n    let alternateBody = context.serializeGenerator(this.alternateGenerator, valuesToProcess);\n    context.emit(t.ifStatement(condition, t.blockStatement(consequentBody), t.blockStatement(alternateBody)));\n    context.processValues(valuesToProcess);\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return [this.consequentGenerator, this.alternateGenerator];\n  }\n}\n\nclass BindingAssignmentEntry extends GeneratorEntry {\n  constructor(realm: Realm, binding: Binding, value: Value) {\n    super(realm);\n    this.binding = binding;\n    this.value = value;\n  }\n\n  binding: Binding;\n  value: Value;\n\n  serialize(context: SerializationContext): void {\n    context.emit(\n      t.expressionStatement(\n        t.assignmentExpression(\"=\", context.serializeBinding(this.binding), context.serializeValue(this.value))\n      )\n    );\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    this.value = context.visitBindingAssignment(this.binding, this.value);\n    return true;\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\nfunction serializeBody(\n  generator: Generator,\n  context: SerializationContext,\n  valuesToProcess: Set<AbstractValue | ObjectValue>\n): BabelNodeBlockStatement {\n  let statements = context.serializeGenerator(generator, valuesToProcess);\n  if (statements.length === 1 && statements[0].type === \"BlockStatement\") return (statements[0]: any);\n  return t.blockStatement(statements);\n}\n\nexport class Generator {\n  constructor(realm: Realm, name: string, pathConditions: Array<AbstractValue>, effects?: Effects) {\n    invariant(realm.useAbstractInterpretation);\n    let realmPreludeGenerator = realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n    this.realm = realm;\n    this._entries = [];\n    this.id = realm.nextGeneratorId++;\n    this._name = name;\n    this.effectsToApply = effects;\n    this.pathConditions = pathConditions;\n  }\n\n  realm: Realm;\n  _entries: Array<GeneratorEntry>;\n  preludeGenerator: PreludeGenerator;\n  effectsToApply: void | Effects;\n  id: number;\n  _name: string;\n  pathConditions: Array<AbstractValue>;\n\n  static _generatorOfEffects(\n    realm: Realm,\n    name: string,\n    environmentRecordIdAfterGlobalCode: number,\n    effects: Effects\n  ): Generator {\n    let { result, generator, modifiedBindings, modifiedProperties, createdObjects } = effects;\n\n    let output = new Generator(realm, name, generator.pathConditions, effects);\n    output.appendGenerator(generator, generator._name);\n\n    for (let propertyBinding of modifiedProperties.keys()) {\n      let object = propertyBinding.object;\n      if (createdObjects.has(object)) continue; // Created Object's binding\n      if (object.refuseSerialization) continue; // modification to internal state\n      // modifications to intrinsic objects are tracked in the generator\n      if (object.isIntrinsic()) continue;\n      output.emitPropertyModification(propertyBinding);\n    }\n\n    for (let modifiedBinding of modifiedBindings.keys()) {\n      // TODO: Instead of looking at the environment ids, keep instead track of a createdEnvironmentRecords set,\n      // and only consider bindings here from environment records that already existed, or even better,\n      // ensure upstream that only such bindings are ever added to the modified-bindings set.\n      if (modifiedBinding.environment.id >= environmentRecordIdAfterGlobalCode) continue;\n\n      output.emitBindingModification(modifiedBinding);\n    }\n\n    if (result instanceof UndefinedValue) return output;\n    if (result instanceof SimpleNormalCompletion || result instanceof ReturnCompletion) {\n      output.emitReturnValue(result.value);\n    } else if (result instanceof PossiblyNormalCompletion || result instanceof ForkedAbruptCompletion) {\n      output.emitIfThenElse(result, realm);\n    } else if (result instanceof ThrowCompletion) {\n      output.emitThrow(result.value);\n    } else if (result instanceof AbruptCompletion) {\n      // no-op\n    } else {\n      invariant(false);\n    }\n    return output;\n  }\n\n  // Make sure to to fixup\n  // how to apply things around sets of things\n  static fromEffects(\n    effects: Effects,\n    realm: Realm,\n    name: string,\n    environmentRecordIdAfterGlobalCode: number = 0\n  ): Generator {\n    return realm.withEffectsAppliedInGlobalEnv(\n      this._generatorOfEffects.bind(this, realm, name, environmentRecordIdAfterGlobalCode),\n      effects\n    );\n  }\n\n  emitPropertyModification(propertyBinding: PropertyBinding): void {\n    invariant(this.effectsToApply !== undefined);\n    let desc = propertyBinding.descriptor;\n    if (desc !== undefined) {\n      let value = desc.value;\n      if (value instanceof AbstractValue) {\n        if (value.kind === \"conditional\") {\n          let [c, x, y] = value.args;\n          if (c instanceof AbstractValue && c.kind === \"template for property name condition\") {\n            let ydesc = Object.assign({}, desc, { value: y });\n            let yprop = Object.assign({}, propertyBinding, { descriptor: ydesc });\n            this.emitPropertyModification(yprop);\n            let xdesc = Object.assign({}, desc, { value: x });\n            let key = c.args[0];\n            invariant(key instanceof AbstractValue);\n            let xprop = Object.assign({}, propertyBinding, { key, descriptor: xdesc });\n            this.emitPropertyModification(xprop);\n            return;\n          }\n        } else if (value.kind === \"template for prototype member expression\") {\n          return;\n        }\n      }\n    }\n    this._entries.push(\n      new ModifiedPropertyEntry(this.realm, {\n        propertyBinding,\n        newDescriptor: desc,\n        containingGenerator: this,\n      })\n    );\n  }\n\n  emitBindingModification(modifiedBinding: Binding): void {\n    invariant(this.effectsToApply !== undefined);\n    this._entries.push(\n      new ModifiedBindingEntry(this.realm, {\n        modifiedBinding,\n        newValue: modifiedBinding.value,\n        containingGenerator: this,\n      })\n    );\n  }\n\n  emitReturnValue(result: Value): void {\n    this._entries.push(new ReturnValueEntry(this.realm, this, result));\n  }\n\n  emitIfThenElse(result: PossiblyNormalCompletion | ForkedAbruptCompletion, realm: Realm): void {\n    this._entries.push(new IfThenElseEntry(this, result, realm));\n  }\n\n  getName(): string {\n    return `${this._name}(#${this.id})`;\n  }\n\n  empty(): boolean {\n    return this._entries.length === 0;\n  }\n\n  emitGlobalDeclaration(key: string, value: Value): void {\n    this.preludeGenerator.declaredGlobals.add(key);\n    if (!(value instanceof UndefinedValue)) this.emitGlobalAssignment(key, value);\n  }\n\n  emitGlobalAssignment(key: string, value: Value): void {\n    this._addEntry({\n      args: [value],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, false), valueNode)\n        ),\n    });\n  }\n\n  emitConcreteModel(key: string, value: Value): void {\n    this._addEntry({\n      args: [concretize(this.realm, value)],\n      buildNode: ([valueNode]) =>\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", this.preludeGenerator.globalReference(key, false), valueNode)\n        ),\n    });\n  }\n\n  emitGlobalDelete(key: string): void {\n    this._addEntry({\n      args: [],\n      buildNode: ([]) =>\n        t.expressionStatement(t.unaryExpression(\"delete\", this.preludeGenerator.globalReference(key, false))),\n    });\n  }\n\n  emitBindingAssignment(binding: Binding, value: Value): void {\n    this._entries.push(new BindingAssignmentEntry(this.realm, binding, value));\n  }\n\n  emitPropertyAssignment(object: ObjectValue, key: string, value: Value): void {\n    if (object.refuseSerialization) return;\n    this._addEntry({\n      args: [object, value],\n      buildNode: ([objectNode, valueNode], context) =>\n        context.getPropertyAssignmentStatement(\n          memberExpressionHelper(objectNode, key),\n          value,\n          value.mightHaveBeenDeleted(),\n          /* deleteIfMightHaveBeenDeleted */ true\n        ),\n    });\n  }\n\n  emitDefineProperty(object: ObjectValue, key: string, desc: Descriptor, isDescChanged: boolean = true): void {\n    if (object.refuseSerialization) return;\n    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      this.emitPropertyAssignment(object, key, descValue);\n    } else {\n      desc = Object.assign({}, desc);\n      let descValue = desc.value || object.$Realm.intrinsics.undefined;\n      invariant(descValue instanceof Value);\n      this._addEntry({\n        args: [\n          object,\n          descValue,\n          desc.get || object.$Realm.intrinsics.undefined,\n          desc.set || object.$Realm.intrinsics.undefined,\n        ],\n        buildNode: (_, context: SerializationContext) => context.emitDefinePropertyBody(object, key, desc),\n      });\n    }\n  }\n\n  emitPropertyDelete(object: ObjectValue, key: string): void {\n    if (object.refuseSerialization) return;\n    this._addEntry({\n      args: [object],\n      buildNode: ([objectNode]) =>\n        t.expressionStatement(t.unaryExpression(\"delete\", memberExpressionHelper(objectNode, key))),\n    });\n  }\n\n  emitCall(createCallee: () => BabelNodeExpression, args: Array<Value>): void {\n    this._addEntry({\n      args,\n      buildNode: values => t.expressionStatement(t.callExpression(createCallee(), [...values])),\n    });\n  }\n\n  emitConsoleLog(method: ConsoleMethodTypes, args: Array<string | ConcreteValue>): void {\n    this.emitCall(\n      () => t.memberExpression(t.identifier(\"console\"), t.identifier(method)),\n      args.map(v => (typeof v === \"string\" ? new StringValue(this.realm, v) : v))\n    );\n  }\n\n  // test must be a temporal value, which means that it must have a defined intrinsicName\n  emitDoWhileStatement(test: AbstractValue, body: Generator): void {\n    this._addEntry({\n      args: [],\n      buildNode: function([], context, valuesToProcess) {\n        let testId = test.intrinsicName;\n        invariant(testId !== undefined);\n        let statements = context.serializeGenerator(body, valuesToProcess);\n        let block = t.blockStatement(statements);\n        return t.doWhileStatement(t.identifier(testId), block);\n      },\n      dependencies: [body],\n    });\n  }\n\n  emitConditionalThrow(value: Value): void {\n    function createStatement(val: Value, context: SerializationContext) {\n      if (!(val instanceof AbstractValue) || val.kind !== \"conditional\") {\n        return t.throwStatement(context.serializeValue(val));\n      }\n      let [cond, trueVal, falseVal] = val.args;\n      let condVal = context.serializeValue(cond);\n      let trueStat, falseStat;\n      if (trueVal instanceof EmptyValue) trueStat = t.blockStatement([]);\n      else trueStat = createStatement(trueVal, context);\n      if (falseVal instanceof EmptyValue) falseStat = t.blockStatement([]);\n      else falseStat = createStatement(falseVal, context);\n      return t.ifStatement(condVal, trueStat, falseStat);\n    }\n    this._addEntry({\n      args: [value],\n      buildNode: function([argument], context: SerializationContext) {\n        return createStatement(value, context);\n      },\n    });\n  }\n\n  _issueThrowCompilerDiagnostic(value: Value): void {\n    let message = \"Program may terminate with exception\";\n    if (value instanceof ObjectValue) {\n      let object = ((value: any): ObjectValue);\n      let objectMessage = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue(\"message\"));\n      if (objectMessage instanceof StringValue) message += `: ${objectMessage.value}`;\n      const objectStack = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue(\"stack\"));\n      if (objectStack instanceof StringValue)\n        message += `\n  ${objectStack.value}`;\n    }\n    const diagnostic = new CompilerDiagnostic(message, value.expressionLocation, \"PP0023\", \"Warning\");\n    this.realm.handleError(diagnostic);\n  }\n\n  emitThrow(value: Value): void {\n    this._issueThrowCompilerDiagnostic(value);\n    this.emitStatement([value], ([argument]) => t.throwStatement(argument));\n  }\n\n  // Checks the full set of possible concrete values as well as typeof\n  // for any AbstractValues\n  // e.g: (obj.property !== undefined && typeof obj.property !== \"object\")\n  // NB: if the type of the AbstractValue is top, skips the invariant\n  emitFullInvariant(object: ObjectValue | AbstractObjectValue, key: string, value: Value): void {\n    if (object.refuseSerialization) return;\n    let accessedPropertyOf = objectNode => memberExpressionHelper(objectNode, key);\n    let condition;\n    if (value instanceof AbstractValue) {\n      let isTop = false;\n      let concreteComparisons = [];\n      let typeComparisons = new Set();\n\n      function populateComparisonsLists(absValue: AbstractValue) {\n        if (absValue.kind === \"abstractConcreteUnion\") {\n          // recurse\n          for (let nestedValue of absValue.args)\n            if (nestedValue instanceof ConcreteValue) {\n              concreteComparisons.push(nestedValue);\n            } else {\n              invariant(nestedValue instanceof AbstractValue);\n              populateComparisonsLists(nestedValue);\n            }\n        } else if (absValue.getType() === Value) {\n          isTop = true;\n        } else {\n          typeComparisons.add(absValue.getType());\n        }\n      }\n      populateComparisonsLists(value);\n\n      // No point in doing the invariant if we don't know the type\n      // of one of the nested abstract values\n      if (isTop) {\n        return;\n      } else {\n        condition = ([valueNode]) => {\n          // Create `object.property !== concreteValue`\n          let checks = concreteComparisons.map(concreteValue =>\n            t.binaryExpression(\"!==\", valueNode, t.valueToNode(concreteValue.serialize()))\n          );\n          // Create `typeof object.property !== typeValue`\n          checks = checks.concat(\n            [...typeComparisons].map(typeValue => {\n              let typeString = Utils.typeToString(typeValue);\n              invariant(typeString !== undefined, typeValue);\n              return t.binaryExpression(\n                \"!==\",\n                t.unaryExpression(\"typeof\", valueNode, true),\n                t.stringLiteral(typeString)\n              );\n            })\n          );\n          return checks.reduce((expr, newCondition) => t.logicalExpression(\"&&\", expr, newCondition));\n        };\n        this._emitInvariant([value, value], condition, valueNode => valueNode);\n      }\n    } else if (value instanceof FunctionValue) {\n      // We do a special case for functions,\n      // as we like to use concrete functions in the model to model abstract behaviors.\n      // These concrete functions do not have the right identity.\n      condition = ([objectNode]) =>\n        t.binaryExpression(\n          \"!==\",\n          t.unaryExpression(\"typeof\", accessedPropertyOf(objectNode), true),\n          t.stringLiteral(\"function\")\n        );\n      this._emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));\n    } else {\n      condition = ([objectNode, valueNode]) => t.binaryExpression(\"!==\", accessedPropertyOf(objectNode), valueNode);\n      this._emitInvariant([object, value, object], condition, objnode => accessedPropertyOf(objnode));\n    }\n  }\n\n  getErrorStatement(message: BabelNodeExpression): BabelNodeStatement {\n    if (this.realm.invariantMode === \"throw\")\n      return t.throwStatement(t.newExpression(this.preludeGenerator.memoizeReference(\"Error\"), [message]));\n    else {\n      let targetReference = this.realm.invariantMode;\n      let args = [message];\n      let i = targetReference.indexOf(\"+\");\n      if (i !== -1) {\n        let s = targetReference.substr(i + 1);\n        let x = Number.parseInt(s, 10);\n        args.push(isNaN(x) ? t.stringLiteral(s) : t.numericLiteral(x));\n        targetReference = targetReference.substr(0, i);\n      }\n      return t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference(targetReference), args));\n    }\n  }\n\n  emitPropertyInvariant(\n    object: ObjectValue | AbstractObjectValue,\n    key: string,\n    state: \"MISSING\" | \"PRESENT\" | \"DEFINED\"\n  ): void {\n    if (object.refuseSerialization) return;\n    let accessedPropertyOf = (objectNode: BabelNodeExpression) => memberExpressionHelper(objectNode, key);\n    let condition = ([objectNode: BabelNodeExpression]) => {\n      let n = t.callExpression(\n        t.memberExpression(\n          this.preludeGenerator.memoizeReference(\"Object.prototype.hasOwnProperty\"),\n          t.identifier(\"call\")\n        ),\n        [objectNode, t.stringLiteral(key)]\n      );\n      if (state !== \"MISSING\") {\n        n = t.unaryExpression(\"!\", n, true);\n        if (state === \"DEFINED\")\n          n = t.logicalExpression(\n            \"||\",\n            n,\n            t.binaryExpression(\"===\", accessedPropertyOf(objectNode), t.valueToNode(undefined))\n          );\n      }\n      return n;\n    };\n\n    this._emitInvariant([object, object], condition, objnode => accessedPropertyOf(objnode));\n  }\n\n  _emitInvariant(\n    args: Array<Value>,\n    violationConditionFn: (Array<BabelNodeExpression>) => BabelNodeExpression,\n    appendLastToInvariantFn?: BabelNodeExpression => BabelNodeExpression\n  ): void {\n    invariant(this.realm.invariantLevel > 0);\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) => {\n        let messageComponents = [\n          t.stringLiteral(\"Prepack model invariant violation (\"),\n          t.numericLiteral(this.preludeGenerator.nextInvariantId++),\n        ];\n        if (appendLastToInvariantFn) {\n          let last = nodes.pop();\n          messageComponents.push(t.stringLiteral(\"): \"));\n          messageComponents.push(appendLastToInvariantFn(last));\n        } else messageComponents.push(t.stringLiteral(\")\"));\n        let throwString = messageComponents[0];\n        for (let i = 1; i < messageComponents.length; i++)\n          throwString = t.binaryExpression(\"+\", throwString, messageComponents[i]);\n        let condition = violationConditionFn(nodes);\n        let consequent = this.getErrorStatement(throwString);\n        return t.ifStatement(condition, consequent);\n      },\n    });\n  }\n\n  emitCallAndCaptureResult(\n    types: TypesDomain,\n    values: ValuesDomain,\n    createCallee: () => BabelNodeExpression,\n    args: Array<Value>,\n    kind?: AbstractValueKind\n  ): AbstractValue {\n    return this.deriveAbstract(types, values, args, (nodes: any) => t.callExpression(createCallee(), nodes), { kind });\n  }\n\n  emitStatement(args: Array<Value>, buildNode_: (Array<BabelNodeExpression>) => BabelNodeStatement): void {\n    this._addEntry({\n      args,\n      buildNode: buildNode_,\n    });\n  }\n\n  emitVoidExpression(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: AbstractValueBuildNodeFunction | BabelNodeExpression\n  ): UndefinedValue {\n    this._addEntry({\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>) =>\n        t.expressionStatement(\n          (buildNode_: any) instanceof Function\n            ? ((buildNode_: any): AbstractValueBuildNodeFunction)(nodes)\n            : ((buildNode_: any): BabelNodeExpression)\n        ),\n    });\n    return this.realm.intrinsics.undefined;\n  }\n\n  emitForInStatement(\n    o: ObjectValue | AbstractObjectValue,\n    lh: BabelNodeVariableDeclaration,\n    sourceObject: ObjectValue,\n    targetObject: ObjectValue,\n    boundName: BabelNodeIdentifier\n  ): void {\n    this._addEntry({\n      // duplicate args to ensure refcount > 1\n      args: [o, targetObject, sourceObject, targetObject, sourceObject],\n      buildNode: ([obj, tgt, src, obj1, tgt1, src1]) => {\n        return t.forInStatement(\n          lh,\n          obj,\n          t.blockStatement([\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                memberExpressionHelper(tgt, boundName),\n                memberExpressionHelper(src, boundName)\n              )\n            ),\n          ])\n        );\n      },\n    });\n  }\n\n  deriveConcreteObject(\n    buildValue: (intrinsicName: string) => ObjectValue,\n    args: Array<Value>,\n    buildNode_: DerivedExpressionBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {| isPure?: boolean |}\n  ): ConcreteValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    let value = buildValue(id.name);\n    value.intrinsicNameGenerated = true;\n    value._isScopedTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope\n    this._addDerivedEntry(id.name, {\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: value,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>, context: SerializationContext, valuesToProcess) => {\n        return t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): DerivedExpressionBuildNodeFunction)(nodes, context, valuesToProcess)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n      },\n    });\n    return value;\n  }\n\n  deriveAbstract(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    buildNode_: DerivedExpressionBuildNodeFunction | BabelNodeExpression,\n    optionalArgs?: {|\n      kind?: AbstractValueKind,\n      isPure?: boolean,\n      skipInvariant?: boolean,\n      mutatesOnly?: Array<Value>,\n      temporalType?: TemporalBuildNodeType,\n    |}\n  ): AbstractValue {\n    invariant(buildNode_ instanceof Function || args.length === 0);\n    let id = t.identifier(this.preludeGenerator.nameGenerator.generate(\"derived\"));\n    let options = {};\n    if (optionalArgs && optionalArgs.kind) options.kind = optionalArgs.kind;\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let res = new Constructor(\n      this.realm,\n      types,\n      values,\n      1735003607742176 + this.realm.derivedIds.size,\n      [],\n      id,\n      options\n    );\n    this._addDerivedEntry(id.name, {\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: res,\n      args,\n      buildNode: (nodes: Array<BabelNodeExpression>, context: SerializationContext, valuesToProcess) => {\n        return t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            id,\n            (buildNode_: any) instanceof Function\n              ? ((buildNode_: any): DerivedExpressionBuildNodeFunction)(nodes, context, valuesToProcess)\n              : ((buildNode_: any): BabelNodeExpression)\n          ),\n        ]);\n      },\n      mutatesOnly: optionalArgs ? optionalArgs.mutatesOnly : undefined,\n      temporalType: optionalArgs ? optionalArgs.temporalType : undefined,\n    });\n    let type = types.getType();\n    res.intrinsicName = id.name;\n    if (optionalArgs && optionalArgs.skipInvariant) return res;\n    let typeofString;\n    if (type instanceof FunctionValue) typeofString = \"function\";\n    else if (type === UndefinedValue) invariant(false);\n    else if (type === NullValue) invariant(false);\n    else if (type === StringValue) typeofString = \"string\";\n    else if (type === BooleanValue) typeofString = \"boolean\";\n    else if (type === NumberValue) typeofString = \"number\";\n    else if (type === IntegralValue) typeofString = \"number\";\n    else if (type === SymbolValue) typeofString = \"symbol\";\n    else if (type === ObjectValue) typeofString = \"object\";\n    if (typeofString !== undefined && this.realm.invariantLevel >= 1) {\n      // Verify that the types are as expected, a failure of this invariant\n      // should mean the model is wrong.\n      this._emitInvariant(\n        [res, res],\n        nodes => {\n          invariant(typeofString !== undefined);\n          let condition = t.binaryExpression(\n            \"!==\",\n            t.unaryExpression(\"typeof\", nodes[0]),\n            t.stringLiteral(typeofString)\n          );\n          if (typeofString === \"object\") {\n            condition = t.logicalExpression(\n              \"&&\",\n              condition,\n              t.binaryExpression(\"!==\", t.unaryExpression(\"typeof\", nodes[0]), t.stringLiteral(\"function\"))\n            );\n            condition = t.logicalExpression(\"||\", condition, t.binaryExpression(\"===\", nodes[0], nullExpression));\n          }\n          return condition;\n        },\n        node => node\n      );\n    }\n\n    return res;\n  }\n\n  visit(callbacks: VisitEntryCallbacks): void {\n    let visitFn = () => {\n      for (let entry of this._entries) entry.visit(callbacks, this);\n      return null;\n    };\n    if (this.effectsToApply) {\n      this.realm.withEffectsAppliedInGlobalEnv(visitFn, this.effectsToApply);\n    } else {\n      visitFn();\n    }\n  }\n\n  serialize(context: SerializationContext): void {\n    let serializeFn = () => {\n      context.initGenerator(this);\n      for (let entry of this._entries) entry.serialize(context);\n      context.finalizeGenerator(this);\n      return null;\n    };\n    if (this.effectsToApply) {\n      this.realm.withEffectsAppliedInGlobalEnv(serializeFn, this.effectsToApply);\n    } else {\n      serializeFn();\n    }\n  }\n\n  getDependencies(): Array<Generator> {\n    let res = [];\n    for (let entry of this._entries) {\n      let dependencies = entry.getDependencies();\n      if (dependencies !== undefined) res.push(...dependencies);\n    }\n    return res;\n  }\n\n  _addEntry(entryArgs: TemporalBuildNodeEntryArgs): TemporalBuildNodeEntry {\n    let entry;\n    if (entryArgs.temporalType === \"OBJECT_ASSIGN\") {\n      entry = new TemporalObjectAssignEntry(this.realm, entryArgs);\n    } else {\n      entry = new TemporalBuildNodeEntry(this.realm, entryArgs);\n    }\n    this.realm.saveTemporalGeneratorEntryArgs(entry);\n    this._entries.push(entry);\n    return entry;\n  }\n\n  _addDerivedEntry(id: string, entryArgs: TemporalBuildNodeEntryArgs): void {\n    let entry = this._addEntry(entryArgs);\n    this.realm.derivedIds.set(id, entry);\n  }\n\n  appendGenerator(other: Generator, leadingComment: string): void {\n    invariant(other !== this);\n    invariant(other.realm === this.realm);\n    invariant(other.preludeGenerator === this.preludeGenerator);\n\n    if (other.empty()) return;\n    if (other.effectsToApply === undefined) {\n      this._entries.push(...other._entries);\n    } else {\n      this._addEntry({\n        args: [],\n        buildNode: function(args, context, valuesToProcess) {\n          let statements = context.serializeGenerator(other, valuesToProcess);\n          if (statements.length === 1) {\n            let statement = statements[0];\n            if (leadingComment.length > 0)\n              statement.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n            return statement;\n          }\n          let block = t.blockStatement(statements);\n          if (leadingComment.length > 0)\n            block.leadingComments = [({ type: \"BlockComment\", value: leadingComment }: any)];\n          return block;\n        },\n        dependencies: [other],\n      });\n    }\n  }\n\n  joinGenerators(joinCondition: AbstractValue, generator1: Generator, generator2: Generator): void {\n    invariant(generator1 !== this && generator2 !== this && generator1 !== generator2);\n    if (generator1.empty() && generator2.empty()) return;\n    this._addEntry({\n      args: [joinCondition],\n      buildNode: function([cond], context, valuesToProcess) {\n        let block1 = generator1.empty() ? null : serializeBody(generator1, context, valuesToProcess);\n        let block2 = generator2.empty() ? null : serializeBody(generator2, context, valuesToProcess);\n        if (block1) return t.ifStatement(cond, block1, block2);\n        invariant(block2);\n        return t.ifStatement(t.unaryExpression(\"!\", cond), block2);\n      },\n      dependencies: [generator1, generator2],\n    });\n  }\n}\n\nfunction escapeInvalidIdentifierCharacters(s: string): string {\n  let res = \"\";\n  for (let c of s)\n    if ((c >= \"0\" && c <= \"9\") || (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\")) res += c;\n    else res += \"_\" + c.charCodeAt(0);\n  return res;\n}\n\nconst base62characters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nfunction base62encode(n: number): string {\n  invariant((n | 0) === n && n >= 0);\n  if (n === 0) return \"0\";\n  let s = \"\";\n  while (n > 0) {\n    let f = n % base62characters.length;\n    s = base62characters[f] + s;\n    n = (n - f) / base62characters.length;\n  }\n  return s;\n}\n\nexport class NameGenerator {\n  constructor(forbiddenNames: Set<string>, debugNames: boolean, uniqueSuffix: string, prefix: string) {\n    this.prefix = prefix;\n    this.uidCounter = 0;\n    this.debugNames = debugNames;\n    this.forbiddenNames = forbiddenNames;\n    this.uniqueSuffix = uniqueSuffix;\n  }\n  prefix: string;\n  uidCounter: number;\n  debugNames: boolean;\n  forbiddenNames: Set<string>;\n  uniqueSuffix: string;\n  generate(debugSuffix: ?string): string {\n    let id;\n    do {\n      id = this.prefix + base62encode(this.uidCounter++);\n      if (this.uniqueSuffix.length > 0) id += this.uniqueSuffix;\n      if (this.debugNames) {\n        if (debugSuffix) id += \"_\" + escapeInvalidIdentifierCharacters(debugSuffix);\n        else id += \"_\";\n      }\n    } while (this.forbiddenNames.has(id));\n    return id;\n  }\n}\n\nexport class PreludeGenerator {\n  constructor(debugNames: ?boolean, uniqueSuffix: ?string) {\n    this.prelude = [];\n    this.memoizedRefs = new Map();\n    this.nameGenerator = new NameGenerator(new Set(), !!debugNames, uniqueSuffix || \"\", \"_$\");\n    this.usesThis = false;\n    this.declaredGlobals = new Set();\n    this.nextInvariantId = 0;\n  }\n\n  prelude: Array<BabelNodeStatement>;\n  memoizedRefs: Map<string, BabelNodeIdentifier>;\n  nameGenerator: NameGenerator;\n  usesThis: boolean;\n  declaredGlobals: Set<string>;\n  nextInvariantId: number;\n\n  createNameGenerator(prefix: string): NameGenerator {\n    return new NameGenerator(\n      this.nameGenerator.forbiddenNames,\n      this.nameGenerator.debugNames,\n      this.nameGenerator.uniqueSuffix,\n      prefix\n    );\n  }\n\n  convertStringToMember(str: string): BabelNodeIdentifier | BabelNodeThisExpression | BabelNodeMemberExpression {\n    return str\n      .split(\".\")\n      .map(name => {\n        if (name === \"global\") {\n          return this.memoizeReference(name);\n        } else if (name === \"this\") {\n          return t.thisExpression();\n        } else {\n          return t.identifier(name);\n        }\n      })\n      .reduce((obj, prop) => t.memberExpression(obj, prop));\n  }\n\n  globalReference(key: string, globalScope: boolean = false): BabelNodeIdentifier | BabelNodeMemberExpression {\n    if (globalScope && t.isValidIdentifier(key)) return t.identifier(key);\n    return memberExpressionHelper(this.memoizeReference(\"global\"), key);\n  }\n\n  memoizeReference(key: string): BabelNodeIdentifier {\n    let ref = this.memoizedRefs.get(key);\n    if (ref) return ref;\n\n    let init;\n    if (key.includes(\"(\") || key.includes(\"[\")) {\n      // Horrible but effective hack:\n      // Some internal object have intrinsic names such as\n      //    ([][Symbol.iterator]().__proto__.__proto__)\n      // and\n      //    RegExp.prototype[Symbol.match]\n      // which get turned into a babel node here.\n      // TODO: We should properly parse such a string, and memoize all references in it separately.\n      // Instead, we just turn it into a funky identifier, which Babel seems to accept.\n      init = t.identifier(key);\n    } else if (key === \"global\") {\n      this.usesThis = true;\n      init = t.thisExpression();\n    } else {\n      let i = key.lastIndexOf(\".\");\n      if (i === -1) {\n        init = t.memberExpression(this.memoizeReference(\"global\"), t.identifier(key));\n      } else {\n        init = t.memberExpression(this.memoizeReference(key.substr(0, i)), t.identifier(key.substr(i + 1)));\n      }\n    }\n    ref = t.identifier(this.nameGenerator.generate(key));\n    this.prelude.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, init)]));\n    this.memoizedRefs.set(key, ref);\n    return ref;\n  }\n}\n\ntype TemporalBuildNodeEntryOptimizationStatus = \"NO_OPTIMIZATION\" | \"POSSIBLE_OPTIMIZATION\";\n\n// This function attempts to optimize Object.assign calls, by merging mulitple\n// calls into one another where possible. For example:\n//\n// var a = Object.assign({}, someAbstact);\n// var b = Object.assign({}, a);\n//\n// Becomes:\n// var b = Object.assign({}, someAbstract, a);\n//\nexport function attemptToMergeEquivalentObjectAssigns(\n  realm: Realm,\n  callbacks: VisitEntryCallbacks,\n  temporalBuildNodeEntry: TemporalBuildNodeEntry\n): TemporalBuildNodeEntryOptimizationStatus | TemporalObjectAssignEntry {\n  let args = temporalBuildNodeEntry.args;\n  // If we are Object.assigning 2 or more args\n  if (args.length < 2) {\n    return \"NO_OPTIMIZATION\";\n  }\n  let to = args[0];\n  // Then scan through the args after the \"to\" of this Object.assign, to see if any\n  // other sources are the \"to\" of a previous Object.assign call\n  loopThroughArgs: for (let i = 1; i < args.length; i++) {\n    let possibleOtherObjectAssignTo = args[i];\n    // Ensure that the \"to\" value can be omitted\n    // Note: this check is still somewhat fragile and depends on the visiting order\n    // but it's not a functional problem right now and can be better addressed at a\n    // later point.\n    if (!callbacks.canOmit(possibleOtherObjectAssignTo)) {\n      continue;\n    }\n    // Check if the \"to\" was definitely an Object.assign, it should\n    // be a snapshot AbstractObjectValue\n    if (possibleOtherObjectAssignTo instanceof AbstractObjectValue) {\n      let otherTemporalBuildNodeEntry = realm.getTemporalBuildNodeEntryFromDerivedValue(possibleOtherObjectAssignTo);\n      if (!(otherTemporalBuildNodeEntry instanceof TemporalObjectAssignEntry)) {\n        continue;\n      }\n      let otherArgs = otherTemporalBuildNodeEntry.args;\n      // Object.assign has at least 1 arg\n      if (otherArgs.length < 2) {\n        continue;\n      }\n      let otherArgsToUse = [];\n      for (let x = 1; x < otherArgs.length; x++) {\n        let arg = otherArgs[x];\n        // The arg might have been havoced, so ensure we do not continue in this case\n        if (arg instanceof ObjectValue && arg.mightBeHavocedObject()) {\n          continue loopThroughArgs;\n        }\n        if (arg instanceof ObjectValue || arg instanceof AbstractValue) {\n          let temporalGeneratorEntries = realm.getTemporalGeneratorEntriesReferencingArg(arg);\n          // We need to now check if there are any other temporal entries that exist\n          // between the Object.assign TemporalObjectAssignEntry that we're trying to\n          // merge and the current TemporalObjectAssignEntry we're going to merge into.\n          if (temporalGeneratorEntries !== undefined) {\n            for (let temporalGeneratorEntry of temporalGeneratorEntries) {\n              // If the entry is that of another Object.assign, then\n              // we know that this entry isn't going to cause issues\n              // with merging the TemporalObjectAssignEntry.\n              if (temporalGeneratorEntry instanceof TemporalObjectAssignEntry) {\n                continue;\n              }\n              // TODO: what if the temporalGeneratorEntry can be omitted and not needed?\n\n              // If the index of this entry exists between start and end indexes,\n              // then we cannot optimize and merge the TemporalObjectAssignEntry\n              // because another generator entry may have a dependency on the Object.assign\n              // TemporalObjectAssignEntry we're trying to merge.\n              if (\n                temporalGeneratorEntry.notEqualToAndDoesNotHappenBefore(otherTemporalBuildNodeEntry) &&\n                temporalGeneratorEntry.notEqualToAndDoesNotHappenAfter(temporalBuildNodeEntry)\n              ) {\n                continue loopThroughArgs;\n              }\n            }\n          }\n        }\n        otherArgsToUse.push(arg);\n      }\n      // If we cannot omit the \"to\" value that means it's being used, so we shall not try to\n      // optimize this Object.assign.\n      if (!callbacks.canOmit(to)) {\n        let newArgs = [to, ...otherArgsToUse];\n\n        for (let x = 2; x < args.length; x++) {\n          let arg = args[x];\n          // We don't want to add the \"to\" that we're merging with!\n          if (arg !== possibleOtherObjectAssignTo) {\n            newArgs.push(arg);\n          }\n        }\n        // We now create a new TemporalObjectAssignEntry, without mutating the existing\n        // entry at this point. This new entry is essentially a TemporalObjectAssignEntry\n        // that contains two Object.assign call TemporalObjectAssignEntry entries that have\n        // been merged into a single entry. The previous Object.assign TemporalObjectAssignEntry\n        // should dead-code eliminate away once we replace the original TemporalObjectAssignEntry\n        // we started with with the new merged on as they will no longer be referenced.\n        let newTemporalObjectAssignEntryArgs = Object.assign({}, temporalBuildNodeEntry, {\n          args: newArgs,\n        });\n        return new TemporalObjectAssignEntry(realm, newTemporalObjectAssignEntryArgs);\n      }\n      // We might be able to optimize, but we are not sure because \"to\" can still omit.\n      // So we return possible optimization status and wait until \"to\" does get visited.\n      // It may never get visited, but that's okay as we'll skip the optimization all\n      // together.\n      return \"POSSIBLE_OPTIMIZATION\";\n    }\n  }\n  return \"NO_OPTIMIZATION\";\n}\n"]}