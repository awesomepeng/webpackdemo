{"version":3,"sources":["../../src/utils/paths.js"],"names":["PathImplementation","implies","condition","mightNotBeTrue","path","$Realm","pathConditions","i","length","pathCondition","impliesNot","mightNotBeFalse","withCondition","evaluate","realm","savedPath","pushPathCondition","pushRefinedConditions","e","pushInversePathCondition","withInverseCondition","pushAndRefine","pushInverseAndRefine","kind","left","args","right","cond","x","y","equals","push","op","leftNeNull","createFromBinaryOp","intrinsics","null","leftNeUndefined","undefined","leftEqNull","leftEqUndefined","inverseCondition","createFromUnaryOp","simplifiedInverseCondition","simplifyAndRefineAbstractCondition","unrefinedConditions","refinedConditions","map","c","some","pc"],"mappings":";;;;;;;AAWA;;AACA;;AAEA;;;;;;AAEO,MAAMA,kBAAN,CAAyB;AAC9BC,UAAQC,SAAR,EAAmC;AACjC,QAAI,CAACA,UAAUC,cAAV,EAAL,EAAiC,OAAO,IAAP,CADA,CACa;AAC9C,QAAIC,OAAOF,UAAUG,MAAV,CAAiBC,cAA5B;AACA,SAAK,IAAIC,IAAIH,KAAKI,MAAL,GAAc,CAA3B,EAA8BD,KAAK,CAAnC,EAAsCA,GAAtC,EAA2C;AACzC,UAAIE,gBAAgBL,KAAKG,CAAL,CAApB;AACA,UAAIE,cAAcR,OAAd,CAAsBC,SAAtB,CAAJ,EAAsC,OAAO,IAAP;AACvC;AACD,WAAO,KAAP;AACD;;AAEDQ,aAAWR,SAAX,EAAsC;AACpC,QAAI,CAACA,UAAUS,eAAV,EAAL,EAAkC,OAAO,IAAP,CADE,CACW;AAC/C,QAAIP,OAAOF,UAAUG,MAAV,CAAiBC,cAA5B;AACA,SAAK,IAAIC,IAAIH,KAAKI,MAAL,GAAc,CAA3B,EAA8BD,KAAK,CAAnC,EAAsCA,GAAtC,EAA2C;AACzC,UAAIE,gBAAgBL,KAAKG,CAAL,CAApB;AACA,UAAIE,cAAcC,UAAd,CAAyBR,SAAzB,CAAJ,EAAyC,OAAO,IAAP;AAC1C;AACD,WAAO,KAAP;AACD;;AAEDU,gBAAiBV,SAAjB,EAAmCW,QAAnC,EAAyD;AACvD,QAAI,CAACX,UAAUS,eAAV,EAAL,EAAkC,MAAM,iCAAN;AAClC,QAAIG,QAAQZ,UAAUG,MAAtB;AACA,QAAIU,YAAYD,MAAMR,cAAtB;AACAQ,UAAMR,cAAN,GAAuB,EAAvB;AACA,QAAI;AACFU,wBAAkBd,SAAlB;AACAe,4BAAsBH,KAAtB,EAA6BC,SAA7B;AACA,aAAOF,UAAP;AACD,KAJD,CAIE,OAAOK,CAAP,EAAU;AACV,UAAIA,wCAAJ,EAAsC;AACpC;AACA;AACAJ,cAAMR,cAAN,GAAuBS,SAAvB;AACAI,iCAAyBjB,SAAzB;AACD;AACD,YAAMgB,CAAN;AACD,KAZD,SAYU;AACRJ,YAAMR,cAAN,GAAuBS,SAAvB;AACD;AACF;;AAEDK,uBAAwBlB,SAAxB,EAA0CW,QAA1C,EAAgE;AAC9D,QAAI,CAACX,UAAUC,cAAV,EAAL,EAAiC,MAAM,iCAAN;AACjC,QAAIW,QAAQZ,UAAUG,MAAtB;AACA,QAAIU,YAAYD,MAAMR,cAAtB;AACAQ,UAAMR,cAAN,GAAuB,EAAvB;AACA,QAAI;AACFa,+BAAyBjB,SAAzB;AACAe,4BAAsBH,KAAtB,EAA6BC,SAA7B;AACA,aAAOF,UAAP;AACD,KAJD,CAIE,OAAOK,CAAP,EAAU;AACV,UAAIA,wCAAJ,EAAsC;AACpC;AACA;AACAJ,cAAMR,cAAN,GAAuBS,SAAvB;AACAC,0BAAkBd,SAAlB;AACD;AACD,YAAMgB,CAAN;AACD,KAZD,SAYU;AACRJ,YAAMR,cAAN,GAAuBS,SAAvB;AACD;AACF;;AAEDM,gBAAcnB,SAAd,EAAsC;AACpC,QAAIY,QAAQZ,UAAUG,MAAtB;AACA,QAAIU,YAAYD,MAAMR,cAAtB;AACAQ,UAAMR,cAAN,GAAuB,EAAvB;;AAEAU,sBAAkBd,SAAlB;AACAe,0BAAsBH,KAAtB,EAA6BC,SAA7B;AACD;;AAEDO,uBAAqBpB,SAArB,EAA6C;AAC3C,QAAIY,QAAQZ,UAAUG,MAAtB;AACA,QAAIU,YAAYD,MAAMR,cAAtB;AACAQ,UAAMR,cAAN,GAAuB,EAAvB;;AAEAa,6BAAyBjB,SAAzB;AACAe,0BAAsBH,KAAtB,EAA6BC,SAA7B;AACD;AAjF6B;;QAAnBf,kB,GAAAA,kB,EAoFb;AApGA;;;;;;;;;AASA;;AA4FA,SAASgB,iBAAT,CAA2Bd,SAA3B,EAAmD;AACjD,2BAAUA,UAAUS,eAAV,EAAV,EAAuC,eAAvC,EADiD,CACQ;AACzD,MAAIT,yCAAJ,EAAwC;AACxC,MAAI,CAACA,UAAUC,cAAV,EAAL,EAAiC;AACjC,2BAAUD,yCAAV;AACA,MAAIY,QAAQZ,UAAUG,MAAtB;AACA,MAAIH,UAAUqB,IAAV,KAAmB,IAAvB,EAA6B;AAC3B,QAAIC,OAAOtB,UAAUuB,IAAV,CAAe,CAAf,CAAX;AACA,QAAIC,QAAQxB,UAAUuB,IAAV,CAAe,CAAf,CAAZ;AACA,6BAAUD,oCAAV,EAH2B,CAGe;AAC1CR,sBAAkBQ,IAAlB;AACAR,sBAAkBU,KAAlB;AACD,GAND,MAMO,IAAIxB,UAAUqB,IAAV,KAAmB,KAAvB,EAA8B;AACnC,QAAI,CAACC,IAAD,EAAOE,KAAP,IAAgBxB,UAAUuB,IAA9B;AACA,QAAIC,yCAAkCA,MAAMH,IAAN,KAAe,aAArD,EAAoE,CAACC,IAAD,EAAOE,KAAP,MAAkB,CAACA,KAAD,EAAQF,IAAR,CAAlB;AACpE,QAAIA,wCAAiCA,KAAKD,IAAL,KAAc,aAAnD,EAAkE;AAChE,UAAI,CAACI,IAAD,EAAOC,CAAP,EAAUC,CAAV,IAAeL,KAAKC,IAAxB;AACA,UAAIC,yCAAkCE,iCAAlC,IAAgEC,iCAApE,EAAgG;AAC9F,YAAIH,MAAMI,MAAN,CAAaF,CAAb,KAAmB,CAACF,MAAMI,MAAN,CAAaD,CAAb,CAAxB,EAAyC;AACvCb,4BAAkBW,IAAlB;AACD,SAFD,MAEO,IAAI,CAACD,MAAMI,MAAN,CAAaF,CAAb,CAAD,IAAoBF,MAAMI,MAAN,CAAaD,CAAb,CAAxB,EAAyC;AAC9CV,mCAAyBQ,IAAzB;AACD;AACF;AACF;AACDb,UAAMR,cAAN,CAAqByB,IAArB,CAA0B7B,SAA1B;AACD,GAdM,MAcA;AACL,QAAIA,UAAUqB,IAAV,KAAmB,IAAnB,IAA2BrB,UAAUqB,IAAV,KAAmB,IAAlD,EAAwD;AACtD,UAAIC,OAAOtB,UAAUuB,IAAV,CAAe,CAAf,CAAX;AACA,UAAIC,QAAQxB,UAAUuB,IAAV,CAAe,CAAf,CAAZ;AACA,UAAID,wCAAiCE,qCAArC,EAAqE,CAACF,IAAD,EAAOE,KAAP,IAAgB,CAACA,KAAD,EAAQF,IAAR,CAAhB;AACrE,UAAIA,yCAAkCE,0CAAmCA,iCAArE,CAAJ,EAAsG;AACpG,YAAIM,KAAK9B,UAAUqB,IAAV,KAAmB,IAAnB,GAA0B,KAA1B,GAAkC,KAA3C;AACA,YAAIS,OAAO,KAAX,EAAkBhB,kBAAkBQ,IAAlB,EAAlB,KACKL,yBAAyBK,IAAzB;AACL,YAAIS,aAAa,qBAAcC,kBAAd,CAAiCpB,KAAjC,EAAwCkB,EAAxC,EAA4CR,IAA5C,EAAkDV,MAAMqB,UAAN,CAAiBC,IAAnE,CAAjB;AACA,YAAIH,WAAWtB,eAAX,EAAJ,EAAkCK,kBAAkBiB,UAAlB;AAClC,YAAII,kBAAkB,qBAAcH,kBAAd,CAAiCpB,KAAjC,EAAwCkB,EAAxC,EAA4CR,IAA5C,EAAkDV,MAAMqB,UAAN,CAAiBG,SAAnE,CAAtB;AACA,YAAID,gBAAgB1B,eAAhB,EAAJ,EAAuCK,kBAAkBqB,eAAlB;AACvC;AACD;AACF;AACDvB,UAAMR,cAAN,CAAqByB,IAArB,CAA0B7B,SAA1B;AACD;AACF;;AAED;AACA,SAASiB,wBAAT,CAAkCjB,SAAlC,EAA0D;AACxD;AACA,2BAAUA,UAAUC,cAAV,EAAV;AACA,MAAID,yCAAJ,EAAwC;AACxC,2BAAUA,yCAAV;AACA,MAAIA,UAAUqB,IAAV,KAAmB,IAAvB,EAA6B;AAC3B,QAAIC,OAAOtB,UAAUuB,IAAV,CAAe,CAAf,CAAX;AACA,QAAIC,QAAQxB,UAAUuB,IAAV,CAAe,CAAf,CAAZ;AACA,6BAAUD,oCAAV,EAH2B,CAGe;AAC1CL,6BAAyBK,IAAzB;AACA,QAAIE,MAAMvB,cAAN,EAAJ,EAA4BgB,yBAAyBO,KAAzB;AAC7B,GAND,MAMO;AACL,QAAIZ,QAAQZ,UAAUG,MAAtB;AACA,QAAIH,UAAUqB,IAAV,KAAmB,IAAnB,IAA2BrB,UAAUqB,IAAV,KAAmB,IAAlD,EAAwD;AACtD,UAAIC,OAAOtB,UAAUuB,IAAV,CAAe,CAAf,CAAX;AACA,UAAIC,QAAQxB,UAAUuB,IAAV,CAAe,CAAf,CAAZ;AACA,UAAID,wCAAiCE,qCAArC,EAAqE,CAACF,IAAD,EAAOE,KAAP,IAAgB,CAACA,KAAD,EAAQF,IAAR,CAAhB;AACrE,UAAIA,yCAAkCE,0CAAmCA,iCAArE,CAAJ,EAAsG;AACpG,YAAIM,KAAK9B,UAAUqB,IAAV,KAAmB,IAAnB,GAA0B,KAA1B,GAAkC,KAA3C;AACA,YAAIS,OAAO,KAAX,EAAkBhB,kBAAkBQ,IAAlB,EAAlB,KACKL,yBAAyBK,IAAzB;AACL,YAAIe,aAAa,qBAAcL,kBAAd,CAAiCpB,KAAjC,EAAwCkB,EAAxC,EAA4CR,IAA5C,EAAkDV,MAAMqB,UAAN,CAAiBC,IAAnE,CAAjB;AACA,YAAIG,WAAW5B,eAAX,EAAJ,EAAkCK,kBAAkBuB,UAAlB;AAClC,YAAIC,kBAAkB,qBAAcN,kBAAd,CAAiCpB,KAAjC,EAAwCkB,EAAxC,EAA4CR,IAA5C,EAAkDV,MAAMqB,UAAN,CAAiBG,SAAnE,CAAtB;AACA,YAAIE,gBAAgB7B,eAAhB,EAAJ,EAAuCK,kBAAkBwB,eAAlB;AACvC;AACD;AACF;AACD,QAAIC,mBAAmB,qBAAcC,iBAAd,CAAgC5B,KAAhC,EAAuC,GAAvC,EAA4CZ,SAA5C,CAAvB;AACAc,sBAAkByB,gBAAlB;AACA,QAAIA,gDAAJ,EAA+C;AAC7C,UAAIE,6BAA6B7B,MAAM8B,kCAAN,CAAyCH,gBAAzC,CAAjC;AACA,UAAI,CAACE,2BAA2Bb,MAA3B,CAAkCW,gBAAlC,CAAL,EAA0DzB,kBAAkB2B,0BAAlB;AAC3D;AACF;AACF;;AAED,SAAS1B,qBAAT,CAA+BH,KAA/B,EAA6C+B,mBAA7C,EAA8F;AAC5F,MAAIC,oBAAoBD,oBAAoBE,GAApB,CAAwBC,KAAKlC,MAAM8B,kCAAN,CAAyCI,CAAzC,CAA7B,CAAxB;AACA,MAAIF,kBAAkBG,IAAlB,CAAuBD,KAAK,CAACA,EAAErC,eAAF,EAA7B,CAAJ,EAAuD,MAAM,iCAAN;AACvD,MAAIuC,KAAKpC,MAAMR,cAAf;AACAQ,QAAMR,cAAN,GAAuB,EAAvB;AACA,OAAK,IAAI0C,CAAT,IAAcF,iBAAd,EAAiC9B,kBAAkBgC,CAAlB;AACjC,OAAK,IAAIA,CAAT,IAAcE,EAAd,EAAkBpC,MAAMR,cAAN,CAAqByB,IAArB,CAA0BiB,CAA1B;AACnB","file":"paths.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { AbstractValue, ConcreteValue, NullValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { InfeasiblePathError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\n\nexport class PathImplementation {\n  implies(condition: Value): boolean {\n    if (!condition.mightNotBeTrue()) return true; // any path implies true\n    let path = condition.$Realm.pathConditions;\n    for (let i = path.length - 1; i >= 0; i--) {\n      let pathCondition = path[i];\n      if (pathCondition.implies(condition)) return true;\n    }\n    return false;\n  }\n\n  impliesNot(condition: Value): boolean {\n    if (!condition.mightNotBeFalse()) return true; // any path implies !false\n    let path = condition.$Realm.pathConditions;\n    for (let i = path.length - 1; i >= 0; i--) {\n      let pathCondition = path[i];\n      if (pathCondition.impliesNot(condition)) return true;\n    }\n    return false;\n  }\n\n  withCondition<T>(condition: Value, evaluate: () => T): T {\n    if (!condition.mightNotBeFalse()) throw new InfeasiblePathError();\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n    try {\n      pushPathCondition(condition);\n      pushRefinedConditions(realm, savedPath);\n      return evaluate();\n    } catch (e) {\n      if (e instanceof InfeasiblePathError) {\n        // if condition is true, one of the saved path conditions must be false\n        // since we have to assume that those conditions are true we now know that on this path, condition is false\n        realm.pathConditions = savedPath;\n        pushInversePathCondition(condition);\n      }\n      throw e;\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  withInverseCondition<T>(condition: Value, evaluate: () => T): T {\n    if (!condition.mightNotBeTrue()) throw new InfeasiblePathError();\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n    try {\n      pushInversePathCondition(condition);\n      pushRefinedConditions(realm, savedPath);\n      return evaluate();\n    } catch (e) {\n      if (e instanceof InfeasiblePathError) {\n        // if condition is false, one of the saved path conditions must be false\n        // since we have to assume that those conditions are true we now know that on this path, condition is true\n        realm.pathConditions = savedPath;\n        pushPathCondition(condition);\n      }\n      throw e;\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  pushAndRefine(condition: Value): void {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n\n    pushPathCondition(condition);\n    pushRefinedConditions(realm, savedPath);\n  }\n\n  pushInverseAndRefine(condition: Value): void {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = [];\n\n    pushInversePathCondition(condition);\n    pushRefinedConditions(realm, savedPath);\n  }\n}\n\n// A path condition is an abstract value that must be true in this particular code path, so we want to assume as much\nfunction pushPathCondition(condition: Value): void {\n  invariant(condition.mightNotBeFalse(), \"pushing false\"); // it is mistake to assume that false is true\n  if (condition instanceof ConcreteValue) return;\n  if (!condition.mightNotBeTrue()) return;\n  invariant(condition instanceof AbstractValue);\n  let realm = condition.$Realm;\n  if (condition.kind === \"&&\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushPathCondition(left);\n    pushPathCondition(right);\n  } else if (condition.kind === \"===\") {\n    let [left, right] = condition.args;\n    if (right instanceof AbstractValue && right.kind === \"conditional\") [left, right] === [right, left];\n    if (left instanceof AbstractValue && left.kind === \"conditional\") {\n      let [cond, x, y] = left.args;\n      if (right instanceof ConcreteValue && x instanceof ConcreteValue && y instanceof ConcreteValue) {\n        if (right.equals(x) && !right.equals(y)) {\n          pushPathCondition(cond);\n        } else if (!right.equals(x) && right.equals(y)) {\n          pushInversePathCondition(cond);\n        }\n      }\n    }\n    realm.pathConditions.push(condition);\n  } else {\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"!==\" : \"===\";\n        if (op === \"!==\") pushPathCondition(left);\n        else pushInversePathCondition(left);\n        let leftNeNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftNeNull.mightNotBeFalse()) pushPathCondition(leftNeNull);\n        let leftNeUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftNeUndefined.mightNotBeFalse()) pushPathCondition(leftNeUndefined);\n        return;\n      }\n    }\n    realm.pathConditions.push(condition);\n  }\n}\n\n// An inverse path condition is an abstract value that must be false in this particular code path, so we want to assume as much\nfunction pushInversePathCondition(condition: Value): void {\n  // it is mistake to assume that true is false.\n  invariant(condition.mightNotBeTrue());\n  if (condition instanceof ConcreteValue) return;\n  invariant(condition instanceof AbstractValue);\n  if (condition.kind === \"||\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushInversePathCondition(left);\n    if (right.mightNotBeTrue()) pushInversePathCondition(right);\n  } else {\n    let realm = condition.$Realm;\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"===\" : \"!==\";\n        if (op === \"!==\") pushPathCondition(left);\n        else pushInversePathCondition(left);\n        let leftEqNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftEqNull.mightNotBeFalse()) pushPathCondition(leftEqNull);\n        let leftEqUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftEqUndefined.mightNotBeFalse()) pushPathCondition(leftEqUndefined);\n        return;\n      }\n    }\n    let inverseCondition = AbstractValue.createFromUnaryOp(realm, \"!\", condition);\n    pushPathCondition(inverseCondition);\n    if (inverseCondition instanceof AbstractValue) {\n      let simplifiedInverseCondition = realm.simplifyAndRefineAbstractCondition(inverseCondition);\n      if (!simplifiedInverseCondition.equals(inverseCondition)) pushPathCondition(simplifiedInverseCondition);\n    }\n  }\n}\n\nfunction pushRefinedConditions(realm: Realm, unrefinedConditions: Array<AbstractValue>): void {\n  let refinedConditions = unrefinedConditions.map(c => realm.simplifyAndRefineAbstractCondition(c));\n  if (refinedConditions.some(c => !c.mightNotBeFalse())) throw new InfeasiblePathError();\n  let pc = realm.pathConditions;\n  realm.pathConditions = [];\n  for (let c of refinedConditions) pushPathCondition(c);\n  for (let c of pc) realm.pathConditions.push(c);\n}\n"]}