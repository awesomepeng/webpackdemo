{"version":3,"sources":["../../src/methods/environment.js"],"names":["t","EnvironmentImplementation","RestBindingInitialization","realm","property","value","excludedNames","strictCode","environment","BindingIdentifier","argument","restObj","ObjectCreate","intrinsics","ObjectPrototype","CopyDataProperties","bindingId","name","lhs","ResolveBinding","undefined","PutValue","InitializeReferencedBinding","PropertyBindingInitialization","properties","length","BindingProperty","slice","BindingPropertyList","boundNames","nextNames","env","getRunningContext","lexicalEnvironment","P","KeyedBindingInitialization","concat","IsSuperReference","V","thisValue","HasPrimitiveBase","base","GetBase","type","getType","GetReferencedName","referencedName","reportIntrospectionError","GetReferencedNamePartial","GetValue","val","_dereference","simplifyAndRefineAbstractValue","GetConditionValue","simplifyAndRefineAbstractCondition","IsUnresolvableReference","createErrorThrowCompletion","ReferenceError","toString","IsPropertyReference","ToObject","$GetPartial","GetBindingValue","IsStrictReference","strict","NewDeclarativeEnvironment","E","active","activeLexicalEnvironments","add","envRec","environmentRecord","parent","BoundNames","node","Object","keys","getOuterBindingIdentifiers","ContainsExpression","prop","elem","elements","GetIdentifierReference","lex","exists","HasBinding","outer","W","InitializeBinding","BlockDeclarationInstantiation","body","declarations","kind","push","d","dn","SyntaxError","CreateImmutableBinding","CreateMutableBinding","fn","fo","evaluate","NewGlobalEnvironment","G","objRec","dclRec","globalRec","$ObjectRecord","$GlobalThisValue","$DeclarativeRecord","$VarNames","NewObjectEnvironment","O","NewFunctionEnvironment","F","newTarget","$FunctionObject","$ThisMode","$ThisBindingStatus","home","$HomeObject","$NewTarget","$Environment","GetActiveScriptOrModule","contextStack","ec","i","function","$ScriptOrModule","ScriptOrModule","GetThisEnvironment","HasThisBinding","ResolveThisBinding","GetThisBinding","BindingInitialization","iterator","iteratorRecord","$Iterator","$Done","result","IteratorBindingInitialization","error","completion","BindingRestProperty","empty","InitializeBoundName","decl","id","formals","restEl","lastFormal","param","next","e","Initializer","right","left","v","defaultValue","hasNameProperty","SetFunctionName","A","ArrayCreate","n","nextValue","status","CreateDataProperty","IsDestructuring","ast","propertyName"],"mappings":"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","file":"environment.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport * as t from \"babel-types\";\nimport invariant from \"../invariant.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractValue,\n  UndefinedValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  BooleanValue,\n  SymbolValue,\n  ECMAScriptFunctionValue,\n  ObjectValue,\n  StringValue,\n  Value,\n  AbstractObjectValue,\n} from \"../values/index.js\";\nimport {\n  ObjectEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  GlobalEnvironmentRecord,\n  Reference,\n  LexicalEnvironment,\n} from \"../environment.js\";\nimport { AbruptCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  GetV,\n  GetThisValue,\n  HasSomeCompatibleType,\n  GetIterator,\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n  RequireObjectCoercible,\n} from \"./index.js\";\nimport { Create, Functions, Properties, To } from \"../singletons.js\";\nimport type {\n  BabelNode,\n  BabelNodeVariableDeclaration,\n  BabelNodeIdentifier,\n  BabelNodeRestElement,\n  BabelNodeRestProperty,\n  BabelNodeObjectProperty,\n  BabelNodeObjectPattern,\n  BabelNodeArrayPattern,\n  BabelNodeStatement,\n  BabelNodeLVal,\n  BabelNodePattern,\n} from \"babel-types\";\n\nexport class EnvironmentImplementation {\n  // 2.6 RestBindingInitialization (please suggest an appropriate section name)\n  RestBindingInitialization(\n    realm: Realm,\n    property: BabelNodeRestProperty,\n    value: Value,\n    excludedNames: Array<PropertyKeyValue>,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment\n  ): void | boolean | Value {\n    let BindingIdentifier = ((property.argument: any): BabelNodeIdentifier);\n\n    // 1. Let restObj be ObjectCreate(%ObjectPrototype%).\n    let restObj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 2. Let assignStatus be CopyDataProperties(restObj, value, excludedNames).\n    /* let assignStatus = */ Create.CopyDataProperties(realm, restObj, value, excludedNames);\n\n    // 3. ReturnIfAbrupt(assignStatus).\n\n    // 4. Let bindingId be StringValue of BindingIdentifier.\n    let bindingId = BindingIdentifier.name;\n\n    // 5. Let lhs be ResolveBinding(bindingId, environment).\n    let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment);\n\n    // 6. ReturnIfAbrupt(lhs).\n\n    // 7. If environment is undefined, return PutValue(lhs, restObj).\n    if (environment === undefined) {\n      return Properties.PutValue(realm, lhs, restObj);\n    }\n\n    // 8. Return InitializeReferencedBinding(lhs, restObj).\n    return this.InitializeReferencedBinding(realm, lhs, restObj);\n  }\n\n  // 2.5  PropertyBindingInitialization (please suggest an appropriate section name)\n  PropertyBindingInitialization(\n    realm: Realm,\n    properties: Array<BabelNodeObjectProperty>,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment\n  ): Array<PropertyKeyValue> {\n    // Base condition for recursive call below\n    if (properties.length === 0) {\n      return [];\n    }\n\n    let BindingProperty = properties.slice(-1)[0];\n    let BindingPropertyList = properties.slice(0, -1);\n\n    // 1. Let boundNames be the result of performing PropertyBindingInitialization for BindingPropertyList using value and environment as arguments.\n    let boundNames = this.PropertyBindingInitialization(realm, BindingPropertyList, value, strictCode, environment);\n\n    // 2. ReturnIfAbrupt(status boundNames).\n\n    // 3. Let nextNames be the result of performing PropertyBindingInitialization for BindingProperty using value and environment as arguments.\n    let nextNames;\n\n    // SingleNameBinding\n    // PropertyName : BindingElement\n    // 1. Let P be the result of evaluating PropertyName.\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n    let P = EvalPropertyName(BindingProperty, env, realm, strictCode);\n    // 2. ReturnIfAbrupt(P).\n\n    // 3. Let status be the result of performing KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.\n    /* let status = */ this.KeyedBindingInitialization(\n      realm,\n      ((BindingProperty.value: any): BabelNodeIdentifier | BabelNodePattern),\n      value,\n      strictCode,\n      environment,\n      P\n    );\n\n    // 4. ReturnIfAbrupt(status).\n\n    // 5. Return a new List containing P.\n    nextNames = [P];\n\n    // 4. ReturnIfAbrupt(nextNames).\n\n    // 5. Append each item in nextNames to the end of boundNames.\n    boundNames = boundNames.concat(nextNames);\n\n    return boundNames;\n  }\n\n  // ECMA262 6.2.3\n  // IsSuperReference(V). Returns true if this reference has a thisValue component.\n  IsSuperReference(realm: Realm, V: Reference): boolean {\n    return V.thisValue !== undefined;\n  }\n\n  // ECMA262 6.2.3\n  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\n  HasPrimitiveBase(realm: Realm, V: Reference): boolean {\n    let base = this.GetBase(realm, V);\n    // void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord | AbstractValue;\n    if (!base || base instanceof EnvironmentRecord) return false;\n    let type = base.getType();\n    return (\n      type === BooleanValue ||\n      type === StringValue ||\n      type === SymbolValue ||\n      type === NumberValue ||\n      type === IntegralValue\n    );\n  }\n\n  // ECMA262 6.2.3\n  // GetReferencedName(V). Returns the referenced name component of the reference V.\n  GetReferencedName(realm: Realm, V: Reference): string | SymbolValue {\n    if (V.referencedName instanceof AbstractValue) {\n      AbstractValue.reportIntrospectionError(V.referencedName);\n      throw new FatalError();\n    }\n    return V.referencedName;\n  }\n\n  GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue {\n    return V.referencedName;\n  }\n\n  // ECMA262 6.2.3.1\n  GetValue(realm: Realm, V: Reference | Value): Value {\n    let val = this._dereference(realm, V);\n    if (val instanceof AbstractValue) return realm.simplifyAndRefineAbstractValue(val);\n    return val;\n  }\n\n  GetConditionValue(realm: Realm, V: Reference | Value): Value {\n    let val = this._dereference(realm, V);\n    if (val instanceof AbstractValue) return realm.simplifyAndRefineAbstractCondition(val);\n    return val;\n  }\n\n  _dereference(realm: Realm, V: Reference | Value): Value {\n    // This step is not necessary as we propagate completions with exceptions.\n    // 1. ReturnIfAbrupt(V).\n\n    // 2. If Type(V) is not Reference, return V.\n    if (!(V instanceof Reference)) return V;\n\n    // 3. Let base be GetBase(V).\n    let base = this.GetBase(realm, V);\n\n    // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.\n    if (this.IsUnresolvableReference(realm, V)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.ReferenceError,\n        `${V.referencedName.toString()} is not defined`\n      );\n    }\n\n    // 5. If IsPropertyReference(V) is true, then\n    if (this.IsPropertyReference(realm, V)) {\n      if (base instanceof AbstractValue) {\n        // Ensure that abstract values are coerced to objects. This might yield\n        // an operation that might throw.\n        base = To.ToObject(realm, base);\n      }\n      // a. If HasPrimitiveBase(V) is true, then\n      if (this.HasPrimitiveBase(realm, V)) {\n        // i. Assert: In this case, base will never be null or undefined.\n        invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n        // ii. Let base be To.ToObject(base).\n        base = To.ToObject(realm, base);\n      }\n      invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n      // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).\n      return base.$GetPartial(this.GetReferencedNamePartial(realm, V), GetThisValue(realm, V));\n    }\n\n    // 6. Else base must be an Environment Record,\n    if (base instanceof EnvironmentRecord) {\n      // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).\n      let referencedName = this.GetReferencedName(realm, V);\n      invariant(typeof referencedName === \"string\");\n      return base.GetBindingValue(referencedName, this.IsStrictReference(realm, V));\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 6.2.3\n  // IsStrictReference(V). Returns the strict reference flag component of the reference V.\n  IsStrictReference(realm: Realm, V: Reference): boolean {\n    return V.strict;\n  }\n\n  // ECMA262 6.2.3\n  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\n  IsPropertyReference(realm: Realm, V: Reference): boolean {\n    // V.base is AbstractValue | void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\n    return V.base instanceof AbstractValue || V.base instanceof ObjectValue || this.HasPrimitiveBase(realm, V);\n  }\n\n  // ECMA262 6.2.3\n  // GetBase(V). Returns the base value component of the reference V.\n  GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord {\n    return V.base;\n  }\n\n  // ECMA262 6.2.3\n  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\n  IsUnresolvableReference(realm: Realm, V: Reference): boolean {\n    return !V.base;\n  }\n\n  // ECMA262 8.1.2.2\n  NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment, active: boolean = true): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    if (active) realm.activeLexicalEnvironments.add(env);\n\n    // 2. Let envRec be a new declarative Environment Record containing no bindings.\n    let envRec = new DeclarativeEnvironmentRecord(realm);\n\n    // 3. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 4. Set the outer lexical environment reference of env to E.\n    env.parent = E;\n\n    // 5. Return env.\n    return env;\n  }\n\n  BoundNames(realm: Realm, node: BabelNode): Array<string> {\n    return Object.keys(t.getOuterBindingIdentifiers(node));\n  }\n\n  // ECMA262 13.3.3.2\n  ContainsExpression(realm: Realm, node: ?BabelNode): boolean {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case \"ObjectPattern\":\n        for (let prop of ((node: any): BabelNodeObjectPattern).properties) {\n          if (this.ContainsExpression(realm, prop)) return true;\n        }\n        return false;\n      case \"ArrayPattern\":\n        for (let elem of ((node: any): BabelNodeArrayPattern).elements) {\n          if (this.ContainsExpression(realm, elem)) return true;\n        }\n        return false;\n      case \"RestElement\":\n        return this.ContainsExpression(realm, ((node: any): BabelNodeRestElement).argument);\n      case \"AssignmentPattern\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ECMA262 8.3.2\n  ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference {\n    // 1. If env was not passed or if env is undefined, then\n    if (!env) {\n      // a. Let env be the running execution context's LexicalEnvironment.\n      env = realm.getRunningContext().lexicalEnvironment;\n    }\n\n    // 2. Assert: env is a Lexical Environment.\n    invariant(env instanceof LexicalEnvironment, \"expected lexical environment\");\n\n    // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.\n\n    // 4. Return ? GetIdentifierReference(env, name, strict).\n    return this.GetIdentifierReference(realm, env, name, strict);\n  }\n\n  // ECMA262 8.1.2.1\n  GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference {\n    // 1. If lex is the value null, then\n    if (!lex) {\n      // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.\n      return new Reference(undefined, name, strict);\n    }\n\n    // 2. Let envRec be lex's EnvironmentRecord.\n    let envRec = lex.environmentRecord;\n\n    // 3. Let exists be ? envRec.HasBinding(name).\n    let exists = envRec.HasBinding(name);\n\n    // 4. If exists is true, then\n    if (exists) {\n      // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.\n      return new Reference(envRec, name, strict);\n    } else {\n      // 5. Else,\n      // a. Let outer be the value of lex's outer environment reference.\n      let outer = lex.parent;\n\n      // b. Return ? GetIdentifierReference(outer, name, strict).\n      return this.GetIdentifierReference(realm, outer, name, strict);\n    }\n  }\n\n  // ECMA262 6.2.3.4\n  InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value {\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n\n    // 3. Assert: Type(V) is Reference.\n    invariant(V instanceof Reference, \"expected reference\");\n\n    // 4. Assert: IsUnresolvableReference(V) is false.\n    invariant(!this.IsUnresolvableReference(realm, V), \"expected resolvable reference\");\n\n    // 5. Let base be GetBase(V).\n    let base = this.GetBase(realm, V);\n\n    // 6. Assert: base is an Environment Record.\n    invariant(base instanceof EnvironmentRecord, \"expected environment record\");\n\n    // 7. Return base.InitializeBinding(GetReferencedName(V), W).\n    let referencedName = this.GetReferencedName(realm, V);\n    invariant(typeof referencedName === \"string\");\n    return base.InitializeBinding(referencedName, W);\n  }\n\n  // ECMA262 13.2.14\n  BlockDeclarationInstantiation(\n    realm: Realm,\n    strictCode: boolean,\n    body: Array<BabelNodeStatement>,\n    env: LexicalEnvironment\n  ): void {\n    // 1. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 2. Assert: envRec is a declarative Environment Record.\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n\n    // 3. Let declarations be the LexicallyScopedDeclarations of code.\n    let declarations = [];\n    for (let node of body) {\n      if (\n        node.type === \"ClassDeclaration\" ||\n        node.type === \"FunctionDeclaration\" ||\n        (node.type === \"VariableDeclaration\" && node.kind !== \"var\")\n      ) {\n        declarations.push(node);\n      }\n    }\n\n    // 4. For each element d in declarations do\n    for (let d of declarations) {\n      // a. For each element dn of the BoundNames of d do\n      for (let dn of this.BoundNames(realm, d)) {\n        if (envRec.HasBinding(dn)) {\n          //ECMA262 13.2.1\n          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, dn + \" already declared\");\n        }\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.type === \"VariableDeclaration\" && d.kind === \"const\") {\n          // 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n          envRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! envRec.CreateMutableBinding(dn, false).\n          envRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then\n      if (d.type === \"FunctionDeclaration\") {\n        // i. Let fn be the sole element of the BoundNames of d.\n        let fn = this.BoundNames(realm, d)[0];\n\n        // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n        let fo = env.evaluate(d, strictCode);\n        invariant(fo instanceof Value);\n\n        // iii. Perform envRec.InitializeBinding(fn, fo).\n        envRec.InitializeBinding(fn, fo);\n      }\n    }\n  }\n\n  // ECMA262 8.1.2.5\n  NewGlobalEnvironment(\n    realm: Realm,\n    G: ObjectValue | AbstractObjectValue,\n    thisValue: ObjectValue | AbstractObjectValue\n  ): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n\n    // 2. Let objRec be a new object Environment Record containing G as the binding object.\n    let objRec = new ObjectEnvironmentRecord(realm, G);\n\n    // 3. Let dclRec be a new declarative Environment Record containing no bindings.\n    let dclRec = new DeclarativeEnvironmentRecord(realm);\n\n    // 4. Let globalRec be a new global Environment Record.\n    let globalRec = new GlobalEnvironmentRecord(realm);\n\n    // 5. Set globalRec.[[ObjectRecord]] to objRec.\n    globalRec.$ObjectRecord = objRec;\n\n    // 6. Set globalRec.[[GlobalThisValue]] to thisValue.\n    globalRec.$GlobalThisValue = thisValue;\n\n    // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.\n    globalRec.$DeclarativeRecord = dclRec;\n\n    // 8. Set globalRec.[[VarNames]] to a new empty List.\n    globalRec.$VarNames = [];\n\n    // 9. Set env's EnvironmentRecord to globalRec.\n    env.environmentRecord = globalRec;\n    realm.activeLexicalEnvironments.add(env);\n\n    // 10. Set the outer lexical environment reference of env to null.\n    env.parent = null;\n\n    // 11. Return env.\n    return env;\n  }\n\n  // ECMA262 8.1.2.3\n  NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    realm.activeLexicalEnvironments.add(env);\n\n    // 2. Let envRec be a new object Environment Record containing O as the binding object.\n    let envRec = new ObjectEnvironmentRecord(realm, O);\n\n    // 3. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 4. Set the outer lexical environment reference of env to E.\n    env.parent = E;\n\n    // 5. Return env.\n    return env;\n  }\n\n  // ECMA262 8.1.2.4\n  NewFunctionEnvironment(realm: Realm, F: ECMAScriptFunctionValue, newTarget?: ObjectValue): LexicalEnvironment {\n    // 1. Assert: F is an ECMAScript function.\n    invariant(F instanceof ECMAScriptFunctionValue, \"expected a function\");\n\n    // 2. Assert: Type(newTarget) is Undefined or Object.\n    invariant(\n      newTarget === undefined || newTarget instanceof ObjectValue,\n      \"expected undefined or object value for new target\"\n    );\n\n    // 3. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    realm.activeLexicalEnvironments.add(env);\n\n    // 4. Let envRec be a new function Environment Record containing no bindings.\n    let envRec = new FunctionEnvironmentRecord(realm);\n\n    // 5. Set envRec.[[FunctionObject]] to F.\n    envRec.$FunctionObject = F;\n\n    // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to \"lexical\".\n    if (F.$ThisMode === \"lexical\") {\n      envRec.$ThisBindingStatus = \"lexical\";\n    } else {\n      // 7. Else, set envRec.[[ThisBindingStatus]] to \"uninitialized\".\n      envRec.$ThisBindingStatus = \"uninitialized\";\n    }\n\n    // 8. Let home be the value of F's [[HomeObject]] internal slot.\n    let home = F.$HomeObject;\n\n    // 9. Set envRec.[[HomeObject]] to home.\n    envRec.$HomeObject = home;\n\n    // 10. Set envRec.[[NewTarget]] to newTarget.\n    envRec.$NewTarget = newTarget;\n\n    // 11. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.\n    env.parent = F.$Environment;\n\n    // 13. Return env.\n    return env;\n  }\n\n  // ECMA262 8.3.1\n  GetActiveScriptOrModule(realm: Realm): any {\n    // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.\n    // GetActiveScriptOrModule performs the following steps:\n    //\n    // If the execution context stack is empty, return null.\n    if (realm.contextStack.length === 0) return null;\n    // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.\n    // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.\n    let ec;\n    for (let i = realm.contextStack.length - 1; i >= 0; i--) {\n      ec = realm.contextStack[i];\n      let F = ec.function;\n      if (F == null) continue;\n      if (F.$ScriptOrModule instanceof Object) {\n        return F.$ScriptOrModule;\n      }\n    }\n    // Otherwise, let ec be the running execution context.\n    ec = realm.getRunningContext();\n    // Assert: ec's ScriptOrModule component is not null.\n    invariant(ec.ScriptOrModule !== null);\n    // Return ec's ScriptOrModule component.\n    return ec.ScriptOrModule;\n  }\n\n  // ECMA262 8.3.3\n  GetThisEnvironment(realm: Realm): EnvironmentRecord {\n    // 1. Let lex be the running execution context's LexicalEnvironment.\n    let lex = realm.getRunningContext().lexicalEnvironment;\n\n    // 2. Repeat\n    while (true) {\n      // a. Let envRec be lex's EnvironmentRecord.\n      let envRec = lex.environmentRecord;\n\n      // b. Let exists be envRec.HasThisBinding().\n      let exists = envRec.HasThisBinding();\n\n      // c. If exists is true, return envRec.\n      if (exists) return envRec;\n\n      // d. Let outer be the value of lex's outer environment reference.\n      let outer = lex.parent;\n      invariant(outer);\n\n      // e. Let lex be outer.\n      lex = outer;\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 8.3.4\n  ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be GetThisEnvironment( ).\n    let envRec = this.GetThisEnvironment(realm);\n\n    // 2. Return ? envRec.GetThisBinding().\n    return envRec.GetThisBinding();\n  }\n\n  BindingInitialization(\n    realm: Realm,\n    node: BabelNodeLVal | BabelNodeVariableDeclaration,\n    value: Value,\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value {\n    if (node.type === \"ArrayPattern\") {\n      // ECMA262 13.3.3.5\n      // 1. Let iterator be ? GetIterator(value).\n      let iterator = GetIterator(realm, value);\n\n      // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n      let iteratorRecord = {\n        $Iterator: iterator,\n        $Done: false,\n      };\n\n      let result;\n\n      // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.\n      try {\n        result = this.IteratorBindingInitialization(realm, node.elements, iteratorRecord, strictCode, environment);\n      } catch (error) {\n        // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n        if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n          throw IteratorClose(realm, iterator, error);\n        }\n        throw error;\n      }\n\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false) {\n        let completion = IteratorClose(realm, iterator, new SimpleNormalCompletion(realm.intrinsics.undefined));\n        if (completion instanceof AbruptCompletion) {\n          throw completion;\n        }\n      }\n\n      // 5. Return result.\n      return result;\n    } else if (node.type === \"ObjectPattern\") {\n      RequireObjectCoercible(realm, value);\n\n      let BindingPropertyList = [],\n        BindingRestProperty = null;\n\n      for (let property of node.properties) {\n        if (property.type === \"RestProperty\") {\n          BindingRestProperty = property;\n        } else {\n          BindingPropertyList.push(property);\n        }\n      }\n\n      // ObjectBindingPattern:\n      //   { BindingPropertyList }\n      //   { BindingPropertyList, }\n\n      if (!BindingRestProperty) {\n        // 1. Let excludedNames be the result of performing PropertyBindingInitialization for BindingPropertyList using value and environment as the argument.\n        /* let excludedNames = */ this.PropertyBindingInitialization(\n          realm,\n          BindingPropertyList,\n          value,\n          strictCode,\n          environment\n        );\n\n        // 2. ReturnIfAbrupt(excludedNames).\n\n        // 3. Return NormalCompletion(empty).\n        return realm.intrinsics.empty;\n      }\n\n      // ObjectBindingPattern : { BindingRestProperty }\n      if (BindingPropertyList.length === 0) {\n        // 1. Let excludedNames be a new empty List.\n        let excludedNames = [];\n\n        // 2. Return the result of performing RestBindingInitialization of BindingRestProperty with value, environment and excludedNames as the arguments.\n        return this.RestBindingInitialization(\n          realm,\n          BindingRestProperty,\n          value,\n          excludedNames,\n          strictCode,\n          environment\n        );\n      } else {\n        // ObjectBindingPattern : { BindingPropertyList, BindingRestProperty }\n\n        // 1. Let excludedNames be the result of performing PropertyBindingInitialization of BindingPropertyList using value and environment as arguments.\n        let excludedNames = this.PropertyBindingInitialization(\n          realm,\n          BindingPropertyList,\n          value,\n          strictCode,\n          environment\n        );\n\n        // 2. ReturnIfAbrupt(excludedNames).\n\n        // 3. Return the result of performing RestBindingInitialization of BindingRestProperty with value, environment and excludedNames as the arguments.\n        return this.RestBindingInitialization(\n          realm,\n          BindingRestProperty,\n          value,\n          excludedNames,\n          strictCode,\n          environment\n        );\n      }\n    } else if (node.type === \"Identifier\") {\n      // ECMA262 12.1.5\n      // 1. Let name be StringValue of Identifier.\n      let name = ((node: any): BabelNodeIdentifier).name;\n\n      // 2. Return ? InitializeBoundName(name, value, environment).\n      return this.InitializeBoundName(realm, name, value, environment);\n    } else {\n      invariant(node.type === \"VariableDeclaration\");\n      // ECMA262 13.7.5.9\n      for (let decl of ((node: any): BabelNodeVariableDeclaration).declarations) {\n        this.BindingInitialization(realm, decl.id, value, strictCode, environment);\n      }\n    }\n  }\n\n  // ECMA262 13.3.3.6\n  // ECMA262 14.1.19\n  IteratorBindingInitialization(\n    realm: Realm,\n    formals: $ReadOnlyArray<BabelNodeLVal | null>,\n    iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void {\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n    // Check if the last formal is a rest element. If so then we want to save the\n    // element and handle it separately after we iterate through the other\n    // formals. This also enforces that a rest element may only ever be in the\n    // last position.\n    let restEl;\n    if (formals.length > 0) {\n      let lastFormal = formals[formals.length - 1];\n      if (lastFormal !== null && lastFormal.type === \"RestElement\") {\n        restEl = lastFormal;\n        formals = formals.slice(0, -1);\n      }\n    }\n\n    for (let param of formals) {\n      if (param === null) {\n        // Elision handling in IteratorDestructuringAssignmentEvaluation\n\n        // 1. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n        // 2. Return NormalCompletion(empty).\n        continue;\n      }\n\n      let Initializer;\n      if (param.type === \"AssignmentPattern\") {\n        Initializer = param.right;\n        param = param.left;\n      }\n\n      if (param.type === \"Identifier\") {\n        // SingleNameBinding : BindingIdentifier Initializer\n\n        // 1. Let bindingId be StringValue of BindingIdentifier.\n        let bindingId = param.name;\n\n        // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n        let lhs = this.ResolveBinding(realm, param.name, strictCode, environment);\n\n        // Initialized later in the algorithm.\n        let v;\n\n        // 3. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next: ObjectValue | false;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n            // Normally this assignment would be done in step 4, but we do it\n            // here so that Flow knows `v` will always be initialized by step 5.\n            v = realm.intrinsics.undefined;\n          } else {\n            // e. Else,\n            // i. Let v be IteratorValue(next).\n            try {\n              v = IteratorValue(realm, next);\n            } catch (e) {\n              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n              if (e instanceof AbruptCompletion) {\n                iteratorRecord.$Done = true;\n              }\n              // iii. ReturnIfAbrupt(v).\n              throw e;\n            }\n          }\n        } else {\n          // 4. If iteratorRecord.[[Done]] is true, let v be undefined.\n          v = realm.intrinsics.undefined;\n        }\n\n        // 5. If Initializer is present and v is undefined, then\n        if (Initializer && v instanceof UndefinedValue) {\n          // a. Let defaultValue be the result of evaluating Initializer.\n          let defaultValue = env.evaluate(Initializer, strictCode);\n\n          // b. Let v be ? GetValue(defaultValue).\n          v = this.GetValue(realm, defaultValue);\n\n          // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n          if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n            // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n            let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n            // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n            if (hasNameProperty === false) {\n              Functions.SetFunctionName(realm, v, bindingId);\n            }\n          }\n        }\n\n        // 6. If environment is undefined, return ? PutValue(lhs, v).\n        if (!environment) {\n          Properties.PutValue(realm, lhs, v);\n          continue;\n        }\n\n        // 7. Return InitializeReferencedBinding(lhs, v).\n        this.InitializeReferencedBinding(realm, lhs, v);\n        continue;\n      } else {\n        invariant(param.type === \"ObjectPattern\" || param.type === \"ArrayPattern\");\n        // BindingElement : BindingPatternInitializer\n\n        // Initialized later in the algorithm.\n        let v;\n\n        // 1. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n            // Normally this assignment would be done in step 2, but we do it\n            // here so that Flow knows `v` will always be initialized by step 3.\n            v = realm.intrinsics.undefined;\n          } else {\n            // e. Else,\n            // i. Let v be IteratorValue(next).\n            try {\n              v = IteratorValue(realm, next);\n            } catch (e) {\n              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n              if (e instanceof AbruptCompletion) {\n                iteratorRecord.$Done = true;\n              }\n              // iii. ReturnIfAbrupt(v).\n              throw e;\n            }\n          }\n        } else {\n          // 2. If iteratorRecord.[[Done]] is true, let v be undefined.\n          v = realm.intrinsics.undefined;\n        }\n\n        // 3. If Initializer is present and v is undefined, then\n        if (Initializer && v instanceof UndefinedValue) {\n          // a. Let defaultValue be the result of evaluating Initializer.\n          let defaultValue = env.evaluate(Initializer, strictCode);\n\n          // b. Let v be ? GetValue(defaultValue).\n          v = this.GetValue(realm, defaultValue);\n        }\n\n        // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.\n        this.BindingInitialization(realm, param, v, strictCode, environment);\n        continue;\n      }\n    }\n\n    // Handle the rest element if we have one.\n    if (restEl && restEl.argument.type === \"Identifier\") {\n      // BindingRestElement : ...BindingIdentifier\n\n      // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).\n      let lhs = this.ResolveBinding(realm, restEl.argument.name, strictCode, environment);\n\n      // 2. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // 3. Let n be 0.\n      let n = 0;\n\n      // 4. Repeat,\n      while (true) {\n        // Initialized later in the algorithm.\n        let next: ObjectValue | false;\n\n        // a. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // iv. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n\n        // b. If iteratorRecord.[[Done]] is true, then\n        if (iteratorRecord.$Done === true) {\n          // i. If environment is undefined, return ? PutValue(lhs, A).\n          if (!environment) {\n            Properties.PutValue(realm, lhs, A);\n            break;\n          }\n\n          // ii. Return InitializeReferencedBinding(lhs, A).\n          this.InitializeReferencedBinding(realm, lhs, A);\n          break;\n        }\n\n        // Given the nature of the algorithm this should always be true, however\n        // it is difficult to arrange the code in such a way where Flow's control\n        // flow analysis will pick that up, so we add an invariant here.\n        invariant(next instanceof ObjectValue);\n\n        // c. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // e. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // g. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // h. Increment n by 1.\n        n += 1;\n      }\n    } else if (restEl) {\n      invariant(restEl.argument.type === \"ArrayPattern\" || restEl.argument.type === \"ObjectPattern\");\n      // 1. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // 2. Let n be 0.\n      let n = 0;\n\n      // 3. Repeat,\n      while (true) {\n        // Initialized later in the algorithm.\n        let next;\n\n        // a. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // iv. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n\n        // b. If iteratorRecord.[[Done]] is true, then\n        if (iteratorRecord.$Done === true) {\n          // i. Return the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.\n          this.BindingInitialization(realm, restEl.argument, A, strictCode, environment);\n          break;\n        }\n\n        // Given the nature of the algorithm this should always be true, however\n        // it is difficult to arrange the code in such a way where Flow's control\n        // flow analysis will pick that up, so we add an invariant here.\n        invariant(next instanceof ObjectValue);\n\n        // c. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // e. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // g. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // h. Increment n by 1.\n        n += 1;\n      }\n    }\n  }\n\n  // ECMA262 12.1.5.1\n  InitializeBoundName(\n    realm: Realm,\n    name: string,\n    value: Value,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value {\n    // 1. Assert: Type(name) is String.\n    invariant(typeof name === \"string\", \"expected name to be a string\");\n\n    // 2. If environment is not undefined, then\n    if (environment) {\n      // a. Let env be the EnvironmentRecord component of environment.\n      let env = environment.environmentRecord;\n\n      // b. Perform env.InitializeBinding(name, value).\n      env.InitializeBinding(name, value);\n\n      // c. Return NormalCompletion(undefined).\n      return realm.intrinsics.undefined;\n    } else {\n      // 3. Else,\n      // a. Let lhs be ResolveBinding(name).\n      // Note that the undefined environment implies non-strict.\n      let lhs = this.ResolveBinding(realm, name, false);\n\n      // b. Return ? PutValue(lhs, value).\n      return Properties.PutValue(realm, lhs, value);\n    }\n  }\n\n  // ECMA262 12.3.1.3 and 13.7.5.6\n  IsDestructuring(ast: BabelNode): boolean {\n    switch (ast.type) {\n      case \"VariableDeclaration\":\n        for (let decl of ((ast: any): BabelNodeVariableDeclaration).declarations) {\n          switch (decl.type) {\n            case \"VariableDeclarator\":\n              switch (decl.id.type) {\n                case \"ArrayPattern\":\n                case \"AssignmentPattern\":\n                case \"ObjectPattern\":\n                  return true;\n                default:\n                  break;\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        return false;\n      case \"ArrayLiteral\":\n      case \"ObjectLiteral\":\n        return true;\n      case \"ArrayPattern\":\n      case \"ObjectPattern\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ECMA262 13.3.3.7\n  KeyedBindingInitialization(\n    realm: Realm,\n    node: BabelNodeIdentifier | BabelNodePattern,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment,\n    propertyName: PropertyKeyValue\n  ): void | boolean | Value {\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n    let Initializer;\n    if (node.type === \"AssignmentPattern\") {\n      Initializer = node.right;\n      node = node.left;\n    }\n\n    if (node.type === \"Identifier\") {\n      // SingleNameBinding : BindingIdentifier Initializer\n\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = node.name;\n\n      // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n      let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment);\n\n      // 3. Let v be ? GetV(value, propertyName).\n      let v = GetV(realm, value, propertyName);\n\n      // 4. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = this.GetValue(realm, defaultValue);\n\n        // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n        if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n          // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n          let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n          // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n          if (hasNameProperty === false) {\n            Functions.SetFunctionName(realm, v, bindingId);\n          }\n        }\n      }\n\n      // 5. If environment is undefined, return ? PutValue(lhs, v).\n      if (!environment) return Properties.PutValue(realm, lhs, v);\n\n      // 6. Return InitializeReferencedBinding(lhs, v).\n      return this.InitializeReferencedBinding(realm, lhs, v);\n    } else if (node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\") {\n      // BindingElement : BindingPattern Initializer\n\n      // 1. Let v be ? GetV(value, propertyName).\n      let v = GetV(realm, value, propertyName);\n\n      // 2. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = this.GetValue(realm, defaultValue);\n      }\n\n      // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.\n      return this.BindingInitialization(realm, node, v, strictCode, env);\n    }\n  }\n}\n"]}