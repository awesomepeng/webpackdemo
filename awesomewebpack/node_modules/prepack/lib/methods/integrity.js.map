{"version":3,"sources":["../../src/methods/integrity.js"],"names":["OrdinaryPreventExtensions","SetIntegrityLevel","TestIntegrityLevel","realm","O","mightBeHavocedObject","getExtensible","setExtensible","level","status","$PreventExtensions","keys","$OwnPropertyKeys","k","DefinePropertyOrThrow","configurable","currentDesc","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","value","desc","writable"],"mappings":";;;;;QAqBgBA,yB,GAAAA,yB;QAcAC,iB,GAAAA,iB;QA0DAC,kB,GAAAA,kB;;AAjFhB;;AACA;;AACA;;AACA;;AACA;;;;;;AAIA;AApBA;;;;;;;;;AASA;;AAYO,SAASF,yBAAT,CAAmCG,KAAnC,EAAiDC,CAAjD,EAA0E;AAC/E,MAAIA,EAAEC,oBAAF,MAA4BD,EAAEE,aAAF,EAAhC,EAAmD;AACjD;AACA,UAAM,wBAAN;AACD;;AAED;AACAF,IAAEG,aAAF,CAAgB,KAAhB;;AAEA;AACA,SAAO,IAAP;AACD;;AAED;AACO,SAASN,iBAAT,CAA2BE,KAA3B,EAAyCC,CAAzC,EAAyDI,KAAzD,EAA0F;AAC/F;AACA,2BAAUJ,+BAAV,EAAoC,oBAApC;;AAEA;AACA,2BAAUI,UAAU,QAAV,IAAsBA,UAAU,QAA1C,EAAoD,eAApD;;AAEA;AACA,MAAIC,SAASL,EAAEM,kBAAF,EAAb;;AAEA;AACA,MAAID,WAAW,KAAf,EAAsB,OAAO,KAAP;;AAEtB;AACA,MAAIE,OAAOP,EAAEQ,gBAAF,EAAX;;AAEA;AACA,MAAIJ,UAAU,QAAd,EAAwB;AACtB;AACA,SAAK,IAAIK,CAAT,IAAcF,IAAd,EAAoB;AAClB;AACA,6BAAWG,qBAAX,CAAiCX,KAAjC,EAAwCC,CAAxC,EAA2CS,CAA3C,EAA8C;AAC5CE,sBAAc;AAD8B,OAA9C;AAGD;AACF,GARD,MAQO,IAAIP,UAAU,QAAd,EAAwB;AAC7B;AACA;AACA,SAAK,IAAIK,CAAT,IAAcF,IAAd,EAAoB;AAClB;AACA,UAAIK,cAAcZ,EAAEa,eAAF,CAAkBJ,CAAlB,CAAlB;;AAEA;AACA,UAAIG,WAAJ,EAAiB;AACf,+BAAWE,2BAAX,CAAuCF,YAAYG,KAAnD;AACA,YAAIC,IAAJ;;AAEA;AACA,YAAI,kCAAqBjB,KAArB,EAA4Ba,WAA5B,CAAJ,EAA8C;AAC5C;AACAI,iBAAO,EAAEL,cAAc,KAAhB,EAAP;AACD,SAHD,MAGO;AACL;AACA;AACAK,iBAAO,EAAEL,cAAc,KAAhB,EAAuBM,UAAU,KAAjC,EAAP;AACD;;AAED;AACA,+BAAWP,qBAAX,CAAiCX,KAAjC,EAAwCC,CAAxC,EAA2CS,CAA3C,EAA8CO,IAA9C;AACD;AACF;AACF;;AAED;AACA,SAAO,IAAP;AACD;;AAED;AACO,SAASlB,kBAAT,CAA4BC,KAA5B,EAA0CC,CAA1C,EAA0DI,KAA1D,EAA2F;AAChG;AACA,2BAAUJ,+BAAV,EAAoC,oBAApC;;AAEA;AACA,2BAAUI,UAAU,QAAV,IAAsBA,UAAU,QAA1C,EAAoD,eAApD;;AAEA;AACA,MAAIC,SAAS,0BAAaN,KAAb,EAAoBC,CAApB,CAAb;;AAEA;AACA,MAAIK,WAAW,IAAf,EAAqB,OAAO,KAAP;;AAErB;;AAEA;AACA,MAAIE,OAAOP,EAAEQ,gBAAF,EAAX;;AAEA;AACA,OAAK,IAAIC,CAAT,IAAcF,IAAd,EAAoB;AAClB;AACA,QAAIK,cAAcZ,EAAEa,eAAF,CAAkBJ,CAAlB,CAAlB;;AAEA;AACA,QAAIG,WAAJ,EAAiB;AACf,6BAAWE,2BAAX,CAAuCF,YAAYG,KAAnD;;AAEA;AACA,UAAIH,YAAYD,YAAZ,KAA6B,IAAjC,EAAuC,OAAO,KAAP;;AAEvC;AACA,UAAIP,UAAU,QAAV,IAAsB,8BAAiBL,KAAjB,EAAwBa,WAAxB,MAAyC,IAAnE,EAAyE;AACvE;AACA,YAAIA,YAAYK,QAAZ,KAAyB,IAA7B,EAAmC,OAAO,KAAP;AACpC;AACF;AACF;;AAED;AACA,SAAO,IAAP;AACD","file":"integrity.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport { ObjectValue } from \"../values/index.js\";\nimport { IsExtensible, IsDataDescriptor, IsAccessorDescriptor } from \"./index.js\";\nimport { Properties } from \"../singletons.js\";\nimport { FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\n\ntype IntegrityLevels = \"sealed\" | \"frozen\";\n\n// ECMA262 9.1.4.1\nexport function OrdinaryPreventExtensions(realm: Realm, O: ObjectValue): boolean {\n  if (O.mightBeHavocedObject() && O.getExtensible()) {\n    // todo: emit a diagnostic messsage\n    throw new FatalError();\n  }\n\n  // 1. Set the value of the [[Extensible]] internal slot of O to false.\n  O.setExtensible(false);\n\n  // 2. Return true.\n  return true;\n}\n\n// ECMA262 7.3.14\nexport function SetIntegrityLevel(realm: Realm, O: ObjectValue, level: IntegrityLevels): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue, \"expected an object\");\n\n  // 2. Assert: level is either \"sealed\" or \"frozen\".\n  invariant(level === \"sealed\" || level === \"frozen\", \"invalid level\");\n\n  // 3. Let status be ? O.[[PreventExtensions]]().\n  let status = O.$PreventExtensions();\n\n  // 4. If status is false, return false.\n  if (status === false) return false;\n\n  // 5. Let keys be ? O.[[OwnPropertyKeys]]().\n  let keys = O.$OwnPropertyKeys();\n\n  // 6. If level is \"sealed\", then\n  if (level === \"sealed\") {\n    // a. Repeat for each element k of keys,\n    for (let k of keys) {\n      // i. Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(realm, O, k, {\n        configurable: false,\n      });\n    }\n  } else if (level === \"frozen\") {\n    // 7. Else level is \"frozen\",\n    // a. Repeat for each element k of keys,\n    for (let k of keys) {\n      // i. Let currentDesc be ? O.[[GetOwnProperty]](k).\n      let currentDesc = O.$GetOwnProperty(k);\n\n      // ii. If currentDesc is not undefined, then\n      if (currentDesc) {\n        Properties.ThrowIfMightHaveBeenDeleted(currentDesc.value);\n        let desc;\n\n        // 1. If IsAccessorDescriptor(currentDesc) is true, then\n        if (IsAccessorDescriptor(realm, currentDesc)) {\n          // a. Let desc be the PropertyDescriptor{[[Configurable]]: false}.\n          desc = { configurable: false };\n        } else {\n          // 2. Else,\n          // b. Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.\n          desc = { configurable: false, writable: false };\n        }\n\n        // 3. Perform ? DefinePropertyOrThrow(O, k, desc).\n        Properties.DefinePropertyOrThrow(realm, O, k, desc);\n      }\n    }\n  }\n\n  // 8. Return true.\n  return true;\n}\n\n// ECMA262 7.3.15\nexport function TestIntegrityLevel(realm: Realm, O: ObjectValue, level: IntegrityLevels): boolean {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue, \"expected an object\");\n\n  // 2. Assert: level is either \"sealed\" or \"frozen\".\n  invariant(level === \"sealed\" || level === \"frozen\", \"invalid level\");\n\n  // 3. Let status be ? IsExtensible(O).\n  let status = IsExtensible(realm, O);\n\n  // 4. If status is true, return false.\n  if (status === true) return false;\n\n  // 5. NOTE If the object is extensible, none of its properties are examined.\n\n  // 6. Let keys be ? O.[[OwnPropertyKeys]]().\n  let keys = O.$OwnPropertyKeys();\n\n  // 7. Repeat for each element k of keys,\n  for (let k of keys) {\n    // a. Let currentDesc be ? O.[[GetOwnProperty]](k).\n    let currentDesc = O.$GetOwnProperty(k);\n\n    // b. If currentDesc is not undefined, then\n    if (currentDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(currentDesc.value);\n\n      // i. If currentDesc.[[Configurable]] is true, return false.\n      if (currentDesc.configurable === true) return false;\n\n      // ii. If level is \"frozen\" and IsDataDescriptor(currentDesc) is true, then\n      if (level === \"frozen\" && IsDataDescriptor(realm, currentDesc) === true) {\n        // 1. If currentDesc.[[Writable]] is true, return false.\n        if (currentDesc.writable === true) return false;\n      }\n    }\n  }\n\n  // 8. Return true.\n  return true;\n}\n"]}