{"version":3,"sources":["../../src/methods/regexp.js"],"names":["RegExpCreate","RegExpAlloc","RegExpInitialize","RegExpExec","RegExpBuiltinExec","AdvanceStringIndex","EscapeRegExpPattern","realm","P","F","obj","intrinsics","RegExp","newTarget","OrdinaryCreateFromConstructor","$RegExpMatcher","undefined","$OriginalSource","$OriginalFlags","DefinePropertyOrThrow","writable","enumerable","configurable","pattern","flags","isNewObject","ToStringPartial","i","length","indexOf","charAt","createErrorThrowCompletion","SyntaxError","j","BMP","computedFlags","matcher","S","lastIndex","match","exec","endIndex","index","captures","e","Set","zero","R","result","TypeError","throwIfNotConcrete","ToLength","global","sticky","fullUnicode","matchSucceeded","r","null","n","A","ArrayCreate","lengthOfA","value","matchIndex","CreateDataProperty","matchedSubstr","substr","captureI","capturedValue","ToString","unicode","Math","pow","first","charCodeAt","second","replace"],"mappings":"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","file":"regexp.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\nimport { NullValue, NumberValue, ObjectValue, StringValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { Get } from \"./get.js\";\nimport { IsCallable } from \"./is.js\";\nimport { Call } from \"./call.js\";\nimport { HasCompatibleType, HasSomeCompatibleType } from \"./has.js\";\nimport { Create, Properties, To } from \"../singletons.js\";\n\n// ECMA262 21.2.3.2.3\nexport function RegExpCreate(realm: Realm, P: ?Value, F: ?Value): ObjectValue {\n  // 1. Let obj be ? RegExpAlloc(%RegExp%).\n  let obj = RegExpAlloc(realm, realm.intrinsics.RegExp);\n\n  // 2. Return ? RegExpInitialize(obj, P, F).\n  return RegExpInitialize(realm, obj, P, F);\n}\n\n// ECMA262 21.2.3.2.1\nexport function RegExpAlloc(realm: Realm, newTarget: ObjectValue): ObjectValue {\n  // 1. Let obj be ? OrdinaryCreateFromConstructor(newTarget, \"%RegExpPrototype%\", Â« [[RegExpMatcher]],\n  //    [[OriginalSource]], [[OriginalFlags]] Â»).\n  let obj = Create.OrdinaryCreateFromConstructor(realm, newTarget, \"RegExpPrototype\", {\n    $RegExpMatcher: undefined, // always initialized to not undefined before use\n    $OriginalSource: undefined, // ditto\n    $OriginalFlags: undefined, // ditto\n  });\n\n  // 2. Perform ! DefinePropertyOrThrow(obj, \"lastIndex\", PropertyDescriptor {[[Writable]]: true,\n  //    [[Enumerable]]: false, [[Configurable]]: false}).\n  Properties.DefinePropertyOrThrow(realm, obj, \"lastIndex\", {\n    writable: true,\n    enumerable: false,\n    configurable: false,\n  });\n\n  // 3. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.3.2.2\nexport function RegExpInitialize(realm: Realm, obj: ObjectValue, pattern: ?Value, flags: ?Value): ObjectValue {\n  // Note that obj is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(obj));\n\n  // 1. If pattern is undefined, let P be the empty String.\n  let P;\n  if (!pattern || HasCompatibleType(pattern, UndefinedValue)) {\n    P = \"\";\n  } else {\n    // 2. Else, let P be ? ToString(pattern).\n    P = To.ToStringPartial(realm, pattern);\n  }\n\n  // 3. If flags is undefined, let F be the empty String.\n  let F;\n  if (!flags || HasCompatibleType(flags, UndefinedValue)) {\n    F = \"\";\n  } else {\n    // 4. Else, let F be ? ToString(flags).\n    F = To.ToStringPartial(realm, flags);\n  }\n\n  // 5. If F contains any code unit other than \"g\", \"i\", \"m\", \"u\", or \"y\" or if it contains the same code unit more than once, throw a SyntaxError exception.\n  for (let i = 0; i < F.length; ++i) {\n    if (\"gimuy\".indexOf(F.charAt(i)) < 0) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp flag\");\n    }\n    for (let j = i + 1; j < F.length; ++j) {\n      if (F.charAt(i) === F.charAt(j)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"duplicate RegExp flag\");\n      }\n    }\n  }\n\n  // 6. If F contains \"u\", let BMP be false; else let BMP be true.\n  let BMP = F.indexOf(\"u\") >= 0 ? false : true;\n\n  // 7. If BMP is true, then\n  if (BMP) {\n    // a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP\n    //    code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is\n    //    Pattern. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P\n    //    were not matched by the parse, or if any Early Error conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code unit elements of P.\n  } else {\n    // 8. Else,\n    // a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points\n    //    (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not\n    //    conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error\n    //    conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16\n    //    decoding to P's sequence of elements.\n  }\n\n  // 9. Set the value of obj's [[OriginalSource]] internal slot to P.\n  obj.$OriginalSource = P;\n\n  // 10. Set the value of obj's [[OriginalFlags]] internal slot to F.\n  obj.$OriginalFlags = F;\n\n  // 11. Set obj's [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of\n  //     P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern's List of\n  //     SourceCharacter values and F as the flag parameters.\n  try {\n    let computedFlags = \"y\";\n    if (F.indexOf(\"i\") >= 0) computedFlags += \"i\";\n    if (F.indexOf(\"u\") >= 0) computedFlags += \"u\";\n    if (F.indexOf(\"m\") >= 0) computedFlags += \"m\";\n    let matcher = new RegExp(P, (computedFlags: any));\n\n    obj.$RegExpMatcher = (S: string, lastIndex: number) => {\n      matcher.lastIndex = lastIndex;\n      let match = matcher.exec(S);\n      if (!match) {\n        return null;\n      }\n      return {\n        endIndex: match.index + match[0].length,\n        captures: match,\n      };\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp\");\n    } else throw e;\n  }\n\n  // 12. Perform ? Set(obj, \"lastIndex\", 0, true).\n  Properties.Set(realm, obj, \"lastIndex\", realm.intrinsics.zero, true);\n\n  // 13. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.5.2.1\nexport function RegExpExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: Type(R) is Object.\n  invariant(R instanceof ObjectValue, \"Type(R) is Object\");\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let exec be ? Get(R, \"exec\").\n  let exec = Get(realm, R, \"exec\");\n\n  // 4. If IsCallable(exec) is true, then\n  if (IsCallable(realm, exec)) {\n    // a. Let result be ? Call(exec, R, Â« S Â»).\n    let result = Call(realm, exec, R, [new StringValue(realm, S)]);\n\n    // b. If Type(result) is neither Object or Null, throw a TypeError exception.\n    if (!HasSomeCompatibleType(result, ObjectValue, NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(result) is neither Object or Null\");\n    }\n\n    // c. Return result.\n    return ((result.throwIfNotConcrete(): any): ObjectValue | NullValue);\n  }\n\n  // 5. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n  if (R.$RegExpMatcher === undefined) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"R does not have a [[RegExpMatcher]] internal slot\"\n    );\n  }\n\n  // 6. Return ? RegExpBuiltinExec(R, S).\n  return RegExpBuiltinExec(realm, R, S);\n}\n\n// ECMA262 21.2.5.2.2\nexport function RegExpBuiltinExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: R is an initialized RegExp instance.\n  invariant(\n    R.$RegExpMatcher !== undefined && R.$OriginalSource !== undefined && R.$OriginalFlags !== undefined,\n    \"R is an initialized RegExp instance\"\n  );\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 4. Let lastIndex be ? ToLength(? Get(R, \"lastIndex\")).\n  let lastIndex = To.ToLength(realm, Get(realm, R, \"lastIndex\"));\n\n  // 5. Let flags be R.[[OriginalFlags]].\n  let flags = R.$OriginalFlags;\n  invariant(typeof flags === \"string\");\n\n  // 6 .If flags contains \"g\", let global be true, else let global be false.\n  let global = flags.indexOf(\"g\") >= 0 ? true : false;\n\n  // 7. If flags contains \"y\", let sticky be true, else let sticky be false.\n  let sticky = flags.indexOf(\"y\") >= 0 ? true : false;\n\n  // 8. If global is false and sticky is false, let lastIndex be 0.\n  if (global === false && sticky === false) lastIndex = 0;\n\n  // 9. Let matcher be the value of R's [[RegExpMatcher]] internal slot.\n  let matcher = R.$RegExpMatcher;\n  invariant(matcher !== undefined);\n\n  // 10. If flags contains \"u\", let fullUnicode be true, else let fullUnicode be false.\n  let fullUnicode = flags.indexOf(\"u\") >= 0 ? true : false;\n\n  // 11. Let matchSucceeded be false.\n  let matchSucceeded = false;\n\n  let r = null;\n  // 12. Repeat, while matchSucceeded is false\n  while (!matchSucceeded) {\n    // a. If lastIndex > length, then\n    if (lastIndex > length) {\n      // i. Perform ? Set(R, \"lastIndex\", 0, true).\n      Properties.Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n      // ii. Return null.\n      return realm.intrinsics.null;\n    }\n\n    // b. Let r be matcher(S, lastIndex).\n    r = matcher(S, lastIndex);\n\n    // c. If r is failure, then\n    if (r == null) {\n      // i. If sticky is true, then\n      if (sticky) {\n        // 1. Perform ? Set(R, \"lastIndex\", 0, true).\n        Properties.Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n\n        // 2. Return null.\n        return realm.intrinsics.null;\n      }\n      // ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode).\n      lastIndex = AdvanceStringIndex(realm, S, lastIndex, fullUnicode);\n    } else {\n      // d. Else,\n      // i. Assert: r is a State.\n      invariant(r, \"r is a State\");\n\n      // ii. Set matchSucceeded to true.\n      matchSucceeded = true;\n\n      // (not in standard) Let lastIndex be the index of the captures\n      lastIndex = (r.captures: any).index;\n    }\n  }\n  invariant(r != null);\n\n  // 13. Let e be r's endIndex value.\n  let e = r.endIndex;\n\n  // 14. If fullUnicode is true, then\n  if (fullUnicode) {\n    // TODO #1018 a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S.\n    // b. Let e be eUTF.\n  }\n\n  // 15. If global is true or sticky is true, then\n  if (global === true || sticky === true) {\n    // a. Perform ? Set(R, \"lastIndex\", e, true).\n    Properties.Set(realm, R, \"lastIndex\", new NumberValue(realm, e), true);\n  }\n\n  // 16. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.)\n  let n = r.captures.length - 1;\n\n  // 17. Let A be ArrayCreate(n + 1).\n  let A = Create.ArrayCreate(realm, n + 1);\n\n  // 18. Assert: The value of A's \"length\" property is n + 1.\n  let lengthOfA = Get(realm, A, \"length\").throwIfNotConcrete();\n  invariant(lengthOfA instanceof NumberValue);\n  invariant(lengthOfA.value === n + 1, 'The value of A\\'s \"length\" property is n + 1');\n\n  // 19. Let matchIndex be lastIndex.\n  let matchIndex = lastIndex;\n\n  // 20. Perform ! CreateDataProperty(A, \"index\", matchIndex).\n  Create.CreateDataProperty(realm, A, \"index\", new NumberValue(realm, matchIndex));\n\n  // 21. Perform ! CreateDataProperty(A, \"input\", S).\n  Create.CreateDataProperty(realm, A, \"input\", new StringValue(realm, S));\n\n  // 22. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive).\n  let matchedSubstr = S.substr(lastIndex, e - lastIndex);\n\n  // 23. Perform ! CreateDataProperty(A, \"0\", matchedSubstr).\n  Create.CreateDataProperty(realm, A, \"0\", new StringValue(realm, matchedSubstr));\n\n  // 24. For each integer i such that i > 0 and i â¤ n\n  for (let i = 1; i <= n; ++i) {\n    // a. Let captureI be ith element of r's captures List.\n    let captureI = r.captures[i];\n\n    let capturedValue;\n    // b. If captureI is undefined, let capturedValue be undefined.\n    if (captureI === undefined) {\n      capturedValue = realm.intrinsics.undefined;\n    } else if (fullUnicode) {\n      // c. Else if fullUnicode is true, then\n      // TODO #1018: i. Assert: captureI is a List of code points.\n      // ii. Let capturedValue be a string whose code units are the UTF16Encoding of the code points of captureI.\n      capturedValue = realm.intrinsics.undefined;\n    } else {\n      // d. Else, fullUnicode is false,\n      // i. Assert: captureI is a List of code units.\n      invariant(typeof captureI === \"string\");\n\n      // ii. Let capturedValue be a string consisting of the code units of captureI.\n      capturedValue = new StringValue(realm, captureI);\n    }\n\n    // e. Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).\n    Create.CreateDataProperty(realm, A, To.ToString(realm, new NumberValue(realm, i)), capturedValue);\n  }\n\n  // 25. Return A.\n  return A;\n}\n\nexport function AdvanceStringIndex(realm: Realm, S: string, index: number, unicode: boolean): number {\n  // 1. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 2. Assert: index is an integer such that 0â¤indexâ¤253-1.\n  invariant(index >= 0 && index <= Math.pow(2, 53) - 1, \"index is an integer such that 0â¤indexâ¤253-1\");\n\n  // 3. Assert: Type(unicode) is Boolean.\n  invariant(typeof unicode === \"boolean\", \"Type(unicode) is Boolean\");\n\n  // 4. If unicode is false, return index+1.\n  if (unicode === false) return index + 1;\n\n  // 5. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 6. If index+1 â¥ length, return index+1.\n  if (index + 1 >= length) return index + 1;\n\n  // 7. Let first be the code unit value at index index in S.\n  let first = S.charCodeAt(index);\n\n  // 8. If first < 0xD800 or first > 0xDBFF, return index+1.\n  if (first < 0xd800 || first > 0xdbff) return index + 1;\n\n  // 9. Let second be the code unit value at index index+1 in S.\n  let second = S.charCodeAt(index + 1);\n\n  // 10. If second < 0xDC00 or second > 0xDFFF, return index+1.\n  if (second < 0xdc00 || second > 0xdfff) return index + 1;\n\n  // 11. Return index+2.\n  return index + 2;\n}\n\nexport function EscapeRegExpPattern(realm: Realm, P: string, F: string): string {\n  return P.replace(\"/\", \"/\");\n}\n"]}