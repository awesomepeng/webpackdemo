{"version":3,"sources":["../../src/methods/call.js"],"names":["ArgumentListEvaluation","Invoke","EvaluateCall","PrepareForOrdinaryCall","OrdinaryCallBindThis","OrdinaryCallEvaluateBody","EvaluateDirectCall","EvaluateDirectCallWithArgList","PrepareForTailCall","Call","t","realm","strictCode","env","argNodes","Array","isArray","args","node_","type","node","list","spreadRef","evaluate","argument","spreadObj","GetValue","iterator","next","nextArg","push","ref","expr","expressions","length","templateLiteral","siteObj","firstSubRef","firstSub","restSub","slice","map","constructor","V","P","argumentsList","func","thisValue","IsPropertyReference","refEnv","GetBase","WithBaseObject","intrinsics","undefined","F","newTarget","callerContext","getRunningContext","calleeContext","createExecutionContext","setFunction","setCaller","calleeRealm","ScriptOrModule","$ScriptOrModule","localEnv","NewFunctionEnvironment","lexicalEnvironment","variableEnvironment","suspend","pushContext","thisArgument","thisMode","$ThisMode","$Realm","globalEnv","$GlobalEnv","globalEnvRec","environmentRecord","$GlobalThisValue","ToObject","envRec","BindThisValue","callNativeFunctionValue","f","context","GetThisBinding","functionCall","contextVal","inConditional","completion","callCallback","$NewTarget","value","err","Error","wrapInReturnCompletion","currentLocation","kind","condValue","consequentVal","alternateVal","evaluateWithAbstractConditional","evaluateForEffects","$FunctionKind","FunctionDeclarationInstantiation","G","OrdinaryCreateFromConstructor","$GeneratorState","$GeneratorContext","code","$ECMAScriptCode","abstractRecursionSummarization","useAbstractInterpretation","pathConditions","normalCall","savedIsSelfRecursive","isSelfRecursive","effects","guardedCall","reportIntrospectionError","applyEffects","c","result","processResult","activeArguments","has","previousPathLength","previousArguments","get","widenedArgumentsList","widenValues","containsArraysOfValue","createFromType","Map","set","delete","evaluateCompletionDeref","$Strict","getCompletion","priorSavedCompletion","savedCompletion","abruptCompletion","incorporateSavedCompletion","containsCompletion","joinedReturnEffects","extractAndJoinCompletionsOfType","remainingCompletions","transferChildrenToPossiblyNormalCompletion","composeWithSavedCompletion","incorporatePriorSavedCompletion","tailPosition","argList","isTypeCompatibleWith","getType","createTemporalFromBuildFunction","functionResultType","concat","nodes","fun_args","callExpression","throwIfNotConcrete","createErrorThrowCompletion","TypeError","leafContext","onDestroyScope","popContext","argsList","arg","fullArgs","memberExpression","identifier","$Call"],"mappings":"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","file":"call.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { PropertyKeyValue } from \"../types.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport {\n  EnvironmentRecord,\n  GlobalEnvironmentRecord,\n  LexicalEnvironment,\n  mightBecomeAnObject,\n  Reference,\n} from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Realm, ExecutionContext } from \"../realm.js\";\nimport Value from \"../values/Value.js\";\nimport {\n  FunctionValue,\n  ECMAScriptSourceFunctionValue,\n  ObjectValue,\n  NullValue,\n  UndefinedValue,\n  NativeFunctionValue,\n  AbstractObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { GetIterator, HasSomeCompatibleType, IsCallable, IsPropertyKey, IteratorStep, IteratorValue } from \"./index.js\";\nimport { GeneratorStart } from \"../methods/generator.js\";\nimport { ReturnCompletion, AbruptCompletion, ThrowCompletion, ForkedAbruptCompletion } from \"../completions.js\";\nimport { GetTemplateObject, GetV, GetThisValue } from \"../methods/get.js\";\nimport { Create, Environment, Functions, Join, Havoc, To, Widen } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeExpression, BabelNodeSpreadElement, BabelNodeTemplateLiteral } from \"babel-types\";\nimport * as t from \"babel-types\";\n\n// ECMA262 12.3.6.1\nexport function ArgumentListEvaluation(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  argNodes: Array<BabelNodeExpression | BabelNodeSpreadElement> | BabelNodeTemplateLiteral\n): Array<Value> {\n  if (Array.isArray(argNodes)) {\n    let args = [];\n    for (let node_ of argNodes) {\n      if (node_.type === \"SpreadElement\") {\n        let node = (node_: BabelNodeSpreadElement);\n        // 1. Let list be a new empty List.\n        let list = args;\n\n        // 2. Let spreadRef be the result of evaluating AssignmentExpression.\n        let spreadRef = env.evaluate(node.argument, strictCode);\n\n        // 3. Let spreadObj be ? GetValue(spreadRef).\n        let spreadObj = Environment.GetValue(realm, spreadRef);\n\n        // 4. Let iterator be ? GetIterator(spreadObj).\n        let iterator = GetIterator(realm, spreadObj);\n\n        // 5. Repeat\n        while (true) {\n          // a. Let next be ? IteratorStep(iterator).\n          let next = IteratorStep(realm, iterator);\n\n          // b. If next is false, return list.\n          if (!next) {\n            break;\n          }\n\n          // c. Let nextArg be ? IteratorValue(next).\n          let nextArg = IteratorValue(realm, next);\n\n          // d. Append nextArg as the last element of list.\n          list.push(nextArg);\n        }\n      } else {\n        let ref = env.evaluate(node_, strictCode);\n        let expr = Environment.GetValue(realm, ref);\n        args.push(expr);\n      }\n    }\n    return args;\n  } else {\n    let node = (argNodes: BabelNodeTemplateLiteral);\n    if (node.expressions.length === 0) {\n      // 1. Let templateLiteral be this TemplateLiteral.\n      let templateLiteral = node;\n\n      // 2. Let siteObj be GetTemplateObject(templateLiteral).\n      let siteObj = GetTemplateObject(realm, templateLiteral);\n\n      // 3. Return a List containing the one element which is siteObj.\n      return [siteObj];\n    } else {\n      // 1. Let templateLiteral be this TemplateLiteral.\n      let templateLiteral = node;\n\n      // 2. Let siteObj be GetTemplateObject(templateLiteral).\n      let siteObj = GetTemplateObject(realm, templateLiteral);\n\n      // 3. Let firstSubRef be the result of evaluating Expression.\n      let firstSubRef = env.evaluate(node.expressions[0], strictCode);\n\n      // 4. Let firstSub be ? GetValue(firstSubRef).\n      let firstSub = Environment.GetValue(realm, firstSubRef);\n\n      // 5. Let restSub be SubstitutionEvaluation of TemplateSpans.\n      let restSub = node.expressions.slice(1, node.expressions.length).map(expr => {\n        return Environment.GetValue(realm, env.evaluate(expr, strictCode));\n      });\n\n      // 6. ReturnIfAbrupt(restSub).\n\n      // 7. Assert: restSub is a List.\n      invariant(restSub.constructor === Array, \"restSub is a List\");\n\n      // 8. Return a List whose first element is siteObj, whose second elements is firstSub, and whose subsequent elements are the elements of restSub, in order. restSub may contain no elements.\n      return [siteObj, firstSub, ...restSub];\n    }\n  }\n}\n\n// ECMA262 7.3.18\nexport function Invoke(realm: Realm, V: Value, P: PropertyKeyValue, argumentsList?: Array<Value>): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. If argumentsList was not passed, let argumentsList be a new empty List.\n  if (!argumentsList) argumentsList = [];\n\n  // 3. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 4. Return ? Call(func, V, argumentsList).\n  return Call(realm, func, V, argumentsList);\n}\n\n// ECMA262 12.3.4.2\nexport function EvaluateCall(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  ref: Reference | Value,\n  args: Array<BabelNode> | BabelNodeTemplateLiteral\n): Value {\n  let thisValue;\n\n  // 1. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  // 2. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 3. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 4. Return ? EvaluateDirectCall(func, thisValue, arguments, tailPosition).\n  return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, args);\n}\n\n// ECMA262 9.2.1.1\nexport function PrepareForOrdinaryCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  newTarget?: ObjectValue\n): ExecutionContext {\n  // 1. Assert: Type(newTarget) is Undefined or Object.\n  invariant(\n    newTarget === undefined || newTarget instanceof ObjectValue,\n    \"expected undefined or object value for new target\"\n  );\n\n  // 2. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 3. Let calleeContext be a new ECMAScript code execution context.\n  let calleeContext = realm.createExecutionContext();\n\n  // 4. Set the Function of calleeContext to F.\n  calleeContext.setFunction(F);\n  calleeContext.setCaller(realm.getRunningContext());\n\n  // 5. Let calleeRealm be the value of F's [[Realm]] internal slot.\n  let calleeRealm = realm;\n\n  // 6. Set the Realm of calleeContext to calleeRealm.\n  calleeContext.realm = calleeRealm;\n\n  // 7. Set the ScriptOrModule of calleeContext to the value of F's [[ScriptOrModule]] internal slot.\n  calleeContext.ScriptOrModule = F.$ScriptOrModule;\n\n  // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).\n  let localEnv = Environment.NewFunctionEnvironment(realm, F, newTarget);\n\n  // 9. Set the LexicalEnvironment of calleeContext to localEnv.\n  calleeContext.lexicalEnvironment = localEnv;\n\n  // 10. Set the VariableEnvironment of calleeContext to localEnv.\n  calleeContext.variableEnvironment = localEnv;\n\n  // 11. If callerContext is not already suspended, suspend callerContext.\n  callerContext.suspend();\n\n  // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.\n  realm.pushContext(calleeContext);\n\n  // 13. NOTE Any exception objects produced after this point are associated with calleeRealm.\n\n  // 14. Return calleeContext.\n  return calleeContext;\n}\n\n// ECMA262 9.2.1.2\nexport function OrdinaryCallBindThis(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  calleeContext: ExecutionContext,\n  thisArgument: Value\n): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n  // 1. Let thisMode be the value of F's [[ThisMode]] internal slot.\n  let thisMode = F.$ThisMode;\n\n  // 2. If thisMode is lexical, return NormalCompletion(undefined).\n  if (thisMode === \"lexical\") return realm.intrinsics.undefined;\n\n  // 3. Let calleeRealm be the value of F's [[Realm]] internal slot.\n  let calleeRealm = F.$Realm;\n\n  // 4. Let localEnv be the LexicalEnvironment of calleeContext.\n  let localEnv = calleeContext.lexicalEnvironment;\n\n  let thisValue;\n  // 5. If thisMode is strict, let thisValue be thisArgument.\n  if (thisMode === \"strict\") {\n    thisValue = (thisArgument: any);\n  } else {\n    // 6. Else,\n    // a. If thisArgument is null or undefined, then\n    if (HasSomeCompatibleType(thisArgument, NullValue, UndefinedValue)) {\n      // i. Let globalEnv be calleeRealm.[[GlobalEnv]].\n      let globalEnv = realm.$GlobalEnv;\n\n      // ii. Let globalEnvRec be globalEnv's EnvironmentRecord.\n      let globalEnvRec = globalEnv.environmentRecord;\n      invariant(globalEnvRec instanceof GlobalEnvironmentRecord);\n\n      // iii. Let thisValue be globalEnvRec.[[GlobalThisValue]].\n      thisValue = globalEnvRec.$GlobalThisValue;\n    } else {\n      //  b. Else,\n      // i. Let thisValue be ! ToObject(thisArgument).\n      thisValue = To.ToObject(calleeRealm, thisArgument);\n\n      // ii. NOTE ToObject produces wrapper objects using calleeRealm.\n    }\n  }\n\n  // 7. Let envRec be localEnv's EnvironmentRecord.\n  invariant(localEnv !== undefined);\n  let envRec = localEnv.environmentRecord;\n\n  // 8. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not \"initialized\".\n\n  // 9. Return envRec.BindThisValue(thisValue).\n  return envRec.BindThisValue(thisValue);\n}\n\nfunction callNativeFunctionValue(\n  realm: Realm,\n  f: NativeFunctionValue,\n  argumentsList: Array<Value>\n): Value | AbruptCompletion {\n  let env = realm.getRunningContext().lexicalEnvironment;\n  let context = env.environmentRecord.GetThisBinding();\n\n  // we have an inConditional flag, as we do not want to return\n  const functionCall = (contextVal, inConditional) => {\n    try {\n      invariant(\n        contextVal instanceof AbstractObjectValue ||\n          contextVal instanceof ObjectValue ||\n          contextVal instanceof NullValue ||\n          contextVal instanceof UndefinedValue ||\n          mightBecomeAnObject(contextVal)\n      );\n      let completion = f.callCallback(\n        // this is to get around Flow not understand the above invariant\n        ((contextVal: any): AbstractObjectValue | ObjectValue | NullValue | UndefinedValue),\n        argumentsList,\n        env.environmentRecord.$NewTarget\n      );\n      return inConditional ? completion.value : completion;\n    } catch (err) {\n      if (err instanceof AbruptCompletion) {\n        return inConditional ? err.value : err;\n      } else if (err instanceof Error) {\n        throw err;\n      } else {\n        throw new FatalError(err);\n      }\n    }\n  };\n\n  const wrapInReturnCompletion = contextVal => new ReturnCompletion(contextVal, undefined, realm.currentLocation);\n\n  if (context instanceof AbstractObjectValue && context.kind === \"conditional\") {\n    let [condValue, consequentVal, alternateVal] = context.args;\n    invariant(condValue instanceof AbstractValue);\n\n    return wrapInReturnCompletion(\n      realm.evaluateWithAbstractConditional(\n        condValue,\n        () => {\n          return realm.evaluateForEffects(\n            () => functionCall(consequentVal, true),\n            null,\n            \"callNativeFunctionValue consequent\"\n          );\n        },\n        () => {\n          return realm.evaluateForEffects(\n            () => functionCall(alternateVal, true),\n            null,\n            \"callNativeFunctionValue alternate\"\n          );\n        }\n      )\n    );\n  }\n  return functionCall(context, false);\n}\n\n// ECMA262 9.2.1.3\nexport function OrdinaryCallEvaluateBody(\n  realm: Realm,\n  f: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>\n): Reference | Value | AbruptCompletion {\n  if (f instanceof NativeFunctionValue) {\n    return callNativeFunctionValue(realm, f, argumentsList);\n  } else {\n    invariant(f instanceof ECMAScriptSourceFunctionValue);\n    let F = f;\n    if (F.$FunctionKind === \"generator\") {\n      // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).\n      Functions.FunctionDeclarationInstantiation(realm, F, argumentsList);\n\n      // 2. Let G be ? OrdinaryCreateFromConstructor(functionObject, \"%GeneratorPrototype%\", « [[GeneratorState]], [[GeneratorContext]] »).\n      let G = Create.OrdinaryCreateFromConstructor(realm, F, \"GeneratorPrototype\", {\n        $GeneratorState: undefined,\n        $GeneratorContext: undefined,\n      });\n\n      // 3. Perform GeneratorStart(G, FunctionBody).\n      let code = F.$ECMAScriptCode;\n      invariant(code !== undefined);\n      GeneratorStart(realm, G, code);\n\n      // 4. Return Completion{[[Type]]: return, [[Value]]: G, [[Target]]: empty}.\n      return new ReturnCompletion(G, undefined, realm.currentLocation);\n    } else {\n      // TODO #1586: abstractRecursionSummarization is disabled for now, as it is likely too limiting\n      // (as observed in large internal tests).\n      const abstractRecursionSummarization = false;\n      if (!realm.useAbstractInterpretation || realm.pathConditions.length === 0 || !abstractRecursionSummarization)\n        return normalCall();\n      let savedIsSelfRecursive = F.isSelfRecursive;\n      try {\n        F.isSelfRecursive = false;\n        let effects = realm.evaluateForEffects(guardedCall, undefined, \"OrdinaryCallEvaluateBody\");\n        if (F.isSelfRecursive) {\n          AbstractValue.reportIntrospectionError(F, \"call to function that calls itself\");\n          throw new FatalError();\n          //todo: need to emit a specialized function that temporally captures the heap state at this point\n        } else {\n          realm.applyEffects(effects);\n          let c = effects.result;\n          return processResult(() => {\n            invariant(c instanceof Value || c instanceof AbruptCompletion);\n            return c;\n          });\n        }\n      } finally {\n        F.isSelfRecursive = savedIsSelfRecursive;\n      }\n\n      function guardedCall() {\n        let currentLocation = realm.currentLocation;\n        if (F.activeArguments !== undefined && F.activeArguments.has(currentLocation)) {\n          let [previousPathLength, previousArguments] = F.activeArguments.get(currentLocation);\n          if (realm.pathConditions.length > previousPathLength) {\n            invariant(previousArguments !== undefined);\n            // F is being called recursively while a call to it is still active\n            F.isSelfRecursive = true;\n            let widenedArgumentsList: Array<Value> = (Widen.widenValues(realm, previousArguments, argumentsList): any);\n            if (Widen.containsArraysOfValue(realm, previousArguments, widenedArgumentsList)) {\n              // Reached a fixed point. Executing this call will not add any knowledge\n              // about the effects of the original call.\n              return AbstractValue.createFromType(realm, Value, \"widened return result\");\n            } else {\n              argumentsList = widenedArgumentsList;\n            }\n          }\n        }\n        try {\n          if (F.activeArguments === undefined) F.activeArguments = new Map();\n          F.activeArguments.set(currentLocation, [realm.pathConditions.length, argumentsList]);\n          return normalCall();\n        } finally {\n          F.activeArguments.delete(currentLocation);\n        }\n      }\n\n      function normalCall() {\n        // 1. Perform ? FunctionDeclarationInstantiation(F, argumentsList).\n        Functions.FunctionDeclarationInstantiation(realm, F, argumentsList);\n\n        // 2. Return the result of EvaluateBody of the parsed code that is the value of F's\n        //    [[ECMAScriptCode]] internal slot passing F as the argument.\n        let code = F.$ECMAScriptCode;\n        invariant(code !== undefined);\n        let context = realm.getRunningContext();\n        return processResult(() => context.lexicalEnvironment.evaluateCompletionDeref(code, F.$Strict));\n      }\n\n      function processResult(getCompletion: () => AbruptCompletion | Value): AbruptCompletion | Value {\n        let priorSavedCompletion = realm.savedCompletion;\n        try {\n          realm.savedCompletion = undefined;\n          let c = getCompletion();\n\n          // We are about the leave this function and this presents a join point where all non exceptional control flows\n          // converge into a single flow using their joint effects to update the post join point state.\n          if (!(c instanceof ReturnCompletion)) {\n            if (!(c instanceof AbruptCompletion)) {\n              c = new ReturnCompletion(realm.intrinsics.undefined, undefined, realm.currentLocation);\n            }\n          }\n          invariant(c instanceof AbruptCompletion);\n\n          // If there is a saved completion (i.e. unjoined abruptly completing control flows) then combine them with c\n          let abruptCompletion = Functions.incorporateSavedCompletion(realm, c);\n          invariant(abruptCompletion instanceof AbruptCompletion);\n\n          // If there is single completion, we don't need to join\n          if (!(abruptCompletion instanceof ForkedAbruptCompletion)) return abruptCompletion;\n\n          // If none of the completions are return completions, there is no need to join either\n          if (!abruptCompletion.containsCompletion(ReturnCompletion)) return abruptCompletion;\n\n          // Apply the joined effects of return completions to the current state since these now join the normal path\n          let joinedReturnEffects = Join.extractAndJoinCompletionsOfType(ReturnCompletion, realm, abruptCompletion);\n          realm.applyEffects(joinedReturnEffects);\n          c = joinedReturnEffects.result;\n          invariant(c instanceof ReturnCompletion);\n\n          // We now make a PossiblyNormalCompletion out of abruptCompletion.\n          // extractAndJoinCompletionsOfType helped with this by cheating and turning all of its nested completions\n          // that contain return completions into PossiblyNormalCompletions.\n          let remainingCompletions = abruptCompletion.transferChildrenToPossiblyNormalCompletion();\n\n          // If there are no throw completions left inside remainingCompletions, just return.\n          if (!remainingCompletions.containsCompletion(ThrowCompletion)) return c;\n\n          // Stash the remaining completions in the realm start tracking the effects that need to be appended\n          // to the normal branch at the next join point.\n          realm.composeWithSavedCompletion(remainingCompletions);\n          return c;\n        } finally {\n          realm.incorporatePriorSavedCompletion(priorSavedCompletion);\n        }\n      }\n    }\n  }\n}\n\n// ECMA262 12.3.4.3\nexport function EvaluateDirectCall(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  ref: Value | Reference,\n  func: Value,\n  thisValue: Value,\n  args: Array<BabelNodeExpression | BabelNodeSpreadElement> | BabelNodeTemplateLiteral,\n  tailPosition?: boolean\n): Value {\n  // 1. Let argList be ? ArgumentListEvaluation(arguments).\n  let argList = ArgumentListEvaluation(realm, strictCode, env, args);\n\n  return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailPosition);\n}\n\nexport function EvaluateDirectCallWithArgList(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  ref: Value | Reference,\n  func: Value,\n  thisValue: Value,\n  argList: Array<Value>,\n  tailPosition?: boolean\n): Value {\n  if (func instanceof AbstractObjectValue && Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n    return AbstractValue.createTemporalFromBuildFunction(\n      realm,\n      func.functionResultType || Value,\n      [func].concat(argList),\n      (nodes: Array<BabelNodeExpression>) => {\n        let fun_args = nodes.slice(1);\n        return t.callExpression(nodes[0], ((fun_args: any): Array<BabelNodeExpression | BabelNodeSpreadElement>));\n      }\n    );\n  }\n  func = func.throwIfNotConcrete();\n\n  // 2. If Type(func) is not Object, throw a TypeError exception.\n  if (!(func instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an object\");\n  }\n\n  // 3. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 4. If tailPosition is true, perform PrepareForTailCall().\n  if (tailPosition === true) PrepareForTailCall(realm);\n\n  // 5. Let result be Call(func, thisValue, argList).\n  let result = Call(realm, func, thisValue, argList);\n\n  // 6. Assert: If tailPosition is true, the above call will not return here, but instead\n  //    evaluation will continue as if the following return has already occurred.\n\n  // 7. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.\n  invariant(result instanceof Value, \"expected language value type\");\n\n  // 8. Return result.\n  return result;\n}\n\n// ECMA262 14.6.3\nexport function PrepareForTailCall(realm: Realm): void {\n  // 1. Let leafContext be the running execution context.\n  let leafContext = realm.getRunningContext();\n\n  // 2. Suspend leafContext.\n  leafContext.suspend();\n\n  // 3. Pop leafContext from the execution context stack. The execution context now on the\n  //    top of the stack becomes the running execution context.\n  realm.onDestroyScope(leafContext.lexicalEnvironment);\n  realm.popContext(leafContext);\n\n  // TODO #1008 4. Assert: leafContext has no further use. It will never be activated as the running execution context.\n}\n\n// ECMA262 7.3.12\nexport function Call(realm: Realm, F: Value, V: Value, argsList?: Array<Value>): Value {\n  // 1. If argumentsList was not passed, let argumentsList be a new empty List.\n  argsList = argsList || [];\n\n  // 2. If IsCallable(F) is false, throw a TypeError exception.\n  if (IsCallable(realm, F) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n  if (F instanceof AbstractValue && Value.isTypeCompatibleWith(F.getType(), FunctionValue)) {\n    Havoc.value(realm, V);\n    for (let arg of argsList) {\n      Havoc.value(realm, arg);\n    }\n    if (V === realm.intrinsics.undefined) {\n      let fullArgs = [F].concat(argsList);\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, fullArgs, nodes => {\n        let fun_args = ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n        return t.callExpression(nodes[0], fun_args);\n      });\n    } else {\n      let fullArgs = [F, V].concat(argsList);\n      return AbstractValue.createTemporalFromBuildFunction(realm, Value, fullArgs, nodes => {\n        let fun_args = ((nodes.slice(1): any): Array<BabelNodeExpression | BabelNodeSpreadElement>);\n        return t.callExpression(t.memberExpression(nodes[0], t.identifier(\"call\")), fun_args);\n      });\n    }\n  }\n  invariant(F instanceof ObjectValue);\n\n  // 3. Return ? F.[[Call]](V, argumentsList).\n  invariant(F.$Call, \"no call method on this value\");\n  return F.$Call(V, argsList);\n}\n"]}