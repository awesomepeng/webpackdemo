{"version":3,"sources":["../../src/methods/properties.js"],"names":["StringKey","key","value","InternalDescriptorPropertyToValue","realm","undefined","intrinsics","InternalGetPropertiesKey","P","InternalGetPropertiesMap","O","properties","symbols","InternalSetProperty","desc","map","propertyBinding","get","descriptor","object","set","recordModifiedProperty","InternalUpdatedProperty","oldDesc","generator","isIntrinsic","temporalAlias","mightBeHavocedObject","mightBeFinalObject","$GlobalObject","emitGlobalDelete","emitPropertyDelete","descValue","configurable","enumerable","writable","emitGlobalDeclaration","emitGlobalAssignment","emitDefineProperty","emitPropertyAssignment","havocDescriptor","val","parentPermitsChildPropertyCreation","ownDesc","$GetOwnProperty","ownDescValue","mightHaveBeenDeleted","parent","$GetPrototypeOf","throwIfNotConcreteObject","ensureIsNotFinal","mightNotBeFinalObject","error","currentLocation","handleError","PropertiesImplementation","OrdinarySet","V","Receiver","ignoreLeakLogic","weakDeletion","existingBinding","isPartialObject","isSimpleObject","$Set","reportIntrospectionError","joinCondition","descriptor2","descriptor1","result","result1","generator1","modifiedBindings","modifiedBindings1","modifiedProperties","modifiedProperties1","createdObjects","createdObjects1","withCondition","evaluateForEffects","OrdinarySetHelper","result2","generator2","modifiedBindings2","modifiedProperties2","createdObjects2","withInverseCondition","joinedEffects","joinForkOrChoose","completion","composeWithSavedCompletion","applyEffects","ToBooleanPartial","throwIfNotConcrete","existingDescriptor","binding","existingDescValue","valueDesc","$Delete","$DefineOwnProperty","CreateDataProperty","setter","FromPropertyDescriptor","Desc","obj","ObjectCreate","ObjectPrototype","getExtensible","size","success","OrdinaryDelete","DeletePropertyOrThrow","createErrorThrowCompletion","TypeError","CompletePropertyDescriptor","like","IsCompatiblePropertyDescriptor","extensible","current","ValidateAndApplyPropertyDescriptor","jc","implies","createFromUnaryOp","mightNotBeTrue","ThrowIfMightHaveBeenDeleted","Object","keys","length","identical","field","dval","cval","currentValue","OrdinaryDefineOwnProperty","ObjectDefineProperties","Properties","mightNotBeObject","mightBeObject","props","ToObject","$OwnPropertyKeys","descriptors","nextKey","propDesc","descObj","ToPropertyDescriptor","push","pair","DefinePropertyOrThrow","Set","Throw","PutValue","W","promoteEmptyToUndefined","ReferenceError","base","GetBase","IsUnresolvableReference","IsStrictReference","globalObj","GetReferencedName","IsPropertyReference","HasPrimitiveBase","succeeded","$SetPartial","GetReferencedNamePartial","referencedName","SetMutableBinding","ArraySetLength","A","DescValue","newLenDesc","assign","newLen","ToUint32","numberLen","ToNumber","RangeError","oldLenDesc","OrdinaryGetOwnProperty","oldLen","newWritable","oldLenCopy","Array","from","x","parseInt","filter","sort","reverse","deleteSucceeded","absVal","createTemporalFromBuildFunction","_templateFor","node","isPure","useAbstractInterpretation","createAbstractPropertyValue","type","isTransitivelySimple","createFromBuildFunction","kind","makeKind","skipInvariant","makeSimple","createAbstractConcreteUnion","null","invariantLevel","isIntrinsicAndHasWidenedNumericProperty","realmGenerator","hasBindingBeenChecked","markPropertyAsChecked","emitPropertyInvariant","callReportPropertyAccess","D","X","savedUnion","savedIndex","args","findIndex","e","deriveAbstract","types","values","getBuildNode","slice","emitFullInvariant","OrdinarySetPrototypeOf","$Prototype","p","done","usesOrdinaryObjectInternalPrototypeMethods","EnumerateObjectProperties","visited","global","index","iterator","defineNativeMethod","proto","CreateIterResultObject","add","has","v","$Realm","simplifyAndRefineAbstractValue","ThrowIfInternalSlotNotWritable","isNewObject","PropertyDefinitionEvaluation","MethodDefinition","env","strictCode","methodDef","DefineMethod","SetFunctionName","$Closure","$Key","$HasComputedName","computed","propKey","strict","body","scope","closure","GeneratorFunctionCreate","params","MakeMethod","prototype","GeneratorPrototype","originalConstructor","formalParameterList","FunctionCreate"],"mappings":"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","file":"properties.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { construct_empty_effects, type Realm, Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  Call,\n  cloneDescriptor,\n  equalDescriptors,\n  Get,\n  GetGlobalObject,\n  GetThisValue,\n  HasSomeCompatibleType,\n  IsAccessorDescriptor,\n  IsDataDescriptor,\n  IsGenericDescriptor,\n  IsPropertyKey,\n  MakeConstructor,\n  SameValue,\n  SameValuePartial,\n} from \"../methods/index.js\";\nimport { type BabelNodeObjectMethod, type BabelNodeClassMethod, isValidIdentifier } from \"babel-types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Create, Environment, Functions, Havoc, Join, Path, To } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport { memberExpressionHelper } from \"../utils/babelhelpers.js\";\n\nfunction StringKey(key: PropertyKeyValue): string {\n  if (key instanceof StringValue) key = key.value;\n  if (typeof key !== \"string\") {\n    // The generator currently only supports string keys.\n    throw new FatalError();\n  }\n  return key;\n}\n\nfunction InternalDescriptorPropertyToValue(realm: Realm, value: void | boolean | Value) {\n  if (value === undefined) return realm.intrinsics.undefined;\n  if (typeof value === \"boolean\") return new BooleanValue(realm, value);\n  invariant(value instanceof Value);\n  return value;\n}\n\nfunction InternalGetPropertiesKey(P: PropertyKeyValue): string | SymbolValue | void {\n  if (typeof P === \"string\") {\n    return P;\n  } else if (P instanceof StringValue) {\n    return P.value;\n  } else if (P instanceof SymbolValue) {\n    return P;\n  }\n  // otherwise, undefined\n}\n\nfunction InternalGetPropertiesMap(O: ObjectValue, P: PropertyKeyValue): Map<any, PropertyBinding> {\n  if (typeof P === \"string\" || P instanceof StringValue) {\n    return O.properties;\n  } else if (P instanceof SymbolValue) {\n    return O.symbols;\n  } else {\n    invariant(false);\n  }\n}\n\nfunction InternalSetProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, desc: Descriptor) {\n  let map = InternalGetPropertiesMap(O, P);\n  let key = InternalGetPropertiesKey(P);\n  let propertyBinding = map.get(key);\n  if (propertyBinding === undefined) {\n    propertyBinding = { descriptor: undefined, object: O, key: key };\n    map.set(key, propertyBinding);\n  }\n  realm.recordModifiedProperty(propertyBinding);\n  propertyBinding.descriptor = desc;\n}\n\nfunction InternalUpdatedProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, oldDesc?: Descriptor) {\n  let generator = realm.generator;\n  if (!generator) return;\n  if (!O.isIntrinsic() && O.temporalAlias === undefined) return;\n  if (P instanceof SymbolValue) return;\n  if (P instanceof StringValue) P = P.value;\n  invariant(!O.mightBeHavocedObject()); // havoced objects are never updated\n  invariant(!O.mightBeFinalObject()); // final objects are never updated\n  invariant(typeof P === \"string\");\n  let propertyBinding = InternalGetPropertiesMap(O, P).get(P);\n  invariant(propertyBinding !== undefined); // The callers ensure this\n  let desc = propertyBinding.descriptor;\n  if (desc === undefined) {\n    // The property is being deleted\n    if (O === realm.$GlobalObject) {\n      generator.emitGlobalDelete(P);\n    } else {\n      generator.emitPropertyDelete(O, P);\n    }\n  } else {\n    let descValue = desc.value || realm.intrinsics.undefined;\n    invariant(descValue instanceof Value);\n    if (oldDesc === undefined) {\n      // The property is being created\n      if (O === realm.$GlobalObject) {\n        if (IsDataDescriptor(realm, desc)) {\n          if (isValidIdentifier(P) && !desc.configurable && desc.enumerable && desc.writable) {\n            generator.emitGlobalDeclaration(P, descValue);\n          } else if (desc.configurable && desc.enumerable && desc.writable) {\n            generator.emitGlobalAssignment(P, descValue);\n          } else {\n            generator.emitDefineProperty(O, P, desc);\n          }\n        } else {\n          generator.emitDefineProperty(O, P, desc);\n        }\n      } else {\n        if (IsDataDescriptor(realm, desc) && desc.configurable && desc.enumerable && desc.writable) {\n          generator.emitPropertyAssignment(O, P, descValue);\n        } else {\n          generator.emitDefineProperty(O, P, desc);\n        }\n      }\n    } else {\n      // The property is being modified\n      if (equalDescriptors(desc, oldDesc)) {\n        // only the value is being modified\n        if (O === realm.$GlobalObject) {\n          generator.emitGlobalAssignment(P, descValue);\n        } else {\n          generator.emitPropertyAssignment(O, P, descValue);\n        }\n      } else {\n        generator.emitDefineProperty(O, P, desc, /*isDescChanged*/ true);\n      }\n    }\n  }\n}\n\nfunction havocDescriptor(realm: Realm, desc: Descriptor) {\n  if (desc.value) {\n    if (desc.value instanceof Value) Havoc.value(realm, desc.value);\n    else if (desc.value !== undefined) {\n      for (let val of desc.value) Havoc.value(realm, val);\n    }\n  }\n  if (desc.get) {\n    Havoc.value(realm, desc.get);\n  }\n  if (desc.set) {\n    Havoc.value(realm, desc.set);\n  }\n}\n\n// Determines if an object with parent O may create its own property P.\nfunction parentPermitsChildPropertyCreation(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  let ownDesc = O.$GetOwnProperty(P);\n  let ownDescValue = !ownDesc\n    ? realm.intrinsics.undefined\n    : ownDesc.value === undefined\n      ? realm.intrinsics.undefined\n      : ownDesc.value;\n  invariant(ownDescValue instanceof Value);\n\n  if (!ownDesc || ownDescValue.mightHaveBeenDeleted()) {\n    // O might not object, so first ask its parent\n    let parent = O.$GetPrototypeOf();\n    if (!(parent instanceof NullValue)) {\n      parent = parent.throwIfNotConcreteObject(); //TODO #1016: deal with abstract parents\n      if (!parentPermitsChildPropertyCreation(realm, parent, P)) return false;\n    }\n\n    // Parent is OK, so if O does not object return true\n    if (!ownDesc) return true; // O has no opinion of its ownDesc\n  }\n  invariant(ownDesc !== undefined);\n\n  // O might have a property P and so might object\n  if (IsDataDescriptor(realm, ownDesc)) {\n    if (ownDesc.writable) {\n      // The grand parent does not object so it is OK that parent does not have P\n      // If parent does have P, it is also OK because it is a writable data property\n      return true;\n    }\n  }\n  // If parent does not have property P, this is too pessimistic, but that is\n  // the caller's problem.\n  return false;\n}\n\nfunction ensureIsNotFinal(realm: Realm, O: ObjectValue, P: void | PropertyKeyValue) {\n  if (O.mightNotBeFinalObject()) {\n    return;\n  }\n\n  // We can't continue because this object is already in its final state.\n  let error = new CompilerDiagnostic(\n    \"Mutating a final object, or an object with unknown properties, after some of those \" +\n      \"properties have already been used, is not supported.\",\n    realm.currentLocation,\n    \"PP0026\",\n    \"FatalError\"\n  );\n  realm.handleError(error);\n  throw new FatalError();\n}\n\nexport class PropertiesImplementation {\n  // ECMA262 9.1.9.1\n  OrdinarySet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    ensureIsNotFinal(realm, O, P);\n    if (!realm.ignoreLeakLogic && O.mightBeHavocedObject()) {\n      // Writing a value to a havoced (because leaked) object leaks the value, so havoc it.\n      Havoc.value(realm, V);\n      if (realm.generator) {\n        realm.generator.emitPropertyAssignment(O, StringKey(P), V);\n      }\n      return true;\n    }\n\n    let weakDeletion = V.mightHaveBeenDeleted();\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let ownDesc be ? O.[[GetOwnProperty]](P).\n    let ownDesc;\n    let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n    if (existingBinding !== undefined || !(O.isPartialObject() && O.isSimpleObject())) ownDesc = O.$GetOwnProperty(P);\n    let ownDescValue = !ownDesc\n      ? realm.intrinsics.undefined\n      : ownDesc.value === undefined\n        ? realm.intrinsics.undefined\n        : ownDesc.value;\n    invariant(ownDescValue instanceof Value);\n\n    // 3. If ownDesc is undefined (or might be), then\n    if (!ownDesc || ownDescValue.mightHaveBeenDeleted()) {\n      // a. Let parent be ? O.[[GetPrototypeOf]]().\n      let parent = O.$GetPrototypeOf();\n\n      // b. If parent is not null, then\n      if (!(parent instanceof NullValue)) {\n        parent = parent.throwIfNotConcreteObject(); //TODO #1016: deal with abstract parents\n        if (!ownDesc) {\n          // i. Return ? parent.[[Set]](P, V, Receiver).\n          return parent.$Set(P, V, Receiver);\n        }\n        // But since we don't know if O has its own property P, the parent might\n        // actually have a say. Give up, unless the parent would be OK with it.\n        if (!parentPermitsChildPropertyCreation(realm, parent, P)) {\n          invariant(ownDescValue instanceof AbstractValue);\n          AbstractValue.reportIntrospectionError(ownDescValue);\n          throw new FatalError();\n        }\n        // Since the parent is OK with us creating a local property for O\n        // we can carry on as if there were no parent.\n      }\n\n      // i. Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.\n      if (!ownDesc)\n        ownDesc = ({\n          value: realm.intrinsics.undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true,\n        }: any);\n    }\n\n    // joined descriptors need special treatment\n    let joinCondition = ownDesc.joinCondition;\n    if (joinCondition !== undefined) {\n      let descriptor2 = ownDesc.descriptor2;\n      ownDesc = ownDesc.descriptor1;\n      let {\n        result: result1,\n        generator: generator1,\n        modifiedBindings: modifiedBindings1,\n        modifiedProperties: modifiedProperties1,\n        createdObjects: createdObjects1,\n      } = Path.withCondition(joinCondition, () => {\n        return ownDesc !== undefined\n          ? realm.evaluateForEffects(() => new BooleanValue(realm, OrdinarySetHelper()), undefined, \"OrdinarySet/1\")\n          : construct_empty_effects(realm);\n      });\n      ownDesc = descriptor2;\n      let {\n        result: result2,\n        generator: generator2,\n        modifiedBindings: modifiedBindings2,\n        modifiedProperties: modifiedProperties2,\n        createdObjects: createdObjects2,\n      } = Path.withInverseCondition(joinCondition, () => {\n        return ownDesc !== undefined\n          ? realm.evaluateForEffects(() => new BooleanValue(realm, OrdinarySetHelper()), undefined, \"OrdinarySet/2\")\n          : construct_empty_effects(realm);\n      });\n\n      // Join the effects, creating an abstract view of what happened, regardless\n      // of the actual value of ownDesc.joinCondition.\n      let joinedEffects = Join.joinForkOrChoose(\n        realm,\n        joinCondition,\n        new Effects(result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1),\n        new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2)\n      );\n      let completion = joinedEffects.result;\n      if (completion instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        completion = realm.composeWithSavedCompletion(completion);\n      }\n      // Note that the effects of (non joining) abrupt branches are not included\n      // in joinedEffects, but are tracked separately inside completion.\n      realm.applyEffects(joinedEffects);\n\n      // return or throw completion\n      if (completion instanceof AbruptCompletion) throw completion;\n      if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n      invariant(completion instanceof Value);\n      return To.ToBooleanPartial(realm, completion);\n    }\n\n    return OrdinarySetHelper();\n\n    function OrdinarySetHelper(): boolean {\n      invariant(ownDesc !== undefined);\n      invariant(ownDescValue instanceof Value);\n      // 4. If IsDataDescriptor(ownDesc) is true, then\n      if (IsDataDescriptor(realm, ownDesc)) {\n        // a. If ownDesc.[[Writable]] is false, return false.\n        if (!ownDesc.writable && !weakDeletion) {\n          // The write will fail if the property actually exists\n          if (ownDescValue.mightHaveBeenDeleted()) {\n            // But maybe it does not and thus would succeed.\n            // Since we don't know what will happen, give up for now.\n            invariant(ownDescValue instanceof AbstractValue);\n            AbstractValue.reportIntrospectionError(ownDescValue);\n            throw new FatalError();\n          }\n          return false;\n        }\n\n        // b. If Type(Receiver) is not Object, return false.\n        Receiver = Receiver.throwIfNotConcrete();\n        if (!(Receiver instanceof ObjectValue)) return false;\n\n        // c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).\n        let existingDescriptor;\n        let binding = InternalGetPropertiesMap(Receiver, P).get(InternalGetPropertiesKey(P));\n        if (binding !== undefined || !(Receiver.isPartialObject() && Receiver.isSimpleObject()))\n          existingDescriptor = Receiver.$GetOwnProperty(P);\n        if (existingDescriptor !== undefined) {\n          if (existingDescriptor.descriptor1 === ownDesc) existingDescriptor = ownDesc;\n          else if (existingDescriptor.descriptor2 === ownDesc) existingDescriptor = ownDesc;\n        }\n        let existingDescValue = !existingDescriptor\n          ? realm.intrinsics.undefined\n          : existingDescriptor.value === undefined\n            ? realm.intrinsics.undefined\n            : existingDescriptor.value;\n        invariant(existingDescValue instanceof Value);\n\n        // d. If existingDescriptor is not undefined, then\n        if (existingDescriptor !== undefined) {\n          // i. If IsAccessorDescriptor(existingDescriptor) is true, return false.\n          if (IsAccessorDescriptor(realm, existingDescriptor)) {\n            invariant(\n              !existingDescValue.mightHaveBeenDeleted(),\n              \"should not fail until weak deletes of accessors are suppported\"\n            );\n            return false;\n          }\n\n          // ii. If existingDescriptor.[[Writable]] is false, return false.\n          if (!existingDescriptor.writable && !(weakDeletion && existingDescriptor.configurable)) {\n            // If we are not sure the receiver actually has a property P we can't just return false here.\n            if (existingDescValue.mightHaveBeenDeleted()) {\n              invariant(existingDescValue instanceof AbstractValue);\n              AbstractValue.reportIntrospectionError(existingDescValue);\n              throw new FatalError();\n            }\n            return false;\n          }\n\n          // iii. Let valueDesc be the PropertyDescriptor{[[Value]]: V}.\n          let valueDesc = { value: V };\n\n          // iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).\n          if (weakDeletion || existingDescValue.mightHaveBeenDeleted()) {\n            // At this point we are not actually sure that Receiver actually has\n            // a property P, however, if it has, we are sure that its a data property,\n            // and that redefining the property with valueDesc will not change the\n            // attributes of the property, so we delete it to make things nice for $DefineOwnProperty.\n            Receiver.$Delete(P);\n            valueDesc = existingDescriptor;\n            valueDesc.value = V;\n          }\n          return Receiver.$DefineOwnProperty(P, valueDesc);\n        } else {\n          // e. Else Receiver does not currently have a property P,\n\n          // i. Return ? CreateDataProperty(Receiver, P, V).\n          return Create.CreateDataProperty(realm, Receiver, P, V);\n        }\n      }\n\n      // 5. Assert: IsAccessorDescriptor(ownDesc) is true.\n      invariant(IsAccessorDescriptor(realm, ownDesc), \"expected accessor\");\n\n      // 6. Let setter be ownDesc.[[Set]].\n      let setter = \"set\" in ownDesc ? ownDesc.set : undefined;\n\n      // 7. If setter is undefined, return false.\n      if (!setter || setter instanceof UndefinedValue) return false;\n\n      // 8. Perform ? Call(setter, Receiver, « V »).\n      Call(realm, setter.throwIfNotConcrete(), Receiver, [V]);\n\n      // 9. Return true.\n      return true;\n    }\n  }\n\n  // ECMA262 6.2.4.4\n  FromPropertyDescriptor(realm: Realm, Desc: ?Descriptor): Value {\n    // 1. If Desc is undefined, return undefined.\n    if (!Desc) return realm.intrinsics.undefined;\n\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n    let obj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 3. Assert: obj is an extensible ordinary object with no own properties.\n    invariant(obj.getExtensible(), \"expected an extensible object\");\n    invariant(!obj.properties.size, \"expected an object with no own properties\");\n\n    // 4. If Desc has a [[Value]] field, then\n    let success = true;\n    if (\"value\" in Desc) {\n      invariant(Desc.value instanceof Value);\n      // a. Perform CreateDataProperty(obj, \"value\", Desc.[[Value]]).\n      success = Create.CreateDataProperty(realm, obj, \"value\", Desc.value) && success;\n    }\n\n    // 5. If Desc has a [[Writable]] field, then\n    if (\"writable\" in Desc) {\n      invariant(Desc.writable !== undefined);\n      // a. Perform CreateDataProperty(obj, \"writable\", Desc.[[Writable]]).\n      success = Create.CreateDataProperty(realm, obj, \"writable\", new BooleanValue(realm, Desc.writable)) && success;\n    }\n\n    // 6. If Desc has a [[Get]] field, then\n    if (\"get\" in Desc) {\n      invariant(Desc.get !== undefined);\n      // a. Perform CreateDataProperty(obj, \"get\", Desc.[[Get]]).\n      success = Create.CreateDataProperty(realm, obj, \"get\", Desc.get) && success;\n    }\n\n    // 7. If Desc has a [[Set]] field, then\n    if (\"set\" in Desc) {\n      invariant(Desc.set !== undefined);\n      // a. Perform CreateDataProperty(obj, \"set\", Desc.[[Set]]).\n      success = Create.CreateDataProperty(realm, obj, \"set\", Desc.set) && success;\n    }\n\n    // 8. If Desc has an [[Enumerable]] field, then\n    if (\"enumerable\" in Desc) {\n      invariant(Desc.enumerable !== undefined);\n      // a. Perform CreateDataProperty(obj, \"enumerable\", Desc.[[Enumerable]]).\n      success =\n        Create.CreateDataProperty(realm, obj, \"enumerable\", new BooleanValue(realm, Desc.enumerable)) && success;\n    }\n\n    // 9. If Desc has a [[Configurable]] field, then\n    if (\"configurable\" in Desc) {\n      invariant(Desc.configurable !== undefined);\n      // a. Perform CreateDataProperty(obj, \"configurable\", Desc.[[Configurable]]).\n      success =\n        Create.CreateDataProperty(realm, obj, \"configurable\", new BooleanValue(realm, Desc.configurable)) && success;\n    }\n\n    // 10. Assert: all of the above CreateDataProperty operations return true.\n    invariant(success, \"fails to create data property\");\n\n    // 11. Return obj.\n    return obj;\n  }\n\n  //\n  OrdinaryDelete(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n    // 2. Let desc be ? O.[[GetOwnProperty]](P).\n    let desc = O.$GetOwnProperty(P);\n\n    // 3. If desc is undefined, return true.\n    if (!desc) {\n      ensureIsNotFinal(realm, O, P);\n      if (!realm.ignoreLeakLogic && O.mightBeHavocedObject()) {\n        if (realm.generator) {\n          realm.generator.emitPropertyDelete(O, StringKey(P));\n        }\n      }\n      return true;\n    }\n\n    // 4. If desc.[[Configurable]] is true, then\n    if (desc.configurable) {\n      ensureIsNotFinal(realm, O, P);\n      if (O.mightBeHavocedObject()) {\n        if (realm.generator) {\n          realm.generator.emitPropertyDelete(O, StringKey(P));\n        }\n        return true;\n      }\n\n      // a. Remove the own property with name P from O.\n      let key = InternalGetPropertiesKey(P);\n      let map = InternalGetPropertiesMap(O, P);\n      let propertyBinding = map.get(key);\n      if (propertyBinding === undefined && O.isPartialObject() && O.isSimpleObject()) {\n        let generator = realm.generator;\n        if (generator) {\n          invariant(typeof key === \"string\" || key instanceof SymbolValue);\n          generator.emitPropertyDelete(O, StringKey(key));\n          return true;\n        }\n      }\n      invariant(propertyBinding !== undefined);\n      realm.recordModifiedProperty(propertyBinding);\n      propertyBinding.descriptor = undefined;\n      InternalUpdatedProperty(realm, O, P, desc);\n\n      // b. Return true.\n      return true;\n    }\n\n    // 5. Return false.\n    return false;\n  }\n\n  // ECMA262 7.3.8\n  DeletePropertyOrThrow(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"expected an object\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n    // 3. Let success be ? O.[[Delete]](P).\n    let success = O.$Delete(P);\n\n    // 4. If success is false, throw a TypeError exception.\n    if (!success) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"couldn't delete property\");\n    }\n\n    // 5. Return success.\n    return success;\n  }\n\n  // ECMA262 6.2.4.6\n  CompletePropertyDescriptor(realm: Realm, Desc: Descriptor): Descriptor {\n    // 1. Assert: Desc is a Property Descriptor.\n\n    // 2. Let like be Record{[[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false}.\n    let like = {\n      value: realm.intrinsics.undefined,\n      get: realm.intrinsics.undefined,\n      set: realm.intrinsics.undefined,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    };\n\n    // 3. If either IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then\n    if (IsGenericDescriptor(realm, Desc) || IsDataDescriptor(realm, Desc)) {\n      // a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].\n      if (!(\"value\" in Desc)) Desc.value = like.value;\n      // b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].\n      if (!(\"writable\" in Desc)) Desc.writable = like.writable;\n    } else {\n      // 4. Else,\n      // a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].\n      if (!(\"get\" in Desc)) Desc.get = like.get;\n      // b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].\n      if (!(\"set\" in Desc)) Desc.set = like.set;\n    }\n\n    // 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].\n    if (!(\"enumerable\" in Desc)) Desc.enumerable = like.enumerable;\n\n    // 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].\n    if (!(\"configurable\" in Desc)) Desc.configurable = like.configurable;\n\n    // 7. Return Desc.\n    return Desc;\n  }\n\n  // ECMA262 9.1.6.2\n  IsCompatiblePropertyDescriptor(realm: Realm, extensible: boolean, Desc: Descriptor, current: ?Descriptor): boolean {\n    // 1. Return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current).\n    return this.ValidateAndApplyPropertyDescriptor(realm, undefined, undefined, extensible, Desc, current);\n  }\n\n  // ECMA262 9.1.6.3\n  ValidateAndApplyPropertyDescriptor(\n    realm: Realm,\n    O: void | ObjectValue,\n    P: void | PropertyKeyValue,\n    extensible: boolean,\n    Desc: Descriptor,\n    current: ?Descriptor\n  ): boolean {\n    // 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.\n    if (O !== undefined) {\n      invariant(P !== undefined);\n      invariant(IsPropertyKey(realm, P));\n    }\n\n    if (current && current.joinCondition !== undefined) {\n      let jc = current.joinCondition;\n      if (Path.implies(jc)) current = current.descriptor1;\n      else if (!AbstractValue.createFromUnaryOp(realm, \"!\", jc, true).mightNotBeTrue()) current = current.descriptor2;\n    }\n\n    // 2. If current is undefined, then\n    if (!current) {\n      // a. If extensible is false, return false.\n      if (!extensible) return false;\n\n      // b. Assert: extensible is true.\n      invariant(extensible === true, \"expected extensible to be true\");\n\n      if (O !== undefined && P !== undefined) {\n        ensureIsNotFinal(realm, O, P);\n        if (!realm.ignoreLeakLogic && O.mightBeHavocedObject()) {\n          havocDescriptor(realm, Desc);\n          if (realm.generator) {\n            realm.generator.emitDefineProperty(O, StringKey(P), Desc);\n          }\n          return true;\n        }\n      }\n\n      // c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then\n      if (IsGenericDescriptor(realm, Desc) || IsDataDescriptor(realm, Desc)) {\n        // i. If O is not undefined, create an own data property named P of object O whose [[Value]],\n        //    [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the\n        //    value of an attribute field of Desc is absent, the attribute of the newly created property is set\n        //    to its default value.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          InternalSetProperty(realm, O, P, {\n            value: \"value\" in Desc ? Desc.value : realm.intrinsics.undefined,\n            writable: \"writable\" in Desc ? Desc.writable : false,\n            enumerable: \"enumerable\" in Desc ? Desc.enumerable : false,\n            configurable: \"configurable\" in Desc ? Desc.configurable : false,\n          });\n          InternalUpdatedProperty(realm, O, P, undefined);\n        }\n      } else {\n        // d. Else Desc must be an accessor Property Descriptor,\n        // i. If O is not undefined, create an own accessor property named P of object O whose [[Get]],\n        //    [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value\n        //    of an attribute field of Desc is absent, the attribute of the newly created property is set to its\n        //    default value.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          InternalSetProperty(realm, O, P, {\n            get: \"get\" in Desc ? Desc.get : realm.intrinsics.undefined,\n            set: \"set\" in Desc ? Desc.set : realm.intrinsics.undefined,\n            enumerable: \"enumerable\" in Desc ? Desc.enumerable : false,\n            configurable: \"configurable\" in Desc ? Desc.configurable : false,\n          });\n          InternalUpdatedProperty(realm, O, P, undefined);\n        }\n      }\n\n      // e. Return true.\n      return true;\n    }\n    this.ThrowIfMightHaveBeenDeleted(current.value);\n\n    // 3. Return true, if every field in Desc is absent.\n    if (!Object.keys(Desc).length) return true;\n\n    // 4. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the\n    // same value as the corresponding field in current when compared using the SameValue algorithm.\n    let identical = true;\n    for (let field in Desc) {\n      if (!(field in current)) {\n        identical = false;\n      } else {\n        let dval = InternalDescriptorPropertyToValue(realm, Desc[field]);\n        let cval = InternalDescriptorPropertyToValue(realm, current[field]);\n        if (dval instanceof ConcreteValue && cval instanceof ConcreteValue) identical = SameValue(realm, dval, cval);\n        else {\n          identical = dval === cval;\n          // This might be false now but true at runtime. This does not\n          // matter because the logic for non identical values will still\n          // do the right thing in the cases below that does not blow up\n          // when dealing with an abstract value.\n        }\n      }\n      if (!identical) break;\n    }\n    // Only return here if the assigment is not temporal.\n    if (identical && (O === realm.$GlobalObject || (O !== undefined && !O.isIntrinsic()))) {\n      return true;\n    }\n\n    // 5. If the [[Configurable]] field of current is false, then\n    if (!current.configurable) {\n      // a. Return false, if the [[Configurable]] field of Desc is true.\n      if (Desc.configurable) return false;\n\n      // b. Return false, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.\n      if (\"enumerable\" in Desc && Desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n\n    if (O !== undefined && P !== undefined) {\n      ensureIsNotFinal(realm, O, P);\n      if (!realm.ignoreLeakLogic && O.mightBeHavocedObject()) {\n        havocDescriptor(realm, Desc);\n        if (realm.generator) {\n          realm.generator.emitDefineProperty(O, StringKey(P), Desc);\n        }\n        return true;\n      }\n    }\n\n    let oldDesc = current;\n    current = cloneDescriptor(current);\n    invariant(current !== undefined);\n\n    // 6. If IsGenericDescriptor(Desc) is true, no further validation is required.\n    if (IsGenericDescriptor(realm, Desc)) {\n    } else if (IsDataDescriptor(realm, current) !== IsDataDescriptor(realm, Desc)) {\n      // 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then\n      // a. Return false, if the [[Configurable]] field of current is false.\n      if (!current.configurable) return false;\n\n      // b. If IsDataDescriptor(current) is true, then\n      if (IsDataDescriptor(realm, current)) {\n        // i. If O is not undefined, convert the property named P of object O from a data property to an accessor property.\n        // Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          let key = InternalGetPropertiesKey(P);\n          let propertyBinding = InternalGetPropertiesMap(O, P).get(key);\n          invariant(propertyBinding !== undefined);\n          delete current.writable;\n          delete current.value;\n          current.get = realm.intrinsics.undefined;\n          current.set = realm.intrinsics.undefined;\n        }\n      } else {\n        // c. Else,\n        // i. If O is not undefined, convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          let key = InternalGetPropertiesKey(P);\n          let propertyBinding = InternalGetPropertiesMap(O, P).get(key);\n          invariant(propertyBinding !== undefined);\n          delete current.get;\n          delete current.set;\n          current.writable = false;\n          current.value = realm.intrinsics.undefined;\n        }\n      }\n    } else if (IsDataDescriptor(realm, current) && IsDataDescriptor(realm, Desc)) {\n      // 8. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then\n      // a. If the [[Configurable]] field of current is false, then\n      if (!current.configurable) {\n        // i. Return false, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.\n        if (!current.writable && Desc.writable) return false;\n\n        // ii. If the [[Writable]] field of current is false, then\n        if (!current.writable) {\n          // 1. Return false, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.\n          let descValue = Desc.value || realm.intrinsics.undefined;\n          invariant(descValue instanceof Value);\n          let currentValue = current.value || realm.intrinsics.undefined;\n          invariant(currentValue instanceof Value);\n          if (Desc.value && !SameValuePartial(realm, descValue, currentValue)) {\n            return false;\n          }\n        }\n      } else {\n        // b. Else the [[Configurable]] field of current is true, so any change is acceptable.\n      }\n    } else {\n      // 9. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,\n      // a. If the [[Configurable]] field of current is false, then\n      if (!current.configurable) {\n        // i. Return false, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.\n        if (Desc.set && !SameValuePartial(realm, Desc.set, current.set || realm.intrinsics.undefined)) return false;\n\n        // ii. Return false, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.\n        if (Desc.get && !SameValuePartial(realm, Desc.get, current.get || realm.intrinsics.undefined)) return false;\n      }\n    }\n\n    // 10. If O is not undefined, then\n    if (O !== undefined) {\n      invariant(P !== undefined);\n      let key = InternalGetPropertiesKey(P);\n      let map = InternalGetPropertiesMap(O, P);\n      let propertyBinding = map.get(key);\n      if (propertyBinding === undefined) {\n        propertyBinding = { descriptor: undefined, object: O, key: key };\n        realm.recordModifiedProperty(propertyBinding);\n        propertyBinding.descriptor = current;\n        map.set(key, propertyBinding);\n      } else if (propertyBinding.descriptor === undefined) {\n        realm.recordModifiedProperty(propertyBinding);\n        propertyBinding.descriptor = current;\n      } else {\n        realm.recordModifiedProperty(propertyBinding);\n        propertyBinding.descriptor = current;\n      }\n\n      // a. For each field of Desc that is present, set the corresponding attribute of the property named P of\n      //    object O to the value of the field.\n      for (let field in Desc) current[field] = Desc[field];\n      InternalUpdatedProperty(realm, O, P, oldDesc);\n    }\n\n    // 11. Return true.\n    return true;\n  }\n\n  // ECMA262 9.1.6.1\n  OrdinaryDefineOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, Desc: Descriptor): boolean {\n    invariant(O instanceof ObjectValue);\n\n    // 1. Let current be ? O.[[GetOwnProperty]](P).\n    let current;\n    let binding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n    if (binding !== undefined || !(O.isPartialObject() && O.isSimpleObject())) current = O.$GetOwnProperty(P);\n\n    // 2. Let extensible be the value of the [[Extensible]] internal slot of O.\n    let extensible = O.getExtensible();\n\n    // 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).\n    return this.ValidateAndApplyPropertyDescriptor(realm, O, P, extensible, Desc, current);\n  }\n\n  // ECMA262 19.1.2.3.1\n  ObjectDefineProperties(realm: Realm, O: Value, Properties: Value): ObjectValue | AbstractObjectValue {\n    // 1. If Type(O) is not Object, throw a TypeError exception.\n    if (O.mightNotBeObject()) {\n      if (O.mightBeObject()) O.throwIfNotConcrete();\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n    invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue);\n\n    // 2. Let props be ? ToObject(Properties).\n    let props = To.ToObject(realm, Properties);\n\n    // 3. Let keys be ? props.[[OwnPropertyKeys]]().\n    let keys = props.$OwnPropertyKeys();\n\n    // 4. Let descriptors be a new empty List.\n    let descriptors = [];\n\n    // 5. Repeat for each element nextKey of keys in List order,\n    for (let nextKey of keys) {\n      // a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).\n      let propDesc = props.$GetOwnProperty(nextKey);\n\n      // b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then\n      if (propDesc && propDesc.enumerable) {\n        this.ThrowIfMightHaveBeenDeleted(propDesc.value);\n\n        // i. Let descObj be ? Get(props, nextKey).\n        let descObj = Get(realm, props, nextKey);\n\n        // ii. Let desc be ? ToPropertyDescriptor(descObj).\n        let desc = To.ToPropertyDescriptor(realm, descObj);\n\n        // iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.\n        descriptors.push([nextKey, desc]);\n      }\n    }\n\n    // 6. For each pair from descriptors in list order,\n    for (let pair of descriptors) {\n      // a. Let P be the first element of pair.\n      let P = pair[0];\n\n      // b. Let desc be the second element of pair.\n      let desc = pair[1];\n\n      // c. Perform ? DefinePropertyOrThrow(O, P, desc).\n      this.DefinePropertyOrThrow(realm, O, P, desc);\n    }\n\n    // 7. Return O.\n    return O;\n  }\n\n  // ECMA262 7.3.3\n  Set(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value, Throw: boolean): boolean {\n    // 1. Assert: Type(O) is Object.\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 3. Assert: Type(Throw) is Boolean.\n    invariant(typeof Throw === \"boolean\", \"expected boolean\");\n\n    // 4. Let success be ? O.[[Set]](P, V, O).\n    let success = O.$Set(P, V, O);\n\n    // 5. If success is false and Throw is true, throw a TypeError exception.\n    if (success === false && Throw === true) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. Return success.\n    return success;\n  }\n\n  // ECMA262 7.3.7\n  DefinePropertyOrThrow(\n    realm: Realm,\n    O: ObjectValue | AbstractObjectValue,\n    P: PropertyKeyValue,\n    desc: Descriptor\n  ): boolean {\n    // 1. Assert: Type(O) is Object.\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(typeof P === \"string\" || IsPropertyKey(realm, P), \"expected property key\");\n\n    // 3. Let success be ? O.[[DefineOwnProperty]](P, desc).\n    let success = O.$DefineOwnProperty(P, desc);\n\n    // 4. If success is false, throw a TypeError exception.\n    if (success === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 5. Return success.\n    return success;\n  }\n\n  // ECMA262 6.2.3.2\n  PutValue(realm: Realm, V: Value | Reference, W: Value): void | boolean | Value {\n    W = W.promoteEmptyToUndefined();\n    // The following two steps are not necessary as we propagate completions with exceptions.\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n\n    // 3. If Type(V) is not Reference, throw a ReferenceError exception.\n    if (!(V instanceof Reference)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, \"can't put a value to a non-reference\");\n    }\n\n    // 4. Let base be GetBase(V).\n    let base = Environment.GetBase(realm, V);\n\n    // 5. If IsUnresolvableReference(V) is true, then\n    if (Environment.IsUnresolvableReference(realm, V)) {\n      // a. If IsStrictReference(V) is true, then\n      if (Environment.IsStrictReference(realm, V)) {\n        // i. Throw a ReferenceError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n\n      // b. Let globalObj be GetGlobalObject().\n      let globalObj = GetGlobalObject(realm);\n\n      // c. Return ? Set(globalObj, GetReferencedName(V), W, false).\n      return this.Set(realm, globalObj, Environment.GetReferencedName(realm, V), W, false);\n    }\n\n    // 6. Else if IsPropertyReference(V) is true, then\n    if (Environment.IsPropertyReference(realm, V)) {\n      if (base instanceof AbstractValue) {\n        // Ensure that abstract values are coerced to objects. This might yield\n        // an operation that might throw.\n        base = To.ToObject(realm, base);\n      }\n      // a. If HasPrimitiveBase(V) is true, then\n      if (Environment.HasPrimitiveBase(realm, V)) {\n        // i. Assert: In realm case, base will never be null or undefined.\n        invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n        // ii. Set base to ToObject(base).\n        base = To.ToObject(realm, base);\n      }\n      invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n      // b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).\n      let succeeded = base.$SetPartial(Environment.GetReferencedNamePartial(realm, V), W, GetThisValue(realm, V));\n\n      // c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.\n      if (succeeded === false && Environment.IsStrictReference(realm, V)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // d. Return.\n      return;\n    }\n\n    // 7. Else base must be an Environment Record,\n    if (base instanceof EnvironmentRecord) {\n      // a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).\n      let referencedName = Environment.GetReferencedName(realm, V);\n      invariant(typeof referencedName === \"string\");\n      return base.SetMutableBinding(referencedName, W, Environment.IsStrictReference(realm, V));\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 9.4.2.4\n  ArraySetLength(realm: Realm, A: ArrayValue, Desc: Descriptor): boolean {\n    // 1. If the [[Value]] field of Desc is absent, then\n    let DescValue = Desc.value;\n    if (!DescValue) {\n      // a. Return OrdinaryDefineOwnProperty(A, \"length\", Desc).\n      return this.OrdinaryDefineOwnProperty(realm, A, \"length\", Desc);\n    }\n    invariant(DescValue instanceof Value);\n\n    // 2. Let newLenDesc be a copy of Desc.\n    let newLenDesc = Object.assign({}, Desc);\n\n    // 3. Let newLen be ? ToUint32(Desc.[[Value]]).\n    let newLen = To.ToUint32(realm, DescValue);\n\n    // 4. Let numberLen be ? ToNumber(Desc.[[Value]]).\n    let numberLen = To.ToNumber(realm, DescValue);\n\n    // 5. If newLen ≠ numberLen, throw a RangeError exception.\n    if (newLen !== numberLen) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"should be a uint\");\n    }\n\n    // 6. Set newLenDesc.[[Value]] to newLen.\n    newLenDesc.value = new NumberValue(realm, newLen);\n\n    // 7. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n    let oldLenDesc = this.OrdinaryGetOwnProperty(realm, A, \"length\");\n\n    // 8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created\n    //    with a length data property that cannot be deleted or reconfigured.\n    invariant(\n      oldLenDesc !== undefined && !IsAccessorDescriptor(realm, oldLenDesc),\n      \"cannot be undefined or an accessor descriptor\"\n    );\n\n    // 9. Let oldLen be oldLenDesc.[[Value]].\n    let oldLen = oldLenDesc.value;\n    invariant(oldLen instanceof Value);\n    oldLen = oldLen.throwIfNotConcrete();\n    invariant(oldLen instanceof NumberValue, \"should be a number\");\n    oldLen = (oldLen.value: number);\n\n    // 10. If newLen ≥ oldLen, then\n    if (newLen >= oldLen) {\n      // a. Return OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n      return this.OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n    }\n\n    // 11. If oldLenDesc.[[Writable]] is false, return false.\n    if (!oldLenDesc.writable) return false;\n\n    // 12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.\n    let newWritable;\n    if (!(\"writable\" in newLenDesc) || newLenDesc.writable === true) {\n      newWritable = true;\n    } else {\n      // 13. Else,\n      // a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.\n\n      // b. Let newWritable be false.\n      newWritable = false;\n\n      // c. Set newLenDesc.[[Writable]] to true.\n      newLenDesc.writable = true;\n    }\n\n    // 14. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n    let succeeded = this.OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n\n    // 15. If succeeded is false, return false.\n    if (succeeded === false) return false;\n\n    // Here we diverge from the spec: instead of traversing all indices from\n    // oldLen to newLen, only the indices that are actually present are touched.\n    let oldLenCopy = oldLen;\n    let keys = Array.from(A.properties.keys())\n      .map(x => parseInt(x, 10))\n      .filter(x => newLen <= x && x <= oldLenCopy)\n      .sort()\n      .reverse();\n\n    // 16. While newLen < oldLen repeat,\n    for (let key of keys) {\n      // a. Set oldLen to oldLen - 1.\n      oldLen = key;\n\n      // b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).\n      let deleteSucceeded = A.$Delete(oldLen + \"\");\n\n      // c. If deleteSucceeded is false, then\n      if (deleteSucceeded === false) {\n        // i. Set newLenDesc.[[Value]] to oldLen + 1.\n        newLenDesc.value = new NumberValue(realm, oldLen + 1);\n\n        // ii. If newWritable is false, set newLenDesc.[[Writable]] to false.\n        if (newWritable === false) newLenDesc.writable = false;\n\n        // iii. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n        succeeded = this.OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n\n        // iv. Return false.\n        return false;\n      }\n    }\n\n    // 17. If newWritable is false, then\n    if (!newWritable) {\n      // a. Return OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Writable]]: false}). This call will always return true.\n      return this.OrdinaryDefineOwnProperty(realm, A, \"length\", {\n        writable: false,\n      });\n    }\n\n    // 18. Return true.\n    return true;\n  }\n\n  // ECMA262 9.1.5.1\n  OrdinaryGetOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): Descriptor | void {\n    // if the object is havoced and final, then it's still safe to read the value from the object\n    if (!realm.ignoreLeakLogic && O.mightBeHavocedObject()) {\n      if (!O.mightNotBeFinalObject()) {\n        let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n        if (existingBinding && existingBinding.descriptor) {\n          return existingBinding.descriptor;\n        } else {\n          return undefined;\n        }\n      }\n\n      invariant(realm.generator);\n      let absVal = AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        [O._templateFor || O],\n        ([node]) => memberExpressionHelper(node, StringKey(P)),\n        { isPure: true }\n      );\n      // TODO: We can't be sure what the descriptor will be, but the value will be abstract.\n      return { configurable: true, enumerable: true, value: absVal, writable: true };\n    }\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n    // 2. If O does not have an own property with key P, return undefined.\n    let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n    if (!existingBinding) {\n      if (O.isPartialObject()) {\n        invariant(realm.useAbstractInterpretation); // __makePartial will already have thrown an error if not\n        if (O.isSimpleObject()) {\n          if (P instanceof StringValue) P = P.value;\n          if (typeof P === \"string\") {\n            // In this case it is safe to defer the property access to runtime (at this point in time)\n            invariant(realm.generator);\n            let absVal;\n            function createAbstractPropertyValue(type: typeof Value) {\n              if (O.isTransitivelySimple()) {\n                invariant(typeof P === \"string\");\n                return AbstractValue.createFromBuildFunction(\n                  realm,\n                  type,\n                  [O._templateFor || O],\n                  ([node]) => {\n                    invariant(typeof P === \"string\");\n                    return memberExpressionHelper(node, P);\n                  },\n                  { kind: AbstractValue.makeKind(\"property\", P) }\n                );\n              } else {\n                return AbstractValue.createTemporalFromBuildFunction(\n                  realm,\n                  type,\n                  [O._templateFor || O],\n                  ([node]) => {\n                    invariant(typeof P === \"string\");\n                    return memberExpressionHelper(node, P);\n                  },\n                  { skipInvariant: true, isPure: true }\n                );\n              }\n            }\n            if (O.isTransitivelySimple()) {\n              absVal = createAbstractPropertyValue(ObjectValue);\n              invariant(absVal instanceof AbstractObjectValue);\n              absVal.makeSimple(\"transitive\");\n              absVal = AbstractValue.createAbstractConcreteUnion(\n                realm,\n                absVal,\n                realm.intrinsics.undefined,\n                realm.intrinsics.null\n              );\n            } else {\n              absVal = createAbstractPropertyValue(Value);\n            }\n            return { configurable: true, enumerable: true, value: absVal, writable: true };\n          } else {\n            invariant(P instanceof SymbolValue);\n            // Simple objects don't have symbol properties\n            return undefined;\n          }\n        }\n        AbstractValue.reportIntrospectionError(O, P);\n        throw new FatalError();\n      } else if (\n        realm.invariantLevel >= 2 &&\n        O.isIntrinsic() &&\n        !ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O)\n      ) {\n        let realmGenerator = realm.generator;\n        // TODO: Because global variables are special, checking for missing global object properties doesn't quite work yet.\n        if (\n          realmGenerator &&\n          typeof P === \"string\" &&\n          O !== realm.$GlobalObject &&\n          !realm.hasBindingBeenChecked(O, P)\n        ) {\n          realm.markPropertyAsChecked(O, P);\n          realmGenerator.emitPropertyInvariant(O, P, \"MISSING\");\n        }\n      }\n      return undefined;\n    }\n    realm.callReportPropertyAccess(existingBinding);\n    if (!existingBinding.descriptor) {\n      if (realm.invariantLevel >= 2 && O.isIntrinsic()) {\n        let realmGenerator = realm.generator;\n        // TODO: Because global variables are special, checking for missing global object properties doesn't quite work yet.\n        if (\n          realmGenerator &&\n          typeof P === \"string\" &&\n          O !== realm.$GlobalObject &&\n          !realm.hasBindingBeenChecked(O, P)\n        ) {\n          realm.markPropertyAsChecked(O, P);\n          realmGenerator.emitPropertyInvariant(O, P, \"MISSING\");\n        }\n      }\n      return undefined;\n    }\n\n    // 3. Let D be a newly created Property Descriptor with no fields.\n    let D = {};\n\n    // 4. Let X be O's own property whose key is P.\n    let X = existingBinding.descriptor;\n    invariant(X !== undefined);\n\n    if (X.joinCondition !== undefined) {\n      D.joinCondition = X.joinCondition;\n      D.descriptor1 = X.descriptor1;\n      D.descriptor2 = X.descriptor2;\n      return D;\n    }\n    // 5. If X is a data property, then\n    if (IsDataDescriptor(realm, X)) {\n      let value = X.value;\n      if (O.isIntrinsic() && O.isPartialObject()) {\n        if (value instanceof AbstractValue) {\n          let savedUnion;\n          let savedIndex;\n          if (value.kind === \"abstractConcreteUnion\") {\n            savedUnion = value;\n            savedIndex = savedUnion.args.findIndex(e => e instanceof AbstractValue);\n            invariant(savedIndex >= 0);\n            value = savedUnion.args[savedIndex];\n            invariant(value instanceof AbstractValue);\n          }\n          if (value.kind !== \"resolved\") {\n            let realmGenerator = realm.generator;\n            invariant(realmGenerator);\n            value = realmGenerator.deriveAbstract(value.types, value.values, value.args, value.getBuildNode(), {\n              isPure: true,\n              kind: \"resolved\",\n              // We can't emit the invariant here otherwise it'll assume the AbstractValue's type not the union type\n              skipInvariant: true,\n            });\n            if (savedUnion !== undefined) {\n              invariant(savedIndex !== undefined);\n              let args = savedUnion.args.slice(0);\n              args[savedIndex] = value;\n              value = AbstractValue.createAbstractConcreteUnion(realm, ...args);\n            }\n            if (realm.invariantLevel >= 1 && typeof P === \"string\" && !realm.hasBindingBeenChecked(O, P)) {\n              realm.markPropertyAsChecked(O, P);\n              realmGenerator.emitFullInvariant(O, P, value);\n            }\n            InternalSetProperty(realm, O, P, {\n              value: value,\n              writable: \"writable\" in X ? X.writable : false,\n              enumerable: \"enumerable\" in X ? X.enumerable : false,\n              configurable: \"configurable\" in X ? X.configurable : false,\n            });\n          }\n        } else if (realm.invariantLevel >= 1 && value instanceof Value && !(value instanceof AbstractValue)) {\n          let realmGenerator = realm.generator;\n          invariant(realmGenerator);\n          if (typeof P === \"string\" && !realm.hasBindingBeenChecked(O, P)) {\n            realm.markPropertyAsChecked(O, P);\n            realmGenerator.emitFullInvariant(O, P, value);\n          }\n        }\n      } else {\n        // TODO: Because global variables are special, checking for global object properties doesn't quite work yet.\n        if (O !== realm.$GlobalObject && O.isIntrinsic() && realm.invariantLevel >= 2 && value instanceof Value) {\n          let realmGenerator = realm.generator;\n          if (realmGenerator && typeof P === \"string\" && !realm.hasBindingBeenChecked(O, P)) {\n            realm.markPropertyAsChecked(O, P);\n            realmGenerator.emitFullInvariant(O, P, value);\n          }\n        }\n      }\n\n      // a. Set D.[[Value]] to the value of X's [[Value]] attribute.\n      D.value = value;\n\n      // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.\n      D.writable = X.writable;\n    } else {\n      // 6. Else X is an accessor property,\n      invariant(IsAccessorDescriptor(realm, X), \"expected accessor property\");\n\n      // a. Set D.[[Get]] to the value of X's [[Get]] attribute.\n      D.get = X.get;\n\n      // b. Set D.[[Set]] to the value of X's [[Set]] attribute.\n      D.set = X.set;\n    }\n\n    // 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.\n    D.enumerable = X.enumerable;\n\n    // 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.\n    D.configurable = X.configurable;\n\n    // 9. Return D.\n    return D;\n  }\n\n  // ECMA262 9.1.2.1\n  OrdinarySetPrototypeOf(realm: Realm, O: ObjectValue, V: ObjectValue | NullValue): boolean {\n    ensureIsNotFinal(realm, O);\n    if (!realm.ignoreLeakLogic && O.mightBeHavocedObject()) {\n      throw new FatalError();\n    }\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    invariant(V instanceof ObjectValue || V instanceof NullValue);\n\n    // 2. Let extensible be the value of the [[Extensible]] internal slot of O.\n    let extensible = O.getExtensible();\n\n    // 3. Let current be the value of the [[Prototype]] internal slot of O.\n    let current = O.$Prototype;\n\n    // 4. If SameValue(V, current) is true, return true.\n    if (SameValuePartial(realm, V, current)) return true;\n\n    // 5. If extensible is false, return false.\n    if (!extensible) return false;\n\n    // 6. Let p be V.\n    let p = V;\n\n    // 7. Let done be false.\n    let done = false;\n\n    // 8. Repeat while done is false,\n    while (!done) {\n      // a. If p is null, let done be true.\n      if (p instanceof NullValue) {\n        done = true;\n      } else if (SameValuePartial(realm, p, O)) {\n        // b. Else if SameValue(p, O) is true, return false.\n        return false;\n      } else {\n        // c. Else,\n        // If the [[GetPrototypeOf]] internal method of p is not the ordinary object internal method defined in 9.1.1, let done be true.\n        if (!p.usesOrdinaryObjectInternalPrototypeMethods()) {\n          done = true;\n        } else {\n          // ii. Else, let p be the value of p's [[Prototype]] internal slot.\n          p = p.$Prototype;\n          if (p instanceof AbstractObjectValue) {\n            AbstractValue.reportIntrospectionError(p);\n            throw new FatalError();\n          }\n        }\n      }\n    }\n\n    // 9. Set the value of the [[Prototype]] internal slot of O to V.\n    O.$Prototype = V;\n\n    // 10. Return true.\n    return true;\n  }\n\n  // ECMA262 13.7.5.15\n  EnumerateObjectProperties(realm: Realm, O: ObjectValue): ObjectValue {\n    /*global global*/\n    let visited = new global.Set();\n    let obj = O;\n    let keys = O.$OwnPropertyKeys();\n    let index = 0;\n\n    let iterator = new ObjectValue(realm);\n    iterator.defineNativeMethod(\"next\", 0, () => {\n      while (true) {\n        if (index >= keys.length) {\n          let proto = obj.$GetPrototypeOf();\n          if (proto instanceof NullValue) {\n            return Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);\n          }\n          obj = proto;\n          keys = obj.$OwnPropertyKeys();\n          index = 0;\n        }\n\n        let key = keys[index];\n\n        // Omit symbols.\n        if (!(key instanceof StringValue)) {\n          index += 1;\n          continue;\n        }\n\n        // Omit non-enumerable properties.\n        let desc = obj.$GetOwnProperty(key);\n        if (desc && !desc.enumerable) {\n          this.ThrowIfMightHaveBeenDeleted(desc.value);\n          index += 1;\n          visited.add(key.value);\n          continue;\n        }\n\n        // Omit duplicates.\n        if (visited.has(key.value)) {\n          index += 1;\n          continue;\n        }\n        visited.add(key.value);\n\n        // Yield the key.\n        return Create.CreateIterResultObject(realm, key, false);\n      }\n    });\n    return iterator;\n  }\n\n  ThrowIfMightHaveBeenDeleted(\n    value: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): void {\n    if (!(value instanceof Value)) return;\n    if (!value.mightHaveBeenDeleted()) return;\n    invariant(value instanceof AbstractValue); // real empty values should never get here\n    let v = value.$Realm.simplifyAndRefineAbstractValue(value);\n    if (!v.mightHaveBeenDeleted()) return;\n    AbstractValue.reportIntrospectionError(value);\n    throw new FatalError();\n  }\n\n  ThrowIfInternalSlotNotWritable<T: ObjectValue>(realm: Realm, object: T, key: string): T {\n    if (!realm.isNewObject(object)) {\n      AbstractValue.reportIntrospectionError(object, key);\n      throw new FatalError();\n    }\n    return object;\n  }\n\n  // ECMA 14.3.9\n  PropertyDefinitionEvaluation(\n    realm: Realm,\n    MethodDefinition: BabelNodeObjectMethod | BabelNodeClassMethod,\n    object: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    enumerable: boolean\n  ): boolean {\n    // MethodDefinition : PropertyName ( StrictFormalParameters ) { FunctionBody }\n    if (MethodDefinition.kind === \"method\") {\n      // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.\n      let methodDef = Functions.DefineMethod(realm, MethodDefinition, object, env, strictCode);\n\n      // 2. ReturnIfAbrupt(methodDef).\n\n      // 3. Perform SetFunctionName(methodDef.[[closure]], methodDef.[[key]]).\n      Functions.SetFunctionName(realm, methodDef.$Closure, methodDef.$Key);\n\n      // If the AST name was computed, give the hint to the closure\n      methodDef.$Closure.$HasComputedName = !!MethodDefinition.computed;\n\n      // 4. Let desc be the Property Descriptor{[[Value]]: methodDef.[[closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc: Descriptor = { value: methodDef.$Closure, writable: true, enumerable: enumerable, configurable: true };\n\n      // 5. Return DefinePropertyOrThrow(object, methodDef.[[key]], desc).\n      return this.DefinePropertyOrThrow(realm, object, methodDef.$Key, desc);\n    } else if (MethodDefinition.kind === \"generator\") {\n      // MethodDefinition : GeneratorMethod\n      // See 14.4.\n      // ECMA 14.4.13\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n      // 3. If the function code for this GeneratorMethod is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(MethodDefinition.body);\n\n      // 4. Let scope be the running execution context’s LexicalEnvironment.\n      let scope = env;\n\n      // 5. Let closure be GeneratorFunctionCreate(Method, StrictFormalParameters, GeneratorBody, scope, strict).\n      let closure = Functions.GeneratorFunctionCreate(\n        realm,\n        \"method\",\n        MethodDefinition.params,\n        MethodDefinition.body,\n        scope,\n        strict\n      );\n\n      // 6. Perform MakeMethod(closure, object).\n      Functions.MakeMethod(realm, closure, object);\n\n      // 7. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 8. Perform MakeConstructor(closure, true, prototype).\n      MakeConstructor(realm, closure, true, prototype);\n\n      // 9. Perform SetFunctionName(closure, propKey).\n      Functions.SetFunctionName(realm, closure, propKey);\n\n      // 10. Let desc be the Property Descriptor{[[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc: Descriptor = { value: closure, writable: true, enumerable: enumerable, configurable: true };\n\n      // 11. Return DefinePropertyOrThrow(object, propKey, desc).\n      return this.DefinePropertyOrThrow(realm, object, propKey, desc);\n    } else if (MethodDefinition.kind === \"get\") {\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(MethodDefinition.body);\n\n      // 4. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 5. Let formalParameterList be the production FormalParameters:[empty] .\n      let formalParameterList = [];\n\n      // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(\n        realm,\n        \"method\",\n        formalParameterList,\n        MethodDefinition.body,\n        scope,\n        strict\n      );\n\n      // 7. Perform MakeMethod(closure, object).\n      Functions.MakeMethod(realm, closure, object);\n\n      // 8. Perform SetFunctionName(closure, propKey, \"get\").\n      Functions.SetFunctionName(realm, closure, propKey, \"get\");\n\n      // If the AST name was computed, give the hint to the closure\n      closure.$HasComputedName = !!MethodDefinition.computed;\n\n      // 9. Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc = {\n        get: closure,\n        enumerable: true,\n        configurable: true,\n      };\n\n      // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).\n      return this.DefinePropertyOrThrow(realm, object, propKey, desc);\n    } else {\n      invariant(MethodDefinition.kind === \"set\");\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(MethodDefinition.body);\n\n      // 4. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(\n        realm,\n        \"method\",\n        MethodDefinition.params,\n        MethodDefinition.body,\n        scope,\n        strict\n      );\n\n      // 6. Perform MakeMethod(closure, object).\n      Functions.MakeMethod(realm, closure, object);\n\n      // 7. Perform SetFunctionName(closure, propKey, \"set\").\n      Functions.SetFunctionName(realm, closure, propKey, \"set\");\n\n      // If the AST name was computed, give the hint to the closure\n      closure.$HasComputedName = !!MethodDefinition.computed;\n\n      // 8. Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc = {\n        set: closure,\n        enumerable: true,\n        configurable: true,\n      };\n\n      // 9. Return ? DefinePropertyOrThrow(object, propKey, desc).\n      return this.DefinePropertyOrThrow(realm, object, propKey, desc);\n    }\n  }\n}\n"]}