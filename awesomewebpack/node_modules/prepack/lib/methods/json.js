"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalizeJSONProperty = InternalizeJSONProperty;

var _index = require("../values/index.js");

var _singletons = require("../singletons.js");

var _get = require("../methods/get.js");

var _call = require("../methods/call.js");

var _is = require("../methods/is.js");

var _own = require("../methods/own.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 24.3.1.1
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

function InternalizeJSONProperty(realm, reviver, holder, name) {
  // 1. Let val be ? Get(holder, name).
  let val = (0, _get.Get)(realm, holder, name);
  // 2. If Type(val) is Object, then
  if (val instanceof _index.ObjectValue) {
    // a. Let isArray be ? IsArray(val).
    let isArray = (0, _is.IsArray)(realm, val);

    // b. If isArray is true, then
    if (isArray === true) {
      // i. Set I to 0.
      let I = 0;

      // ii. Let len be ? ToLength(? Get(val, "length")).
      let len = _singletons.To.ToLength(realm, (0, _get.Get)(realm, val, "length"));

      // iii. Repeat while I < len,
      while (I < len) {
        // 1. Let newElement be ? InternalizeJSONProperty(val, ! ToString(I)).
        let newElement = InternalizeJSONProperty(realm, reviver, val, _singletons.To.ToString(realm, new _index.NumberValue(realm, I)));

        // 2. If newElement is undefined, then
        if (newElement instanceof _index.UndefinedValue) {
          // a. Perform ? val.[[Delete]](! ToString(I)).
          val.$Delete(_singletons.To.ToString(realm, new _index.NumberValue(realm, I)));
        } else {
          // 3. Else,
          // a. Perform ? CreateDataProperty(val, ! ToString(I), newElement).
          _singletons.Create.CreateDataProperty(realm, val, _singletons.To.ToString(realm, new _index.NumberValue(realm, I)), newElement.throwIfNotConcrete());

          // b. NOTE This algorithm intentionally does not throw an exception if CreateDataProperty returns false.
        }

        // 4. Add 1 to I.
        I += 1;
      }
    } else {
      // c. Else,
      // i. Let keys be ? EnumerableOwnProperties(val, "key").
      let keys = (0, _own.EnumerableOwnProperties)(realm, val, "key");

      // ii. For each String P in keys do,
      for (let P of keys) {
        (0, _invariant2.default)(P instanceof _index.StringValue);

        // 1. Let newElement be ? InternalizeJSONProperty(val, P).
        let newElement = InternalizeJSONProperty(realm, reviver, val, P);

        // 2. If newElement is undefined, then
        if (newElement instanceof _index.UndefinedValue) {
          // a. Perform ? val.[[Delete]](P).
          val.$Delete(P);
        } else {
          // 3. Else,
          // a. Perform ? CreateDataProperty(val, P, newElement).
          _singletons.Create.CreateDataProperty(realm, val, P, newElement);

          // b. NOTE This algorithm intentionally does not throw an exception if CreateDataProperty returns false.
        }
      }
    }
  }

  // 3. Return ? Call(reviver, holder, « name, val »).
  return (0, _call.Call)(realm, reviver, holder, [typeof name === "string" ? new _index.StringValue(realm, name) : name, val]);
}
//# sourceMappingURL=json.js.map