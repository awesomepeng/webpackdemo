{"version":3,"sources":["../../src/methods/widen.js"],"names":["t","WidenImplementation","_widenArrays","realm","v1","v2","_widenArraysOfValues","_widenArrayOfsMapEntries","a1","a2","n","Math","max","length","result","i","$Key","key1","$Value","val1","undefined","key2","val2","key3","widenValues","val3","wv","widenEffects","e1","e2","widenResults","bindings","widenBindings","modifiedBindings","properties","widenPropertyBindings","modifiedProperties","createdObjects","Set","generator","pathConditions","result1","result2","val","value","widenMaps","m1","m2","widen","m3","Map","forEach","key","map1","get","set","map2","has","b","b1","b2","intrinsics","kind","phiNode","deriveAbstract","types","values","skipInvariant","intrinsicName","phiName","_buildNode","args","identifier","previousHasLeaked","previousValue","hasLeaked","Array","isArray","throwIfNotConcrete","createFromWidening","c1","c2","d1","d2","object","descriptor","empty","widenDescriptors","rval","pathNode","mightNotBeString","mightNotBeNumber","createFromWidenedProperty","o","p","initVal","emitVoidExpression","v","assignmentExpression","dc","d2value","d1value","containsEffects","containsResults","containsBindings","containsPropertyBindings","_containsValues","containsMap","f","entries","keys","containsBinding","containsPropertyBinding","_containsArray","e","containsArraysOfValue","_containsArrayOfsMapEntries","equals","isTypeCompatibleWith","getType","containsValue"],"mappings":"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","file":"widen.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Bindings, BindingEntry, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport { AbruptCompletion, PossiblyNormalCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ArrayValue, EmptyValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\nimport { memberExpressionHelper } from \"../utils/babelhelpers.js\";\n\nexport class WidenImplementation {\n  _widenArrays(\n    realm: Realm,\n    v1: Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (v1[0] instanceof Value) {\n      invariant(v2[0] instanceof Value);\n      return this._widenArraysOfValues(realm, (v1: any), (v2: any));\n    }\n    invariant(!(v2[0] instanceof Value));\n    return this._widenArrayOfsMapEntries(realm, (v1: any), (v2: any));\n  }\n\n  _widenArrayOfsMapEntries(\n    realm: Realm,\n    a1: Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Array<{ $Key: void | Value, $Value: void | Value }> {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result: Array<{ $Key: void | Value, $Value: void | Value }> = [];\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = a1[i] || { $Key: undefined, $Value: undefined };\n      let { $Key: key2, $Value: val2 } = a2[i] || { $Key: undefined, $Value: undefined };\n      if (key1 === undefined && key2 === undefined) {\n        result[i] = { $Key: undefined, $Value: undefined };\n      } else {\n        if (key1 === undefined) key1 = key2;\n        else if (key2 === undefined) key2 = key1;\n        invariant(key1 !== undefined);\n        invariant(key2 !== undefined);\n        let key3 = this.widenValues(realm, key1, key2);\n        invariant(key3 instanceof Value);\n        if (val1 === undefined && val2 === undefined) {\n          result[i] = { $Key: key3, $Value: undefined };\n        } else {\n          if (val1 === undefined) val1 = val2;\n          else if (val2 === undefined) val2 = val1;\n          invariant(val1 !== undefined);\n          invariant(val2 !== undefined);\n          let val3 = this.widenValues(realm, val1, val2);\n          invariant(val3 === undefined || val3 instanceof Value);\n          result[i] = { $Key: key3, $Value: val3 };\n        }\n      }\n    }\n    return result;\n  }\n\n  _widenArraysOfValues(realm: Realm, a1: Array<Value>, a2: Array<Value>): Array<Value> {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    let result = [];\n    for (let i = 0; i < n; i++) {\n      let wv = this.widenValues(realm, a1[i], a2[i]);\n      invariant(wv === undefined || wv instanceof Value);\n      result[i] = wv;\n    }\n    return result;\n  }\n\n  // Returns a new effects summary that includes both e1 and e2.\n  widenEffects(realm: Realm, e1: Effects, e2: Effects): Effects {\n    let result = this.widenResults(realm, e1.result, e2.result);\n    let bindings = this.widenBindings(realm, e1.modifiedBindings, e2.modifiedBindings);\n    let properties = this.widenPropertyBindings(\n      realm,\n      e1.modifiedProperties,\n      e2.modifiedProperties,\n      e1.createdObjects,\n      e2.createdObjects\n    );\n    let createdObjects = new Set(); // Top, since the empty set knows nothing. There is no other choice for widen.\n    let generator = new Generator(realm, \"widen\", realm.pathConditions); // code subject to widening will be generated somewhere else\n    return new Effects(result, generator, bindings, properties, createdObjects);\n  }\n\n  widenResults(\n    realm: Realm,\n    result1: EvaluationResult,\n    result2: EvaluationResult\n  ): PossiblyNormalCompletion | SimpleNormalCompletion {\n    invariant(!(result1 instanceof Reference || result2 instanceof Reference), \"loop bodies should not result in refs\");\n    invariant(\n      !(result1 instanceof AbruptCompletion || result2 instanceof AbruptCompletion),\n      \"if a loop iteration ends abruptly, there is no need for fixed point computation\"\n    );\n    if (result1 instanceof SimpleNormalCompletion && result2 instanceof SimpleNormalCompletion) {\n      let val = this.widenValues(realm, result1.value, result2.value);\n      invariant(val instanceof Value);\n      return new SimpleNormalCompletion(val);\n    }\n    if (result1 instanceof PossiblyNormalCompletion || result2 instanceof PossiblyNormalCompletion) {\n      //todo: #1174 figure out how to deal with loops that have embedded conditional exits\n      // widen join pathConditions\n      // widen normal result and Effects\n      // use abrupt part of result2, depend stability to make this safe. See below.\n      throw new FatalError();\n    }\n    invariant(false);\n  }\n\n  widenMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, widen: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = widen(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, widen(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  widenBindings(realm: Realm, m1: Bindings, m2: Bindings): Bindings {\n    let widen = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let v1 = b1 === undefined || b1.value === undefined ? b.value : b1.value;\n      invariant(b2 !== undefined); // Local variables are not going to get deleted as a result of widening\n      let v2 = b2.value;\n      invariant(v2 !== undefined);\n      let result = this.widenValues(realm, v1 || realm.intrinsics.undefined, v2);\n      if (result instanceof AbstractValue && result.kind === \"widened\") {\n        let phiNode = b.phiNode;\n        if (phiNode === undefined) {\n          // Create a temporal location for binding\n          let generator = realm.generator;\n          invariant(generator !== undefined);\n          phiNode = generator.deriveAbstract(\n            result.types,\n            result.values,\n            [b.value || realm.intrinsics.undefined],\n            ([n]) => n,\n            { skipInvariant: true }\n          );\n          b.phiNode = phiNode;\n        }\n        // Let the widened value be a reference to the phiNode of the binding\n        invariant(phiNode.intrinsicName !== undefined);\n        let phiName = phiNode.intrinsicName;\n        result.intrinsicName = phiName;\n        result._buildNode = args => t.identifier(phiName);\n      }\n      invariant(result instanceof Value);\n      let previousHasLeaked = b2.previousHasLeaked;\n      let previousValue = b2.previousValue;\n      return {\n        hasLeaked: previousHasLeaked,\n        value: result,\n        previousHasLeaked,\n        previousValue,\n      };\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  // Returns an abstract value that includes both v1 and v2 as potential values.\n  widenValues(\n    realm: Realm,\n    v1: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(Array.isArray(v1));\n      invariant(Array.isArray(v2));\n      return this._widenArrays(realm, ((v1: any): Array<Value>), ((v2: any): Array<Value>));\n    }\n    invariant(v1 instanceof Value);\n    invariant(v2 instanceof Value);\n    if (\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1; // no need to widen a loop invariant value\n    } else {\n      invariant(v1 && v2);\n      return AbstractValue.createFromWidening(realm, v1, v2);\n    }\n  }\n\n  widenPropertyBindings(\n    realm: Realm,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let widen = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      if (d1 === undefined && d2 === undefined) return undefined;\n      // If the PropertyBinding object has been freshly allocated do not widen (that happens in AbstractObjectValue)\n      if (d1 === undefined) {\n        if (c2.has(b.object)) return d2; // no widen\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was present in (n-1)th iteration and deleted in nth iteration\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in nth iteration, use the value from the (n-1)th iteration\n          d1 = b.descriptor;\n          if (d1 === undefined) {\n            d1 = cloneDescriptor(d2);\n            invariant(d1 !== undefined);\n            d1.value = realm.intrinsics.empty;\n          }\n        }\n      }\n      if (d2 === undefined) {\n        if (c1.has(b.object)) return d1; // no widen\n        if (m2.has(b)) {\n          // property was present in nth iteration and deleted in (n+1)th iteration\n          d2 = cloneDescriptor(d1);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property in (n+1)th iteration, use the value from the nth iteration\n          d2 = d1;\n        }\n        invariant(d2 !== undefined);\n      }\n      let result = this.widenDescriptors(realm, d1, d2);\n      if (result && result.value instanceof AbstractValue && result.value.kind === \"widened\") {\n        let rval = result.value;\n        let pathNode = b.pathNode;\n        if (pathNode === undefined) {\n          //Since properties already have mutable storage locations associated with them, we do not\n          //need phi nodes. What we need is an abstract value with a build node that results in a memberExpression\n          //that resolves to the storage location of the property.\n\n          // For now, we only handle loop invariant properties\n          //i.e. properties where the member expresssion does not involve any values written to inside the loop.\n          let key = b.key;\n          if (\n            typeof key === \"string\" ||\n            (key instanceof AbstractValue && !(key.mightNotBeString() && key.mightNotBeNumber()))\n          ) {\n            if (typeof key === \"string\") {\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object], ([o]) =>\n                memberExpressionHelper(o, key)\n              );\n            } else {\n              invariant(key instanceof AbstractValue);\n              pathNode = AbstractValue.createFromWidenedProperty(realm, rval, [b.object, key], ([o, p]) => {\n                return memberExpressionHelper(o, p);\n              });\n            }\n            // The value of the property at the start of the loop needs to be written to the property\n            // before the loop commences, otherwise the memberExpression will result in an undefined value.\n            let generator = realm.generator;\n            invariant(generator !== undefined);\n            let initVal = (b.descriptor && b.descriptor.value) || realm.intrinsics.empty;\n            if (!(initVal instanceof Value)) throw new FatalError(\"todo: handle internal properties\");\n            if (!(initVal instanceof EmptyValue)) {\n              if (key === \"length\" && b.object instanceof ArrayValue) {\n                // do nothing, the array length will already be initialized\n              } else if (typeof key === \"string\") {\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, initVal], ([o, v]) => {\n                  invariant(typeof key === \"string\");\n                  return t.assignmentExpression(\"=\", memberExpressionHelper(o, key), v);\n                });\n              } else {\n                invariant(key instanceof AbstractValue);\n                generator.emitVoidExpression(rval.types, rval.values, [b.object, key, initVal], ([o, p, v]) =>\n                  t.assignmentExpression(\"=\", memberExpressionHelper(o, p), v)\n                );\n              }\n            }\n          } else {\n            throw new FatalError(\"todo: handle the case where key is an abstract value\");\n          }\n          b.pathNode = pathNode;\n        }\n        result.value = pathNode;\n      }\n      return result;\n    };\n    return this.widenMaps(m1, m2, widen);\n  }\n\n  widenDescriptors(realm: Realm, d1: void | Descriptor, d2: Descriptor): void | Descriptor {\n    if (d1 === undefined) {\n      // d2 is a property written to only in the (n+1)th iteration\n      if (!IsDataDescriptor(realm, d2)) return d2; // accessor properties need not be widened.\n      let dc = cloneDescriptor(d2);\n      invariant(dc !== undefined);\n      let d2value = dc.value;\n      invariant(d2value !== undefined); // because IsDataDescriptor is true for d2/dc\n      dc.value = this.widenValues(realm, d2value, d2value);\n      return dc;\n    } else {\n      if (equalDescriptors(d1, d2)) {\n        if (!IsDataDescriptor(realm, d1)) return d1; // identical accessor properties need not be widened.\n        // equalDescriptors plus IsDataDescriptor guarantee that both have value props and if you have a value prop is value is defined.\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        let d1value = d1.value;\n        invariant(d1value !== undefined);\n        let d2value = d2.value;\n        invariant(d2value !== undefined);\n        dc.value = this.widenValues(realm, d1value, d2value);\n        return dc;\n      }\n      //todo: #1174 if we get here, the loop body contains a call to create a property and different iterations\n      // create them differently. That seems beyond what a fixpoint computation can reasonably handle without\n      // losing precision. Report an error here.\n      throw new FatalError();\n    }\n  }\n\n  // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,\n  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general\n  // summary of the loop, regardless of how many iterations will be performed at runtime.\n  containsEffects(e1: Effects, e2: Effects): boolean {\n    if (!this.containsResults(e1.result, e2.result)) return false;\n    if (!this.containsBindings(e1.modifiedBindings, e2.modifiedBindings)) return false;\n    if (\n      !this.containsPropertyBindings(e1.modifiedProperties, e2.modifiedProperties, e1.createdObjects, e2.createdObjects)\n    )\n      return false;\n    return true;\n  }\n\n  containsResults(result1: EvaluationResult, result2: EvaluationResult): boolean {\n    if (result1 instanceof SimpleNormalCompletion && result2 instanceof SimpleNormalCompletion)\n      return this._containsValues(result1.value, result2.value);\n    return false;\n  }\n\n  containsMap<K, V>(m1: Map<K, V>, m2: Map<K, V>, f: (void | V, void | V) => boolean): boolean {\n    for (const [key1, val1] of m1.entries()) {\n      if (val1 === undefined) continue; // deleted\n      let val2 = m2.get(key1);\n      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key\n      if (!f(val1, val2)) return false;\n    }\n    for (const key2 of m2.keys()) {\n      if (!m1.has(key2)) return false;\n    }\n    return true;\n  }\n\n  containsBindings(m1: Bindings, m2: Bindings): boolean {\n    let containsBinding = (b1: void | BindingEntry, b2: void | BindingEntry) => {\n      if (\n        b1 === undefined ||\n        b2 === undefined ||\n        b1.value === undefined ||\n        b2.value === undefined ||\n        !this._containsValues(b1.value, b2.value) ||\n        b1.hasLeaked !== b2.hasLeaked\n      ) {\n        return false;\n      }\n      return true;\n    };\n    return this.containsMap(m1, m2, containsBinding);\n  }\n\n  containsPropertyBindings(\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): boolean {\n    let containsPropertyBinding = (d1: void | Descriptor, d2: void | Descriptor) => {\n      let [v1, v2] = [d1 && d1.value, d2 && d2.value];\n      if (v1 === undefined) {\n        return v2 === undefined;\n      }\n      if (v1 instanceof Value && v2 instanceof Value) return this._containsValues(v1, v2);\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        return this._containsArray(((v1: any): Array<Value>), ((v2: any): Array<Value>));\n      }\n      return v2 === undefined;\n    };\n    for (const [key1, val1] of m1.entries()) {\n      if (val1 === undefined) continue; // deleted\n      let val2 = m2.get(key1);\n      if (val2 === undefined) continue; // A key that disappears has been widened away into the unknown key\n      if (c1.has(key1.object)) {\n        continue;\n      }\n      if (!containsPropertyBinding(val1, val2)) return false;\n    }\n    for (const key2 of m2.keys()) {\n      if (c2.has(key2.object)) {\n        continue;\n      }\n      if (!m1.has(key2)) return false;\n    }\n    return true;\n  }\n\n  _containsArray(\n    v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let e = (v1 && v1[0]) || (v2 && v2[0]);\n    if (e instanceof Value) return this.containsArraysOfValue((v1: any), (v2: any));\n    else return this._containsArrayOfsMapEntries((v1: any), (v2: any));\n  }\n\n  _containsArrayOfsMapEntries(\n    realm: Realm,\n    a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n    a2: void | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): boolean {\n    let empty = realm.intrinsics.empty;\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n      let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n      if (key1 === undefined) {\n        if (key2 !== undefined) return false;\n      } else {\n        if (key1 instanceof Value && key2 instanceof Value && key1.equals(key2)) {\n          if (val1 instanceof Value && val2 instanceof Value && this._containsValues(val1, val2)) continue;\n        }\n        return false;\n      }\n    }\n    return true;\n  }\n\n  containsArraysOfValue(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): boolean {\n    let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n    for (let i = 0; i < n; i++) {\n      let [val1, val2] = [a1 && a1[i], a2 && a2[i]];\n      if (val1 instanceof Value && val2 instanceof Value && !this._containsValues(val1, val2)) return false;\n    }\n    return true;\n  }\n\n  _containsValues(val1: Value, val2: Value) {\n    if (val1 instanceof AbstractValue) {\n      if (\n        !Value.isTypeCompatibleWith(val2.getType(), val1.getType()) &&\n        !Value.isTypeCompatibleWith(val1.getType(), val2.getType())\n      )\n        return false;\n      return val1.values.containsValue(val2);\n    }\n    return val1.equals(val2);\n  }\n}\n"]}