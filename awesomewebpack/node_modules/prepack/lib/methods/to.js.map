{"version":3,"sources":["../../src/methods/to.js"],"names":["t","modulo","x","y","ToImplementation","constructor","ElementConv","Int8","ToInt8","bind","Int16","ToInt16","Int32","ToInt32","Uint8","ToUint8","Uint16","ToUint16","Uint32","ToUint32","Uint8Clamped","ToUint8Clamp","realm","argument","number","ToNumber","isNaN","isFinite","int","Math","floor","abs","int32bit","pow","int16bit","int8bit","f","thisBooleanValue","value","$BooleanData","booleanData","throwIfNotConcreteBoolean","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","thisNumberValue","$NumberData","numberData","throwIfNotConcreteNumber","thisStringValue","$StringData","stringData","throwIfNotConcreteString","ToPropertyDescriptor","Obj","desc","hasEnumerable","enu","ToBooleanPartial","enumerable","hasConfigurable","conf","configurable","hasValue","hasWritable","writable","hasGet","getter","mightBeUndefined","get","hasSet","setter","set","ToObject","arg","_WrapAbstractInObject","obj","BooleanPrototype","NumberPrototype","StringCreate","StringPrototype","SymbolPrototype","$SymbolData","getType","mightBeNull","mightHaveBeenDeleted","isInPureScope","createFromType","throwIfNotConcreteObject","ToLength","len","ToInteger","Infinity","min","ToIndex","index","integerIndex","RangeError","ToIndexPartial","val","num","ToNumberOrAbstract","reportIntrospectionError","NaN","prim","ToPrimitiveOrAbstract","Number","IsToNumberPure","IsToPrimitivePure","type","ToPrimitive","input","hint","throwIfNotConcretePrimitive","exoticToPrim","SymbolToPrimitive","result","OrdinaryToPrimitiveOrAbstract","GetToPrimitivePureResultType","mightBeObject","undefined","OrdinaryToPrimitive","methodNames","name","method","resultType","error","currentLocation","handleError","isTypeCompatibleWith","ToString","primValue","ToStringPartial","ToStringValue","str","ToStringAbstract","mightNotBeString","coerceToString","p","binaryExpression","stringLiteral","mightNotBeNumber","isSimpleObject","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","topVal","createFromBuildFunction","ToBoolean","length","mightNotBeObject","ToPropertyKey","key","ToPropertyKeyPartial","CanonicalNumericIndexString","n"],"mappings":"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","file":"to.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Descriptor, CallableObjectValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { Create } from \"../singletons.js\";\nimport { HasProperty } from \"./has.js\";\nimport { Call } from \"./call.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { IsCallable } from \"./is.js\";\nimport { SameValue, SameValueZero } from \"./abstract.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"babel-types\";\n\ntype ElementConvType = {\n  Int8: (Realm, numberOrValue) => number,\n  Int16: (Realm, numberOrValue) => number,\n  Int32: (Realm, numberOrValue) => number,\n  Uint8: (Realm, numberOrValue) => number,\n  Uint16: (Realm, numberOrValue) => number,\n  Uint32: (Realm, numberOrValue) => number,\n  Uint8Clamped: (Realm, numberOrValue) => number,\n};\ntype numberOrValue = number | Value;\n\nfunction modulo(x: number, y: number): number {\n  return x < 0 ? (x % y) + y : x % y;\n}\n\nexport class ToImplementation {\n  constructor() {\n    this.ElementConv = {\n      Int8: this.ToInt8.bind(this),\n      Int16: this.ToInt16.bind(this),\n      Int32: this.ToInt32.bind(this),\n      Uint8: this.ToUint8.bind(this),\n      Uint16: this.ToUint16.bind(this),\n      Uint32: this.ToUint32.bind(this),\n      Uint8Clamped: this.ToUint8Clamp.bind(this),\n    };\n  }\n\n  ElementConv: ElementConvType;\n\n  // ECMA262 7.1.5\n  ToInt32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. If int32bit ≥ 2^31, return int32bit - 2^32; otherwise return int32bit.\n    return int32bit >= Math.pow(2, 31) ? int32bit - Math.pow(2, 32) : int32bit;\n  }\n\n  // ECMA262 7.1.6\n  ToUint32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. Return int32bit.\n    return int32bit;\n  }\n\n  // ECMA262 7.1.7\n  ToInt16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. If int16bit ≥ 2^15, return int16bit - 2^16; otherwise return int16bit.\n    return int16bit >= Math.pow(2, 15) ? int16bit - Math.pow(2, 16) : int16bit;\n  }\n\n  // ECMA262 7.1.8\n  ToUint16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. Return int16bit.\n    return int16bit;\n  }\n\n  // ECMA262 7.1.9\n  ToInt8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. If int8bit ≥ 2^7, return int8bit - 2^8; otherwise return int8bit.\n    return int8bit >= Math.pow(2, 7) ? int8bit - Math.pow(2, 8) : int8bit;\n  }\n\n  // ECMA262 7.1.10\n  ToUint8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. Return int8bit.\n    return int8bit;\n  }\n\n  // ECMA262 7.1.11\n  ToUint8Clamp(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number ≤ 0, return +0.\n    if (number <= 0) return +0;\n\n    // 4. If number ≥ 255, return 255.\n    if (number >= 255) return 255;\n\n    // 5. Let f be floor(number).\n    let f = Math.floor(number);\n\n    // 6. If f + 0.5 < number, return f + 1.\n    if (f + 0.5 < number) return f + 1;\n\n    // 7. If number < f + 0.5, return f.\n    if (number < f + 0.5) return f;\n\n    // 8. If f is odd, return f + 1.\n    if (f % 2 === 1) return f + 1;\n\n    // 9. Return f.\n    return f;\n  }\n\n  // ECMA262 19.3.3.1\n  thisBooleanValue(realm: Realm, value: Value): BooleanValue {\n    // 1. If Type(value) is Boolean, return value.\n    if (value instanceof BooleanValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n    if (value instanceof ObjectValue && value.$BooleanData) {\n      const booleanData = value.$BooleanData.throwIfNotConcreteBoolean();\n      // a. Assert: value's [[BooleanData]] internal slot is a Boolean value.\n      invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n\n      // b. Return the value of value's [[BooleanData]] internal slot.\n      return booleanData;\n    }\n\n    value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 20.1.3\n  thisNumberValue(realm: Realm, value: Value): NumberValue {\n    // 1. If Type(value) is Number, return value.\n    if (value instanceof NumberValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then\n    if (value instanceof ObjectValue && value.$NumberData) {\n      const numberData = value.$NumberData.throwIfNotConcreteNumber();\n      // a. Assert: value's [[NumberData]] internal slot is a Number value.\n      invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n\n      // b. Return the value of value's [[NumberData]] internal slot.\n      return numberData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 21.1.3\n  thisStringValue(realm: Realm, value: Value): StringValue {\n    // 1. If Type(value) is String, return value.\n    if (value instanceof StringValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[StringData]] internal slot, then\n    if (value instanceof ObjectValue && value.$StringData) {\n      const stringData = value.$StringData.throwIfNotConcreteString();\n      // a. Assert: value's [[StringData]] internal slot is a String value.\n      invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n\n      // b. Return the value of value's [[StringData]] internal slot.\n      return stringData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 6.2.4.5\n  ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor {\n    Obj = Obj.throwIfNotConcrete();\n\n    // 1. If Type(Obj) is not Object, throw a TypeError exception.\n    if (!(Obj instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 2. Let desc be a new Property Descriptor that initially has no fields.\n    let desc: Descriptor = {};\n\n    // 3. Let hasEnumerable be ? HasProperty(Obj, \"enumerable\").\n    let hasEnumerable = HasProperty(realm, Obj, \"enumerable\");\n\n    // 4. If hasEnumerable is true, then\n    if (hasEnumerable === true) {\n      // a. Let enum be ToBoolean(? Get(Obj, \"enumerable\")).\n      let enu = this.ToBooleanPartial(realm, Get(realm, Obj, \"enumerable\"));\n\n      // b. Set the [[Enumerable]] field of desc to enum.\n      desc.enumerable = enu === true;\n    }\n\n    // 5. Let hasConfigurable be ? HasProperty(Obj, \"configurable\").\n    let hasConfigurable = HasProperty(realm, Obj, \"configurable\");\n\n    // 6. If hasConfigurable is true, then\n    if (hasConfigurable === true) {\n      // a. Let conf be ToBoolean(? Get(Obj, \"configurable\")).\n      let conf = this.ToBooleanPartial(realm, Get(realm, Obj, \"configurable\"));\n\n      // b. Set the [[Configurable]] field of desc to conf.\n      desc.configurable = conf === true;\n    }\n\n    // 7. Let hasValue be ? HasProperty(Obj, \"value\").\n    let hasValue = HasProperty(realm, Obj, \"value\");\n\n    // 8. If hasValue is true, then\n    if (hasValue === true) {\n      // a. Let value be ? Get(Obj, \"value\").\n      let value = Get(realm, Obj, \"value\");\n\n      // b. Set the [[Value]] field of desc to value.\n      desc.value = value;\n    }\n\n    // 9. Let hasWritable be ? HasProperty(Obj, \"writable\").\n    let hasWritable = HasProperty(realm, Obj, \"writable\");\n\n    // 10. If hasWritable is true, then\n    if (hasWritable === true) {\n      // a. Let writable be ToBoolean(? Get(Obj, \"writable\")).\n      let writable = this.ToBooleanPartial(realm, Get(realm, Obj, \"writable\"));\n\n      // b. Set the [[Writable]] field of desc to writable.\n      desc.writable = writable === true;\n    }\n\n    // 11. Let hasGet be ? HasProperty(Obj, \"get\").\n    let hasGet = HasProperty(realm, Obj, \"get\");\n\n    // 12. If hasGet is true, then\n    if (hasGet === true) {\n      // a. Let getter be ? Get(Obj, \"get\").\n      let getter = Get(realm, Obj, \"get\");\n\n      // b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, getter) === false && !getter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      getter.throwIfNotConcrete();\n\n      // c. Set the [[Get]] field of desc to getter.\n      desc.get = ((getter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 13. Let hasSet be ? HasProperty(Obj, \"set\").\n    let hasSet = HasProperty(realm, Obj, \"set\");\n\n    // 14. If hasSet is true, then\n    if (hasSet === true) {\n      // a. Let setter be ? Get(Obj, \"set\").\n      let setter = Get(realm, Obj, \"set\");\n\n      // b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, setter) === false && !setter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      setter.throwIfNotConcrete();\n\n      // c. Set the [[Set]] field of desc to setter.\n      desc.set = ((setter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 15. If either desc.[[Get]] or desc.[[Set]] is present, then\n    if (desc.get || desc.set) {\n      // a. If either desc.[[Value]] or desc.[[Writable]] is present, throw a TypeError exception.\n      if (\"value\" in desc || \"writable\" in desc) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 16. Return desc.\n    return desc;\n  }\n\n  // ECMA262 7.1.13\n  ToObject(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue {\n    if (arg instanceof AbstractObjectValue) return arg;\n    if (arg instanceof AbstractValue) {\n      return this._WrapAbstractInObject(realm, arg);\n    }\n    if (arg instanceof UndefinedValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof BooleanValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n      obj.$BooleanData = arg;\n      return obj;\n    } else if (arg instanceof NumberValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n      obj.$NumberData = arg;\n      return obj;\n    } else if (arg instanceof StringValue) {\n      let obj = Create.StringCreate(realm, arg, realm.intrinsics.StringPrototype);\n      return obj;\n    } else if (arg instanceof SymbolValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n      obj.$SymbolData = arg;\n      return obj;\n    } else if (arg instanceof ObjectValue) {\n      return arg;\n    }\n    invariant(false);\n  }\n\n  _WrapAbstractInObject(realm: Realm, arg: AbstractValue): ObjectValue | AbstractObjectValue {\n    let obj;\n    switch (arg.getType()) {\n      case IntegralValue:\n      case NumberValue:\n        obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n        obj.$NumberData = arg;\n        break;\n\n      case StringValue:\n        obj = new ObjectValue(realm, realm.intrinsics.StringPrototype);\n        obj.$StringData = arg;\n        break;\n\n      case BooleanValue:\n        obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n        obj.$BooleanData = arg;\n        break;\n\n      case SymbolValue:\n        obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n        obj.$SymbolData = arg;\n        break;\n\n      case UndefinedValue:\n      case NullValue:\n      case PrimitiveValue:\n        if (arg.mightBeNull() || arg.mightHaveBeenDeleted() || arg.mightBeUndefined())\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n\n      /*eslint-disable */\n      default:\n        /*eslint-enable */\n        if (realm.isInPureScope()) {\n          // will be serialized as Object.assign(serialized_arg)\n          obj = AbstractValue.createFromType(realm, ObjectValue, \"explicit conversion to object\", [arg]);\n          invariant(obj instanceof AbstractObjectValue);\n        } else {\n          obj = arg.throwIfNotConcreteObject();\n        }\n        break;\n    }\n    return obj;\n  }\n\n  // ECMA262 7.1.15\n  ToLength(realm: Realm, argument: numberOrValue): number {\n    // Let len be ? ToInteger(argument).\n    let len = this.ToInteger(realm, argument);\n\n    // If len ≤ +0, return +0.\n    if (len <= 0) return +0;\n\n    // If len is +∞, return 2^53-1.\n    if (len === +Infinity) return Math.pow(2, 53) - 1;\n\n    // Return min(len, 2^53-1).\n    return Math.min(len, Math.pow(2, 53) - 1);\n  }\n\n  // ECMA262 7.1.4\n  ToInteger(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number is +0, -0, +∞, or -∞, return number.\n    if (!isFinite(number) || number === 0) return number;\n\n    // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n    return number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n  }\n\n  // ECMA262 7.1.17\n  ToIndex(realm: Realm, value: number | ConcreteValue): number {\n    let index;\n    // 1. If value is undefined, then\n    if (value instanceof UndefinedValue) {\n      // a. Let index be 0.\n      index = 0;\n    } else {\n      // 2. Else,\n      // a. Let integerIndex be ? ToInteger(value).\n      let integerIndex = this.ToInteger(realm, value);\n\n      // b. If integerIndex < 0, throw a RangeError exception.\n      if (integerIndex < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n\n      // c. Let index be ! ToLength(integerIndex).\n      index = this.ToLength(realm, integerIndex);\n\n      // d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.\n      if (SameValueZero(realm, new NumberValue(realm, integerIndex), new NumberValue(realm, index)) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n    }\n    // 3. Return index.\n    return index;\n  }\n\n  ToIndexPartial(realm: Realm, value: numberOrValue): number {\n    return this.ToIndex(realm, typeof value === \"number\" ? value : value.throwIfNotConcrete());\n  }\n\n  ToNumber(realm: Realm, val: numberOrValue): number {\n    const num = this.ToNumberOrAbstract(realm, val);\n    if (typeof num !== \"number\") {\n      AbstractValue.reportIntrospectionError(num);\n      throw new FatalError();\n    }\n    return num;\n  }\n\n  // ECMA262 7.1.3\n  ToNumberOrAbstract(realm: Realm, val: numberOrValue | AbstractValue): AbstractValue | number {\n    if (typeof val === \"number\") {\n      return val;\n    } else if (val instanceof AbstractValue) {\n      return val;\n    } else if (val instanceof UndefinedValue) {\n      return NaN;\n    } else if (val instanceof NullValue) {\n      return +0;\n    } else if (val instanceof ObjectValue) {\n      let prim = this.ToPrimitiveOrAbstract(realm, val, \"number\");\n      return this.ToNumberOrAbstract(realm, prim);\n    } else if (val instanceof BooleanValue) {\n      if (val.value === true) {\n        return 1;\n      } else {\n        // `val.value === false`\n        return 0;\n      }\n    } else if (val instanceof NumberValue) {\n      return val.value;\n    } else if (val instanceof StringValue) {\n      return Number(val.value);\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else {\n      invariant(false, \"unexpected type of value\");\n    }\n  }\n\n  IsToNumberPure(realm: Realm, val: numberOrValue): boolean {\n    if (val instanceof Value) {\n      if (this.IsToPrimitivePure(realm, val)) {\n        let type = val.getType();\n        return type !== SymbolValue && type !== PrimitiveValue && type !== Value;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  // ECMA262 7.1.1\n  ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue {\n    return this.ToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  ToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ConcreteValue,\n    hint?: \"default\" | \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    if (input instanceof PrimitiveValue) {\n      return input;\n    }\n\n    // When Type(input) is Object, the following steps are taken\n    invariant(input instanceof ObjectValue, \"expected an object\");\n\n    // 1. If PreferredType was not passed, let hint be \"default\".\n    hint = hint || \"default\";\n\n    // Following two steps are redundant since we just pass string hints.\n    // 2. Else if PreferredType is hint String, let hint be \"string\".\n    // 3. Else PreferredType is hint Number, let hint be \"number\".\n\n    // 4. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n    let exoticToPrim = GetMethod(realm, input, realm.intrinsics.SymbolToPrimitive);\n\n    // 5. If exoticToPrim is not undefined, then\n    if (!(exoticToPrim instanceof UndefinedValue)) {\n      // a. Let result be ? Call(exoticToPrim, input, « hint »).\n      let result = Call(realm, exoticToPrim, input, [new StringValue(realm, hint)]);\n\n      // b. If Type(result) is not Object, return result.\n      if (!(result instanceof ObjectValue)) {\n        invariant(result instanceof PrimitiveValue);\n        return result;\n      }\n\n      // c. Throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If hint is \"default\", let hint be \"number\".\n    if (hint === \"default\") hint = \"number\";\n\n    // 7. Return ? OrdinaryToPrimitive(input, hint).\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint);\n  }\n\n  // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\n  GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value {\n    let type = input.getType();\n    if (input instanceof PrimitiveValue) return type;\n    if (input instanceof AbstractValue && !input.mightBeObject()) return PrimitiveValue;\n    return undefined;\n  }\n\n  IsToPrimitivePure(realm: Realm, input: Value) {\n    return this.GetToPrimitivePureResultType(realm, input) !== undefined;\n  }\n\n  // ECMA262 7.1.1\n  OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue {\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  OrdinaryToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ObjectValue,\n    hint: \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    let methodNames;\n\n    // 1. Assert: Type(O) is Object.\n    invariant(input instanceof ObjectValue, \"Expected object\");\n\n    // 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n    invariant(hint === \"string\" || hint === \"number\", \"Expected string or number hint\");\n\n    // 3. If hint is \"string\", then\n    if (hint === \"string\") {\n      // a. Let methodNames be « \"toString\", \"valueOf\" ».\n      methodNames = [\"toString\", \"valueOf\"];\n    } else {\n      // 4. Else,\n      // a. Let methodNames be « \"valueOf\", \"toString\" ».\n      methodNames = [\"valueOf\", \"toString\"];\n    }\n\n    // 5. For each name in methodNames in List order, do\n    for (let name of methodNames) {\n      // a. Let method be ? Get(O, name).\n      let method = Get(realm, input, new StringValue(realm, name));\n\n      // b. If IsCallable(method) is true, then\n      if (IsCallable(realm, method)) {\n        // i. Let result be ? Call(method, O).\n        let result = Call(realm, method, input);\n        let resultType = result.getType();\n\n        // ii. If Type(result) is not Object, return result.\n        if (resultType === Value) {\n          invariant(result instanceof AbstractValue);\n          let error = new CompilerDiagnostic(\n            `${name} might return either an object or primitive`,\n            realm.currentLocation,\n            \"PP0028\",\n            \"RecoverableError\"\n          );\n          realm.handleError(error);\n          throw new FatalError();\n        }\n        if (Value.isTypeCompatibleWith(resultType, PrimitiveValue)) {\n          invariant(result instanceof AbstractValue || result instanceof PrimitiveValue);\n          return result;\n        }\n      }\n    }\n\n    // 6. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"can't turn to primitive\");\n  }\n\n  // ECMA262 7.1.12\n  ToString(realm: Realm, val: string | ConcreteValue): string {\n    if (typeof val === \"string\") {\n      return val;\n    } else if (val instanceof StringValue) {\n      return val.value;\n    } else if (val instanceof NumberValue) {\n      return val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      return \"undefined\";\n    } else if (val instanceof NullValue) {\n      return \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      return val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitive(realm, val, \"string\");\n      return this.ToString(realm, primValue);\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n    }\n  }\n\n  ToStringPartial(realm: Realm, val: string | Value): string {\n    return this.ToString(realm, typeof val === \"string\" ? val : val.throwIfNotConcrete());\n  }\n\n  ToStringValue(realm: Realm, val: Value): Value {\n    if (val.getType() === StringValue) return val;\n    let str;\n    if (typeof val === \"string\") {\n      str = val;\n    } else if (val instanceof NumberValue) {\n      str = val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      str = \"undefined\";\n    } else if (val instanceof NullValue) {\n      str = \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      str = val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitiveOrAbstract(realm, val, \"string\");\n      if (primValue.getType() === StringValue) return primValue;\n      str = this.ToStringPartial(realm, primValue);\n    } else if (val instanceof AbstractValue) {\n      return this.ToStringAbstract(realm, val);\n    } else {\n      invariant(false, \"unknown value type, can't coerce to string\");\n    }\n    return new StringValue(realm, str);\n  }\n\n  ToStringAbstract(realm: Realm, value: AbstractValue): AbstractValue {\n    if (value.mightNotBeString()) {\n      // If the property is not a string we need to coerce it.\n      let coerceToString = ([p]) => t.binaryExpression(\"+\", t.stringLiteral(\"\"), p);\n      let result;\n      if (value.mightNotBeNumber() && !value.isSimpleObject()) {\n        // If this might be a non-simple object, we need to coerce this at a\n        // temporal point since it can have side-effects.\n        // We can't rely on comparison to do it later, even if\n        // it is non-strict comparison since we'll do multiple\n        // comparisons. So we have to be explicit about when this\n        // happens.\n        result = realm.evaluateWithPossibleThrowCompletion(\n          () => AbstractValue.createTemporalFromBuildFunction(realm, StringValue, [value], coerceToString),\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n      } else {\n        result = AbstractValue.createFromBuildFunction(realm, StringValue, [value], coerceToString);\n      }\n      invariant(result instanceof AbstractValue);\n      return result;\n    }\n    return value;\n  }\n\n  // ECMA262 7.1.2\n  ToBoolean(realm: Realm, val: ConcreteValue): boolean {\n    if (val instanceof BooleanValue) {\n      return val.value;\n    } else if (val instanceof UndefinedValue) {\n      return false;\n    } else if (val instanceof NullValue) {\n      return false;\n    } else if (val instanceof NumberValue) {\n      return val.value !== 0 && !isNaN(val.value);\n    } else if (val instanceof StringValue) {\n      return val.value.length > 0;\n    } else if (val instanceof ObjectValue) {\n      return true;\n    } else if (val instanceof SymbolValue) {\n      return true;\n    } else {\n      invariant(!(val instanceof AbstractValue));\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"unknown value type, can't coerce to a boolean\"\n      );\n    }\n  }\n\n  ToBooleanPartial(realm: Realm, val: Value): boolean {\n    if (!val.mightNotBeObject()) return true;\n    return this.ToBoolean(realm, val.throwIfNotConcrete());\n  }\n\n  // ECMA262 7.1.14\n  ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */ {\n    // 1. Let key be ? ToPrimitive(argument, hint String).\n    let key = this.ToPrimitive(realm, arg, \"string\");\n\n    // 2. If Type(key) is Symbol, then\n    if (key instanceof SymbolValue) {\n      // a. Return key.\n      return key;\n    }\n\n    // 3. Return ! ToString(key).\n    return this.ToString(realm, key);\n  }\n\n  ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */ {\n    if (arg instanceof ConcreteValue) return this.ToPropertyKey(realm, arg);\n    // if we are in pure scope, we can assume that ToPropertyKey\n    // won't cause side-effects even if it's not simple\n    if (arg.mightNotBeString() && arg.mightNotBeNumber() && !arg.isSimpleObject() && !realm.isInPureScope()) {\n      arg.throwIfNotConcrete();\n    }\n    invariant(arg instanceof AbstractValue);\n    return arg;\n  }\n\n  // ECMA262 7.1.16\n  CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void {\n    // 1. Assert: Type(argument) is String.\n    invariant(argument instanceof StringValue);\n\n    // 2. If argument is \"-0\", return −0.\n    if (argument.value === \"-0\") return -0;\n\n    // 3. Let n be ToNumber(argument).\n    let n = this.ToNumber(realm, argument);\n\n    // 4. If SameValue(ToString(n), argument) is false, return undefined.\n    if (SameValue(realm, new StringValue(realm, this.ToString(realm, new NumberValue(realm, n))), argument) === false)\n      return undefined;\n\n    // 5. Return n.\n    return n;\n  }\n}\n"]}