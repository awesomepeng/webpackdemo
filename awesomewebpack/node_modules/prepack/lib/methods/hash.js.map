{"version":3,"sources":["../../src/methods/hash.js"],"names":["hashBinary","hashCall","hashTernary","hashString","hashUnary","op","x","y","xHash","getHash","yHash","commutative","mightBeObject","mightBeString","hash","calleeName","args","a","z","value","i","length","charCodeAt","HashSet","constructor","expectedEntries","initialSize","_entries","Array","_count","add","e","entries","n","key","entry","undefined","expand","equals","oldEntries","m","oldEntry","j"],"mappings":"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","file":"hash.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelBinaryOperator, BabelUnaryOperator } from \"babel-types\";\nimport invariant from \"../invariant.js\";\n\ninterface Hashable {\n  getHash(): number;\n  mightBeString(): boolean;\n  mightBeObject(): boolean;\n}\n\nexport function hashBinary<T: Hashable>(op: BabelBinaryOperator, x: T, y: T): [number, Array<T>] {\n  let xHash = x.getHash();\n  let yHash = y.getHash();\n  if (yHash < xHash) {\n    // Check if the operation is commutative so that we can normalize the arguments on hash value order.\n    let commutative;\n    switch (op) {\n      case \"*\":\n      case \"==\":\n      case \"!=\":\n      case \"===\":\n      case \"!==\":\n        // If both operands might be objects, the operation does not commute because of the possibility\n        // that arbitrary code can run on both operands while converting them, in which case the order of the\n        // operands must be maintained to make sure any side-effects happen in the right order.\n        commutative = !(x.mightBeObject() && y.mightBeObject());\n        break;\n      case \"+\":\n        // As above, but in addition, if one of the operands might be a string the operation does not commute\n        commutative = !(x.mightBeObject() && y.mightBeObject()) && !(x.mightBeString() || y.mightBeString());\n        break;\n      default:\n        // The operation itself is not commutative\n        commutative = false;\n        break;\n    }\n    if (commutative) {\n      [x, y] = [y, x];\n      [xHash, yHash] = [yHash, xHash];\n    }\n  }\n  let hash = (((hashString(op) * 13) ^ xHash) * 13) ^ yHash;\n  return [hash, [x, y]];\n}\n\nexport function hashCall<T: Hashable>(calleeName: string, ...args: Array<T>): [number, Array<T>] {\n  let hash = hashString(calleeName);\n  for (let a of args) hash = (hash * 13) ^ a.getHash();\n  return [hash, args];\n}\n\nexport function hashTernary<T: Hashable>(x: T, y: T, z: T): [number, Array<T>] {\n  let hash = (((x.getHash() * 13) ^ y.getHash()) * 13) ^ z.getHash();\n  return [hash, [x, y, z]];\n}\n\nexport function hashString(value: string): number {\n  let hash = 5381;\n  for (let i = value.length - 1; i >= 0; i--) {\n    hash = (hash * 33) ^ value.charCodeAt(i);\n  }\n  return hash;\n}\n\nexport function hashUnary(op: BabelUnaryOperator, x: Hashable): number {\n  return (hashString(op) * 13) ^ x.getHash();\n}\n\ninterface Equatable { equals(x: any): boolean }\n\nexport class HashSet<T: Equatable & Hashable> {\n  constructor(expectedEntries?: number = 32 * 1024) {\n    let initialSize = 16;\n    expectedEntries *= 2;\n    while (initialSize < expectedEntries) initialSize *= 2;\n    this._entries = new Array(initialSize);\n    this._count = 0;\n  }\n\n  _count: number;\n  _entries: Array<void | T>;\n\n  add(e: T): T {\n    let entries = this._entries;\n    let n = entries.length;\n    let key = e.getHash();\n    let i = key & (n - 1);\n    while (true) {\n      let entry = entries[i];\n      if (entry === undefined) {\n        entries[i] = e;\n        if (++this._count > n / 2) this.expand();\n        return e;\n      } else if (e.equals(entry)) {\n        return entry;\n      }\n      if (++i >= n) i = 0;\n    }\n    invariant(false); // otherwise Flow thinks this method can return undefined\n  }\n\n  expand(): void {\n    let oldEntries = this._entries;\n    let n = oldEntries.length;\n    let m = n * 2;\n    if (m <= 0) return;\n    let entries = new Array(m);\n    for (let i = 0; i < n; i++) {\n      let oldEntry = oldEntries[i];\n      if (oldEntry === undefined) continue;\n      let key = oldEntry.getHash();\n      let j = key & (m - 1);\n      while (true) {\n        let entry = entries[j];\n        if (entry === undefined) {\n          entries[j] = oldEntry;\n          break;\n        }\n        if (++j >= m) j = 0;\n      }\n    }\n    this._entries = entries;\n  }\n}\n"]}