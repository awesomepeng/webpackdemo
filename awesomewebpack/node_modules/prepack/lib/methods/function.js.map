{"version":3,"sources":["../../src/methods/function.js"],"names":["t","InternalCall","realm","F","thisArgument","argsList","tracerIndex","tracers","length","tracer","nextIndex","detourResult","detourCall","undefined","$FunctionKind","createErrorThrowCompletion","intrinsics","TypeError","callerContext","getRunningContext","calleeContext","calleeEnv","lexicalEnvironment","result","t1","beforeCall","popContext","onDestroyScope","t2","afterCall","value","$BoundCall","argumentsList","target","$BoundTargetFunction","boundThis","$BoundThis","boundArgs","$BoundArguments","args","concat","$BoundConstruct","newTarget","$Construct","InternalConstruct","hasRunningContext","useAbstractInterpretation","kind","$ConstructorKind","OrdinaryCreateFromConstructor","envRec","constructorEnv","environmentRecord","mightBeObject","throwIfNotConcreteObject","mightBeUndefined","throwIfNotConcrete","envRecThisBinding","GetThisBinding","FunctionImplementation","FindVarScopedDeclarations","ast_node","FindVarScopedDeclarationsFor","ast","level","statements","type","body","astIfStatement","consequent","alternate","astForStatement","init","astForInStatement","left","astForOfStatement","switchCase","cases","push","astTryStatement","block","finalizer","handler","decls","statement","FunctionDeclarationInstantiation","func","env","code","$ECMAScriptCode","strict","$Strict","formals","$FormalParameters","parameterNames","Object","create","param","paramBindings","getBindingIdentifiers","name","hasDuplicates","identifiers","keys","simpleParameterList","hasParameterExpressions","ContainsExpression","varNames","node","varDeclarations","lexicalNames","functionNames","functionsToInitialize","d","reverse","fn","BoundNames","indexOf","unshift","argumentsObjectNeeded","$ThisMode","paramName","alreadyDeclared","HasBinding","CreateMutableBinding","InitializeBinding","ao","CreateUnmappedArgumentsObject","CreateMappedArgumentsObject","CreateImmutableBinding","iteratorRecord","$Iterator","$Done","IteratorBindingInitialization","varEnv","varEnvRec","instantiatedVarNames","slice","n","NewDeclarativeEnvironment","activeLexicalEnvironments","delete","variableEnvironment","initialValue","GetBindingValue","lexEnv","add","lexEnvRec","lexDeclarations","dn","f","fo","evaluate","SetMutableBinding","empty","SetFunctionName","_name","prefix","getExtensible","description","$Description","emptyString","throwIfNotConcreteString","prefixVal","createFromBinaryOp","expressionLocation","DefinePropertyOrThrow","enumerable","writable","configurable","FunctionInitialize","ParameterList","Body","Scope","markVisibleLocalBindingsAsPotentiallyCaptured","isNewObject","len","FormalParameter","Strict","$Environment","uniqueOrderedTag","functionBodyUniqueTagSeed","$ScriptOrModule","GetActiveScriptOrModule","GeneratorFunctionCreate","functionPrototype","Generator","FunctionAllocate","AddRestrictedFunctionProperties","thrower","ThrowTypeError","desc","get","set","$Call","functionKind","needsConstruct","$Prototype","setExtensible","$Realm","BoundFunctionCreate","targetFunction","proto","$GetPrototypeOf","obj","PerformEval","x","evalRealm","strictCaller","direct","script","program","blockStatement","directives","strictEval","ctx","$GlobalEnv","suspend","evalCxt","createExecutionContext","isStrict","setFunction","setRealm","ScriptOrModule","pushContext","EvalDeclarationInstantiation","e","directive","EvaluateStatements","resume","incorporateSavedCompletion","c","savedCompletion","savedPathConditions","pathConditions","updatePossiblyNormalCompletionWithValue","getCapturedEffects","stopEffectCaptureAndUndoEffects","replacePossiblyNormalCompletionWithForkedAbruptCompletion","initialBlockValue","strictCode","blockEnv","blockValue","res","evaluateCompletionDeref","PartiallyEvaluateStatements","statementAsts","nast","nio","partiallyEvaluateCompletionDeref","ioAst","FunctionCreate","prototype","FunctionPrototype","allocKind","HasLexicalDeclaration","SyntaxError","thisLex","thisEnvRec","parent","declaredFunctionNames","fnDefinable","CanDeclareGlobalFunction","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","s","CreateGlobalFunctionBinding","bindingExists","CreateGlobalVarBinding","MakeMethod","homeObject","$HomeObject","DefineMethod","prop","propKey","scope","closure","params","$Key","$Closure"],"mappings":"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","file":"function.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue, FunctionBodyAstNode } from \"../types.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport { Completion, ReturnCompletion, AbruptCompletion, NormalCompletion } from \"../completions.js\";\nimport { GlobalEnvironmentRecord, ObjectEnvironmentRecord } from \"../environment.js\";\nimport {\n  AbstractValue,\n  AbstractObjectValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { OrdinaryCallEvaluateBody, OrdinaryCallBindThis, PrepareForOrdinaryCall, Call } from \"./call.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { CreateListIterator } from \"../methods/iterator.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport { Create, Environment, Join, Properties } from \"../singletons.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport * as t from \"babel-types\";\nimport type {\n  BabelNode,\n  BabelNodeBlockStatement,\n  BabelNodeClassMethod,\n  BabelNodeDoWhileStatement,\n  BabelNodeForInStatement,\n  BabelNodeForOfStatement,\n  BabelNodeForStatement,\n  BabelNodeIfStatement,\n  BabelNodeLabeledStatement,\n  BabelNodeLVal,\n  BabelNodeObjectMethod,\n  BabelNodeProgram,\n  BabelNodeStatement,\n  BabelNodeSwitchStatement,\n  BabelNodeTryStatement,\n  BabelNodeVariableDeclaration,\n  BabelNodeWhileStatement,\n  BabelNodeWithStatement,\n} from \"babel-types\";\n\nfunction InternalCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  thisArgument: Value,\n  argsList: Array<Value>,\n  tracerIndex: number\n): Value {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function value\");\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () =>\n      InternalCall(realm, F, thisArgument, argsList, nextIndex)\n    );\n    if (detourResult instanceof Value) return detourResult;\n  }\n\n  // 2. If F's [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n  if (F.$FunctionKind === \"classConstructor\")\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, undefined);\n  let calleeEnv = calleeContext.lexicalEnvironment;\n\n  let result;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argsList, undefined);\n\n    // 5. Assert: calleeContext is now the running execution context.\n    invariant(realm.getRunningContext() === calleeContext, \"calleeContext should be current execution context\");\n\n    // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n\n    // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argsList);\n  } finally {\n    // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    realm.onDestroyScope(calleeContext.lexicalEnvironment);\n    if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argsList, undefined, (result: any));\n  }\n\n  // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n  if (result instanceof ReturnCompletion) {\n    return result.value;\n  }\n\n  // 10. ReturnIfAbrupt(result).  or if possibly abrupt\n  if (result instanceof Completion) {\n    throw result;\n  }\n\n  // 11. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 9.4.1.1\nfunction $BoundCall(realm: Realm, F: BoundFunctionValue, thisArgument: Value, argumentsList: Array<Value>): Value {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.\n  let boundThis = F.$BoundThis;\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. Return ? Call(target, boundThis, args).\n  return Call(realm, target, boundThis, args);\n}\n\n// ECMA262 9.4.1.2\nfunction $BoundConstruct(\n  realm: Realm,\n  F: BoundFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue\n): ObjectValue {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Assert: target has a [[Construct]] internal method.\n  invariant(target.$Construct !== undefined, \"doesn't have a construct internal method\");\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. If SameValue(F, newTarget) is true, let newTarget be target.\n  if (SameValue(realm, F, newTarget)) newTarget = target;\n\n  // 6. Return ? Construct(target, args, newTarget).\n  return Construct(realm, target, args, newTarget);\n}\n\nfunction InternalConstruct(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue,\n  thisArgument: void | ObjectValue,\n  tracerIndex: number\n): ObjectValue {\n  // 1. Assert: F is an ECMAScript function object.\n  invariant(F instanceof FunctionValue, \"expected function\");\n\n  // 2. Assert: Type(newTarget) is Object.\n  invariant(newTarget instanceof ObjectValue, \"expected object\");\n\n  if (!realm.hasRunningContext()) {\n    invariant(realm.useAbstractInterpretation);\n    throw new FatalError(\"no running context\");\n  }\n\n  // 3. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 4. Let kind be F's [[ConstructorKind]] internal slot.\n  let kind = F.$ConstructorKind;\n\n  // 5. If kind is \"base\", then\n  if (thisArgument === undefined && kind === \"base\") {\n    // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n    thisArgument = Create.OrdinaryCreateFromConstructor(realm, newTarget, \"ObjectPrototype\");\n  }\n\n  // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n  while (tracerIndex < realm.tracers.length) {\n    let tracer = realm.tracers[tracerIndex];\n    let nextIndex = ++tracerIndex;\n    let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () =>\n      InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex)\n    );\n    if (detourResult instanceof ObjectValue) return detourResult;\n    invariant(detourResult === undefined);\n  }\n\n  // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n  let calleeContext = PrepareForOrdinaryCall(realm, F, newTarget);\n  let calleeEnv = calleeContext.lexicalEnvironment;\n\n  // 7. Assert: calleeContext is now the running execution context.\n  invariant(realm.getRunningContext() === calleeContext, \"expected calleeContext to be running context\");\n\n  let result, envRec;\n  try {\n    for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argumentsList, newTarget);\n\n    // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n    }\n\n    // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n    let constructorEnv = calleeContext.lexicalEnvironment;\n\n    // 10. Let envRec be constructorEnv's EnvironmentRecord.\n    envRec = constructorEnv.environmentRecord;\n\n    // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    result = OrdinaryCallEvaluateBody(realm, F, argumentsList);\n  } finally {\n    // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.popContext(calleeContext);\n    realm.onDestroyScope(calleeContext.lexicalEnvironment);\n    if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);\n    invariant(realm.getRunningContext() === callerContext);\n\n    for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argumentsList, newTarget, result);\n  }\n\n  // 13. If result.[[Type]] is return, then\n  if (result instanceof ReturnCompletion) {\n    // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n    if (result.value.mightBeObject()) {\n      return result.value.throwIfNotConcreteObject();\n    }\n\n    // b. If kind is \"base\", return NormalCompletion(thisArgument).\n    if (kind === \"base\") {\n      invariant(thisArgument, \"this wasn't initialized for some reason\");\n      return thisArgument;\n    }\n\n    // c. If result.[[Value]] is not undefined, throw a TypeError exception.\n    if (!result.value.mightBeUndefined())\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"constructor must return Object\");\n    result.value.throwIfNotConcrete();\n  } else if (result instanceof AbruptCompletion) {\n    // 14. Else, ReturnIfAbrupt(result).\n    throw result;\n  }\n\n  // 15. Return ? envRec.GetThisBinding().\n  let envRecThisBinding = envRec.GetThisBinding();\n  invariant(envRecThisBinding instanceof ObjectValue);\n  return envRecThisBinding;\n}\n\nexport class FunctionImplementation {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode> {\n    function FindVarScopedDeclarationsFor(ast: BabelNode, level: number) {\n      let statements = [];\n      switch (ast.type) {\n        case \"Program\":\n          statements = ((ast: any): BabelNodeProgram).body;\n          break;\n        case \"BlockStatement\":\n          statements = ((ast: any): BabelNodeBlockStatement).body;\n          break;\n        case \"DoWhileStatement\":\n          statements = [((ast: any): BabelNodeDoWhileStatement).body];\n          break;\n        case \"WhileStatement\":\n          statements = [((ast: any): BabelNodeWhileStatement).body];\n          break;\n        case \"IfStatement\":\n          let astIfStatement: BabelNodeIfStatement = (ast: any);\n          statements = [astIfStatement.consequent, astIfStatement.alternate];\n          break;\n        case \"ForStatement\":\n          let astForStatement: BabelNodeForStatement = (ast: any);\n          statements = [astForStatement.init, astForStatement.body];\n          break;\n        case \"ForInStatement\":\n          let astForInStatement: BabelNodeForInStatement = (ast: any);\n          statements = [astForInStatement.left, astForInStatement.body];\n          break;\n        case \"ForOfStatement\":\n          let astForOfStatement: BabelNodeForOfStatement = (ast: any);\n          statements = [astForOfStatement.left, astForOfStatement.body];\n          break;\n        case \"LabeledStatement\":\n          statements = [((ast: any): BabelNodeLabeledStatement).body];\n          break;\n        case \"WithStatement\":\n          statements = [((ast: any): BabelNodeWithStatement).body];\n          break;\n        case \"SwitchStatement\":\n          for (let switchCase of ((ast: any): BabelNodeSwitchStatement).cases) {\n            statements.push(...switchCase.consequent);\n          }\n          break;\n        case \"TryStatement\":\n          let astTryStatement: BabelNodeTryStatement = (ast: any);\n          statements = [astTryStatement.block];\n          if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);\n          if (astTryStatement.handler) statements.push(astTryStatement.handler.body);\n          break;\n        case \"VariableDeclaration\":\n          return ((ast: any): BabelNodeVariableDeclaration).kind === \"var\" ? [ast] : [];\n        case \"FunctionDeclaration\":\n          return level < 2 ? [ast] : [];\n        default:\n          return [];\n      }\n\n      let decls = [];\n      for (let statement of statements) {\n        if (statement) {\n          decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));\n        }\n      }\n\n      return decls;\n    }\n    return FindVarScopedDeclarationsFor(ast_node, 0);\n  }\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue {\n    // 1. Let calleeContext be the running execution context.\n    let calleeContext = realm.getRunningContext();\n\n    // 2. Let env be the LexicalEnvironment of calleeContext.\n    let env = calleeContext.lexicalEnvironment;\n\n    // 3. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.\n    let code = func.$ECMAScriptCode;\n    invariant(code !== undefined);\n\n    // 5. Let strict be the value of the [[Strict]] internal slot of func.\n    let strict = func.$Strict;\n\n    // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.\n    let formals = func.$FormalParameters;\n    invariant(formals !== undefined);\n\n    // 7. Let parameterNames be the BoundNames of formals.\n    let parameterNames = Object.create(null);\n    for (let param of formals) {\n      let paramBindings = t.getBindingIdentifiers(param, true);\n\n      for (let name in paramBindings) {\n        parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);\n      }\n    }\n\n    // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n    let hasDuplicates = false;\n    for (let name in parameterNames) {\n      let identifiers = parameterNames[name];\n      if (identifiers.length > 1) hasDuplicates = true;\n    }\n    parameterNames = Object.keys(parameterNames);\n\n    // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n    let simpleParameterList = true;\n    for (let param of formals) {\n      if (param.type !== \"Identifier\") {\n        simpleParameterList = false;\n        break;\n      }\n    }\n\n    // 10. Let hasParameterExpressions be ContainsExpression of formals.\n    let hasParameterExpressions = false;\n    invariant(formals !== undefined);\n    for (let param of formals) {\n      if (Environment.ContainsExpression(realm, param)) {\n        hasParameterExpressions = true;\n        break;\n      }\n    }\n\n    // 11. Let varNames be the VarDeclaredNames of code.\n    let varNames = [];\n    traverseFast(code, node => {\n      if (node.type === \"VariableDeclaration\" && ((node: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 12. Let varDeclarations be the VarScopedDeclarations of code.\n    let varDeclarations = this.FindVarScopedDeclarations(code);\n\n    // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n    let lexicalNames = [];\n\n    // 14. Let functionNames be an empty List.\n    let functionNames = [];\n\n    // 15. Let functionsToInitialize be an empty List.\n    let functionsToInitialize = [];\n\n    // 16. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iii. If fn is not an element of functionNames, then\n        if (functionNames.indexOf(fn) < 0) {\n          // 1. Insert fn as the first element of functionNames.\n          functionNames.unshift(fn);\n          // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 17. Let argumentsObjectNeeded be true.\n    let argumentsObjectNeeded = true;\n\n    // 18. If the value of the [[realmMode]] internal slot of func is lexical, then\n    if (func.$ThisMode === \"lexical\") {\n      // a. NOTE Arrow functions never have an arguments objects.\n      // b. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (parameterNames.indexOf(\"arguments\") >= 0) {\n      // 19. Else if \"arguments\" is an element of parameterNames, then\n      // a. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (hasParameterExpressions === false) {\n      // 20. Else if hasParameterExpressions is false, then\n      // a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n      if (functionNames.indexOf(\"arguments\") >= 0 || lexicalNames.indexOf(\"arguments\") >= 0) {\n        // i. Let argumentsObjectNeeded be false.\n        argumentsObjectNeeded = true;\n      }\n    }\n\n    // 21. For each String paramName in parameterNames, do\n    for (let paramName of parameterNames) {\n      // a. Let alreadyDeclared be envRec.HasBinding(paramName).\n      let alreadyDeclared = envRec.HasBinding(paramName);\n\n      // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n\n      // c. If alreadyDeclared is false, then\n      if (alreadyDeclared === false) {\n        // i. Perform ! envRec.CreateMutableBinding(paramName, false).\n        envRec.CreateMutableBinding(paramName, false);\n\n        // ii. If hasDuplicates is true, then\n        if (hasDuplicates === true) {\n          // 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n          envRec.InitializeBinding(paramName, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 22. If argumentsObjectNeeded is true, then\n    if (argumentsObjectNeeded === true) {\n      let ao;\n\n      // a. If strict is true or if simpleParameterList is false, then\n      if (strict === true || simpleParameterList === false) {\n        // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n        ao = Create.CreateUnmappedArgumentsObject(realm, argumentsList);\n      } else {\n        // b. Else,\n        // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n        // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n        invariant(formals !== undefined);\n        ao = Create.CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);\n      }\n\n      // c. If strict is true, then\n      if (strict === true) {\n        // i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n        envRec.CreateImmutableBinding(\"arguments\", false);\n      } else {\n        // d. Else,\n        // i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n        envRec.CreateMutableBinding(\"arguments\", false);\n      }\n\n      // e. Call envRec.InitializeBinding(\"arguments\", ao).\n      envRec.InitializeBinding(\"arguments\", ao);\n\n      // f. Append \"arguments\" to parameterNames.\n      parameterNames.push(\"arguments\");\n    }\n\n    // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: CreateListIterator(realm, argumentsList),\n      $Done: false,\n    };\n\n    // 24. If hasDuplicates is true, then\n    if (hasDuplicates === true) {\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict);\n    } else {\n      // 25. Else,\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict, env);\n    }\n\n    // 26. If hasParameterExpressions is false, then\n    let varEnv, varEnvRec;\n    if (hasParameterExpressions === false) {\n      // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.\n      // b. Let instantiatedVarNames be a copy of the List parameterNames.\n      let instantiatedVarNames = parameterNames.slice();\n\n      // c. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! envRec.CreateMutableBinding(n, false).\n          envRec.CreateMutableBinding(n, false);\n\n          // 3. Call envRec.InitializeBinding(n, undefined).\n          envRec.InitializeBinding(n, realm.intrinsics.undefined);\n        }\n      }\n\n      // e. Let varEnv be env.\n      varEnv = env;\n\n      // f. Let varEnvRec be envRec.\n      varEnvRec = envRec;\n    } else {\n      // 27. Else,\n      // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n\n      // b. Let varEnv be NewDeclarativeEnvironment(env).\n      varEnv = Environment.NewDeclarativeEnvironment(realm, env);\n      // At this point we haven't set any context's lexical environment to varEnv (and we might never do so),\n      // so it shouldn't be active\n      realm.activeLexicalEnvironments.delete(varEnv);\n\n      // c. Let varEnvRec be varEnv's EnvironmentRecord.\n      varEnvRec = varEnv.environmentRecord;\n\n      // d. Set the VariableEnvironment of calleeContext to varEnv.\n      calleeContext.variableEnvironment = varEnv;\n\n      // e. Let instantiatedVarNames be a new empty List.\n      let instantiatedVarNames = [];\n\n      // f. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n          varEnvRec.CreateMutableBinding(n, false);\n\n          // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.\n          let initialValue;\n          if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {\n            initialValue = realm.intrinsics.undefined;\n          } else {\n            // 4. Else,\n            // a. Let initialValue be ! envRec.GetBindingValue(n, false).\n            initialValue = envRec.GetBindingValue(n, false);\n          }\n\n          // 5. Call varEnvRec.InitializeBinding(n, initialValue).\n          varEnvRec.InitializeBinding(n, initialValue);\n\n          // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n\n    // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.\n\n    let lexEnv;\n\n    // 29. If strict is false, then\n    if (strict === false) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, varEnv);\n\n      // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n    } else {\n      // 30. Else, let lexEnv be varEnv.\n      lexEnv = varEnv;\n      // Since we previously removed varEnv, make sure to re-add it when it's used.\n      realm.activeLexicalEnvironments.add(varEnv);\n    }\n\n    // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 32. Set the LexicalEnvironment of calleeContext to lexEnv.\n    calleeContext.lexicalEnvironment = lexEnv;\n\n    // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n    let lexDeclarations = [];\n\n    // 34. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 35. For each parsed grammar phrase f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n      varEnvRec.SetMutableBinding(fn, fo, false);\n    }\n\n    // 36. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, _name: PropertyKeyValue | AbstractValue, prefix?: string): boolean {\n    // 1. Assert: F is an extensible object that does not have a name own property.\n    invariant(F.getExtensible(), \"expected object to be extensible and not have a name property\");\n\n    // 2. Assert: Type(name) is either Symbol or String.\n    invariant(\n      typeof _name === \"string\" ||\n        _name instanceof StringValue ||\n        _name instanceof SymbolValue ||\n        _name instanceof AbstractValue,\n      \"expected name to be a string or symbol\"\n    );\n    let name = typeof _name === \"string\" ? new StringValue(realm, _name) : _name;\n\n    // 3. Assert: If prefix was passed, then Type(prefix) is String.\n    invariant(prefix === undefined || typeof prefix === \"string\", \"expected prefix to be a string if passed\");\n\n    // 4. If Type(name) is Symbol, then\n    if (name instanceof SymbolValue) {\n      // a. Let description be name's [[Description]] value.\n      let description = name.$Description;\n\n      // b. If description is undefined, let name be the empty String.\n      if (description === undefined) {\n        name = realm.intrinsics.emptyString;\n      } else {\n        // c. Else, let name be the concatenation of \"[\", description, and \"]\".\n        invariant(description instanceof Value);\n        name = new StringValue(realm, `[${description.throwIfNotConcreteString().value}]`);\n      }\n    }\n\n    // 5. If prefix was passed, then\n    if (prefix) {\n      // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.\n      if (name instanceof AbstractValue) {\n        let prefixVal = new StringValue(realm, prefix + \" \");\n        name = AbstractValue.createFromBinaryOp(realm, \"+\", prefixVal, name, name.expressionLocation);\n      } else {\n        name = new StringValue(realm, `${prefix} ${name.value}`);\n      }\n    }\n\n    // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"name\", {\n      value: name,\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n  }\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue {\n    // Tell the realm to mark any local bindings that are visible to this function as being potentially captured by it.\n    realm.markVisibleLocalBindingsAsPotentiallyCaptured();\n\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an extensible object that does not have a length own property.\n    invariant(F.getExtensible(), \"expected to be extensible and no length property\");\n\n    // 2. Let len be the ExpectedArgumentCount of ParameterList.\n    let len = 0;\n    for (let FormalParameter of ParameterList) {\n      if (FormalParameter.type === \"AssignmentPattern\") {\n        break;\n      }\n      len += 1;\n    }\n\n    // 3. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"length\", {\n      value: new NumberValue(realm, len),\n      writable: false,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 4. Let Strict be the value of the [[Strict]] internal slot of F.\n    let Strict = F.$Strict;\n    if (!Strict) {\n      Properties.DefinePropertyOrThrow(realm, F, \"caller\", {\n        value: new UndefinedValue(realm),\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      });\n    }\n\n    // 5. Set the [[Environment]] internal slot of F to the value of Scope.\n    F.$Environment = Scope;\n\n    // 6. Set the [[FormalParameters]] internal slot of F to ParameterList.\n    F.$FormalParameters = ParameterList;\n\n    // 7. Set the [[ECMAScriptCode]] internal slot of F to Body.\n    ((Body: any): FunctionBodyAstNode).uniqueOrderedTag = realm.functionBodyUniqueTagSeed++;\n    F.$ECMAScriptCode = Body;\n\n    // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().\n    F.$ScriptOrModule = Environment.GetActiveScriptOrModule(realm);\n\n    // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.\n    if (kind === \"arrow\") {\n      F.$ThisMode = \"lexical\";\n    } else if (Strict === true) {\n      // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.\n      F.$ThisMode = \"strict\";\n    } else {\n      // 11. Else set the [[realmMode]] internal slot of F to global.\n      F.$ThisMode = \"global\";\n    }\n\n    // Return F.\n    return F;\n  }\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Let functionPrototype be the intrinsic object %Generator%.\n    let functionPrototype = realm.intrinsics.Generator;\n\n    // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n    let F = this.FunctionAllocate(realm, functionPrototype, Strict, \"generator\");\n\n    // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean {\n    // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n    // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].\n    let thrower = realm.intrinsics.ThrowTypeError;\n    invariant(thrower);\n\n    let desc = {\n      get: thrower,\n      set: thrower,\n      enumerable: false,\n      configurable: true,\n    };\n    // 3. Perform ! DefinePropertyOrThrow(F, \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"caller\", desc);\n    // 4. Return ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"arguments\", desc);\n  }\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value {\n    return InternalCall(realm, F, thisArgument, argsList, 0);\n  }\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue {\n    return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);\n  }\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue | AbstractObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Assert: Type(functionPrototype) is Object.\n    invariant(functionPrototype instanceof ObjectValue, \"expected functionPrototype to be an object\");\n\n    // 2. Assert: functionKind is either \"normal\", \"non-constructor\" or \"generator\".\n    invariant(\n      functionKind === \"normal\" || functionKind === \"non-constructor\" || functionKind === \"generator\",\n      \"invalid functionKind\"\n    );\n\n    // 3. If functionKind is \"normal\", let needsConstruct be true.\n    let needsConstruct;\n    if (functionKind === \"normal\") {\n      needsConstruct = true;\n    } else {\n      // 4. Else, let needsConstruct be false.\n      needsConstruct = false;\n    }\n\n    // 5. If functionKind is \"non-constructor\", let functionKind be \"normal\".\n    if (functionKind === \"non-constructor\") {\n      functionKind = \"normal\";\n    }\n\n    // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n    let F = new ECMAScriptSourceFunctionValue(realm);\n\n    // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.\n    F.$Call = (thisArgument, argsList) => {\n      return this.$Call(realm, F, thisArgument, argsList);\n    };\n\n    // 9. If needsConstruct is true, then\n    if (needsConstruct === true) {\n      // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.\n      F.$Construct = (argumentsList, newTarget) => {\n        return this.$Construct(realm, F, argumentsList, newTarget);\n      };\n\n      // b. Set the [[ConstructorKind]] internal slot of F to \"base\".\n      F.$ConstructorKind = \"base\";\n    }\n\n    // 10. Set the [[Strict]] internal slot of F to strict.\n    F.$Strict = strict;\n\n    // 11. Set the [[FunctionKind]] internal slot of F to functionKind.\n    F.$FunctionKind = functionKind;\n\n    // 12. Set the [[Prototype]] internal slot of F to functionPrototype.\n    F.$Prototype = functionPrototype;\n\n    // 13. Set the [[Extensible]] internal slot of F to true.\n    F.setExtensible(true);\n\n    // 14. Set the [[Realm]] internal slot of F to the current Realm Record.\n    F.$Realm = realm;\n\n    // 15. Return F.\n    return F;\n  }\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue {\n    // 1. Assert: Type(targetFunction) is Object.\n    invariant(targetFunction instanceof ObjectValue, \"expected an object\");\n\n    // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().\n    let proto = targetFunction.$GetPrototypeOf();\n\n    // 3. Let obj be a newly created object.\n    let obj = new BoundFunctionValue(realm);\n\n    // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n    obj.$Call = (thisArgument, argsList) => {\n      return $BoundCall(realm, obj, thisArgument, argsList);\n    };\n\n    // 6. If targetFunction has a [[Construct]] internal method, then\n    if (targetFunction.$Construct) {\n      // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n      obj.$Construct = (thisArgument, argsList) => {\n        return $BoundConstruct(realm, obj, thisArgument, argsList);\n      };\n    }\n\n    // 7. Set the [[Prototype]] internal slot of obj to proto.\n    obj.$Prototype = proto;\n\n    // 8. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.\n    obj.$BoundTargetFunction = targetFunction;\n\n    // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.\n    obj.$BoundThis = boundThis;\n\n    // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.\n    obj.$BoundArguments = boundArgs;\n\n    // 12. Return obj.\n    return obj;\n  }\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value {\n    // 1. Assert: If direct is false, then strictCaller is also false.\n    if (direct === false) invariant(strictCaller === false, \"strictCaller is only allowed on direct eval\");\n\n    // 2. If Type(x) is not String, return x.\n    if (!(x instanceof StringValue)) return x;\n\n    // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text\n    //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any\n    //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the\n    //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation\n    //    dependent manner.\n    let ast = parse(realm, x.value, \"eval\", \"script\");\n    let script = ast.program;\n\n    // 4. If script Contains ScriptBody is false, return undefined.\n    if (!script.body) return realm.intrinsics.undefined;\n\n    // 5. Let body be the ScriptBody of script.\n    let body = t.blockStatement(script.body, script.directives);\n\n    // 6. If strictCaller is true, let strictEval be true.\n    let strictEval;\n    if (strictCaller) {\n      strictEval = true;\n    } else {\n      // 7. Else, let strictEval be IsStrict of script.\n      strictEval = IsStrict(script);\n    }\n\n    // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that\n    //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of\n    //    the eval function.\n    let ctx = realm.getRunningContext();\n\n    // 9. If direct is true, then\n    let lexEnv, varEnv;\n    if (direct) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment);\n\n      // b. Let varEnv be ctx's VariableEnvironment.\n      varEnv = ctx.variableEnvironment;\n    } else {\n      // 10. Else,\n      // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv);\n\n      // b. Let varEnv be evalRealm.[[GlobalEnv]].\n      varEnv = evalRealm.$GlobalEnv;\n    }\n\n    // 11. If strictEval is true, let varEnv be lexEnv.\n    if (strictEval) varEnv = lexEnv;\n\n    // 12. If ctx is not already suspended, suspend ctx.\n    ctx.suspend();\n\n    // 13. Let evalCxt be a new ECMAScript code execution context.\n    let evalCxt = realm.createExecutionContext();\n    evalCxt.isStrict = strictEval;\n\n    // 14. Set the evalCxt's Function to null.\n    evalCxt.setFunction(null);\n\n    // 15. Set the evalCxt's Realm to evalRealm.\n    evalCxt.setRealm(evalRealm);\n\n    // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n    evalCxt.ScriptOrModule = ctx.ScriptOrModule;\n\n    // 17. Set the evalCxt's VariableEnvironment to varEnv.\n    evalCxt.variableEnvironment = varEnv;\n\n    // 18. Set the evalCxt's LexicalEnvironment to lexEnv.\n    evalCxt.lexicalEnvironment = lexEnv;\n\n    // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n    realm.pushContext(evalCxt);\n\n    let result;\n    try {\n      // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n      invariant(varEnv);\n      try {\n        result = this.EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);\n      } catch (e) {\n        if (e instanceof AbruptCompletion) {\n          result = e;\n        } else {\n          throw e;\n        }\n      }\n      invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n      // 21. If result.[[Type]] is normal, then\n      if (result instanceof Value) {\n        // Evaluate expressions that passed for directives.\n        if (script.directives) {\n          for (let directive of script.directives) {\n            result = new StringValue(realm, directive.value.value);\n          }\n        }\n\n        // a. Let result be the result of evaluating body.\n        result = this.EvaluateStatements(script.body, result, strictEval, lexEnv, realm);\n      }\n\n      // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then\n      if (result instanceof EmptyValue) {\n        // a. Let result be NormalCompletion(undefined).\n        result = realm.intrinsics.undefined;\n      }\n    } finally {\n      // 23. Suspend evalCxt and remove it from the execution context stack.\n      evalCxt.suspend();\n      realm.popContext(evalCxt);\n      realm.onDestroyScope(evalCxt.lexicalEnvironment);\n    }\n\n    // 24. Resume the context that is now on the top of the execution context stack as the running execution context.\n    invariant(realm.getRunningContext() === ctx);\n    ctx.resume();\n\n    // 25. Return Completion(result).\n    if (result instanceof Value) {\n      return result;\n    } else {\n      invariant(result instanceof AbruptCompletion);\n      throw result;\n    }\n  }\n\n  // If c is an abrupt completion and realm.savedCompletion is defined, the result is an instance of\n  // ForkedAbruptCompletion and the effects that have been captured since the PossiblyNormalCompletion instance\n  // in realm.savedCompletion has been created, becomes the effects of the branch that terminates in c.\n  // If c is a normal completion, the result is realm.savedCompletion, with its value updated to c.\n  // If c is undefined, the result is just realm.savedCompletion.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | AbruptCompletion | Value): void | Completion | Value {\n    let savedCompletion = realm.savedCompletion;\n    if (savedCompletion !== undefined) {\n      if (savedCompletion.savedPathConditions) {\n        // Since we are joining several control flow paths, we need the curent path conditions to reflect\n        // only the refinements that applied at the corresponding fork point.\n        realm.pathConditions = savedCompletion.savedPathConditions;\n        savedCompletion.savedPathConditions = [];\n      }\n      realm.savedCompletion = undefined;\n      if (c === undefined) return savedCompletion;\n      if (c instanceof Value) {\n        Join.updatePossiblyNormalCompletionWithValue(realm, savedCompletion, c);\n        return savedCompletion;\n      } else {\n        let e = realm.getCapturedEffects();\n        realm.stopEffectCaptureAndUndoEffects(savedCompletion);\n        return Join.replacePossiblyNormalCompletionWithForkedAbruptCompletion(realm, savedCompletion, c, e);\n      }\n    }\n    return c;\n  }\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value {\n    let blockValue = initialBlockValue;\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let res = blockEnv.evaluateCompletionDeref(node, strictCode);\n        if (!(res instanceof EmptyValue)) {\n          if (res instanceof AbruptCompletion) throw UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty);\n          invariant(res instanceof Value);\n          blockValue = res;\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return blockValue || realm.intrinsics.empty;\n  }\n\n  PartiallyEvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    blockValue: void | NormalCompletion | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): [Completion | Value, Array<BabelNodeStatement>] {\n    let statementAsts = [];\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let [res, nast, nio] = blockEnv.partiallyEvaluateCompletionDeref(node, strictCode);\n        for (let ioAst of nio) statementAsts.push(ioAst);\n        statementAsts.push((nast: any));\n        if (!(res instanceof EmptyValue)) {\n          if (blockValue === undefined || blockValue instanceof Value) {\n            if (res instanceof AbruptCompletion)\n              return [UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty), statementAsts];\n            invariant(res instanceof NormalCompletion || res instanceof Value);\n            blockValue = res;\n          }\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return [blockValue || realm.intrinsics.empty, statementAsts];\n  }\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue {\n    // 1. If the prototype argument was not passed, then\n    if (!prototype) {\n      // a. Let prototype be the intrinsic object %FunctionPrototype%.\n      prototype = realm.intrinsics.FunctionPrototype;\n    }\n\n    // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n    let allocKind;\n    if (kind !== \"normal\") {\n      allocKind = \"non-constructor\";\n    } else {\n      // 3. Else, let allocKind be \"normal\".\n      allocKind = \"normal\";\n    }\n\n    // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n    let F = this.FunctionAllocate(realm, prototype, Strict, allocKind);\n\n    // ECMAScript 2016, section 17:\n    //   \"Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified.\"\n    // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property \"arguments\" will raise a `TypeError` by default.\n    // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.\n    // Note: \"arguments\" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.\n    //   See 16.2 \"Forbidden Extensions\"\n    if (!Strict && kind === \"normal\") {\n      Properties.DefinePropertyOrThrow(realm, F, \"arguments\", {\n        value: realm.intrinsics.undefined,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n      });\n    }\n\n    // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value {\n    // 1. Let varNames be the VarDeclaredNames of body.\n    let varNames = [];\n    traverseFast(body, node => {\n      if (node.type === \"VariableDeclaration\" && ((node: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 2. Let varDeclarations be the VarScopedDeclarations of body.\n    let varDeclarations = this.FindVarScopedDeclarations(body);\n\n    // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n    let varEnvRec = varEnv.environmentRecord;\n\n    // 5. If strict is false, then\n    if (!strict) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. For each name in varNames, do\n        for (let name of varNames) {\n          // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n          if (varEnvRec.HasLexicalDeclaration(name)) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.SyntaxError,\n              new StringValue(realm, name + \" global object is restricted\")\n            );\n          }\n          // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n        }\n      }\n      // b. Let thisLex be lexEnv.\n      let thisLex = lexEnv;\n      // c. Assert: The following loop will terminate.\n      // d. Repeat while thisLex is not the same as varEnv,\n      while (thisLex !== varEnv) {\n        // i. Let thisEnvRec be thisLex's EnvironmentRecord.\n        let thisEnvRec = thisLex.environmentRecord;\n        // ii. If thisEnvRec is not an object Environment Record, then\n        if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {\n          // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n          // 2. For each name in varNames, do\n          for (let name of varNames) {\n            // a. If thisEnvRec.HasBinding(name) is true, then\n            if (thisEnvRec.HasBinding(name)) {\n              // i. Throw a SyntaxError exception.\n              throw realm.createErrorThrowCompletion(\n                realm.intrinsics.SyntaxError,\n                name + \" global object is restricted\"\n              );\n              // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n            }\n            // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n          }\n        }\n        // iii. Let thisLex be thisLex's outer environment reference.\n        thisLex = thisLex.parent;\n        invariant(thisLex !== null);\n      }\n    }\n\n    // 6. Let functionsToInitialize be a new empty List.\n    let functionsToInitialize = [];\n\n    // 7. Let declaredFunctionNames be a new empty List.\n    let declaredFunctionNames = [];\n\n    // 8. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n        // iii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iv. If fn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(fn) < 0) {\n          // 1. If varEnvRec is a global Environment Record, then\n          if (varEnvRec instanceof GlobalEnvironmentRecord) {\n            // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n            let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);\n            // b. If fnDefinable is false, throw a TypeError exception.\n            if (!fnDefinable) {\n              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + \" is not definable\");\n            }\n          }\n          // 2. Append fn to declaredFunctionNames.\n          declaredFunctionNames.push(fn);\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n\n    // 10. Let declaredVarNames be a new empty List.\n    let declaredVarNames = [];\n\n    // 11. For each d in varDeclarations, do\n    for (let d of varDeclarations) {\n      // a. If d is a VariableDeclaration or a ForBinding, then\n      if (d.type === \"VariableDeclaration\") {\n        // i. For each String vn in the BoundNames of d, do\n        for (let vn of Environment.BoundNames(realm, d)) {\n          // 1. If vn is not an element of declaredFunctionNames, then\n          if (declaredFunctionNames.indexOf(vn) < 0) {\n            // a. If varEnvRec is a global Environment Record, then\n            if (varEnvRec instanceof GlobalEnvironmentRecord) {\n              // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n              let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);\n              // ii. If vnDefinable is false, throw a TypeError exception.\n              if (!vnDefinable) {\n                throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + \" is not definable\");\n              }\n            }\n            // b. If vn is not an element of declaredVarNames, then\n            if (declaredVarNames.indexOf(vn) < 0) {\n              // i. Append vn to declaredVarNames.\n              declaredVarNames.push(vn);\n            }\n          }\n        }\n      }\n    }\n\n    // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n\n    // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n    let lexDeclarations = [];\n    for (let s of body.body) {\n      if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n        lexDeclarations.push(s);\n      }\n    }\n\n    // 14. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // c. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // d. Else,\n          // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 15. For each production f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n        varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);\n      } else {\n        // d. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(fn).\n        let bindingExists = varEnvRec.HasBinding(fn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n          varEnvRec.CreateMutableBinding(fn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n          varEnvRec.InitializeBinding(fn, fo);\n        } else {\n          // iii. Else,\n          // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n          varEnvRec.SetMutableBinding(fn, fo, false);\n        }\n      }\n    }\n\n    // 16. For each String vn in declaredVarNames, in list order do\n    for (let vn of declaredVarNames) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n        varEnvRec.CreateGlobalVarBinding(vn, true);\n      } else {\n        // b. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(vn).\n        let bindingExists = varEnvRec.HasBinding(vn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n          varEnvRec.CreateMutableBinding(vn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n          varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 17. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value {\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an ECMAScript function object.\n    invariant(F instanceof ECMAScriptSourceFunctionValue, \"F is an ECMAScript function object.\");\n\n    // 2. Assert: Type(homeObject) is Object.\n    invariant(homeObject instanceof ObjectValue, \"Type(homeObject) is Object.\");\n\n    // 3. Set the [[HomeObject]] internal slot of F to homeObject.\n    F.$HomeObject = homeObject;\n\n    // 4. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue } {\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(prop.body);\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    let scope = env;\n\n    // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.\n    let kind;\n    if (functionPrototype) {\n      // let kind be Normal;\n      kind = \"normal\";\n    } else {\n      // otherwise let kind be Method.\n      kind = \"method\";\n    }\n\n    // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.\n    let closure = this.FunctionCreate(realm, kind, prop.params, prop.body, scope, strict, functionPrototype);\n\n    // 7. Perform MakeMethod(closure, object).\n    this.MakeMethod(realm, closure, obj);\n\n    // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.\n    return { $Key: propKey, $Closure: closure };\n  }\n}\n"]}