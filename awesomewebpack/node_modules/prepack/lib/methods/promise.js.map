{"version":3,"sources":["../../src/methods/promise.js"],"names":["EnqueueJob","NewPromiseCapability","PerformPromiseAll","PerformPromiseRace","PerformPromiseThen","PromiseReactionJob","CreateResolvingFunctions","FulfillPromise","RejectPromise","TriggerPromiseReactions","HostPromiseRejectionTracker","PromiseResolveThenableJob","realm","queueName","job","args","C","createErrorThrowCompletion","intrinsics","TypeError","promiseCapability","promise","undefined","resolve","reject","executor","context","$Capability","mightBeUndefined","throwIfNotConcrete","createResolveElementFunction","resolveElement","x","alreadyCalled","$AlreadyCalled","value","myIndex","$Index","values","$Values","Array","$Capabilities","remainingElementsCount","$RemainingElements","valuesArray","CreateArrayFromList","iteratorRecord","constructor","resultCapability","index","next","$Iterator","e","$Done","nextValue","push","nextPromise","onFulfilled","onRejected","fulfillReaction","capabilities","handler","rejectReaction","$PromiseState","ThrowIfInternalSlotNotWritable","$PromiseFulfillReactions","$PromiseRejectReactions","$PromiseResult","reason","$PromiseIsHandled","reaction","argument","createResolveFunction","resolution","$Promise","alreadyResolved","$AlreadyResolved","selfResolutionError","then","thenAction","createRejectFunction","reactions","operation","promiseToResolve","thenable"],"mappings":"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","file":"promise.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { ResolvingFunctions, PromiseCapability, PromiseReaction } from \"../types.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport {\n  Value,\n  ObjectValue,\n  StringValue,\n  NativeFunctionValue,\n  FunctionValue,\n  type UndefinedValue,\n} from \"../values/index.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { Get } from \"../methods/get.js\";\nimport { Invoke, Call } from \"../methods/call.js\";\nimport { IsCallable, IsConstructor, IsPromise } from \"../methods/is.js\";\nimport { IteratorStep, IteratorValue } from \"../methods/iterator.js\";\nimport { Create, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 8.4.1\nexport function EnqueueJob(realm: Realm, queueName: string, job: Function, args: Array<any>): void {}\n\n// ECMA262 25.4.1.5\nexport function NewPromiseCapability(realm: Realm, C: Value): PromiseCapability {\n  // 1. If IsConstructor(C) is false, throw a TypeError exception.\n  if (IsConstructor(realm, C) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n  }\n  invariant(C instanceof ObjectValue);\n\n  // 2. NOTE C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.4.3.1).\n\n  // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.\n  let promiseCapability = {\n    promise: realm.intrinsics.undefined,\n    resolve: realm.intrinsics.undefined,\n    reject: realm.intrinsics.undefined,\n  };\n\n  // 4. Let executor be a new built-in function object as defined in GetCapabilitiesExecutor Functions (25.4.1.5.1).\n  let executor = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    2,\n    (context, [resolve, reject]) => {\n      // 1. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.\n      invariant(executor.$Capability, \"F has a [[Capability]] internal slot whose value is a PromiseCapability Record\");\n\n      // 2. Let promiseCapability be the value of F's [[Capability]] internal slot.\n      invariant(promiseCapability === executor.$Capability);\n\n      // 3. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.\n      if (!promiseCapability.resolve.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"promiseCapability.[[Resolve]] is not undefined\"\n        );\n      }\n      promiseCapability.resolve.throwIfNotConcrete();\n\n      // 4. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.\n      if (!promiseCapability.reject.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"promiseCapability.[[Reject]] is not undefined\"\n        );\n      }\n      promiseCapability.reject.throwIfNotConcrete();\n\n      // 5. Set promiseCapability.[[Resolve]] to resolve.\n      promiseCapability.resolve = resolve;\n\n      // 6. Set promiseCapability.[[Reject]] to reject.\n      promiseCapability.reject = reject;\n\n      // 7. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n\n  // 5. Set the [[Capability]] internal slot of executor to promiseCapability.\n  executor.$Capability = promiseCapability;\n\n  // 6. Let promise be ? Construct(C, « executor »).\n  let promise = Construct(realm, C, [executor]);\n\n  // 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.resolve) === false) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"IsCallable(promiseCapability.[[Resolve]]) is false\"\n    );\n  }\n\n  // 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.reject) === false) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"IsCallable(promiseCapability.[[Reject]]) is false\"\n    );\n  }\n\n  // 9. Set promiseCapability.[[Promise]] to promise.\n  promiseCapability.promise = promise;\n\n  // 10. Return promiseCapability.\n  return promiseCapability;\n}\n\n// ECMA262 25.4.4.1.1j\nfunction createResolveElementFunction(realm) {\n  let resolveElement = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [x]) => {\n      // 1. Let alreadyCalled be the value of F's [[AlreadyCalled]] internal slot.\n      let alreadyCalled = resolveElement.$AlreadyCalled;\n      invariant(alreadyCalled);\n\n      // 2. If alreadyCalled.[[Value]] is true, return undefined.\n      if (alreadyCalled.value === true) {\n        return realm.intrinsics.undefined;\n      }\n\n      // 3. Set alreadyCalled.[[Value]] to true.\n      alreadyCalled.value = true;\n\n      // 4. Let index be the value of F's [[Index]] internal slot.\n      let myIndex = resolveElement.$Index;\n      invariant(typeof myIndex === \"number\");\n\n      // 5. Let values be the value of F's [[Values]] internal slot.\n      let values = resolveElement.$Values;\n      invariant(values instanceof Array);\n\n      // 6. Let promiseCapability be the value of F's [[Capabilities]] internal slot.\n      let promiseCapability = resolveElement.$Capabilities;\n      invariant(promiseCapability);\n\n      // 7. Let remainingElementsCount be the value of F's [[RemainingElements]] internal slot.\n      let remainingElementsCount = resolveElement.$RemainingElements;\n      invariant(remainingElementsCount);\n\n      // 8. Set values[index] to x.\n      values[myIndex] = x;\n\n      // 9. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // 10. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // a. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = Create.CreateArrayFromList(realm, values);\n\n        // b. Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, promiseCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // 11. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n  return resolveElement;\n}\n\n// ECMA262 25.4.4.1.1\nexport function PerformPromiseAll(\n  realm: Realm,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  constructor: FunctionValue,\n  resultCapability: PromiseCapability\n): Value {\n  // 1. Assert: constructor is a constructor function.\n  invariant(\n    constructor instanceof FunctionValue && IsConstructor(realm, constructor),\n    \"constructor is a constructor function\"\n  );\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. Let values be a new empty List.\n  let values = [];\n\n  // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.\n  let remainingElementsCount = { value: 1 };\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // iii. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // 1. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = Create.CreateArrayFromList(realm, values);\n\n        // 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, resultCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // iv. Return resultCapability.[[Promise]].\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Append undefined to values.\n    values.push(realm.intrinsics.undefined);\n\n    // i. Let nextPromise be ? Invoke(constructor, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, constructor, \"resolve\", [nextValue]);\n\n    // j. Let resolveElement be a new built-in function object as defined in Promise.all Resolve Element Functions.\n    let resolveElement = createResolveElementFunction(realm);\n\n    // k. Set the [[AlreadyCalled]] internal slot of resolveElement to a new Record {[[Value]]: false }.\n    resolveElement.$AlreadyCalled = { value: false };\n\n    // l. Set the [[Index]] internal slot of resolveElement to index.\n    resolveElement.$Index = index;\n\n    // m. Set the [[Values]] internal slot of resolveElement to values.\n    resolveElement.$Values = values;\n\n    // n. Set the [[Capabilities]] internal slot of resolveElement to resultCapability.\n    resolveElement.$Capabilities = resultCapability;\n\n    // o. Set the [[RemainingElements]] internal slot of resolveElement to remainingElementsCount.\n    resolveElement.$RemainingElements = remainingElementsCount;\n\n    // p. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.\n    remainingElementsCount.value = remainingElementsCount.value + 1;\n\n    // q. Perform ? Invoke(nextPromise, \"then\", « resolveElement, resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resolveElement, resultCapability.reject]);\n\n    // r. Set index to index + 1.\n    index = index + 1;\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.4.3.1\nexport function PerformPromiseRace(\n  realm: Realm,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  resultCapability: PromiseCapability,\n  C: ObjectValue\n): ObjectValue {\n  // 1. Assert: constructor is a constructor function.\n  invariant(IsConstructor(realm, C), \"constructor is a constructor function\");\n\n  // 2. Assert: resultCapability is a PromiseCapability Record.\n  resultCapability;\n\n  // 3. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Return resultCapability.[[Promise]].\n      invariant(resultCapability.promise instanceof ObjectValue);\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Let nextPromise be ? Invoke(C, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, C, \"resolve\", [nextValue]);\n\n    // i. Perform ? Invoke(nextPromise, \"then\", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resultCapability.resolve, resultCapability.reject]);\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.5.3.1\nexport function PerformPromiseThen(\n  realm: Realm,\n  promise: ObjectValue,\n  onFulfilled: Value,\n  onRejected: Value,\n  resultCapability: PromiseCapability\n): ObjectValue {\n  // 1. Assert: IsPromise(promise) is true.\n  invariant(IsPromise(realm, promise), \"IsPromise(promise) is true\");\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. If IsCallable(onFulfilled) is false, then\n  if (IsCallable(realm, onFulfilled) === false) {\n    // a. Let onFulfilled be \"Identity\".\n    onFulfilled = new StringValue(realm, \"Identity\");\n  }\n\n  // 4. If IsCallable(onRejected) is false, then\n  if (IsCallable(realm, onRejected)) {\n    // a. Let onRejected be \"Thrower\".\n    onRejected = new StringValue(realm, \"Thrower\");\n  }\n\n  // 5. Let fulfillReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled }.\n  let fulfillReaction = { capabilities: resultCapability, handler: onFulfilled };\n\n  // 6. Let rejectReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onRejected}.\n  let rejectReaction = { capabilities: resultCapability, handler: onRejected };\n\n  // 7. If the value of promise's [[PromiseState]] internal slot is \"pending\", then\n  if (promise.$PromiseState === \"pending\") {\n    // a. Append fulfillReaction as the last element of the List that is the value of promise's [[PromiseFulfillReactions]] internal slot.\n    Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseFulfillReactions\");\n    invariant(promise.$PromiseFulfillReactions);\n    promise.$PromiseFulfillReactions.push(fulfillReaction);\n    // b. Append rejectReaction as the last element of the List that is the value of promise's [[PromiseRejectReactions]] internal slot.\n    Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseRejectReactions\");\n    invariant(promise.$PromiseRejectReactions);\n    promise.$PromiseRejectReactions.push(rejectReaction);\n  } else if (promise.$PromiseState === \"fulfilled\") {\n    // 8. Else if the value of promise's [[PromiseState]] internal slot is \"fulfilled\", then\n    // a. Let value be the value of promise's [[PromiseResult]] internal slot.\n    let value = promise.$PromiseResult;\n    // b. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « fulfillReaction, value »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [fulfillReaction, value]);\n  } else {\n    // 9. Else,\n    // a. Assert: The value of promise's [[PromiseState]] internal slot is \"rejected\".\n    invariant(promise.$PromiseState === \"rejected\");\n\n    // b. Let reason be the value of promise's [[PromiseResult]] internal slot.\n    let reason = promise.$PromiseResult;\n\n    // c. If the value of promise's [[PromiseIsHandled]] internal slot is false, perform HostPromiseRejectionTracker(promise, \"handle\").\n    if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"handle\");\n\n    // d. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « rejectReaction, reason »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [rejectReaction, reason]);\n  }\n\n  // 10. Set promise's [[PromiseIsHandled]] internal slot to true.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseIsHandled\").$PromiseIsHandled = true;\n\n  // 11. Return resultCapability.[[Promise]].\n  invariant(resultCapability.promise instanceof ObjectValue);\n  return resultCapability.promise;\n}\n\n// ECMA262 25.4.2.1\nexport function PromiseReactionJob(realm: Realm, reaction: Function, argument: Value): Value {\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.3.2\nfunction createResolveFunction(realm) {\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [resolution]) => {\n      // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n      invariant(resolve.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n      // 2. Let promise be the value of F's [[Promise]] internal slot.\n      let promise = resolve.$Promise;\n\n      // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n      let alreadyResolved = resolve.$AlreadyResolved;\n      invariant(alreadyResolved !== undefined);\n\n      // 4. If alreadyResolved.[[Value]] is true, return undefined.\n      if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n      // 5. Set alreadyResolved.[[Value]] to true.\n      alreadyResolved.value = true;\n\n      // 6. If SameValue(resolution, promise) is true, then\n      if (SameValue(realm, resolution.throwIfNotConcrete(), promise)) {\n        // a. Let selfResolutionError be a newly created TypeError object.\n        let selfResolutionError = Construct(realm, realm.intrinsics.TypeError, [new StringValue(realm, \"resolve\")]);\n\n        // b. Return RejectPromise(promise, selfResolutionError).\n        return RejectPromise(realm, promise, selfResolutionError);\n      }\n      // 7. If Type(resolution) is not Object, then\n      if (!(resolution instanceof ObjectValue)) {\n        // a. Return FulfillPromise(promise, resolution).\n        return FulfillPromise(realm, promise, resolution);\n      }\n\n      // 8. Let then be Get(resolution, \"then\").\n      let then;\n      try {\n        then = Get(realm, resolution, \"then\");\n      } catch (e) {\n        // 9. If then is an abrupt completion, then\n        if (e instanceof AbruptCompletion) {\n          // a. Return RejectPromise(promise, then.[[Value]]).\n          return RejectPromise(realm, promise, e);\n        } else throw e;\n      }\n\n      // 10. Let thenAction be then.[[Value]].\n      let thenAction = then;\n\n      // 11. If IsCallable(thenAction) is false, then\n      if (IsCallable(realm, thenAction)) {\n        // a. Return FulfillPromise(promise, resolution).\n        return FulfillPromise(realm, promise, resolution);\n      }\n\n      // 12. Perform EnqueueJob(\"PromiseJobs\", PromiseResolveThenableJob, « promise, resolution, thenAction »).\n      EnqueueJob(realm, \"PromiseJobs\", PromiseResolveThenableJob, [promise, resolution, thenAction]);\n\n      // 13. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n  return resolve;\n}\n\n// ECMA262 25.4.1.3.1\nfunction createRejectFunction(realm) {\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [reason]) => {\n      // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n      invariant(reject.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n      // 2. Let promise be the value of F's [[Promise]] internal slot.\n      let promise = reject.$Promise;\n\n      // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n      let alreadyResolved = reject.$AlreadyResolved;\n      invariant(alreadyResolved !== undefined);\n\n      // 4. If alreadyResolved.[[Value]] is true, return undefined.\n      if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n      // 5. Set alreadyResolved.[[Value]] to true.\n      alreadyResolved.value = true;\n\n      // 6. Return RejectPromise(promise, reason).\n      return RejectPromise(realm, promise, reason);\n    },\n    false\n  );\n  return reject;\n}\n\n// ECMA262 25.4.1.3\nexport function CreateResolvingFunctions(realm: Realm, promise: ObjectValue): ResolvingFunctions {\n  // 1. Let alreadyResolved be a new Record { [[Value]]: false }.\n  let alreadyResolved = { value: false };\n\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = createResolveFunction(realm);\n\n  // 3. Set the [[Promise]] internal slot of resolve to promise.\n  resolve.$Promise = promise;\n\n  // 4. Set the [[AlreadyResolved]] internal slot of resolve to alreadyResolved.\n  resolve.$AlreadyResolved = alreadyResolved;\n\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = createRejectFunction(realm);\n\n  // 6. Set the [[Promise]] internal slot of reject to promise.\n  reject.$Promise = promise;\n\n  // 7. Set the [[AlreadyResolved]] internal slot of reject to alreadyResolved.\n  reject.$AlreadyResolved = alreadyResolved;\n\n  // 8. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.\n  return { resolve: resolve, reject: reject };\n}\n\n// ECMA262 25.4.1.4\nexport function FulfillPromise(realm: Realm, promise: ObjectValue, value: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseFulfillReactions]].\n  let reactions = promise.$PromiseFulfillReactions;\n  invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to value.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = value;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseFulfillReactions\"\n  ).$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseRejectReactions\"\n  ).$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"fulfilled\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"fulfilled\";\n\n  // 7. Return TriggerPromiseReactions(reactions, value).\n  return TriggerPromiseReactions(realm, reactions, value);\n}\n\n// ECMA262 25.4.1.7\nexport function RejectPromise(realm: Realm, promise: ObjectValue, reason: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseRejectReactions]].\n  let reactions = promise.$PromiseFulfillReactions;\n  invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to reason.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = reason;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseFulfillReactions\"\n  ).$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseRejectReactions\"\n  ).$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"rejected\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"rejected\";\n\n  // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"reject\").\n  if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"reject\");\n\n  // 8. Return TriggerPromiseReactions(reactions, reason).\n  return TriggerPromiseReactions(realm, reactions, reason);\n}\n\n// ECMA262 25.4.1.8\nexport function TriggerPromiseReactions(\n  realm: Realm,\n  reactions: Array<PromiseReaction>,\n  argument: Value\n): UndefinedValue {\n  // 1. Repeat for each reaction in reactions, in original insertion order\n  for (let reaction of reactions) {\n    // a. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « reaction, argument »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [reaction, argument]);\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.9\nexport function HostPromiseRejectionTracker(realm: Realm, promise: ObjectValue, operation: \"reject\" | \"handle\"): void {}\n\n// ECMA262 25.4.2.2\nexport function PromiseResolveThenableJob(\n  realm: Realm,\n  promiseToResolve: ObjectValue,\n  thenable: Value,\n  then: Value\n): void {}\n"]}