"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrdinaryPreventExtensions = OrdinaryPreventExtensions;
exports.SetIntegrityLevel = SetIntegrityLevel;
exports.TestIntegrityLevel = TestIntegrityLevel;

var _index = require("../values/index.js");

var _index2 = require("./index.js");

var _singletons = require("../singletons.js");

var _errors = require("../errors.js");

var _invariant = require("../invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ECMA262 9.1.4.1
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */

function OrdinaryPreventExtensions(realm, O) {
  if (O.mightBeHavocedObject() && O.getExtensible()) {
    // todo: emit a diagnostic messsage
    throw new _errors.FatalError();
  }

  // 1. Set the value of the [[Extensible]] internal slot of O to false.
  O.setExtensible(false);

  // 2. Return true.
  return true;
}

// ECMA262 7.3.14
function SetIntegrityLevel(realm, O, level) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index.ObjectValue, "expected an object");

  // 2. Assert: level is either "sealed" or "frozen".
  (0, _invariant2.default)(level === "sealed" || level === "frozen", "invalid level");

  // 3. Let status be ? O.[[PreventExtensions]]().
  let status = O.$PreventExtensions();

  // 4. If status is false, return false.
  if (status === false) return false;

  // 5. Let keys be ? O.[[OwnPropertyKeys]]().
  let keys = O.$OwnPropertyKeys();

  // 6. If level is "sealed", then
  if (level === "sealed") {
    // a. Repeat for each element k of keys,
    for (let k of keys) {
      // i. Perform ? DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false}).
      _singletons.Properties.DefinePropertyOrThrow(realm, O, k, {
        configurable: false
      });
    }
  } else if (level === "frozen") {
    // 7. Else level is "frozen",
    // a. Repeat for each element k of keys,
    for (let k of keys) {
      // i. Let currentDesc be ? O.[[GetOwnProperty]](k).
      let currentDesc = O.$GetOwnProperty(k);

      // ii. If currentDesc is not undefined, then
      if (currentDesc) {
        _singletons.Properties.ThrowIfMightHaveBeenDeleted(currentDesc.value);
        let desc;

        // 1. If IsAccessorDescriptor(currentDesc) is true, then
        if ((0, _index2.IsAccessorDescriptor)(realm, currentDesc)) {
          // a. Let desc be the PropertyDescriptor{[[Configurable]]: false}.
          desc = { configurable: false };
        } else {
          // 2. Else,
          // b. Let desc be the PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }.
          desc = { configurable: false, writable: false };
        }

        // 3. Perform ? DefinePropertyOrThrow(O, k, desc).
        _singletons.Properties.DefinePropertyOrThrow(realm, O, k, desc);
      }
    }
  }

  // 8. Return true.
  return true;
}

// ECMA262 7.3.15
function TestIntegrityLevel(realm, O, level) {
  // 1. Assert: Type(O) is Object.
  (0, _invariant2.default)(O instanceof _index.ObjectValue, "expected an object");

  // 2. Assert: level is either "sealed" or "frozen".
  (0, _invariant2.default)(level === "sealed" || level === "frozen", "invalid level");

  // 3. Let status be ? IsExtensible(O).
  let status = (0, _index2.IsExtensible)(realm, O);

  // 4. If status is true, return false.
  if (status === true) return false;

  // 5. NOTE If the object is extensible, none of its properties are examined.

  // 6. Let keys be ? O.[[OwnPropertyKeys]]().
  let keys = O.$OwnPropertyKeys();

  // 7. Repeat for each element k of keys,
  for (let k of keys) {
    // a. Let currentDesc be ? O.[[GetOwnProperty]](k).
    let currentDesc = O.$GetOwnProperty(k);

    // b. If currentDesc is not undefined, then
    if (currentDesc) {
      _singletons.Properties.ThrowIfMightHaveBeenDeleted(currentDesc.value);

      // i. If currentDesc.[[Configurable]] is true, return false.
      if (currentDesc.configurable === true) return false;

      // ii. If level is "frozen" and IsDataDescriptor(currentDesc) is true, then
      if (level === "frozen" && (0, _index2.IsDataDescriptor)(realm, currentDesc) === true) {
        // 1. If currentDesc.[[Writable]] is true, return false.
        if (currentDesc.writable === true) return false;
      }
    }
  }

  // 8. Return true.
  return true;
}
//# sourceMappingURL=integrity.js.map