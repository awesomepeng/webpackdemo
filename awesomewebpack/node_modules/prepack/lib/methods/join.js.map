{"version":3,"sources":["../../src/methods/join.js"],"names":["joinGenerators","realm","joinCondition","generator1","generator2","result","pathConditions","empty","joinArrays","v1","v2","getAbstractValue","e","joinArraysOfValues","joinArrayOfsMapEntries","a1","a2","intrinsics","n","Math","max","length","i","$Key","key1","$Value","val1","key2","val2","undefined","key3","val3","JoinImplementation","stopEffectCaptureJoinApplyAndReturnCompletion","c1","c2","getCapturedEffects","stopEffectCaptureAndUndoEffects","replacePossiblyNormalCompletionWithForkedAbruptCompletion","unbundleNormalCompletion","completionOrValue","completion","value","composeNormalCompletions","leftCompletion","rightCompletion","resultValue","updatePossiblyNormalCompletionWithValue","composePossiblyNormalCompletions","pnc","c","priorEffects","savedEffects","savedPathConditions","consequent","alternate","generator","modifiedBindings","modifiedProperties","createdObjects","alternateEffects","newAlternateEffects","consequentEffects","composeEffects","na","newConsequentEffects","nc","updatePossiblyNormalCompletionWithSubsequentEffects","subsequentEffects","v","effects","withInverseCondition","simplifyAndRefineAbstractValue","updateAlternateKeepingCurrentEffects","withCondition","updateConsequentKeepingCurrentEffects","ac","pncc","ae","nae","nce","ce","pnca","updatePossiblyNormalCompletionWithConditionalSimpleNormalCompletion","createFromConditionalOp","updatePossiblyNormalCompletionWithInverseConditionalSimpleNormalCompletion","joinPossiblyNormalCompletions","a","rv","joinValues","extractAndJoinCompletionsOfType","CompletionType","emptyEffects","containsCompletion","transferChildrenToPossiblyNormalCompletion","joinForkOrChoose","collapseResults","e1","e2","mightNotBeTrue","mightNotBeFalse","result1","modifiedBindings1","modifiedProperties1","createdObjects1","result2","modifiedBindings2","modifiedProperties2","createdObjects2","joinOrForkResults","modifiedGenerator1","modifiedGenerator2","bindings","joinBindings","properties","joinPropertyBindings","Set","forEach","o","add","joinNestedEffects","precedingEffects","e3","target","val","expressionLocation","location","reportIntrospectionError","getNormalCompletion","composeGenerators","concat","appendGenerator","joinMaps","m1","m2","join","m3","Map","key","map1","get","set","map2","has","g1","g2","rewritten1","rewritten2","leak","b","g","rewritten","h","emitBindingAssignment","b1","b2","l1","hasLeaked","l2","previousHasLeaked","previousValue","joinedBindings","Array","isArray","throwIfNotConcrete","d1","d2","object","descriptor","joinDescriptors","clone_with_abstract_value","d","d3","dc","dcValue","elem0","map","descriptor2","descriptor1","mapAndJoin","values","joinConditionFactory","functionToMap","size","joinedEffects","condition","evaluateForEffects","composeWithSavedCompletion","applyEffects"],"mappings":"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","file":"join.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Binding } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Bindings, BindingEntry, EvaluationResult, PropertyBindings, CreatedObjects, Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding } from \"../types.js\";\n\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  PossiblyNormalCompletion,\n  ForkedAbruptCompletion,\n  SimpleNormalCompletion,\n  NormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { Reference } from \"../environment.js\";\nimport { cloneDescriptor, equalDescriptors, IsDataDescriptor, StrictEqualityComparison } from \"../methods/index.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { Path } from \"../singletons.js\";\nimport { Generator } from \"../utils/generator.js\";\nimport { AbstractValue, ConcreteValue, EmptyValue, Value } from \"../values/index.js\";\n\nimport invariant from \"../invariant.js\";\n\nfunction joinGenerators(\n  realm: Realm,\n  joinCondition: AbstractValue,\n  generator1: Generator,\n  generator2: Generator\n): Generator {\n  // TODO #2222: Check if `realm.pathConditions` is correct here.\n  let result = new Generator(realm, \"joined\", realm.pathConditions);\n  if (!generator1.empty() || !generator2.empty()) {\n    result.joinGenerators(joinCondition, generator1, generator2);\n  }\n  return result;\n}\n\nfunction joinArrays(\n  realm: Realm,\n  v1: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  v2: void | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n  let e = (v1 && v1[0]) || (v2 && v2[0]);\n  if (e instanceof Value) return joinArraysOfValues(realm, (v1: any), (v2: any), getAbstractValue);\n  else return joinArrayOfsMapEntries(realm, (v1: any), (v2: any), getAbstractValue);\n}\n\nfunction joinArrayOfsMapEntries(\n  realm: Realm,\n  a1: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  a2: void | Array<{ $Key: void | Value, $Value: void | Value }>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<{ $Key: void | Value, $Value: void | Value }> {\n  let empty = realm.intrinsics.empty;\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    let { $Key: key1, $Value: val1 } = (a1 && a1[i]) || { $Key: empty, $Value: empty };\n    let { $Key: key2, $Value: val2 } = (a2 && a2[i]) || { $Key: empty, $Value: empty };\n    if (key1 === undefined && key2 === undefined) {\n      result[i] = { $Key: undefined, $Value: undefined };\n    } else {\n      let key3 = getAbstractValue(key1, key2);\n      let val3 = getAbstractValue(val1, val2);\n      result[i] = { $Key: key3, $Value: val3 };\n    }\n  }\n  return result;\n}\n\nfunction joinArraysOfValues(\n  realm: Realm,\n  a1: void | Array<Value>,\n  a2: void | Array<Value>,\n  getAbstractValue: (void | Value, void | Value) => Value\n): Array<Value> {\n  let n = Math.max((a1 && a1.length) || 0, (a2 && a2.length) || 0);\n  let result = [];\n  for (let i = 0; i < n; i++) {\n    result[i] = getAbstractValue((a1 && a1[i]) || undefined, (a2 && a2[i]) || undefined);\n  }\n  return result;\n}\n\nexport class JoinImplementation {\n  stopEffectCaptureJoinApplyAndReturnCompletion(\n    c1: PossiblyNormalCompletion,\n    c2: AbruptCompletion,\n    realm: Realm\n  ): ForkedAbruptCompletion {\n    let e = realm.getCapturedEffects();\n    realm.stopEffectCaptureAndUndoEffects(c1);\n    return this.replacePossiblyNormalCompletionWithForkedAbruptCompletion(realm, c1, c2, e);\n  }\n\n  unbundleNormalCompletion(\n    completionOrValue: Completion | Value | Reference\n  ): [void | NormalCompletion, Value | Reference] {\n    let completion, value;\n    if (completionOrValue instanceof PossiblyNormalCompletion) {\n      completion = completionOrValue;\n      value = completionOrValue.value;\n    } else {\n      invariant(completionOrValue instanceof Value || completionOrValue instanceof Reference);\n      value = completionOrValue;\n    }\n    return [completion, value];\n  }\n\n  composeNormalCompletions(\n    leftCompletion: void | NormalCompletion,\n    rightCompletion: void | NormalCompletion,\n    resultValue: Value,\n    realm: Realm\n  ): PossiblyNormalCompletion | Value {\n    if (leftCompletion instanceof PossiblyNormalCompletion) {\n      if (rightCompletion instanceof PossiblyNormalCompletion) {\n        this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n        return this.composePossiblyNormalCompletions(realm, leftCompletion, rightCompletion);\n      }\n      this.updatePossiblyNormalCompletionWithValue(realm, leftCompletion, resultValue);\n      return leftCompletion;\n    } else if (rightCompletion instanceof PossiblyNormalCompletion) {\n      this.updatePossiblyNormalCompletionWithValue(realm, rightCompletion, resultValue);\n      return rightCompletion;\n    } else {\n      invariant(leftCompletion === undefined && rightCompletion === undefined);\n      return resultValue;\n    }\n  }\n\n  composePossiblyNormalCompletions(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    c: PossiblyNormalCompletion,\n    priorEffects?: Effects\n  ): PossiblyNormalCompletion {\n    invariant(c.savedEffects === undefined); // the caller should ensure this\n    let savedPathConditions = pnc.savedPathConditions;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof SimpleNormalCompletion) {\n        let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.alternateEffects;\n        let newAlternateEffects = new Effects(c, generator, modifiedBindings, modifiedProperties, createdObjects);\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          pnc.consequent,\n          pnc.consequentEffects,\n          c,\n          !priorEffects ? newAlternateEffects : realm.composeEffects(priorEffects, newAlternateEffects),\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let na = this.composePossiblyNormalCompletions(realm, pnc.alternate, c, priorEffects);\n      let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.alternateEffects;\n      let newAlternateEffects = new Effects(na, generator, modifiedBindings, modifiedProperties, createdObjects);\n      return new PossiblyNormalCompletion(\n        c.value,\n        pnc.joinCondition,\n        pnc.consequent,\n        pnc.consequentEffects,\n        na,\n        newAlternateEffects,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    } else {\n      if (pnc.consequent instanceof SimpleNormalCompletion) {\n        let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.consequentEffects;\n        let newConsequentEffects = new Effects(c, generator, modifiedBindings, modifiedProperties, createdObjects);\n        return new PossiblyNormalCompletion(\n          c.value,\n          pnc.joinCondition,\n          c,\n          !priorEffects ? newConsequentEffects : realm.composeEffects(priorEffects, newConsequentEffects),\n          pnc.alternate,\n          pnc.alternateEffects,\n          savedPathConditions,\n          pnc.savedEffects\n        );\n      }\n      invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n      let nc = this.composePossiblyNormalCompletions(realm, pnc.consequent, c);\n      let { generator, modifiedBindings, modifiedProperties, createdObjects } = pnc.consequentEffects;\n      let newConsequentEffects = new Effects(nc, generator, modifiedBindings, modifiedProperties, createdObjects);\n      return new PossiblyNormalCompletion(\n        c.value,\n        pnc.joinCondition,\n        nc,\n        newConsequentEffects,\n        pnc.alternate,\n        pnc.alternateEffects,\n        savedPathConditions,\n        pnc.savedEffects\n      );\n    }\n  }\n\n  updatePossiblyNormalCompletionWithSubsequentEffects(\n    realm: Realm,\n    pnc: PossiblyNormalCompletion,\n    subsequentEffects: Effects\n  ): void {\n    let v = subsequentEffects.result;\n    invariant(v instanceof SimpleNormalCompletion);\n    pnc.value = v.value;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof SimpleNormalCompletion) {\n        pnc.alternateEffects.result = v;\n        v.effects = realm.composeEffects(pnc.alternateEffects, subsequentEffects);\n        pnc.alternate = v;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.alternate, subsequentEffects);\n      }\n    } else {\n      if (pnc.consequent instanceof SimpleNormalCompletion) {\n        pnc.consequentEffects.result = v;\n        v.effects = realm.composeEffects(pnc.consequentEffects, subsequentEffects);\n        pnc.consequent = v;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithSubsequentEffects(realm, pnc.consequent, subsequentEffects);\n      }\n    }\n  }\n\n  updatePossiblyNormalCompletionWithValue(realm: Realm, pnc: PossiblyNormalCompletion, v: Value): void {\n    let nc = new SimpleNormalCompletion(v);\n    pnc.value = v;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      Path.withInverseCondition(pnc.joinCondition, () => {\n        if (v instanceof AbstractValue) v = realm.simplifyAndRefineAbstractValue(v);\n        if (pnc.alternate instanceof SimpleNormalCompletion) {\n          nc.value = v;\n          pnc = pnc.updateAlternateKeepingCurrentEffects(nc);\n          pnc.value = v;\n        } else {\n          invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n          this.updatePossiblyNormalCompletionWithValue(realm, pnc.alternate, v);\n          invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n          pnc.value = pnc.alternate.value;\n        }\n      });\n    } else {\n      Path.withCondition(pnc.joinCondition, () => {\n        if (v instanceof AbstractValue) v = realm.simplifyAndRefineAbstractValue(v);\n        if (pnc.consequent instanceof SimpleNormalCompletion) {\n          nc.value = v;\n          pnc = pnc.updateConsequentKeepingCurrentEffects(nc);\n          pnc.value = v;\n        } else {\n          invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n          this.updatePossiblyNormalCompletionWithValue(realm, pnc.consequent, v);\n          invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n          pnc.value = pnc.consequent.value;\n        }\n      });\n    }\n  }\n\n  replacePossiblyNormalCompletionWithForkedAbruptCompletion(\n    realm: Realm,\n    // a forked path with a non abrupt (normal) component\n    pnc: PossiblyNormalCompletion,\n    // an abrupt completion that completes the normal path\n    ac: AbruptCompletion,\n    // effects collected after pnc was constructed\n    e: Effects\n  ): ForkedAbruptCompletion {\n    // set up e with ac as the completion. It's OK to do this repeatedly since ac is not changed by recursive calls.\n    e.result = ac;\n    let pncc = pnc.consequent;\n    if (pncc instanceof AbruptCompletion) {\n      e = realm.composeEffects(pnc.alternateEffects, e);\n      if (pnc.alternate instanceof SimpleNormalCompletion) {\n        return new ForkedAbruptCompletion(realm, pnc.joinCondition, pncc, pnc.consequentEffects, ac, e);\n      }\n      invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n      let na = this.replacePossiblyNormalCompletionWithForkedAbruptCompletion(realm, pnc.alternate, ac, e);\n      let ae = pnc.alternateEffects;\n      let nae = new Effects(na, ae.generator, ae.modifiedBindings, ae.modifiedProperties, ae.createdObjects);\n      return new ForkedAbruptCompletion(realm, pnc.joinCondition, pncc, pnc.consequentEffects, na, nae);\n    } else {\n      let nc, nce;\n      if (pncc instanceof PossiblyNormalCompletion) {\n        nc = this.replacePossiblyNormalCompletionWithForkedAbruptCompletion(realm, pncc, ac, e);\n        let ce = pnc.consequentEffects;\n        nce = new Effects(nc, ce.generator, ce.modifiedBindings, ce.modifiedProperties, ce.createdObjects);\n      } else {\n        invariant(pncc instanceof SimpleNormalCompletion);\n        nc = ac;\n        nce = realm.composeEffects(pnc.consequentEffects, e);\n      }\n      let pnca = pnc.alternate;\n      let na, nae;\n      // TODO (hermanv) if we use e as is, it ends up being applied twice when the join of the normal\n      // path is applied to the current state. Follow up with a PR that allows Effects to get deeply cloned\n      // and then clone e at this point.\n      e = construct_empty_effects(realm);\n      // Note that ac may depend on the effects in the original e, so use e.result until the cloning is done.\n      ac = (e.result: any);\n      if (pnca instanceof PossiblyNormalCompletion) {\n        na = this.replacePossiblyNormalCompletionWithForkedAbruptCompletion(realm, pnca, ac, e);\n        let ae = pnc.alternateEffects;\n        nae = new Effects(na, ae.generator, ae.modifiedBindings, ae.modifiedProperties, ae.createdObjects);\n      } else if (pnca instanceof SimpleNormalCompletion) {\n        na = ac;\n        nae = realm.composeEffects(pnc.alternateEffects, e);\n      } else {\n        invariant(pnca instanceof AbruptCompletion);\n        na = pnca;\n        nae = pnc.alternateEffects;\n      }\n      return new ForkedAbruptCompletion(realm, pnc.joinCondition, nc, nce, na, nae);\n    }\n  }\n\n  updatePossiblyNormalCompletionWithConditionalSimpleNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    nc: SimpleNormalCompletion\n  ): void {\n    let v = nc.value;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof SimpleNormalCompletion) {\n        nc.value = AbstractValue.createFromConditionalOp(realm, joinCondition, pnc.alternate.value, v);\n        pnc.alternateEffects.result = nc;\n        nc.effects = pnc.alternateEffects;\n        pnc.alternate = nc;\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithConditionalSimpleNormalCompletion(\n          realm,\n          joinCondition,\n          pnc.alternate,\n          nc\n        );\n      }\n    } else {\n      if (pnc.consequent instanceof SimpleNormalCompletion) {\n        nc.value = AbstractValue.createFromConditionalOp(realm, joinCondition, pnc.consequent.value, v);\n        pnc.consequentEffects.result = nc;\n        nc.effects = pnc.consequentEffects;\n        pnc.consequent = nc;\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithConditionalSimpleNormalCompletion(\n          realm,\n          joinCondition,\n          pnc.consequent,\n          nc\n        );\n      }\n    }\n  }\n\n  updatePossiblyNormalCompletionWithInverseConditionalSimpleNormalCompletion(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    pnc: PossiblyNormalCompletion,\n    nc: SimpleNormalCompletion\n  ): void {\n    let v = nc.value;\n    if (pnc.consequent instanceof AbruptCompletion) {\n      if (pnc.alternate instanceof SimpleNormalCompletion) {\n        nc.value = AbstractValue.createFromConditionalOp(realm, joinCondition, v, pnc.alternate.value);\n        pnc = pnc.updateAlternateKeepingCurrentEffects(nc);\n      } else {\n        invariant(pnc.alternate instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithInverseConditionalSimpleNormalCompletion(\n          realm,\n          joinCondition,\n          pnc.alternate,\n          nc\n        );\n      }\n    } else {\n      if (pnc.consequent instanceof SimpleNormalCompletion) {\n        nc.value = AbstractValue.createFromConditionalOp(realm, joinCondition, v, pnc.consequent.value);\n        pnc = pnc.updateConsequentKeepingCurrentEffects(nc);\n      } else {\n        invariant(pnc.consequent instanceof PossiblyNormalCompletion);\n        this.updatePossiblyNormalCompletionWithInverseConditionalSimpleNormalCompletion(\n          realm,\n          joinCondition,\n          pnc.consequent,\n          nc\n        );\n      }\n    }\n  }\n\n  joinPossiblyNormalCompletions(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    c: PossiblyNormalCompletion,\n    a: PossiblyNormalCompletion\n  ): PossiblyNormalCompletion {\n    let getAbstractValue = (v1: void | Value, v2: void | Value): Value => {\n      if (v1 instanceof EmptyValue) return v2 || realm.intrinsics.undefined;\n      if (v2 instanceof EmptyValue) return v1 || realm.intrinsics.undefined;\n      return AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);\n    };\n    let ce = construct_empty_effects(realm, c);\n    let ae = construct_empty_effects(realm, a);\n    let rv = this.joinValues(realm, c.value, a.value, getAbstractValue);\n    invariant(rv instanceof Value);\n    a.value = rv;\n    return new PossiblyNormalCompletion(rv, joinCondition, c, ce, a, ae, []);\n  }\n\n  // Join all effects that result in completions of type CompletionType.\n  // Erase all completions of type Completion type from c, so that we never join them again.\n  // Also erase any generators that appears in branches resulting in completions of type CompletionType.\n  // Note that c is modified in place and should be replaced with a PossiblyNormalCompletion by the caller\n  // if either of its branches cease to be an AbruptCompletion.\n  extractAndJoinCompletionsOfType(CompletionType: typeof AbruptCompletion, realm: Realm, c: AbruptCompletion): Effects {\n    let emptyEffects = construct_empty_effects(realm);\n    if (c instanceof CompletionType) {\n      emptyEffects.result = c;\n      return emptyEffects;\n    }\n    if (!(c instanceof ForkedAbruptCompletion)) {\n      return emptyEffects;\n    }\n    // Join up the consequent and alternate completions and compose them with their prefix effects\n    let ce = this.extractAndJoinCompletionsOfType(CompletionType, realm, c.consequent);\n    // ce will be applied to the global state before any non joining branches in c.consequent, so move\n    // the generator from c.consequentEffects to ce.generator so that all branches will see its effects.\n    ce = realm.composeEffects(c.consequentEffects, ce);\n    // ce now incorporates c.consequentEffects.generator, so remove it from there.\n    c.consequentEffects.generator = emptyEffects.generator;\n    if (ce.result instanceof CompletionType) {\n      // Erase completions of type CompletionType and prepare for transformation of c to a possibly normal completion\n      if (c.consequent instanceof CompletionType) {\n        c.updateConsequentKeepingCurrentEffects(new SimpleNormalCompletion(realm.intrinsics.empty, undefined));\n      } else if (c.consequent instanceof ForkedAbruptCompletion && c.consequent.containsCompletion(NormalCompletion)) {\n        c.updateConsequentKeepingCurrentEffects((c.consequent.transferChildrenToPossiblyNormalCompletion(): any));\n      }\n    } else {\n      ce.result = new CompletionType(realm.intrinsics.empty);\n    }\n    let ae = this.extractAndJoinCompletionsOfType(CompletionType, realm, c.alternate);\n    // ae will be applied to the global state before any non joining branches in c.alternate, so move\n    // the generator from c.alternateEffects to ae.generator so that all branches will see its effects.\n    ae = realm.composeEffects(c.alternateEffects, ae);\n    // ae now incorporates c.alternateEffects.generator, so remove it from there.\n    c.alternateEffects.generator = emptyEffects.generator;\n    if (ae.result instanceof CompletionType) {\n      // Erase completions of type CompletionType and prepare for transformation of c to a possibly normal completion\n      if (c.alternate instanceof CompletionType) {\n        c.updateAlternateKeepingCurrentEffects(new SimpleNormalCompletion(realm.intrinsics.empty, undefined));\n      } else if (c.alternate instanceof ForkedAbruptCompletion && c.alternate.containsCompletion(NormalCompletion)) {\n        c.updateAlternateKeepingCurrentEffects((c.alternate.transferChildrenToPossiblyNormalCompletion(): any));\n      }\n    } else {\n      ae.result = new CompletionType(realm.intrinsics.empty);\n    }\n\n    let e = this.joinForkOrChoose(realm, c.joinCondition, ce, ae);\n    if (e.result instanceof ForkedAbruptCompletion) {\n      if (e.result.consequent instanceof CompletionType && e.result.alternate instanceof CompletionType) {\n        e.result = this.collapseResults(realm, e.result.joinCondition, e, e.result.consequent, e.result.alternate);\n      }\n    }\n    return e;\n  }\n\n  joinForkOrChoose(realm: Realm, joinCondition: Value, e1: Effects, e2: Effects): Effects {\n    if (!joinCondition.mightNotBeTrue()) return e1;\n    if (!joinCondition.mightNotBeFalse()) return e2;\n    invariant(joinCondition instanceof AbstractValue);\n\n    let {\n      result: result1,\n      generator: generator1,\n      modifiedBindings: modifiedBindings1,\n      modifiedProperties: modifiedProperties1,\n      createdObjects: createdObjects1,\n    } = e1;\n\n    let {\n      result: result2,\n      generator: generator2,\n      modifiedBindings: modifiedBindings2,\n      modifiedProperties: modifiedProperties2,\n      createdObjects: createdObjects2,\n    } = e2;\n\n    let result = this.joinOrForkResults(realm, joinCondition, result1, result2, e1, e2);\n    if (result1 instanceof AbruptCompletion) {\n      if (!(result2 instanceof AbruptCompletion)) {\n        invariant(result instanceof PossiblyNormalCompletion);\n        return new Effects(result, generator2, modifiedBindings2, modifiedProperties2, createdObjects2);\n      }\n    } else if (result2 instanceof AbruptCompletion) {\n      invariant(result instanceof PossiblyNormalCompletion);\n      return new Effects(result, generator1, modifiedBindings1, modifiedProperties1, createdObjects1);\n    }\n\n    let [modifiedGenerator1, modifiedGenerator2, bindings] = this.joinBindings(\n      realm,\n      joinCondition,\n      generator1,\n      modifiedBindings1,\n      generator2,\n      modifiedBindings2\n    );\n    let properties = this.joinPropertyBindings(\n      realm,\n      joinCondition,\n      modifiedProperties1,\n      modifiedProperties2,\n      createdObjects1,\n      createdObjects2\n    );\n    let createdObjects = new Set();\n    createdObjects1.forEach(o => {\n      createdObjects.add(o);\n    });\n    createdObjects2.forEach(o => {\n      createdObjects.add(o);\n    });\n\n    let generator = joinGenerators(realm, joinCondition, modifiedGenerator1, modifiedGenerator2);\n\n    return new Effects(result, generator, bindings, properties, createdObjects);\n  }\n\n  joinNestedEffects(realm: Realm, c: Completion, precedingEffects?: Effects): Effects {\n    if (c instanceof PossiblyNormalCompletion || c instanceof ForkedAbruptCompletion) {\n      let e1 = this.joinNestedEffects(realm, c.consequent, c.consequentEffects);\n      let e2 = this.joinNestedEffects(realm, c.alternate, c.alternateEffects);\n      let e3 = this.joinForkOrChoose(realm, c.joinCondition, e1, e2);\n      this.collapseResults(realm, c.joinCondition, e3, e1.result, e2.result);\n      return e3;\n    }\n    if (precedingEffects !== undefined) return precedingEffects;\n    let result = construct_empty_effects(realm);\n    result.result = c;\n    return result;\n  }\n\n  collapseResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    precedingEffects: Effects,\n    result1: EvaluationResult,\n    result2: EvaluationResult\n  ): Completion {\n    let getAbstractValue = (v1: void | Value, v2: void | Value): Value => {\n      if (v1 instanceof EmptyValue) return v2 || realm.intrinsics.undefined;\n      if (v2 instanceof EmptyValue) return v1 || realm.intrinsics.undefined;\n      return AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);\n    };\n    if (result1 instanceof BreakCompletion && result2 instanceof BreakCompletion && result1.target === result2.target) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new BreakCompletion(val, precedingEffects, joinCondition.expressionLocation, result1.target);\n    }\n    if (\n      result1 instanceof ContinueCompletion &&\n      result2 instanceof ContinueCompletion &&\n      result1.target === result2.target\n    ) {\n      return new ContinueCompletion(\n        realm.intrinsics.empty,\n        precedingEffects,\n        joinCondition.expressionLocation,\n        result1.target\n      );\n    }\n    if (result1 instanceof ReturnCompletion && result2 instanceof ReturnCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ReturnCompletion(val, precedingEffects, joinCondition.expressionLocation);\n    }\n    if (result1 instanceof ThrowCompletion && result2 instanceof ThrowCompletion) {\n      getAbstractValue = (v1: void | Value, v2: void | Value) => {\n        return AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);\n      };\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new ThrowCompletion(val, precedingEffects, result1.location);\n    }\n    if (result1 instanceof SimpleNormalCompletion && result2 instanceof SimpleNormalCompletion) {\n      return new SimpleNormalCompletion(getAbstractValue(result1.value, result2.value), precedingEffects);\n    }\n    AbstractValue.reportIntrospectionError(joinCondition);\n    throw new FatalError();\n  }\n\n  joinOrForkResults(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    result1: EvaluationResult,\n    result2: EvaluationResult,\n    e1: Effects,\n    e2: Effects\n  ): Completion {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);\n    };\n    if (result1 instanceof Reference || result2 instanceof Reference) {\n      AbstractValue.reportIntrospectionError(joinCondition);\n      throw new FatalError();\n    }\n    if (result1 instanceof SimpleNormalCompletion && result2 instanceof SimpleNormalCompletion) {\n      let val = this.joinValues(realm, result1.value, result2.value, getAbstractValue);\n      invariant(val instanceof Value);\n      return new SimpleNormalCompletion(val);\n    }\n    if (result1 instanceof AbruptCompletion && result2 instanceof AbruptCompletion) {\n      return new ForkedAbruptCompletion(realm, joinCondition, result1, e1, result2, e2);\n    }\n    if (result1 instanceof PossiblyNormalCompletion && result2 instanceof PossiblyNormalCompletion) {\n      return this.joinPossiblyNormalCompletions(realm, joinCondition, result1, result2);\n    }\n    if (result1 instanceof AbruptCompletion) {\n      let completion = result2;\n      let savedEffects;\n      let savedPathConditions = [];\n      if (result2 instanceof PossiblyNormalCompletion) {\n        completion = result2.getNormalCompletion();\n        savedEffects = result2.savedEffects;\n        savedPathConditions = result2.savedPathConditions;\n      }\n      invariant(completion instanceof SimpleNormalCompletion);\n      return new PossiblyNormalCompletion(\n        completion.value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result2 instanceof AbruptCompletion) {\n      let completion = result1;\n      let savedEffects;\n      let savedPathConditions = [];\n      if (result1 instanceof PossiblyNormalCompletion) {\n        completion = result1.getNormalCompletion();\n        savedEffects = result1.savedEffects;\n        savedPathConditions = result1.savedPathConditions;\n      }\n      invariant(completion instanceof SimpleNormalCompletion);\n      return new PossiblyNormalCompletion(\n        completion.value,\n        joinCondition,\n        result1,\n        e1,\n        result2,\n        e2,\n        savedPathConditions,\n        savedEffects\n      );\n    }\n    if (result1 instanceof PossiblyNormalCompletion) {\n      invariant(result2 instanceof SimpleNormalCompletion);\n      this.updatePossiblyNormalCompletionWithConditionalSimpleNormalCompletion(realm, joinCondition, result1, result2);\n      return result1;\n    }\n    if (result2 instanceof PossiblyNormalCompletion) {\n      invariant(result1 instanceof SimpleNormalCompletion);\n      this.updatePossiblyNormalCompletionWithInverseConditionalSimpleNormalCompletion(\n        realm,\n        joinCondition,\n        result2,\n        result1\n      );\n      return result2;\n    }\n    invariant(false);\n  }\n\n  composeGenerators(realm: Realm, generator1: Generator, generator2: Generator): Generator {\n    // TODO #2222: The path condition of the resulting generator should really just be generator2.pathConditions,\n    // and we shouldn't have to bring in generator1.pathConditions. We have observed that this causes an issue\n    // in InstantRender.\n    let result = new Generator(realm, \"composed\", generator1.pathConditions.concat(generator2.pathConditions));\n    // We copy the entries here because actually composing the generators breaks the serializer\n    if (!generator1.empty()) result.appendGenerator(generator1, \"\");\n    if (!generator2.empty()) result.appendGenerator(generator2, \"\");\n    return result;\n  }\n\n  // Creates a single map that joins together maps m1 and m2 using the given join\n  // operator. If an entry is present in one map but not the other, the missing\n  // entry is treated as if it were there and its value were undefined.\n  joinMaps<K, V>(m1: Map<K, V>, m2: Map<K, V>, join: (K, void | V, void | V) => V): Map<K, V> {\n    let m3: Map<K, V> = new Map();\n    m1.forEach((val1, key, map1) => {\n      let val2 = m2.get(key);\n      let val3 = join(key, val1, val2);\n      m3.set(key, val3);\n    });\n    m2.forEach((val2, key, map2) => {\n      if (!m1.has(key)) {\n        m3.set(key, join(key, undefined, val2));\n      }\n    });\n    return m3;\n  }\n\n  // Creates a single map that has an key, value pair for the union of the key\n  // sets of m1 and m2. The value of a pair is the join of m1[key] and m2[key]\n  // where the join is defined to be just m1[key] if m1[key] === m2[key] and\n  // and abstract value with expression \"joinCondition ? m1[key] : m2[key]\" if not.\n  joinBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    g1: Generator,\n    m1: Bindings,\n    g2: Generator,\n    m2: Bindings\n  ): [Generator, Generator, Bindings] {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);\n    };\n    let rewritten1 = false;\n    let rewritten2 = false;\n    let leak = (b: Binding, g: Generator, v: void | Value, rewritten: boolean) => {\n      // just like to what happens in havocBinding, we are going to append a\n      // binding-assignment generator entry; however, we play it safe and don't\n      // mutate the generator; instead, we create a new one that wraps around the old one.\n      if (!rewritten) {\n        let h = new Generator(realm, \"RewrittenToAppendBindingAssignments\", g.pathConditions);\n        if (!g.empty()) h.appendGenerator(g, \"\");\n        g = h;\n        rewritten = true;\n      }\n      if (v !== undefined && v !== realm.intrinsics.undefined) g.emitBindingAssignment(b, v);\n      return [g, rewritten];\n    };\n    let join = (b: Binding, b1: void | BindingEntry, b2: void | BindingEntry) => {\n      let l1 = b1 === undefined ? b.hasLeaked : b1.hasLeaked;\n      let l2 = b2 === undefined ? b.hasLeaked : b2.hasLeaked;\n      let v1 = b1 === undefined ? b.value : b1.value;\n      let v2 = b2 === undefined ? b.value : b2.value;\n      // ensure that if either none or both sides have leaked\n      // note that if one side didn't have a binding entry yet, then there's nothing to actively leak\n      if (!l1 && l2) [g1, rewritten1] = leak(b, g1, v1, rewritten1);\n      else if (l1 && !l2) [g2, rewritten2] = leak(b, g2, v2, rewritten2);\n      let hasLeaked = l1 || l2;\n      // For leaked (and mutable) bindings, the actual value is no longer directly available.\n      // In that case, we reset the value to undefined to prevent any use of the last known value.\n      let value = hasLeaked ? undefined : this.joinValues(realm, v1, v2, getAbstractValue);\n      invariant(value === undefined || value instanceof Value);\n      let previousHasLeaked, previousValue;\n      if (b1 !== undefined) {\n        previousHasLeaked = b1.previousHasLeaked;\n        previousValue = b1.previousValue;\n        invariant(\n          b2 === undefined || (previousHasLeaked === b2.previousHasLeaked && previousValue === b2.previousValue)\n        );\n      } else if (b2 !== undefined) {\n        previousHasLeaked = b2.previousHasLeaked;\n        previousValue = b2.previousValue;\n      }\n      return { hasLeaked, value, previousHasLeaked, previousValue };\n    };\n    let joinedBindings = this.joinMaps(m1, m2, join);\n    return [g1, g2, joinedBindings];\n  }\n\n  // If v1 is known and defined and v1 === v2 return v1,\n  // otherwise return getAbstractValue(v1, v2)\n  joinValues(\n    realm: Realm,\n    v1: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: void | Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    getAbstractValue: (void | Value, void | Value) => Value\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }> {\n    if (Array.isArray(v1) || Array.isArray(v2)) {\n      invariant(v1 === undefined || Array.isArray(v1));\n      invariant(v2 === undefined || Array.isArray(v2));\n      return joinArrays(realm, ((v1: any): void | Array<Value>), ((v2: any): void | Array<Value>), getAbstractValue);\n    }\n    invariant(v1 === undefined || v1 instanceof Value);\n    invariant(v2 === undefined || v2 instanceof Value);\n    if (\n      v1 !== undefined &&\n      v2 !== undefined &&\n      !(v1 instanceof AbstractValue) &&\n      !(v2 instanceof AbstractValue) &&\n      StrictEqualityComparison(realm, v1.throwIfNotConcrete(), v2.throwIfNotConcrete())\n    ) {\n      return v1;\n    } else {\n      return getAbstractValue(v1, v2);\n    }\n  }\n\n  joinPropertyBindings(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    m1: PropertyBindings,\n    m2: PropertyBindings,\n    c1: CreatedObjects,\n    c2: CreatedObjects\n  ): PropertyBindings {\n    let join = (b: PropertyBinding, d1: void | Descriptor, d2: void | Descriptor) => {\n      // If the PropertyBinding object has been freshly allocated do not join\n      if (d1 === undefined) {\n        if (c2.has(b.object)) return d2; // no join\n        if (b.descriptor !== undefined && m1.has(b)) {\n          // property was deleted\n          d1 = cloneDescriptor(b.descriptor);\n          invariant(d1 !== undefined);\n          d1.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d1 = b.descriptor; //Get value of property before the split\n        }\n      }\n      if (d2 === undefined) {\n        if (c1.has(b.object)) return d1; // no join\n        if (b.descriptor !== undefined && m2.has(b)) {\n          // property was deleted\n          d2 = cloneDescriptor(b.descriptor);\n          invariant(d2 !== undefined);\n          d2.value = realm.intrinsics.empty;\n        } else {\n          // no write to property\n          d2 = b.descriptor; //Get value of property before the split\n        }\n      }\n      return this.joinDescriptors(realm, joinCondition, d1, d2);\n    };\n    return this.joinMaps(m1, m2, join);\n  }\n\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor {\n    let getAbstractValue = (v1: void | Value, v2: void | Value) => {\n      return AbstractValue.createFromConditionalOp(realm, joinCondition, v1, v2);\n    };\n    let clone_with_abstract_value = (d: Descriptor) => {\n      invariant(d === d1 || d === d2);\n      if (!IsDataDescriptor(realm, d)) {\n        let d3: Descriptor = {};\n        d3.joinCondition = joinCondition;\n        return d3;\n      }\n      let dc = cloneDescriptor(d);\n      invariant(dc !== undefined);\n      let dcValue = dc.value;\n      if (Array.isArray(dcValue)) {\n        invariant(dcValue.length > 0);\n        let elem0 = dcValue[0];\n        if (elem0 instanceof Value) {\n          dc.value = dcValue.map(e => {\n            return d === d1\n              ? getAbstractValue((e: any), realm.intrinsics.empty)\n              : getAbstractValue(realm.intrinsics.empty, (e: any));\n          });\n        } else {\n          dc.value = dcValue.map(e => {\n            let { $Key: key1, $Value: val1 } = (e: any);\n            let key3 =\n              d === d1\n                ? getAbstractValue(key1, realm.intrinsics.empty)\n                : getAbstractValue(realm.intrinsics.empty, key1);\n            let val3 =\n              d === d1\n                ? getAbstractValue(val1, realm.intrinsics.empty)\n                : getAbstractValue(realm.intrinsics.empty, val1);\n            return { $Key: key3, $Value: val3 };\n          });\n        }\n      } else {\n        invariant(dcValue === undefined || dcValue instanceof Value);\n        dc.value =\n          d === d1\n            ? getAbstractValue(dcValue, realm.intrinsics.empty)\n            : getAbstractValue(realm.intrinsics.empty, dcValue);\n      }\n      return dc;\n    };\n    if (d1 === undefined) {\n      if (d2 === undefined) return undefined;\n      // d2 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d2);\n      if (!IsDataDescriptor(realm, d2)) d3.descriptor2 = d2;\n      return d3;\n    } else if (d2 === undefined) {\n      invariant(d1 !== undefined);\n      // d1 is a new property created in only one branch, join with empty\n      let d3 = clone_with_abstract_value(d1);\n      if (!IsDataDescriptor(realm, d1)) d3.descriptor1 = d1;\n      return d3;\n    } else {\n      if (equalDescriptors(d1, d2) && IsDataDescriptor(realm, d1)) {\n        let dc = cloneDescriptor(d1);\n        invariant(dc !== undefined);\n        dc.value = this.joinValues(realm, d1.value, d2.value, getAbstractValue);\n        return dc;\n      }\n      let d3: Descriptor = {};\n      d3.joinCondition = joinCondition;\n      d3.descriptor1 = d1;\n      d3.descriptor2 = d2;\n      return d3;\n    }\n  }\n\n  mapAndJoin(\n    realm: Realm,\n    values: Set<ConcreteValue>,\n    joinConditionFactory: ConcreteValue => Value,\n    functionToMap: ConcreteValue => Completion | Value\n  ): Value {\n    invariant(values.size > 1);\n    let joinedEffects;\n    for (let val of values) {\n      let condition = joinConditionFactory(val);\n      let effects = realm.evaluateForEffects(\n        () => {\n          invariant(condition instanceof AbstractValue);\n          return Path.withCondition(condition, () => {\n            return functionToMap(val);\n          });\n        },\n        undefined,\n        \"mapAndJoin\"\n      );\n      joinedEffects =\n        joinedEffects === undefined ? effects : this.joinForkOrChoose(realm, condition, effects, joinedEffects);\n    }\n    invariant(joinedEffects !== undefined);\n    let completion = joinedEffects.result;\n    if (completion instanceof PossiblyNormalCompletion) {\n      // in this case one of the branches may complete abruptly, which means that\n      // not all control flow branches join into one flow at this point.\n      // Consequently we have to continue tracking changes until the point where\n      // all the branches come together into one.\n      completion = realm.composeWithSavedCompletion(completion);\n    }\n    // Note that the effects of (non joining) abrupt branches are not included\n    // in joinedEffects, but are tracked separately inside completion.\n    realm.applyEffects(joinedEffects);\n\n    // return or throw completion\n    if (completion instanceof AbruptCompletion) throw completion;\n    if (completion instanceof SimpleNormalCompletion) {\n      completion = completion.value;\n    }\n    invariant(completion instanceof Value);\n    return completion;\n  }\n}\n"]}