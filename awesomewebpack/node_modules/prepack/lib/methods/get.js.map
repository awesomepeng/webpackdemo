{"version":3,"sources":["../../src/methods/get.js"],"names":["GetFunctionRealm","OrdinaryGet","GetGlobalObject","GetSubstitution","GetMethod","GetPrototypeFromConstructor","Get","GetV","GetThisValue","GetNewTarget","GetTemplateObject","GetFromArrayWithWidenedNumericProperty","t","realm","obj","$ProxyHandler","createErrorThrowCompletion","intrinsics","TypeError","$ProxyTarget","proxyTarget","$Realm","target","$BoundTargetFunction","O","P","Receiver","dataOnly","desc","$GetOwnProperty","undefined","joinCondition","OrdinaryGetHelper","descriptor1","descriptor2","simplifyAndRefineAbstractCondition","mightNotBeTrue","mightNotBeFalse","result1","generator1","modifiedBindings1","modifiedProperties1","createdObjects1","result","generator","modifiedBindings","modifiedProperties","createdObjects","withCondition","evaluateForEffects","e","result2","generator2","modifiedBindings2","modifiedProperties2","createdObjects2","withInverseCondition","joinedEffects","joinForkOrChoose","completion","composeWithSavedCompletion","applyEffects","descValue","value","mightHaveBeenDeleted","parent","$GetPrototypeOf","parentVal","throwIfNotConcreteObject","cond","createFromBinaryOp","empty","createFromConditionalOp","$Get","reportIntrospectionError","getter","get","ctx","getRunningContext","currentRealm","$GlobalObject","matched","str","position","captures","replacement","matchLength","length","stringLength","Array","isArray","tailPos","m","i","ch","charAt","peek","substr","idx","charCodeAt","peek2","newIdx","V","func","constructor","intrinsicDefaultProto","proto","ToObject","IsPropertyReference","IsSuperReference","thisValue","GetBase","envRec","GetThisEnvironment","SyntaxError","$NewTarget","templateLiteral","rawStrings","quasis","map","quasi","raw","templateRegistry","$TemplateMap","same","$Strings","$Array","cookedStrings","cooked","count","template","ArrayCreate","rawObj","index","prop","ToString","cookedValue","$DefineOwnProperty","writable","enumerable","configurable","rawValue","push","arr","ArrayPrototype","createTemporalFromBuildFunction","o","memberExpression","identifier","skipInvariant","isPure","prototypeBinding","properties","descriptor","p"],"mappings":"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","file":"get.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { AbruptCompletion, PossiblyNormalCompletion } from \"../completions.js\";\nimport { InfeasiblePathError } from \"../errors.js\";\nimport { construct_empty_effects, type Realm, Effects } from \"../realm.js\";\nimport type { PropertyKeyValue, CallableObjectValue } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BoundFunctionValue,\n  EmptyValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { SetIntegrityLevel } from \"./integrity.js\";\nimport {\n  Call,\n  HasSomeCompatibleType,\n  IsAccessorDescriptor,\n  IsCallable,\n  IsDataDescriptor,\n  IsPropertyKey,\n} from \"./index.js\";\nimport { Create, Environment, Join, Path, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeTemplateLiteral } from \"babel-types\";\nimport * as t from \"babel-types\";\nimport { memberExpressionHelper } from \"../utils/babelhelpers.js\";\n\n// ECMA262 7.3.22\nexport function GetFunctionRealm(realm: Realm, obj: ObjectValue): Realm {\n  // 1. Assert: obj is a callable object.\n  invariant(IsCallable(realm, obj), \"expected callable object\");\n\n  // ProxyValue moved to realm before\n  // https://github.com/facebook/prepack/pull/1351\n\n  // 4. If obj is a Proxy exotic object, then\n  if (obj instanceof ProxyValue) {\n    // a. If the value of the [[ProxyHandler]] internal slot of obj is null, throw a TypeError exception.\n    if (obj.$ProxyHandler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"proxy handler is null\");\n    }\n    invariant(obj.$ProxyTarget instanceof ObjectValue);\n\n    // b. Let proxyTarget be the value of obj's [[ProxyTarget]] internal slot.\n    let proxyTarget = obj.$ProxyTarget;\n\n    // c. Return ? GetFunctionRealm(proxyTarget).\n    return GetFunctionRealm(realm, proxyTarget);\n  }\n\n  // 2. If obj has a [[Realm]] internal slot, then\n  if (obj.$Realm) {\n    // a. Return obj's [[Realm]] internal slot.\n    return obj.$Realm;\n  }\n\n  // 3. If obj is a Bound Function exotic object, then\n  if (obj instanceof BoundFunctionValue) {\n    // a. Let target be obj's [[BoundTargetFunction]] internal slot.\n    let target = obj.$BoundTargetFunction;\n\n    // b. Return ? GetFunctionRealm(target).\n    return GetFunctionRealm(realm, target);\n  }\n\n  // 5. Return the current Realm Record.\n  return realm;\n}\n\n// ECMA262 9.1.8.1\nexport function OrdinaryGet(\n  realm: Realm,\n  O: ObjectValue,\n  P: PropertyKeyValue,\n  Receiver: Value,\n  dataOnly?: boolean\n): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n  if (desc === undefined || desc.joinCondition === undefined) return OrdinaryGetHelper();\n\n  // joined descriptors need special treatment\n  let joinCondition = desc.joinCondition;\n  let descriptor1 = desc.descriptor1;\n  let descriptor2 = desc.descriptor2;\n  joinCondition = realm.simplifyAndRefineAbstractCondition(joinCondition);\n  if (!joinCondition.mightNotBeTrue()) {\n    desc = descriptor1;\n    return OrdinaryGetHelper();\n  }\n  if (!joinCondition.mightNotBeFalse()) {\n    desc = desc.descriptor2;\n    return OrdinaryGetHelper();\n  }\n  invariant(joinCondition instanceof AbstractValue);\n  let result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1;\n  try {\n    desc = descriptor1;\n    ({\n      result: result1,\n      generator: generator1,\n      modifiedBindings: modifiedBindings1,\n      modifiedProperties: modifiedProperties1,\n      createdObjects: createdObjects1,\n    } = Path.withCondition(joinCondition, () => {\n      return desc !== undefined\n        ? realm.evaluateForEffects(() => OrdinaryGetHelper(), undefined, \"OrdinaryGet/1\")\n        : construct_empty_effects(realm);\n    }));\n  } catch (e) {\n    if (e instanceof InfeasiblePathError) {\n      // The joinCondition cannot be true in the current path, after all\n      desc = descriptor2;\n      return OrdinaryGetHelper();\n    } else {\n      throw e;\n    }\n  }\n  let result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2;\n  try {\n    desc = descriptor2;\n    ({\n      result: result2,\n      generator: generator2,\n      modifiedBindings: modifiedBindings2,\n      modifiedProperties: modifiedProperties2,\n      createdObjects: createdObjects2,\n    } = Path.withInverseCondition(joinCondition, () => {\n      return desc !== undefined\n        ? realm.evaluateForEffects(() => OrdinaryGetHelper(), undefined, \"OrdinaryGet/2\")\n        : construct_empty_effects(realm);\n    }));\n  } catch (e) {\n    if (e instanceof InfeasiblePathError) {\n      // The joinCondition cannot be false in the current path, after all\n      desc = descriptor1;\n      return OrdinaryGetHelper();\n    } else {\n      throw e;\n    }\n  }\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of ownDesc.joinCondition.\n  let joinedEffects = Join.joinForkOrChoose(\n    realm,\n    joinCondition,\n    new Effects(result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1),\n    new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2)\n  );\n  let completion = joinedEffects.result;\n  if (completion instanceof PossiblyNormalCompletion) {\n    // in this case one of the branches may complete abruptly, which means that\n    // not all control flow branches join into one flow at this point.\n    // Consequently we have to continue tracking changes until the point where\n    // all the branches come together into one.\n    completion = realm.composeWithSavedCompletion(completion);\n  }\n  // Note that the effects of (non joining) abrupt branches are not included\n  // in joinedEffects, but are tracked separately inside completion.\n  realm.applyEffects(joinedEffects);\n\n  // return or throw completion\n  if (completion instanceof AbruptCompletion) throw completion;\n  invariant(completion instanceof Value);\n  return completion;\n\n  function OrdinaryGetHelper() {\n    let descValue = !desc\n      ? realm.intrinsics.undefined\n      : desc.value === undefined\n        ? realm.intrinsics.undefined\n        : desc.value;\n    invariant(descValue instanceof Value);\n\n    // 3. If desc is undefined, then\n    if (!desc || descValue.mightHaveBeenDeleted()) {\n      // a. Let parent be ? O.[[GetPrototypeOf]]().\n      let parent = O.$GetPrototypeOf();\n\n      // b. If parent is null, return undefined.\n      if (parent instanceof NullValue) {\n        // Return the property value since it is now known to be the right value\n        // even in the case when it is empty.\n        return descValue;\n      }\n\n      // c. Return ? parent.[[Get]](P, Receiver).\n      if (descValue.mightHaveBeenDeleted() && descValue instanceof AbstractValue) {\n        // We don't know for sure that O.P does not exist.\n        let parentVal = OrdinaryGet(realm, parent.throwIfNotConcreteObject(), P, descValue, true);\n        if (parentVal instanceof UndefinedValue)\n          // even O.P returns undefined it is still the right value.\n          return descValue;\n        // Join with parent value with descValue because the actual value will be\n        // descValue unless it is empty.\n        // Only get the parent value if it does not involve a getter call.\n        // Use a property get for the joined value since it does the check for empty.\n        let cond = AbstractValue.createFromBinaryOp(realm, \"!==\", descValue, realm.intrinsics.empty);\n        return AbstractValue.createFromConditionalOp(realm, cond, descValue, parentVal);\n      }\n      invariant(!desc || descValue instanceof EmptyValue);\n      return parent.$Get(P, Receiver);\n    }\n\n    // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].\n    if (IsDataDescriptor(realm, desc)) return descValue;\n    if (dataOnly) {\n      invariant(descValue instanceof AbstractValue);\n      AbstractValue.reportIntrospectionError(descValue);\n      throw new FatalError();\n    }\n\n    // 5. Assert: IsAccessorDescriptor(desc) is true.\n    invariant(IsAccessorDescriptor(realm, desc), \"expected accessor descriptor\");\n\n    // 6. Let getter be desc.[[Get]].\n    let getter = desc.get;\n\n    // 7. If getter is undefined, return undefined.\n    if (!getter || getter instanceof UndefinedValue) return realm.intrinsics.undefined;\n\n    // 8. Return ? Call(getter, Receiver).\n    return Call(realm, getter, Receiver);\n  }\n}\n\n// ECMA262 8.3.6\nexport function GetGlobalObject(realm: Realm): ObjectValue | AbstractObjectValue {\n  // 1. Let ctx be the running execution context.\n  let ctx = realm.getRunningContext();\n\n  // 2. Let currentRealm be ctx's Realm.\n  let currentRealm = ctx.realm;\n\n  // 3. Return currentRealm.[[GlobalObject]].\n  return currentRealm.$GlobalObject;\n}\n\n// ECMA262 21.1.3.14.1\nexport function GetSubstitution(\n  realm: Realm,\n  matched: string,\n  str: string,\n  position: number,\n  captures: Array<string | void>,\n  replacement: string\n): string {\n  // 1. Assert: Type(matched) is String.\n  invariant(typeof matched === \"string\", \"expected matched to be a stirng\");\n\n  // 2. Let matchLength be the number of code units in matched.\n  let matchLength = matched.length;\n\n  // 3. Assert: Type(str) is String.\n  invariant(typeof str === \"string\", \"expected matched to be a stirng\");\n\n  // 4. Let stringLength be the number of code units in str.\n  let stringLength = str.length;\n\n  // 5. Assert: position is a nonnegative integer.\n  invariant(position >= 0, \"expected position to be a nonegative integer\");\n\n  // 6. Assert: position ≤ stringLength.\n  invariant(position <= stringLength, \"expected position to be less than string length\");\n\n  // 7. Assert: captures is a possibly empty List of Strings.\n  invariant(Array.isArray(captures), \"expected captures to be an array\");\n\n  // 8. Assert: Type(replacement) is String.\n  invariant(typeof replacement === \"string\", \"expected replacement to be a stirng\");\n\n  // 9. Let tailPos be position + matchLength.\n  let tailPos = position + matchLength;\n\n  // 10. Let m be the number of elements in captures.\n  let m = captures.length;\n\n  // 11. Let result be a String value derived from replacement by copying code unit elements\n  //     from replacement to result while performing replacements as specified in Table 46.\n  //     These $ replacements are done left-to-right, and, once such a replacement is performed,\n  //     the new replacement text is not subject to further replacements.\n  let result = \"\";\n  for (let i = 0; i < replacement.length; ++i) {\n    let ch = replacement.charAt(i);\n    if (ch !== \"$\" || i + 1 >= replacement.length) {\n      result += ch;\n      continue;\n    }\n    let peek = replacement.charAt(i + 1);\n    if (peek === \"&\") {\n      result += matched;\n    } else if (peek === \"$\") {\n      result += \"$\";\n    } else if (peek === \"`\") {\n      result += str.substr(0, position);\n    } else if (peek === \"'\") {\n      result += str.substr(tailPos);\n    } else if (peek >= \"0\" && peek <= \"9\") {\n      let idx = peek.charCodeAt(0) - \"0\".charCodeAt(0);\n      if (i + 2 < replacement.length) {\n        let peek2 = replacement.charAt(i + 2);\n        if (peek2 >= \"0\" && peek2 <= \"9\") {\n          let newIdx = idx * 10 + (peek2.charCodeAt(0) - \"0\".charCodeAt(0));\n          if (newIdx <= m) {\n            idx = newIdx;\n            i += 1;\n          }\n        }\n      }\n      if (idx > 0 && idx <= m) {\n        result += captures[idx - 1] || \"\";\n      } else {\n        result += \"$\" + idx;\n      }\n    } else {\n      result += \"$\" + peek;\n    }\n    i += 1;\n  }\n\n  // 12. Return result.\n  return result;\n}\n\n// ECMA262 7.3.9\nexport function GetMethod(realm: Realm, V: Value, P: PropertyKeyValue): UndefinedValue | CallableObjectValue {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 3. If func is either undefined or null, return undefined.\n  if (HasSomeCompatibleType(func, NullValue, UndefinedValue)) {\n    return realm.intrinsics.undefined;\n  }\n\n  // 4. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 5. Return func.\n  return ((func: any): CallableObjectValue);\n}\n\n// ECMA262 9.1.14\nexport function GetPrototypeFromConstructor(\n  realm: Realm,\n  constructor: ObjectValue,\n  intrinsicDefaultProto: string\n): ObjectValue | AbstractObjectValue {\n  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic\n  //   object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]\n  //   value of an object.\n  invariant(realm.intrinsics[intrinsicDefaultProto], \"not a valid proto ref\");\n\n  // 2. Assert: IsCallable(constructor) is true.\n  invariant(IsCallable(realm, constructor) === true, \"expected constructor to be callable\");\n\n  // 3. Let proto be ? Get(constructor, \"prototype\").\n  let proto = Get(realm, constructor, new StringValue(realm, \"prototype\"));\n\n  // 4. If Type(proto) is not Object, then\n  if (!(proto instanceof ObjectValue) && !(proto instanceof AbstractObjectValue)) {\n    // a. Let realm be ? GetFunctionRealm(constructor).\n    realm = GetFunctionRealm(realm, constructor);\n\n    // b. Let proto be realm's intrinsic object named intrinsicDefaultProto.\n    proto = realm.intrinsics[intrinsicDefaultProto];\n  }\n\n  // 5. Return proto.\n  return proto;\n}\n\n// ECMA262 7.3.1\nexport function Get(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): Value {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"Not an object value\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 3. Return ? O.[[Get]](P, O).\n  return O.$Get(P, O);\n}\n\n// ECMA262 7.3.2\nexport function GetV(realm: Realm, V: Value, P: PropertyKeyValue): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 2. Let O be ? ToObject(V).\n  let O = To.ToObject(realm, V);\n\n  // 3. Return ? O.[[Get]](P, V).\n  return O.$Get(P, V);\n}\n\n// ECMA262 6.2.3.3\nexport function GetThisValue(realm: Realm, V: Reference): Value {\n  // 1. Assert: IsPropertyReference(V) is true.\n  invariant(Environment.IsPropertyReference(realm, V), \"expected property reference\");\n\n  // 2. If IsSuperReference(V) is true, then\n  if (Environment.IsSuperReference(realm, V)) {\n    invariant(V.thisValue !== undefined);\n    // a. Return the value of the thisValue component of the reference V.\n    return V.thisValue;\n  }\n\n  // 3. Return GetBase(V).\n  let result = Environment.GetBase(realm, V);\n  invariant(result instanceof Value);\n  return result;\n}\n\n// ECMA262 8.3.5\nexport function GetNewTarget(realm: Realm): UndefinedValue | ObjectValue {\n  // 1. Let envRec be GetThisEnvironment( ).\n  let envRec = Environment.GetThisEnvironment(realm);\n\n  // 2. Assert: envRec has a [[NewTarget]] field.\n  if (!(\"$NewTarget\" in envRec)) {\n    // In the spec we should not get here because earlier static checks are supposed to prevent it.\n    // However, we do not have an appropriate place to do this check earlier.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"new.target not allowed here\");\n  }\n\n  // 3. Return envRec.[[NewTarget]].\n  return envRec.$NewTarget || realm.intrinsics.undefined;\n}\n\nexport function GetTemplateObject(realm: Realm, templateLiteral: BabelNodeTemplateLiteral): ObjectValue {\n  // 1. Let rawStrings be TemplateStrings of templateLiteral with argument true.\n  let rawStrings = templateLiteral.quasis.map(quasi => quasi.value.raw);\n\n  // 2. Let realm be the current Realm Record.\n  realm;\n\n  // 3. Let templateRegistry be realm.[[TemplateMap]].\n  let templateRegistry = realm.$TemplateMap;\n\n  // 4. For each element e of templateRegistry, do\n  for (let e of templateRegistry) {\n    let same;\n    if (e.$Strings.length === rawStrings.length) {\n      same = true;\n      for (let i = 0; i < rawStrings.length; ++i) {\n        if (e.$Strings[i] !== rawStrings[i]) {\n          same = false;\n          break;\n        }\n      }\n    } else {\n      same = false;\n    }\n\n    // a. If e.[[Strings]] and rawStrings contain the same values in the same order, then\n    if (same) {\n      // i. Return e.[[Array]].\n      return e.$Array;\n    }\n  }\n\n  // 5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.\n  let cookedStrings = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n\n  // 6. Let count be the number of elements in the List cookedStrings.\n  let count = cookedStrings.length;\n\n  // 7. Let template be ArrayCreate(count).\n  let template = Create.ArrayCreate(realm, count);\n\n  // 8. Let rawObj be ArrayCreate(count).\n  let rawObj = Create.ArrayCreate(realm, count);\n\n  // 9. Let index be 0.\n  let index = 0;\n\n  // 10. Repeat while index < count\n  while (index < count) {\n    // a. Let prop be ! ToString(index).\n    let prop = To.ToString(realm, new NumberValue(realm, index));\n\n    // b. Let cookedValue be the String value cookedStrings[index].\n    let cookedValue = new StringValue(realm, cookedStrings[index]);\n\n    // c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    template.$DefineOwnProperty(prop, {\n      value: cookedValue,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    });\n\n    // d. Let rawValue be the String value rawStrings[index].\n    let rawValue = new StringValue(realm, rawStrings[index]);\n\n    // e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    rawObj.$DefineOwnProperty(prop, {\n      value: rawValue,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    });\n\n    // f. Let index be index+1.\n    index = index + 1;\n  }\n\n  // 11. Perform SetIntegrityLevel(rawObj, \"frozen\").\n  SetIntegrityLevel(realm, rawObj, \"frozen\");\n\n  // 12. Call template.[[DefineOwnProperty]](\"raw\", PropertyDescriptor{[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).\n  template.$DefineOwnProperty(\"raw\", {\n    value: rawObj,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n\n  // 13. Perform SetIntegrityLevel(template, \"frozen\").\n  SetIntegrityLevel(realm, template, \"frozen\");\n\n  // 14. Append the Record{[[Strings]]: rawStrings, [[Array]]: template} to templateRegistry.\n  templateRegistry.push({ $Strings: rawStrings, $Array: template });\n\n  // 15. Return template.\n  return template;\n}\n\nexport function GetFromArrayWithWidenedNumericProperty(realm: Realm, arr: ArrayValue, P: string | Value): Value {\n  let proto = arr.$GetPrototypeOf();\n  invariant(proto instanceof ObjectValue && proto === realm.intrinsics.ArrayPrototype);\n  if (typeof P === \"string\") {\n    if (P === \"length\") {\n      return AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        NumberValue,\n        [arr],\n        ([o]) => t.memberExpression(o, t.identifier(\"length\"), false),\n        { skipInvariant: true, isPure: true }\n      );\n    }\n    let prototypeBinding = proto.properties.get(P);\n    if (prototypeBinding !== undefined) {\n      let descriptor = prototypeBinding.descriptor;\n      // ensure we are accessing a built-in native function\n      if (descriptor !== undefined && descriptor.value instanceof NativeFunctionValue) {\n        return descriptor.value;\n      }\n    }\n  }\n  let prop = typeof P === \"string\" ? new StringValue(realm, P) : P;\n  return AbstractValue.createTemporalFromBuildFunction(\n    realm,\n    Value,\n    [arr, prop],\n    ([o, p]) => memberExpressionHelper(o, p),\n    {\n      skipInvariant: true,\n      isPure: true,\n    }\n  );\n}\n"]}