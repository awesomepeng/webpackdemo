{"version":3,"sources":["../../src/methods/destructuring.js"],"names":["DestructuringAssignmentEvaluation","IteratorDestructuringAssignmentEvaluation","KeyedDestructuringAssignmentEvaluation","RestDestructuringAssignmentEvaluation","realm","property","value","excludedNames","strictCode","env","DestructuringAssignmentTarget","argument","lref","type","evaluate","restObj","ObjectCreate","intrinsics","ObjectPrototype","CopyDataProperties","PutValue","nestedAssignmentPattern","PropertyDestructuringAssignmentEvaluation","properties","length","AssignmentProperty","slice","AssignmentPropertyList","propertyNames","nextNames","key","name","left","computed","Initializer","right","P","ResolveBinding","v","undefined","defaultValue","GetValue","hasNameProperty","SetFunctionName","Array","concat","pattern","AssignmentRestProperty","push","empty","iterator","iteratorRecord","$Iterator","$Done","result","elements","error","completion","_elements","restEl","lastEl","element","next","e","GetReferencedName","A","ArrayCreate","n","nextValue","status","CreateDataProperty","toString","node","propertyName","rhsValue","assignmentPattern"],"mappings":"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","file":"destructuring.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport invariant from \"../invariant.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { Value, ObjectValue, UndefinedValue, StringValue, SymbolValue } from \"../values/index.js\";\nimport { AbruptCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  RequireObjectCoercible,\n  GetIterator,\n  IteratorClose,\n  IteratorStep,\n  IteratorValue,\n  IsAnonymousFunctionDefinition,\n  IsIdentifierRef,\n  HasOwnProperty,\n  GetV,\n} from \"./index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport type {\n  BabelNodeIdentifier,\n  BabelNodeAssignmentPattern,\n  BabelNodeObjectProperty,\n  BabelNodeRestProperty,\n  BabelNodeLVal,\n  BabelNodeArrayPattern,\n  BabelNodeObjectPattern,\n} from \"babel-types\";\n\nfunction RestDestructuringAssignmentEvaluation(\n  realm: Realm,\n  property: BabelNodeRestProperty,\n  value: Value,\n  excludedNames: Array<PropertyKeyValue>,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  let DestructuringAssignmentTarget = property.argument;\n\n  let lref;\n  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n    lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n    // b. ReturnIfAbrupt(lref).\n  }\n\n  // 2. Let restObj be ObjectCreate(%ObjectPrototype%).\n  let restObj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 3. Let assignStatus be CopyDataProperties(restObj, value, excludedNames).\n  /* let assignStatus = */ Create.CopyDataProperties(realm, restObj, value, excludedNames);\n  // 4. ReturnIfAbrupt(assignStatus).\n\n  // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    invariant(lref);\n    // Return PutValue(lref, restObj).\n    return Properties.PutValue(realm, lref, restObj);\n  }\n\n  // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern[?Yield, ?Await] as the goal symbol, adopting the parameter values from AssignmentRestProperty.\n  let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n  return DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, restObj, strictCode, env);\n}\n\nfunction PropertyDestructuringAssignmentEvaluation(\n  realm: Realm,\n  properties: Array<BabelNodeObjectProperty>,\n  value: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): Array<string | StringValue | SymbolValue> {\n  // Base condition for recursive call below\n  if (properties.length === 0) {\n    return [];\n  }\n\n  let AssignmentProperty = properties.slice(-1)[0];\n  let AssignmentPropertyList = properties.slice(0, -1);\n\n  // 1. Let propertyNames be the result of performing PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n  let propertyNames = PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env);\n\n  // 2. ReturnIfAbrupt(status propertyNames).\n\n  // Let nextNames be the result of performing PropertyDestructuringAssignmentEvaluation for AssignmentProperty using value as the argument.\n  let nextNames;\n\n  // AssignmentProperty : IdentifierReference Initializer\n  if (\n    AssignmentProperty.key.type === \"Identifier\" &&\n    ((AssignmentProperty.value.type === \"Identifier\" &&\n      AssignmentProperty.value.name === AssignmentProperty.key.name) ||\n      (AssignmentProperty.value.type === \"AssignmentPattern\" &&\n        AssignmentProperty.value.left.name === AssignmentProperty.key.name)) &&\n    AssignmentProperty.computed === false\n  ) {\n    let Initializer;\n\n    if (AssignmentProperty.value.type === \"AssignmentPattern\") {\n      Initializer = (AssignmentProperty.value: BabelNodeAssignmentPattern).right;\n    }\n\n    // 1. Let P be StringValue of IdentifierReference.\n    let P = (AssignmentProperty.key: BabelNodeIdentifier).name;\n\n    // 2. Let lref be ? ResolveBinding(P).\n    let lref = Environment.ResolveBinding(realm, P, strictCode, env);\n\n    // 3. Let v be ? GetV(value, P).\n    let v = GetV(realm, value, P);\n\n    // 4. If Initializer is present and v is undefined, then\n    if (Initializer !== undefined && v instanceof UndefinedValue) {\n      // 4a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // 4b. Let v be ? GetValue(defaultValue).\n      v = Environment.GetValue(realm, defaultValue);\n\n      // 4c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n        invariant(v instanceof ObjectValue);\n\n        // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n        // j. If hasNameProperty is false, perform SetFunctionName(v, P).\n        if (hasNameProperty === false) {\n          Functions.SetFunctionName(realm, v, P);\n        }\n      }\n    }\n\n    // Perform ? PutValue(lref, v).\n    Properties.PutValue(realm, lref, v);\n\n    // Return a new List containing P.\n    nextNames = [new StringValue(realm, P)];\n  } else {\n    // AssignmentProperty : PropertyName:AssignmentElement\n\n    // 1. Let name be the result of evaluating PropertyName.\n    let name = EvalPropertyName(AssignmentProperty, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(name).\n\n    // 3. Let status be the result of performing KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.\n    /* let status = */ KeyedDestructuringAssignmentEvaluation(\n      realm,\n      // $FlowFixMe\n      AssignmentProperty.value,\n      value,\n      name,\n      strictCode,\n      env\n    );\n\n    // 4. ReturnIfAbrupt(status).\n\n    // 5. Return a new List containing name.\n    nextNames = [name];\n  }\n\n  // 4. ReturnIfAbrupt(nextNames).\n\n  invariant(nextNames instanceof Array);\n  // 5. Append each item in nextNames to the end of propertyNames.\n  propertyNames = propertyNames.concat(nextNames);\n\n  // 6. Return propertyNames.\n  return propertyNames;\n}\n\n// 2.1 Object Rest/Spread Properties\nexport function DestructuringAssignmentEvaluation(\n  realm: Realm,\n  pattern: BabelNodeArrayPattern | BabelNodeObjectPattern,\n  value: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  if (pattern.type === \"ObjectPattern\") {\n    let AssignmentPropertyList = [],\n      AssignmentRestProperty = null;\n\n    for (let property of pattern.properties) {\n      if (property.type === \"RestProperty\") {\n        AssignmentRestProperty = property;\n      } else {\n        AssignmentPropertyList.push(property);\n      }\n    }\n\n    // ObjectAssignmentPattern:\n    //   { AssignmentPropertyList }\n    //   { AssignmentPropertyList, }\n    if (!AssignmentRestProperty) {\n      // 1. Perform ? RequireObjectCoercible(value).\n      RequireObjectCoercible(realm, value);\n\n      // 2. Perform ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n      PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env);\n\n      // 3. Return NormalCompletion(empty).\n      return realm.intrinsics.empty;\n    }\n\n    // ObjectAssignmentPattern : { AssignmentRestProperty }\n    if (AssignmentPropertyList.length === 0) {\n      // 1. Let excludedNames be a new empty List.\n      let excludedNames = [];\n\n      // 2. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestProperty with value and excludedNames as the arguments.\n      return RestDestructuringAssignmentEvaluation(\n        realm,\n        AssignmentRestProperty,\n        value,\n        excludedNames,\n        strictCode,\n        env\n      );\n    } else {\n      // ObjectAssignmentPattern : { AssignmentPropertyList, AssignmentRestProperty }\n      // 1. Let excludedNames be the result of performing ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n      let excludedNames = PropertyDestructuringAssignmentEvaluation(\n        realm,\n        AssignmentPropertyList,\n        value,\n        strictCode,\n        env\n      );\n\n      // 2. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestProperty with value and excludedNames as the arguments.\n      return RestDestructuringAssignmentEvaluation(\n        realm,\n        AssignmentRestProperty,\n        value,\n        excludedNames,\n        strictCode,\n        env\n      );\n    }\n  } else if (pattern.type === \"ArrayPattern\") {\n    // 1. Let iterator be ? GetIterator(value).\n    let iterator = GetIterator(realm, value);\n\n    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: iterator,\n      $Done: false,\n    };\n\n    // 3. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.\n    let result;\n    try {\n      result = IteratorDestructuringAssignmentEvaluation(realm, pattern.elements, iteratorRecord, strictCode, env);\n    } catch (error) {\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n        throw IteratorClose(realm, iterator, error);\n      }\n      throw error;\n    }\n\n    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n    if (iteratorRecord.$Done === false) {\n      let completion = IteratorClose(realm, iterator, new SimpleNormalCompletion(realm.intrinsics.undefined));\n      if (completion instanceof AbruptCompletion) {\n        throw completion;\n      }\n    }\n\n    // 5. Return result.\n    return result;\n  }\n}\n\n// ECMA262 12.15.5.3\nexport function IteratorDestructuringAssignmentEvaluation(\n  realm: Realm,\n  _elements: $ReadOnlyArray<BabelNodeLVal | null>,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  let elements = _elements;\n  // Check if the last element is a rest element. If so then we want to save the\n  // element and handle it separately after we iterate through the other\n  // formals. This also enforces that a rest element may only ever be in the\n  // last position.\n  let restEl;\n  if (elements.length > 0) {\n    let lastEl = elements[elements.length - 1];\n    if (lastEl !== null && lastEl.type === \"RestElement\") {\n      restEl = lastEl;\n      elements = elements.slice(0, -1);\n    }\n  }\n\n  for (let element of elements) {\n    if (element === null) {\n      // Elision handling\n\n      // 1. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        let next;\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // c. ReturnIfAbrupt(next).\n          throw e;\n        }\n        // d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n        }\n      }\n      // 2. Return NormalCompletion(empty).\n      continue;\n    }\n\n    // AssignmentElement : DestructuringAssignmentTarget Initializer\n\n    let DestructuringAssignmentTarget;\n    let Initializer;\n\n    if (element.type === \"AssignmentPattern\") {\n      Initializer = element.right;\n      DestructuringAssignmentTarget = element.left;\n    } else {\n      DestructuringAssignmentTarget = element;\n    }\n\n    let lref;\n\n    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n    }\n\n    let value;\n\n    // 2. If iteratorRecord.[[Done]] is false, then\n    if (iteratorRecord.$Done === false) {\n      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n      let next;\n      try {\n        next = IteratorStep(realm, iteratorRecord.$Iterator);\n      } catch (e) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // c. ReturnIfAbrupt(next).\n        throw e;\n      }\n\n      // d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next === false) {\n        iteratorRecord.$Done = true;\n        // Normally this assignment would be done in step 3, but we do it\n        // here so that Flow knows `value` will always be initialized by step 4.\n        value = realm.intrinsics.undefined;\n      } else {\n        // e. Else,\n        // i. Let value be IteratorValue(next).\n        try {\n          value = IteratorValue(realm, next);\n        } catch (e) {\n          // ii. If value is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(v).\n          throw e;\n        }\n      }\n    } else {\n      // 3. If iteratorRecord.[[Done]] is true, let value be undefined.\n      value = realm.intrinsics.undefined;\n    }\n\n    let v;\n\n    // 4. If Initializer is present and value is undefined, then\n    if (Initializer && value instanceof UndefinedValue) {\n      // a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // b. Let v be ? GetValue(defaultValue).\n      v = Environment.GetValue(realm, defaultValue);\n    } else {\n      // 5. Else, let v be value.\n      v = value;\n    }\n\n    // 6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type === \"ObjectPattern\" ||\n      DestructuringAssignmentTarget.type === \"ArrayPattern\"\n    ) {\n      // a. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n      let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n      // b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.\n      DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, v, strictCode, env);\n      continue;\n    }\n\n    // We know `lref` exists because of how the algorithm is setup, but tell\n    // Flow that `lref` exists with an `invariant()`.\n    invariant(lref);\n\n    // 7. If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then\n    if (\n      Initializer &&\n      value instanceof UndefinedValue &&\n      IsAnonymousFunctionDefinition(realm, Initializer) &&\n      IsIdentifierRef(realm, DestructuringAssignmentTarget) &&\n      v instanceof ObjectValue\n    ) {\n      // a. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n      let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n      // b. If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).\n      if (hasNameProperty === false) {\n        // All of the nodes that may be evaluated to produce lref create\n        // references. Assert this with an invariant as GetReferencedName may\n        // not be called with a value.\n        invariant(lref instanceof Reference);\n\n        Functions.SetFunctionName(realm, v, Environment.GetReferencedName(realm, lref));\n      }\n    }\n\n    // 8. Return ? PutValue(lref, v).\n    Properties.PutValue(realm, lref, v);\n    continue;\n  }\n\n  // Handle the rest element if we have one.\n  if (restEl) {\n    // AssignmentRestElement : ...DestructuringAssignmentTarget\n    let DestructuringAssignmentTarget = restEl.argument;\n\n    let lref;\n\n    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n    }\n\n    // 2. Let A be ArrayCreate(0).\n    let A = Create.ArrayCreate(realm, 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. Repeat while iteratorRecord.[[Done]] is false,\n    while (iteratorRecord.$Done === false) {\n      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n      let next;\n      try {\n        next = IteratorStep(realm, iteratorRecord.$Iterator);\n      } catch (e) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // c. ReturnIfAbrupt(next).\n        throw e;\n      }\n\n      // d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next === false) {\n        iteratorRecord.$Done = true;\n      } else {\n        // e. Else,\n        // i. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // ii. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // iv. Let status be CreateDataProperty(A, ! ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // v. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // vi. Increment n by 1.\n        n += 1;\n      }\n    }\n\n    // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // `lref` will always be defined at this point. Let Flow know with an\n      // invariant.\n      invariant(lref);\n\n      // a. Return ? PutValue(lref, A).\n      return Properties.PutValue(realm, lref, A);\n    } else {\n      // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n      let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n      // 7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.\n      return DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, A, strictCode, env);\n    }\n  }\n}\n\n// ECMA262 12.15.5.4\nexport function KeyedDestructuringAssignmentEvaluation(\n  realm: Realm,\n  node: BabelNodeLVal,\n  value: Value,\n  propertyName: PropertyKeyValue,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  let DestructuringAssignmentTarget;\n  let Initializer;\n\n  if (node.type === \"AssignmentPattern\") {\n    Initializer = node.right;\n    DestructuringAssignmentTarget = node.left;\n  } else {\n    DestructuringAssignmentTarget = node;\n  }\n\n  let lref;\n\n  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  //\n  // The spec assumes we haven't yet distinguished between literals and\n  // patterns, but our parser does that work for us. That means we check for\n  // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n    lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n    // b. ReturnIfAbrupt(lref).\n  }\n\n  let rhsValue;\n\n  // 2. Let v be ? GetV(value, propertyName).\n  let v = GetV(realm, value, propertyName);\n\n  // 3. If Initializer is present and v is undefined, then\n  if (Initializer && v instanceof UndefinedValue) {\n    // a. Let defaultValue be the result of evaluating Initializer.\n    let defaultValue = env.evaluate(Initializer, strictCode);\n\n    // b. Let rhsValue be ? GetValue(defaultValue).\n    rhsValue = Environment.GetValue(realm, defaultValue);\n  } else {\n    // 4. Else, let rhsValue be v.\n    rhsValue = v;\n  }\n\n  // 5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then\n  //\n  // The spec assumes we haven't yet distinguished between literals and\n  // patterns, but our parser does that work for us. That means we check for\n  // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n  if (DestructuringAssignmentTarget.type === \"ObjectPattern\" || DestructuringAssignmentTarget.type === \"ArrayPattern\") {\n    // a. Let assignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n    let assignmentPattern = DestructuringAssignmentTarget;\n\n    // b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.\n    return DestructuringAssignmentEvaluation(realm, assignmentPattern, rhsValue, strictCode, env);\n  }\n\n  // `lref` will always be defined at this point. Let Flow know with an\n  // invariant.\n  invariant(lref);\n\n  // 6. If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then\n  if (\n    Initializer &&\n    v instanceof UndefinedValue &&\n    IsAnonymousFunctionDefinition(realm, Initializer) &&\n    IsIdentifierRef(realm, DestructuringAssignmentTarget) &&\n    rhsValue instanceof ObjectValue\n  ) {\n    // a. Let hasNameProperty be ? HasOwnProperty(rhsValue, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, rhsValue, \"name\");\n\n    // b. If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).\n    if (hasNameProperty === false) {\n      // All of the nodes that may be evaluated to produce lref create\n      // references. Assert this with an invariant as GetReferencedName may\n      // not be called with a value.\n      invariant(lref instanceof Reference);\n\n      Functions.SetFunctionName(realm, rhsValue, Environment.GetReferencedName(realm, lref));\n    }\n  }\n\n  // 7. Return ? PutValue(lref, rhsValue).\n  return Properties.PutValue(realm, lref, rhsValue);\n}\n"]}