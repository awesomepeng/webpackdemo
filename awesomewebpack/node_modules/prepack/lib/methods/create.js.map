{"version":3,"sources":["../../src/methods/create.js"],"names":["allElementTypes","CreateImplementation","StringCreate","realm","value","prototype","S","$StringData","$Prototype","setExtensible","length","DefinePropertyOrThrow","writable","enumerable","configurable","CreateHTML","string","tag","attribute","str","ToStringPartial","p1","V","escapedV","replace","p2","p3","p4","MakeArgGetter","name","env","undefined","context","GetBindingValue","MakeArgSetter","SetMutableBinding","CreateStringIterator","iterator","ObjectCreate","intrinsics","StringIteratorPrototype","$IteratedString","$StringIteratorNextIndex","ArraySpeciesCreate","originalArray","Object","is","C","isArray","thisRealm","realmC","Array","mightBeObject","mightNotBeObject","throwIfNotConcrete","SymbolSpecies","ArrayCreate","createErrorThrowCompletion","TypeError","throwIfNotConcreteObject","CreateIterResultObject","done","obj","ObjectPrototype","CreateDataProperty","CreateArrayIterator","array","kind","ArrayIteratorPrototype","$IteratedObject","$ArrayIteratorNextIndex","$ArrayIterationKind","proto","Math","pow","RangeError","ArrayPrototype","A","OrdinaryDefineOwnProperty","CreateArrayFromList","elems","elem","arr","n","status","CreateUnmappedArgumentsObject","argumentsList","len","$ParameterMap","index","val","SymbolIterator","ArrayProto_values","get","ThrowTypeError","set","CreateMappedArgumentsObject","func","formals","param","type","map","parameterNames","push","numberOfParameters","mappedNames","indexOf","g","p","$DefineOwnProperty","O","P","newDesc","CopyDataProperties","target","source","excluded","null","from","ToObject","keys","$OwnPropertyKeys","nextKey","found","e","mightBeFalse","desc","$GetOwnProperty","propValue","CreateMethodProperty","CreateDataPropertyOrThrow","success","internalSlotsList","assign","OrdinaryCreateFromConstructor","constructor","intrinsicDefaultProto","CreateListFromArrayLike","elementTypes","ToLength","list","indexName","next","CreateDynamicFunction","newTarget","args","fallbackProto","argCount","bodyText","emptyString","firstArg","k","nextArg","nextArgString","ast","SyntaxError","program","body","functionDeclaration","params","strict","containsYield","node","F","FunctionAllocate","realmF","$Realm","scope","$GlobalEnv","FunctionInitialize","GeneratorPrototype","originalConstructor","SetFunctionName"],"mappings":"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","file":"create.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { EnvironmentRecord } from \"../environment.js\";\nimport type { PropertyKeyValue, IterationKind } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  ArrayValue,\n  ArgumentsExotic,\n  BooleanValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringExotic,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { GetPrototypeFromConstructor } from \"./get.js\";\nimport { IsConstructor, IsPropertyKey, IsArray } from \"./is.js\";\nimport { Type, SameValue, RequireObjectCoercible } from \"./abstract.js\";\nimport { Get, GetFunctionRealm } from \"./get.js\";\nimport { Construct, MakeConstructor } from \"./construct.js\";\nimport { Functions, Properties, To } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport type { BabelNodeIdentifier, BabelNodeLVal, BabelNodeFunctionDeclaration } from \"babel-types\";\n\nconst allElementTypes = [\"Undefined\", \"Null\", \"Boolean\", \"String\", \"Symbol\", \"Number\", \"Object\"];\n\nexport class CreateImplementation {\n  // ECMA262 9.4.3.3\n  StringCreate(realm: Realm, value: StringValue, prototype: ObjectValue | AbstractObjectValue): ObjectValue {\n    // 1. Assert: Type(value) is String.\n    invariant(value instanceof StringValue, \"expected string value\");\n\n    // 2. Let S be a newly created String exotic object.\n    let S = new StringExotic(realm);\n\n    // 3. Set the [[StringData]] internal slot of S to value.\n    S.$StringData = value;\n\n    // 4. Set S's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 5. Set the [[GetOwnProperty]] internal method of S as specified in 9.4.3.1.\n\n    // 6. Set the [[OwnPropertyKeys]] internal method of S as specified in 9.4.3.2.\n\n    // 7. Set the [[Prototype]] internal slot of S to prototype.\n    S.$Prototype = prototype;\n\n    // 8. Set the [[Extensible]] internal slot of S to true.\n    S.setExtensible(true);\n\n    // 9. Let length be the number of code unit elements in value.\n    let length = value.value.length;\n\n    // 10. Perform ! DefinePropertyOrThrow(S, \"length\", PropertyDescriptor{[[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).\n    Properties.DefinePropertyOrThrow(realm, S, \"length\", {\n      value: new NumberValue(realm, length),\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // 11. Return S.\n    return S;\n  }\n\n  // B.2.3.2.1\n  CreateHTML(realm: Realm, string: Value, tag: string, attribute: string, value: string | Value): StringValue {\n    // 1. Let str be ? RequireObjectCoercible(string).\n    let str = RequireObjectCoercible(realm, string);\n\n    // 2. Let S be ? ToString(str).\n    let S = To.ToStringPartial(realm, str);\n\n    // 3. Let p1 be the String value that is the concatenation of \"<\" and tag.\n    let p1 = `<${tag}`;\n\n    // 4. If attribute is not the empty String, then\n    if (attribute) {\n      // a. Let V be ? ToString(value).\n      let V = To.ToStringPartial(realm, value);\n\n      // b. Let escapedV be the String value that is the same as V except that each occurrence of the code unit\n      //    0x0022 (QUOTATION MARK) in V has been replaced with the six code unit sequence \"&quot;\".\n      let escapedV = V.replace(/\"/g, \"&quot;\");\n\n      // c. Let p1 be the String value that is the concatenation of the following String values:\n      // - The String value of p1\n      // - Code unit 0x0020 (SPACE)\n      // - The String value of attribute\n      // - Code unit 0x003D (EQUALS SIGN)\n      // - Code unit 0x0022 (QUOTATION MARK)\n      // - The String value of escapedV\n      // - Code unit 0x0022 (QUOTATION MARK)\n      p1 = `${p1} ${attribute}=\"${escapedV}\"`;\n    }\n\n    // 5. Let p2 be the String value that is the concatenation of p1 and \">\".\n    let p2 = `${p1}>`;\n\n    // 6. Let p3 be the String value that is the concatenation of p2 and S.\n    let p3 = `${p2}${S}`;\n\n    // 7. Let p4 be the String value that is the concatenation of p3, \"</\", tag, and \">\".\n    let p4 = `${p3}</${tag}>`;\n\n    // 8. Return p4.\n    return new StringValue(realm, p4);\n  }\n\n  // ECMA262 9.4.4.8.1\n  MakeArgGetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      undefined,\n      undefined,\n      0,\n      context => {\n        return env.GetBindingValue(name, false);\n      },\n      false\n    );\n  }\n\n  // ECMA262 9.4.4.8.1\n  MakeArgSetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      undefined,\n      undefined,\n      1,\n      (context, [value]) => {\n        return env.SetMutableBinding(name, value, false);\n      },\n      false\n    );\n  }\n\n  // ECMA262 21.1.5.1\n  CreateStringIterator(realm: Realm, string: StringValue): ObjectValue {\n    // 1. Assert: Type(string) is String.\n    invariant(string instanceof StringValue, \"expected string to be a string value\");\n\n    // 2. Let iterator be ObjectCreate(%StringIteratorPrototype%, « [[IteratedString]], [[StringIteratorNextIndex]] »).\n    let iterator = this.ObjectCreate(realm, realm.intrinsics.StringIteratorPrototype, {\n      $IteratedString: undefined,\n      $StringIteratorNextIndex: undefined,\n    });\n\n    // 3. Set iterator's [[IteratedString]] internal slot to string.\n    iterator.$IteratedString = string;\n\n    // 4. Set iterator's [[StringIteratorNextIndex]] internal slot to 0.\n    iterator.$StringIteratorNextIndex = 0;\n\n    // 5. Return iterator.\n    return iterator;\n  }\n\n  // ECMA262 9.4.2.3\n  ArraySpeciesCreate(realm: Realm, originalArray: ObjectValue, length: number): ObjectValue {\n    // 1. Assert: length is an integer Number ≥ 0.\n    invariant(length >= 0, \"expected length >= 0\");\n\n    // 2. If length is -0, let length be +0.\n    if (Object.is(length, -0)) length = +0;\n\n    // 3. Let C be undefined.\n    let C = realm.intrinsics.undefined;\n\n    // 4. Let isArray be ? IsArray(originalArray).\n    let isArray = IsArray(realm, originalArray);\n\n    // 5. If isArray is true, then\n    if (isArray) {\n      // a. Let C be ? Get(originalArray, \"constructor\").\n      C = Get(realm, originalArray, \"constructor\");\n\n      // b. If IsConstructor(C) is true, then\n      if (IsConstructor(realm, C)) {\n        invariant(C instanceof ObjectValue);\n        // i. Let thisRealm be the current Realm Record.\n        let thisRealm = realm;\n\n        // ii. Let realmC be ? GetFunctionRealm(C).\n        let realmC = GetFunctionRealm(realm, C);\n\n        // iii. If thisRealm and realmC are not the same Realm Record, then\n        if (thisRealm !== realmC) {\n          // 1. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, let C be undefined.\n          if (SameValue(realm, C, realmC.intrinsics.Array)) {\n            C = realm.intrinsics.undefined;\n          }\n        }\n      }\n\n      // c. If Type(C) is Object, then\n      if (C.mightBeObject()) {\n        if (C.mightNotBeObject()) C.throwIfNotConcrete();\n        invariant(C instanceof ObjectValue || C instanceof AbstractObjectValue);\n        // i. Let C be ? Get(C, @@species).\n        C = Get(realm, C, realm.intrinsics.SymbolSpecies);\n\n        // ii. If C is null, let C be undefined.\n        if (C instanceof NullValue) C = realm.intrinsics.undefined;\n      }\n    }\n\n    // 6. If C is undefined, return ? ArrayCreate(length).\n    if (C instanceof UndefinedValue) return this.ArrayCreate(realm, length);\n\n    // 7. If IsConstructor(C) is false, throw a TypeError exception.\n    if (!IsConstructor(realm, C)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a constructor\");\n    }\n\n    // 8. Return ? Construct(C, « length »).\n    return Construct(realm, C.throwIfNotConcreteObject(), [new NumberValue(realm, length)]);\n  }\n\n  // ECMA262 7.4.7\n  CreateIterResultObject(realm: Realm, value: Value, done: boolean): ObjectValue {\n    // 1. Assert: Type(done) is Boolean.\n    invariant(typeof done === \"boolean\", \"expected done to be a boolean\");\n\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n    let obj = this.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 3. Perform CreateDataProperty(obj, \"value\", value).\n    this.CreateDataProperty(realm, obj, \"value\", value);\n\n    // 4. Perform CreateDataProperty(obj, \"done\", done).\n    this.CreateDataProperty(realm, obj, \"done\", new BooleanValue(realm, done));\n\n    // 5. Return obj.\n    return obj;\n  }\n\n  // ECMA262 22.1.5.1\n  CreateArrayIterator(realm: Realm, array: ObjectValue, kind: IterationKind): ObjectValue {\n    // 1. Assert: Type(array) is Object.\n    invariant(array instanceof ObjectValue, \"expected object\");\n\n    // 2. Let iterator be ObjectCreate(%ArrayIteratorPrototype%, « [[IteratedObject]],\n    //    [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] »).\n    let iterator = this.ObjectCreate(realm, realm.intrinsics.ArrayIteratorPrototype, {\n      $IteratedObject: undefined,\n      $ArrayIteratorNextIndex: undefined,\n      $ArrayIterationKind: undefined,\n    });\n\n    // 3. Set iterator's [[IteratedObject]] internal slot to array.\n    iterator.$IteratedObject = array;\n\n    // 4. Set iterator's [[ArrayIteratorNextIndex]] internal slot to 0.\n    iterator.$ArrayIteratorNextIndex = new NumberValue(realm, 0);\n\n    // 5. Set iterator's [[ArrayIterationKind]] internal slot to kind.\n    iterator.$ArrayIterationKind = kind;\n\n    // 6. Return iterator.\n    return iterator;\n  }\n\n  // ECMA262 9.4.2.2\n  ArrayCreate(realm: Realm, length: number, proto?: ObjectValue | AbstractObjectValue): ArrayValue {\n    // 1. Assert: length is an integer Number ≥ 0.\n    invariant(length >= 0);\n\n    // 2. If length is -0, let length be +0.\n    if (Object.is(length, -0)) length = +0;\n\n    // 3. If length>232-1, throw a RangeError exception.\n    if (length > Math.pow(2, 32) - 1) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"length>2^32-1\");\n    }\n\n    // 4. If the proto argument was not passed, let proto be the intrinsic object %ArrayPrototype%.\n    proto = proto || realm.intrinsics.ArrayPrototype;\n\n    // 5. Let A be a newly created Array exotic object.\n    let A = new ArrayValue(realm);\n\n    // 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.\n    // 7. Set the [[DefineOwnProperty]] internal method of A as specified in 9.4.2.1.\n\n    // 8. Set the [[Prototype]] internal slot of A to proto.\n    A.$Prototype = proto;\n\n    // 9. Set the [[Extensible]] internal slot of A to true.\n    A.setExtensible(true);\n\n    // 10. Perform ! OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n    Properties.OrdinaryDefineOwnProperty(realm, A, \"length\", {\n      value: new NumberValue(realm, length),\n      writable: true,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // 11. Return A.\n    return A;\n  }\n\n  // ECMA262 7.3.16\n  CreateArrayFromList(realm: Realm, elems: Array<Value>): ArrayValue {\n    // 1. Assert: elements is a List whose elements are all ECMAScript language values.\n    for (let elem of elems) invariant(elem instanceof Value, \"value expected\");\n\n    // 2. Let array be ArrayCreate(0) (see 9.4.2.2).\n    let arr = this.ArrayCreate(realm, 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. For each element e of elements\n    for (let elem of elems) {\n      // a. Let status be CreateDataProperty(array, ! ToString(n), e).\n      let status = this.CreateDataProperty(realm, arr, new StringValue(realm, n + \"\"), elem);\n\n      // b. Assert: status is true.\n      invariant(status, \"couldn't create data property\");\n\n      // c. Increment n by 1.\n      n++;\n    }\n\n    // 5. Return array.\n    return arr;\n  }\n\n  // ECMA262 9.4.4.7\n  CreateUnmappedArgumentsObject(realm: Realm, argumentsList: Array<Value>): ObjectValue {\n    // 1. Let len be the number of elements in argumentsList.\n    let len = argumentsList.length;\n\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »).\n    let obj = this.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 3. Set obj's [[ParameterMap]] internal slot to undefined.\n    obj.$ParameterMap = obj; // The value is never used, but allows us to use undefined for \"not in\"\n\n    // 4. Perform DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor{[[Value]]: len,\n    //    [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, obj, \"length\", {\n      value: new NumberValue(realm, len),\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 5. Let index be 0.\n    let index = 0;\n\n    // 6. Repeat while index < len,\n    while (index < len) {\n      // a. Let val be argumentsList[index].\n      let val = argumentsList[index];\n\n      // b. Perform CreateDataProperty(obj, ! ToString(index), val).\n      this.CreateDataProperty(realm, obj, new StringValue(realm, index + \"\"), val);\n\n      // c. Let index be index + 1.\n      index++;\n    }\n\n    // 7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:\n    //    %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, obj, realm.intrinsics.SymbolIterator, {\n      value: realm.intrinsics.ArrayProto_values,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 8. Perform ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor {[[Get]]:\n    // %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false}).\n    Properties.DefinePropertyOrThrow(realm, obj, \"callee\", {\n      get: realm.intrinsics.ThrowTypeError,\n      set: realm.intrinsics.ThrowTypeError,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // 10. Return obj.\n    return obj;\n  }\n\n  // ECMA262 9.4.4.8\n  CreateMappedArgumentsObject(\n    realm: Realm,\n    func: FunctionValue,\n    formals: Array<BabelNodeLVal>,\n    argumentsList: Array<Value>,\n    env: EnvironmentRecord\n  ): ObjectValue {\n    // 1. Assert: formals does not contain a rest parameter, any binding patterns, or any\n    //    initializers. It may contain duplicate identifiers.\n    for (let param of formals) {\n      invariant(param.type === \"Identifier\", \"expected only simple params\");\n    }\n\n    // 2. Let len be the number of elements in argumentsList.\n    let len = argumentsList.length;\n\n    // 3. Let obj be a newly created arguments exotic object with a [[ParameterMap]] internal slot.\n    let obj = new ArgumentsExotic(realm);\n\n    // 4. Set the [[GetOwnProperty]] internal method of obj as specified in 9.4.4.1.\n\n    // 5. Set the [[DefineOwnProperty]] internal method of obj as specified in 9.4.4.2.\n\n    // 6. Set the [[Get]] internal method of obj as specified in 9.4.4.3.\n\n    // 7. Set the [[Set]] internal method of obj as specified in 9.4.4.4.\n\n    // 8. Set the [[Delete]] internal method of obj as specified in 9.4.4.6.\n\n    // 9. Set the remainder of obj's essential internal methods to the default ordinary\n    //    object definitions specified in 9.1.\n\n    // 10. Set the [[Prototype]] internal slot of obj to %ObjectPrototype%.\n    obj.$Prototype = realm.intrinsics.ObjectPrototype;\n\n    // 11. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 12. Let map be ObjectCreate(null).\n    let map = new ObjectValue(realm);\n\n    // 13. Set the [[ParameterMap]] internal slot of obj to map.\n    obj.$ParameterMap = map;\n\n    // 14. Let parameterNames be the BoundNames of formals.\n    let parameterNames = [];\n    for (let param of formals) {\n      parameterNames.push(((param: any): BabelNodeIdentifier).name);\n    }\n\n    // 15. Let numberOfParameters be the number of elements in parameterNames.\n    let numberOfParameters = parameterNames.length;\n\n    // 16. Let index be 0.\n    let index = 0;\n\n    // 17. Repeat while index < len,\n    while (index < len) {\n      // a. Let val be argumentsList[index].\n      let val = argumentsList[index];\n\n      // b. Perform CreateDataProperty(obj, ! ToString(index), val).\n      this.CreateDataProperty(realm, obj, new StringValue(realm, index + \"\"), val);\n\n      // c. Let index be index + 1.\n      index++;\n    }\n\n    // 18. Perform DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor{[[Value]]: len,\n    //     [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, obj, \"length\", {\n      value: new NumberValue(realm, len),\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 19. Let mappedNames be an empty List.\n    let mappedNames = [];\n\n    // 20. Let index be numberOfParameters - 1.\n    index = numberOfParameters - 1;\n\n    // 21. Repeat while index ≥ 0,\n    while (index >= 0) {\n      // a. Let name be parameterNames[index].\n      let name = parameterNames[index];\n\n      // b. If name is not an element of mappedNames, then\n      if (mappedNames.indexOf(name) < 0) {\n        // i. Add name as an element of the list mappedNames.\n        mappedNames.push(name);\n\n        // ii. If index < len, then\n        if (index < len) {\n          // 1. Let g be MakeArgGetter(name, env).\n          let g = this.MakeArgGetter(realm, name, env);\n\n          // 2. Let p be MakeArgSetter(name, env).\n          let p = this.MakeArgSetter(realm, name, env);\n\n          // 3. Perform map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor{[[Set]]: p, [[Get]]: g,\n          //    [[Enumerable]]: false, [[Configurable]]: true}).\n          map.$DefineOwnProperty(new StringValue(realm, index + \"\"), {\n            set: p,\n            get: g,\n            enumerable: false,\n            configurable: true,\n          });\n        }\n      }\n\n      // c. Let index be index - 1.\n      index--;\n    }\n\n    // 22. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:\n    //     %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, obj, realm.intrinsics.SymbolIterator, {\n      value: realm.intrinsics.ArrayProto_values,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 23. Perform ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor {[[Value]]:\n    //     func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, obj, \"callee\", {\n      value: func,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 24. Return obj.\n    return obj;\n  }\n\n  // ECMA262 7.3.4\n  CreateDataProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"Not an object value\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"Not a property key\");\n\n    // 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.\n    let newDesc = {\n      value: V,\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    };\n\n    // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n    return O.$DefineOwnProperty(P, newDesc);\n  }\n\n  CopyDataProperties(realm: Realm, target: ObjectValue, source: Value, excluded: Array<PropertyKeyValue>): ObjectValue {\n    // Assert: Type(target) is Object.\n    invariant(target instanceof ObjectValue, \"Not an object value\");\n\n    // Assert: Type(excluded) is List.\n    invariant(excluded instanceof Array, \"Not an array\");\n\n    //   If source is undefined or null,\n    if (source === realm.intrinsics.null || source === realm.intrinsics.undefined) {\n      // let keys be a new empty List.\n    } else {\n      //   Else,\n      // Let from be ! ToObject(source).\n      let from = To.ToObject(realm, source);\n\n      // Let keys be ? from.[[OwnPropertyKeys]]().\n      let keys = from.$OwnPropertyKeys();\n\n      //   Repeat for each element nextKey of keys in List order,\n      for (let nextKey of keys) {\n        // Let found be false.\n        let found = false;\n\n        //   Repeat for each element e of excluded,\n        for (let e of excluded) {\n          // Seems necessary. Flow complained too. Did I go wrong somewhere else?\n          invariant(e instanceof StringValue);\n          invariant(nextKey instanceof StringValue);\n\n          // If e is not empty and SameValue(e, nextKey) is true, then\n          if (!e.mightBeFalse() && SameValue(realm, e, nextKey)) {\n            // Set found to true.\n            found = true;\n          }\n        }\n        // If found is false, then\n        if (found === false) {\n          // Let desc be ? from.[[GetOwnProperty]](nextKey).\n          let desc = from.$GetOwnProperty(nextKey);\n\n          // If desc is not undefined and desc.[[Enumerable]] is true, then\n          if (desc !== undefined && desc.enumerable === true) {\n            // Let propValue be ? Get(from, nextKey).\n            let propValue = Get(realm, from, nextKey);\n            // Perform ! CreateDataProperty(target, nextKey, propValue).\n            this.CreateDataProperty(realm, target, nextKey, propValue);\n          }\n        }\n      }\n    }\n\n    // Return target.\n    return target;\n  }\n\n  // ECMA262 7.3.5\n  CreateMethodProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"Not an object value\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"Not a property key\");\n\n    // 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.\n    let newDesc = {\n      value: V,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    };\n\n    // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n    return O.$DefineOwnProperty(P, newDesc);\n  }\n\n  // ECMA262 7.3.6\n  CreateDataPropertyOrThrow(realm: Realm, O: Value, P: PropertyKeyValue, V: Value): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"Not an object value\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"Not a property key\");\n\n    //3. Let success be ? CreateDataProperty(O, P, V).\n    let success = this.CreateDataProperty(realm, O, P, V);\n\n    // 4. If success is false, throw a TypeError exception.\n    if (success === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. Return success.\n    return success;\n  }\n\n  // ECMA262 9.1.12\n  ObjectCreate(\n    realm: Realm,\n    proto: ObjectValue | AbstractObjectValue | NullValue,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue {\n    // 1. If internalSlotsList was not provided, let internalSlotsList be an empty List.\n    internalSlotsList = internalSlotsList || {};\n\n    // 2. Let obj be a newly created object with an internal slot for each name in internalSlotsList.\n    let obj = new ObjectValue(realm);\n    Object.assign(obj, internalSlotsList);\n\n    // 3. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 4. Set the [[Prototype]] internal slot of obj to proto.\n    obj.$Prototype = proto;\n\n    // 5. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 6. Return obj.\n    return obj;\n  }\n\n  // ECMA262 9.1.13\n  OrdinaryCreateFromConstructor(\n    realm: Realm,\n    constructor: ObjectValue,\n    intrinsicDefaultProto: string,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue {\n    // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic\n    //    object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]\n    //    value of an object.\n    invariant(realm.intrinsics[intrinsicDefaultProto], \"not a valid proto ref\");\n\n    // 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).\n    let proto = GetPrototypeFromConstructor(realm, constructor, intrinsicDefaultProto);\n\n    // 3. Return ObjectCreate(proto, internalSlotsList).\n    return this.ObjectCreate(realm, proto, internalSlotsList);\n  }\n\n  // ECMA262 7.3.17\n  CreateListFromArrayLike(realm: Realm, obj: Value, elementTypes?: Array<string>): Array<Value> {\n    // 1. If elementTypes was not passed, let elementTypes be « Undefined, Null, Boolean, String, Symbol, Number, Object ».\n    elementTypes = elementTypes || allElementTypes;\n\n    // 2. If Type(obj) is not Object, throw a TypeError exception.\n    if (!(obj instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Not an object\");\n    }\n\n    // 3. Let len be ? ToLength(? Get(obj, \"length\")).\n    let len = To.ToLength(realm, Get(realm, obj, \"length\"));\n\n    // 4. Let list be a new empty List.\n    let list: Array<Value> = [];\n\n    // 5. Let index be 0.\n    let index = 0;\n\n    // 6. Repeat while index < len\n    while (index < len) {\n      // a. Let indexName be ! ToString(index).\n      let indexName = index + \"\";\n\n      // b. Let next be ? Get(obj, indexName).\n      let next = Get(realm, obj, indexName);\n\n      // c. If Type(next) is not an element of elementTypes, throw a TypeError exception.\n      if (elementTypes !== allElementTypes && elementTypes.indexOf(Type(realm, next)) < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"invalid element type\");\n      }\n\n      // d. Append next as the last element of list.\n      list.push(next);\n\n      // e. Set index to index + 1.\n      index++;\n    }\n\n    // 7. Return list.\n    return list;\n  }\n\n  // ECMA262 19.2.1.1.1\n  CreateDynamicFunction(\n    realm: Realm,\n    constructor: ObjectValue,\n    newTarget: void | ObjectValue,\n    kind: \"normal\" | \"generator\",\n    args: Array<Value>\n  ): Value {\n    // 1. If newTarget is undefined, let newTarget be constructor.\n    newTarget = !newTarget ? constructor : newTarget;\n\n    let fallbackProto;\n    // 2. If kind is \"normal\", then\n    if (kind === \"normal\") {\n      // a. Let goal be the grammar symbol FunctionBody.\n\n      // b. Let parameterGoal be the grammar symbol FormalParameters.\n\n      // c. Let fallbackProto be \"%FunctionPrototype%\".\n      fallbackProto = \"FunctionPrototype\";\n    } else {\n      // 3. Else,\n      // a. Let goal be the grammar symbol GeneratorBody.\n\n      // b. Let parameterGoal be the grammar symbol FormalParameters[Yield].\n\n      // c. Let fallbackProto be \"%Generator%\".\n      fallbackProto = \"Generator\";\n    }\n\n    // 4. Let argCount be the number of elements in args.\n    let argCount = args.length;\n\n    // 5. Let P be the empty String.\n    let P = \"\";\n\n    let bodyText;\n    // 6. If argCount = 0, let bodyText be the empty String.\n    if (argCount === 0) {\n      bodyText = realm.intrinsics.emptyString;\n    } else if (argCount === 1) {\n      // 7. Else if argCount = 1, let bodyText be args[0].\n      bodyText = args[0];\n    } else {\n      // 8. Else argCount > 1,\n      // a. Let firstArg be args[0].\n      let firstArg = args[0];\n\n      // b. Let P be ? ToString(firstArg).\n      P = To.ToStringPartial(realm, firstArg);\n\n      // c. Let k be 1.\n      let k = 1;\n\n      // d. Repeat, while k < argCount-1\n      while (k < argCount - 1) {\n        // i. Let nextArg be args[k].\n        let nextArg = args[k];\n\n        // ii. Let nextArgString be ? ToString(nextArg).\n        let nextArgString = To.ToStringPartial(realm, nextArg);\n\n        // iii. Let P be the result of concatenating the previous value of P, the String \",\" (a comma), and nextArgString.\n        P = P + \",\" + nextArgString;\n\n        // iv. Increase k by 1.\n        k += 1;\n      }\n\n      // e. Let bodyText be args[k].\n      bodyText = args[k];\n    }\n\n    // 9. Let bodyText be ? ToString(bodyText).\n    bodyText = To.ToStringPartial(realm, bodyText);\n\n    // 10. Let parameters be the result of parsing P, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.\n    // 11. Let body be the result of parsing bodyText, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.\n    let ast;\n    try {\n      ast = parse(realm, \"function\" + (kind === \"generator\" ? \"*\" : \"\") + \" _(\" + P + \"){\" + bodyText + \"}\", \"eval\");\n    } catch (e) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"parse failed\");\n    }\n    let {\n      program: {\n        body: [functionDeclaration],\n      },\n    } = ast;\n    if (!functionDeclaration) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"parse failed\");\n    }\n    invariant(functionDeclaration.type === \"FunctionDeclaration\");\n    let { params, body } = ((functionDeclaration: any): BabelNodeFunctionDeclaration);\n\n    // 12. If bodyText is strict mode code, then let strict be true, else let strict be false.\n    let strict = IsStrict(body);\n\n    // 13. If any static semantics errors are detected for parameters or body, throw a SyntaxError or a ReferenceError exception, depending on the type of the error. If strict is true, the Early Error rules for StrictFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved in an implementation dependent manner.\n\n    // 14. If ContainsUseStrict of body is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.\n\n    // 15. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.\n\n    // 16. If body Contains SuperCall is true, throw a SyntaxError exception.\n\n    // 17. If parameters Contains SuperCall is true, throw a SyntaxError exception.\n\n    // 18. If body Contains SuperProperty is true, throw a SyntaxError exception.\n\n    // 19. If parameters Contains SuperProperty is true, throw a SyntaxError exception.\n\n    // 20. If kind is \"generator\", then\n    if (kind === \"generator\") {\n      // a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.\n      let containsYield = false;\n      for (let param of params) {\n        traverseFast(param, node => {\n          if (node.type === \"YieldExpression\") {\n            containsYield = true;\n            return true;\n          }\n          if (node.type === \"Identifier\" && ((node: any): BabelNodeIdentifier).name === \"yield\") {\n            containsYield = true;\n            return true;\n          }\n          return false;\n        });\n      }\n      if (containsYield) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"parse failed\");\n      }\n    }\n\n    // 21. If strict is true, then\n    if (strict === true) {\n      // a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.\n    }\n\n    // 22. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).\n    let proto = GetPrototypeFromConstructor(realm, newTarget, fallbackProto);\n\n    // 23. Let F be FunctionAllocate(proto, strict, kind).\n    let F = Functions.FunctionAllocate(realm, proto, strict, kind);\n\n    // 24. Let realmF be the value of F's [[Realm]] internal slot.\n    let realmF = F.$Realm;\n\n    // 25. Let scope be realmF.[[GlobalEnv]].\n    let scope = realmF.$GlobalEnv;\n\n    // 26. Perform FunctionInitialize(F, Normal, parameters, body, scope).\n    Functions.FunctionInitialize(realm, F, \"normal\", params, body, scope);\n\n    // 27. If kind is \"generator\", then\n    if (kind === \"generator\") {\n      // a. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = this.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = F;\n\n      // b. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(realm, F, \"prototype\", {\n        value: prototype,\n        writable: true,\n        enumerable: false,\n        configurable: false,\n      });\n    } else {\n      // 28. Else, perform MakeConstructor(F).\n      MakeConstructor(realm, F);\n    }\n\n    // 29. Perform SetFunctionName(F, \"anonymous\").\n    Functions.SetFunctionName(realm, F, \"anonymous\");\n\n    // 30. Return F.\n    return F;\n  }\n}\n"]}