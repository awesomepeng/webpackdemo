{"version":3,"sources":["../../../src/debugger/server/VariableManager.js"],"names":["VariableManager","constructor","realm","_containerCache","Map","_referenceMap","_realm","getReferenceForValue","value","cachedRef","get","undefined","varRef","add","set","getVariablesByReference","reference","container","_getVariablesFromEnvRecord","environmentRecord","_getVariablesFromObject","_getAbstractValueContent","object","variables","names","properties","keys","name","binding","descriptor","variable","_getVariableFromValue","push","kindVar","kind","variablesReference","contents","argCount","arg","args","envRecord","_getVariablesFromDeclarativeEnv","declVars","$DeclarativeRecord","objVars","$ObjectRecord","concat","env","bindings","_getVariableFromConcreteValue","_getVariableFromAbstractValue","_getAbstractValueDisplay","intrinsicName","startsWith","types","getType","toDisplayString","getKind","evaluate","frameId","expression","evalRealm","isDirect","isStrict","contextStack","length","stackIndex","context","evalString","PerformEval","varInfo","result","displayValue","type","e","clean"],"mappings":"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","file":"VariableManager.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Variable, EvaluateResult } from \"./../common/types.js\";\nimport { ReferenceMap } from \"./ReferenceMap.js\";\nimport {\n  LexicalEnvironment,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"./../../environment.js\";\nimport {\n  Value,\n  ConcreteValue,\n  PrimitiveValue,\n  ObjectValue,\n  AbstractObjectValue,\n  AbstractValue,\n  StringValue,\n} from \"./../../values/index.js\";\nimport invariant from \"./../common/invariant.js\";\nimport type { Realm } from \"./../../realm.js\";\nimport { IsDataDescriptor } from \"./../../methods/is.js\";\nimport { DebuggerError } from \"./../common/DebuggerError.js\";\nimport { Functions } from \"./../../singletons.js\";\n\ntype VariableContainer = LexicalEnvironment | ObjectValue | AbstractValue;\n\n// This class manages the handling of variable requests in the debugger\n// The DebugProtocol specifies collections of variables are to be fetched using a\n// unique reference ID called a variablesReference. This class can generate new\n// variablesReferences to pass to the UI and then perform lookups for those\n// variablesReferences when they are requested.\nexport class VariableManager {\n  constructor(realm: Realm) {\n    this._containerCache = new Map();\n    this._referenceMap = new ReferenceMap();\n    this._realm = realm;\n  }\n  // cache for created references\n  _containerCache: Map<VariableContainer, number>;\n  // map for looking up references\n  _referenceMap: ReferenceMap<VariableContainer>;\n  _realm: Realm;\n\n  // Given a container, either returns a cached reference for that container if\n  // it exists or return a new reference\n  getReferenceForValue(value: VariableContainer): number {\n    let cachedRef = this._containerCache.get(value);\n    if (cachedRef !== undefined) {\n      return cachedRef;\n    }\n\n    let varRef = this._referenceMap.add(value);\n    this._containerCache.set(value, varRef);\n    return varRef;\n  }\n\n  // The entry point for retrieving a collection of variables by a reference\n  getVariablesByReference(reference: number): Array<Variable> {\n    let container = this._referenceMap.get(reference);\n    if (!container) return [];\n    if (container instanceof LexicalEnvironment) {\n      return this._getVariablesFromEnvRecord(container.environmentRecord);\n    } else if (container instanceof ObjectValue) {\n      return this._getVariablesFromObject(container);\n    } else if (container instanceof AbstractValue) {\n      return this._getAbstractValueContent(container);\n    } else {\n      invariant(false, \"Invalid variable container\");\n    }\n  }\n\n  _getVariablesFromObject(object: ObjectValue): Array<Variable> {\n    let variables = [];\n    let names = object.properties.keys();\n    for (let name of names) {\n      let binding = object.properties.get(name);\n      invariant(binding !== undefined);\n      if (binding.descriptor) {\n        if (IsDataDescriptor(this._realm, binding.descriptor)) {\n          let value = binding.descriptor.value;\n          if (value instanceof Value) {\n            let variable = this._getVariableFromValue(name, value);\n            variables.push(variable);\n          }\n        }\n      }\n    }\n    return variables;\n  }\n\n  _getAbstractValueContent(value: AbstractValue): Array<Variable> {\n    let kindVar: Variable = {\n      name: \"kind\",\n      value: value.kind || \"undefined\",\n      variablesReference: 0,\n    };\n    let contents: Array<Variable> = [kindVar];\n    let argCount = 1;\n    for (let arg of value.args) {\n      contents.push(this._getVariableFromValue(\"arg-\" + argCount, arg));\n      argCount++;\n    }\n    return contents;\n  }\n\n  _getVariablesFromEnvRecord(envRecord: EnvironmentRecord): Array<Variable> {\n    if (envRecord instanceof DeclarativeEnvironmentRecord) {\n      return this._getVariablesFromDeclarativeEnv(envRecord);\n    } else if (envRecord instanceof ObjectEnvironmentRecord) {\n      if (envRecord.object instanceof ObjectValue) {\n        return this._getVariablesFromObject(envRecord.object);\n      } else if (envRecord.object instanceof AbstractObjectValue) {\n        // TODO: call _getVariablesFromAbstractObject when it is implemented\n        return [];\n      } else {\n        invariant(false, \"Invalid type of object environment record\");\n      }\n    } else if (envRecord instanceof GlobalEnvironmentRecord) {\n      let declVars = this._getVariablesFromEnvRecord(envRecord.$DeclarativeRecord);\n      let objVars = this._getVariablesFromEnvRecord(envRecord.$ObjectRecord);\n      return declVars.concat(objVars);\n    } else {\n      invariant(false, \"Invalid type of environment record\");\n    }\n  }\n\n  _getVariablesFromDeclarativeEnv(env: DeclarativeEnvironmentRecord): Array<Variable> {\n    let variables = [];\n    let bindings = env.bindings;\n    for (let name in bindings) {\n      let binding = bindings[name];\n      if (binding.value) {\n        let variable = this._getVariableFromValue(name, binding.value);\n        variables.push(variable);\n      }\n    }\n    return variables;\n  }\n\n  _getVariableFromValue(name: string, value: Value): Variable {\n    if (value instanceof ConcreteValue) {\n      return this._getVariableFromConcreteValue(name, value);\n    } else if (value instanceof AbstractValue) {\n      return this._getVariableFromAbstractValue(name, value);\n    } else {\n      invariant(false, \"Value is neither concrete nor abstract\");\n    }\n  }\n\n  _getVariableFromAbstractValue(name: string, value: AbstractValue): Variable {\n    let variable: Variable = {\n      name: name,\n      value: this._getAbstractValueDisplay(value),\n      variablesReference: this.getReferenceForValue(value),\n    };\n    return variable;\n  }\n\n  _getAbstractValueDisplay(value: AbstractValue): string {\n    if (value.intrinsicName && !value.intrinsicName.startsWith(\"_\")) {\n      return value.intrinsicName;\n    }\n    return \"Abstract \" + value.types.getType().name;\n  }\n\n  _getVariableFromConcreteValue(name: string, value: ConcreteValue): Variable {\n    if (value instanceof PrimitiveValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.toDisplayString(),\n        variablesReference: 0,\n      };\n      return variable;\n    } else if (value instanceof ObjectValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.getKind(),\n        variablesReference: this.getReferenceForValue(value),\n      };\n      return variable;\n    } else {\n      invariant(false, \"Concrete value must be primitive or object\");\n    }\n  }\n\n  evaluate(frameId: void | number, expression: string): EvaluateResult {\n    let evalRealm = this._realm;\n    let isDirect = false;\n    let isStrict = false;\n    if (frameId !== undefined) {\n      if (frameId < 0 || frameId >= this._realm.contextStack.length) {\n        throw new DebuggerError(\"Invalid command\", \"Invalid value for frame ID\");\n      }\n      // frameId's are in reverse order of context stack\n      let stackIndex = this._realm.contextStack.length - 1 - frameId;\n      let context = this._realm.contextStack[stackIndex];\n      isDirect = true;\n      isStrict = true;\n      evalRealm = context.realm;\n    }\n\n    let evalString = new StringValue(this._realm, expression);\n    try {\n      let value = Functions.PerformEval(this._realm, evalString, evalRealm, isStrict, isDirect);\n      let varInfo = this._getVariableFromValue(expression, value);\n      let result: EvaluateResult = {\n        kind: \"evaluate\",\n        displayValue: varInfo.value,\n        type: value.getType().name,\n        variablesReference: varInfo.variablesReference,\n      };\n      return result;\n    } catch (e) {\n      let result: EvaluateResult = {\n        kind: \"evaluate\",\n        displayValue: `Failed to evaluate: ${expression}`,\n        type: \"unknown\",\n        variablesReference: 0,\n      };\n      return result;\n    }\n  }\n\n  clean() {\n    this._containerCache = new Map();\n    this._referenceMap.clean();\n  }\n}\n"]}