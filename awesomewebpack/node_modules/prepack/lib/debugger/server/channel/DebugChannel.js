"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugChannel = undefined;

var _invariant = require("./../../common/invariant.js");

var _invariant2 = _interopRequireDefault(_invariant);

var _FileIOWrapper = require("./../../common/channel/FileIOWrapper.js");

var _DebugMessage = require("./../../common/channel/DebugMessage.js");

var _MessageMarshaller = require("./../../common/channel/MessageMarshaller.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//Channel used by the DebugServer in Prepack to communicate with the debug adapter
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
class DebugChannel {
  constructor(ioWrapper) {
    this._requestReceived = false;
    this._ioWrapper = ioWrapper;
    this._marshaller = new _MessageMarshaller.MessageMarshaller();
  }

  /*
  /* Only called in the beginning to check if a debugger is attached
  */
  debuggerIsAttached() {
    let message = this._ioWrapper.readInSyncOnce();
    if (message === null) return false;
    let parts = message.split(" ");
    let requestID = parseInt(parts[0], 10);
    (0, _invariant2.default)(!isNaN(requestID), "Request ID must be a number");
    let command = parts[1];
    if (command === _DebugMessage.DebugMessage.DEBUGGER_ATTACHED) {
      this._requestReceived = true;
      this._ioWrapper.clearInFile();
      this.writeOut(`${requestID} ${_DebugMessage.DebugMessage.PREPACK_READY_RESPONSE}`);
      return true;
    }
    return false;
  }

  /* Reads in a request from the debug adapter
  /* The caller is responsible for sending a response with the appropriate
  /* contents at the right time.
  */
  readIn() {
    let message = this._ioWrapper.readInSync();
    this._requestReceived = true;
    return this._marshaller.unmarshallRequest(message);
  }

  // Write out a response to the debug adapter
  writeOut(contents) {
    //Prepack only writes back to the debug adapter in response to a request
    (0, _invariant2.default)(this._requestReceived, "Prepack writing message without being requested: " + contents);
    this._ioWrapper.writeOutSync(contents);
    this._requestReceived = false;
  }

  sendBreakpointsAcknowledge(messageType, requestID, args) {
    this.writeOut(this._marshaller.marshallBreakpointAcknowledge(requestID, messageType, args.breakpoints));
  }

  sendStoppedResponse(reason, filePath, line, column, message) {
    this.writeOut(this._marshaller.marshallStoppedResponse(reason, filePath, line, column, message));
  }

  sendStackframeResponse(requestID, stackframes) {
    this.writeOut(this._marshaller.marshallStackFramesResponse(requestID, stackframes));
  }

  sendScopesResponse(requestID, scopes) {
    this.writeOut(this._marshaller.marshallScopesResponse(requestID, scopes));
  }

  sendVariablesResponse(requestID, variables) {
    this.writeOut(this._marshaller.marshallVariablesResponse(requestID, variables));
  }

  sendEvaluateResponse(requestID, evalResult) {
    this.writeOut(this._marshaller.marshallEvaluateResponse(requestID, evalResult));
  }

  shutdown() {
    this._ioWrapper.clearInFile();
    this._ioWrapper.clearOutFile();
  }
}
exports.DebugChannel = DebugChannel;
//# sourceMappingURL=DebugChannel.js.map