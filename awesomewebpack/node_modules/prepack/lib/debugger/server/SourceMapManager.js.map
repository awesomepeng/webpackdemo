{"version":3,"sources":["../../../src/debugger/server/SourceMapManager.js"],"names":["SourceMapManager","constructor","buckRoot","sourceMaps","undefined","_buckRoot","length","slice","map","sourceMapContents","_sourcemapCommonPrefix","_sourcemapMapDifference","originalSourcePaths","mapPaths","parsed","JSON","parse","section","sections","source","sources","push","_getAbsoluteSourcePath","filePath","_stripEmptyStringBookends","split","originalSourceCommonPrefix","_findCommonPrefix","originalSourceCPElements","mapCommonPrefix","mapCPElements","_findMapDifference","pathToInput","pathToSource","fullPath","pop","steps","step","paths","divergenceIndex","allPathsMatch","maxDivergenceIndex","Math","max","path","entry","join","commonPrefix","mapPrefix","mapPrefixUniqueElements","replace","mapDifference","i","concat","shift","relativeToAbsolute","absolute","dirRoot","separator","absoluteToRelative","relative"],"mappings":"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","file":"SourceMapManager.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { SourceFile } from \"./../../types.js\";\nimport { DebuggerError } from \"./../common/DebuggerError.js\";\nimport invariant from \"../common/invariant.js\";\n\n/**\n * Sourcemap paths can come in one of two formats:\n *     - Relative: The paths include `../` and can be followed from the sourcemap's location\n *         to arrive at the original source's location. In this format, path conversion\n *         requires two different prefixes (MapDifference and CommonPrefix) that must be\n *         discovered from the input paths.\n *     - Common Directory: The paths take the format of an absolute path (`/foo/bar`) and\n *         assume there is a common prefix to the path that, when added, will make the path an\n *         valid absolute path. This prefix is passed in as the `buckRoot` argument.\n *     Example:\n *         In a directory structure with /A/B/map.js and /A/C/original.js,\n *         the sourcemaps would have the following path structures:\n *           - Relative: ../C/original.js, with `CP` = /A and 'MD' = ../\n *           - Common Directory: /C/original.js, with `buckRoot` = /A\n */\nexport class SourceMapManager {\n  constructor(buckRoot?: string, sourceMaps?: Array<SourceFile>) {\n    // Use presence of buck root argument to indicate which path format sourcemap prefixes take on.\n    if (buckRoot !== undefined) {\n      if (sourceMaps === undefined) {\n        throw new DebuggerError(\n          \"Invalid input\",\n          \"Can't provide a sourcemap directory root without having sourcemaps present\"\n        );\n      }\n      this._buckRoot = buckRoot;\n      if (this._buckRoot[this._buckRoot.length - 1] === \"/\") {\n        // Remove trailing slash to prepare for prepending to internal paths.\n        this._buckRoot = this._buckRoot.slice(0, -1);\n      }\n    } else {\n      // If sourcemaps don't exist, set prefixes to undefined and break.\n      if (sourceMaps) {\n        for (let map of sourceMaps) {\n          if (map.sourceMapContents === undefined || map.sourceMapContents === \"\") {\n            this._sourcemapCommonPrefix = undefined;\n            this._sourcemapMapDifference = undefined;\n            return;\n          }\n        }\n      } else {\n        this._sourcemapCommonPrefix = undefined;\n        this._sourcemapMapDifference = undefined;\n        return;\n      }\n\n      // Extract common prefix and map difference\n      let originalSourcePaths = [];\n      let mapPaths = [];\n      for (let map of sourceMaps) {\n        invariant(map.sourceMapContents); // Checked above.\n        let parsed = JSON.parse(map.sourceMapContents);\n        // Two formats for sourcemaps exist.\n        if (\"sections\" in parsed) {\n          for (let section of parsed.sections) {\n            for (let source of section.map.sources) {\n              originalSourcePaths.push(this._getAbsoluteSourcePath(map.filePath, source));\n            }\n          }\n        } else {\n          for (let source of parsed.sources) {\n            originalSourcePaths.push(this._getAbsoluteSourcePath(map.filePath, source));\n          }\n        }\n        mapPaths.push(this._stripEmptyStringBookends(map.filePath.split(\"/\")));\n      }\n\n      let originalSourceCommonPrefix = this._findCommonPrefix(originalSourcePaths);\n      let originalSourceCPElements = this._stripEmptyStringBookends(originalSourceCommonPrefix.split(\"/\"));\n      let mapCommonPrefix = this._findCommonPrefix(mapPaths);\n      let mapCPElements = this._stripEmptyStringBookends(mapCommonPrefix.split(\"/\"));\n\n      this._sourcemapCommonPrefix = this._findCommonPrefix([originalSourceCPElements, mapCPElements]);\n      this._sourcemapMapDifference = this._findMapDifference(this._sourcemapCommonPrefix, mapCommonPrefix);\n    }\n  }\n\n  // Prefixes used to translate between relative paths stored in AST nodes and absolute paths given to IDE.\n  _sourcemapCommonPrefix: void | string; // For paths relative to map location. (Used in Babel format)\n  _sourcemapMapDifference: void | string; // For paths relative to map location. (Used in Babel format)\n  _buckRoot: void | string; // For paths relative to directory root. (Used in Buck format)\n\n  /**\n   * Assumes that input file and sourcemap are in the same directory.\n   * Assumes pathToInput is an absolute path and pathToSource is relative.\n   * Uses pathToSource to find absolute path of original source file.\n   */\n  _getAbsoluteSourcePath(pathToInput: string, pathToSource: string): Array<string> {\n    // pathToInput is an absolute path to the file being prepacked.\n    let fullPath = this._stripEmptyStringBookends(pathToInput.split(\"/\"));\n    // Remove last entry because it is the filename, while we want the parent directory of the input file.\n    fullPath.pop();\n\n    // Traverse the path to the source file.\n    let steps = pathToSource.split(\"/\");\n    for (let step of steps) {\n      switch (step) {\n        case \".\":\n          break;\n        case \"..\":\n          fullPath.pop();\n          break;\n        default:\n          fullPath.push(step);\n          break;\n      }\n    }\n    return fullPath;\n  }\n\n  /**\n   * Finds the longest possible prefix common to all input paths.\n   * Input paths must be absolute.\n   * Input is nested array because each path must be separated into elements.\n   */\n  _findCommonPrefix(paths: Array<Array<string>>): string {\n    // Find the point at which the paths diverge.\n    let divergenceIndex = 0;\n    let allPathsMatch = true;\n    let maxDivergenceIndex = Math.max(...paths.map(path => path.length));\n\n    while (allPathsMatch && divergenceIndex < maxDivergenceIndex) {\n      let entry = paths[0][divergenceIndex]; // Arbitrary choice of 0th path, since we're checking if all entires match.\n      for (let path of paths) {\n        if (path[divergenceIndex] !== entry) {\n          allPathsMatch = false;\n          break;\n        }\n      }\n      if (allPathsMatch) divergenceIndex += 1;\n    }\n    // Edge case: if there's only one path, it will match itself, including the filename at the end.\n    // For 2+ paths, even if they all share a prefix, the filenames will not match, so this is not needed.\n    if (paths.length === 1) divergenceIndex -= 1;\n\n    // Concatenate prefix into string that's bookended by slashes for use as an absolute path prefix.\n    return `/${paths[0].slice(0, divergenceIndex).join(\"/\")}/`;\n  }\n\n  /**\n   * Finds the path that must be followed to arrive at the directory of the\n   * common prefix from the sourcemap.\n   */\n  _findMapDifference(commonPrefix: string, mapPrefix: string): string {\n    // Find difference in path between the map's location and the common prefix.\n    let mapPrefixUniqueElements = this._stripEmptyStringBookends(mapPrefix.replace(commonPrefix, \"\").split(\"/\"));\n    let mapDifference = \"\";\n    for (let i = 0; i < mapPrefixUniqueElements.length; i++) {\n      mapDifference = mapDifference.concat(\"../\");\n    }\n    return mapDifference;\n  }\n\n  /**\n   *  Takes in [\"\", \"foo\", \"bar\", \"\"] and returns [\"foo\", \"bar\"]\n   */\n  _stripEmptyStringBookends(path: Array<string>): Array<string> {\n    if (path[0] === \"\") path.shift();\n    if (path[path.length - 1] === \"\") path.pop();\n    return path;\n  }\n\n  /**\n   * Used by DebugAdapter to convert relative paths (used internally in debugging/Prepack engine)\n   * into absolute paths (used by debugging UI/IDE).\n   */\n  relativeToAbsolute(path: string): string {\n    let absolute;\n    if (this._buckRoot !== undefined) {\n      let dirRoot = this._buckRoot;\n      if (\n        // If the \"relative\" path is actually absolute, then don't prepend anything.\n        this._stripEmptyStringBookends(path.split(\"/\"))[0] ===\n        this._stripEmptyStringBookends(this._buckRoot.split(\"/\"))[0]\n      ) {\n        absolute = path;\n      } else {\n        let separator = path[0] === \"/\" ? \"\" : \"/\";\n        absolute = dirRoot + separator + path;\n      }\n    } else {\n      if (this._sourcemapCommonPrefix !== undefined && this._sourcemapMapDifference !== undefined) {\n        absolute = path.replace(this._sourcemapMapDifference, \"\");\n        invariant(this._sourcemapCommonPrefix !== undefined);\n        absolute = this._sourcemapCommonPrefix + absolute;\n      } else {\n        absolute = path;\n      }\n    }\n    return absolute;\n  }\n\n  /**\n   * Used by DebugAdapter to convert absolute paths (used by debugging UI/IDE)\n   * into relative paths (used internally in debugging/Prepack engine).\n   */\n  absoluteToRelative(path: string): string {\n    let relative;\n    if (this._buckRoot !== undefined) {\n      relative = path.replace(this._buckRoot, \"\");\n    } else {\n      if (this._sourcemapCommonPrefix !== undefined && this._sourcemapMapDifference !== undefined) {\n        relative = path.replace(this._sourcemapCommonPrefix, \"\");\n        invariant(this._sourcemapMapDifference !== undefined);\n        relative = this._sourcemapMapDifference + relative;\n      } else {\n        relative = path;\n      }\n    }\n    return relative;\n  }\n}\n"]}