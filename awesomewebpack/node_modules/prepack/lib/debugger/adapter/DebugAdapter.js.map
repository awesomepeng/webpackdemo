{"version":3,"sources":["../../../src/debugger/adapter/DebugAdapter.js"],"names":["DebugProtocol","PrepackDebugSession","constructor","setDebuggerLinesStartAt1","setDebuggerColumnsStartAt1","_generateDebugFilePath","direction","time","Date","now","filePath","_registerMessageCallbacks","_ensureAdapterChannelCreated","_adapterChannel","undefined","localCopyAdapterChannel","registerChannelEvent","STOPPED_RESPONSE","response","result","kind","message","reason","line","column","sendEvent","PREPACK_THREAD_ID","STEPINTO_RESPONSE","initializeRequest","args","_clientID","clientID","body","supportsConfigurationDoneRequest","sendResponse","configurationDoneRequest","CLI_CLIENTID","run","DEFAULT_REQUEST_ID","runResponse","launchRequest","inFilePath","outFilePath","adapterChannel","separatedSourceFiles","sourceFile","trim","split","launchArgs","sourceFiles","prepackRuntime","prepackArguments","debugInFilePath","debugOutFilePath","outputCallback","data","outputEvent","toString","exitCallback","process","exit","launch","request_seq","dbgResponse","continueRequest","setBreakPointsRequest","source","path","breakpoints","breakpointInfos","breakpoint","breakpointInfo","requestID","push","setBreakpoints","verified","stackTraceRequest","getStackFrames","frameInfos","stackframes","frames","frameInfo","fileName","frame","id","name","functionName","stackFrames","threadsRequest","thread","threads","scopesRequest","getScopes","frameId","scopeInfos","scopes","scopeInfo","scope","variablesReference","expensive","variablesRequest","getVariables","variableInfos","variables","varInfo","variable","value","stepInRequest","stepInto","nextRequest","stepOver","stepOutRequest","stepOut","evaluateRequest","evaluate","expression","evalResult","displayValue","type","callingRequest"],"mappings":"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","file":"DebugAdapter.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { DebugSession, InitializedEvent, OutputEvent, TerminatedEvent, StoppedEvent } from \"vscode-debugadapter\";\nimport * as DebugProtocol from \"vscode-debugprotocol\";\nimport { AdapterChannel } from \"./channel/AdapterChannel.js\";\nimport invariant from \"./../common/invariant.js\";\nimport { DebugMessage } from \"./../common/channel/DebugMessage.js\";\nimport type {\n  Breakpoint,\n  DebuggerResponse,\n  LaunchRequestArguments,\n  PrepackLaunchArguments,\n} from \"./../common/types.js\";\nimport { DebuggerConstants } from \"./../common/DebuggerConstants.js\";\nimport { DebuggerError } from \"./../common/DebuggerError.js\";\n\n/* An implementation of an debugger adapter adhering to the VSCode Debug protocol\n * The adapter is responsible for communication between the UI and Prepack\n*/\nclass PrepackDebugSession extends DebugSession {\n  /**\n   * Creates a new debug adapter that is used for one debug session.\n   * We configure the default implementation of a debug adapter here.\n   */\n  constructor() {\n    super();\n    this.setDebuggerLinesStartAt1(true);\n    this.setDebuggerColumnsStartAt1(true);\n  }\n  _clientID: void | string;\n  _adapterChannel: void | AdapterChannel;\n\n  _generateDebugFilePath(direction: \"in\" | \"out\") {\n    let time = Date.now();\n    let filePath = \"/tmp/\";\n    if (direction === \"in\") {\n      filePath += `prepack-debug-engine2adapter-${time}.txt`;\n    } else {\n      filePath += `prepack-debug-adapter2engine-${time}.txt`;\n    }\n    return filePath;\n  }\n\n  _registerMessageCallbacks() {\n    this._ensureAdapterChannelCreated(\"registerMessageCallbacks\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    // Create local copy to ensure external functions don't modify the adapterChannel, satisfy flow.\n    let localCopyAdapterChannel = this._adapterChannel;\n    localCopyAdapterChannel.registerChannelEvent(DebugMessage.STOPPED_RESPONSE, (response: DebuggerResponse) => {\n      let result = response.result;\n      invariant(result.kind === \"stopped\");\n      let message = `${result.reason}: ${result.filePath} ${result.line}:${result.column}`;\n      // Append message if there exists one (for Prepack errors)\n      if (result.message !== undefined) {\n        message += `. ${result.message}`;\n      }\n      this.sendEvent(new StoppedEvent(message, DebuggerConstants.PREPACK_THREAD_ID));\n    });\n    localCopyAdapterChannel.registerChannelEvent(DebugMessage.STEPINTO_RESPONSE, (response: DebuggerResponse) => {\n      let result = response.result;\n      invariant(result.kind === \"stepInto\");\n      this.sendEvent(\n        new StoppedEvent(\n          \"Stepped into \" + `${result.filePath} ${result.line}:${result.column}`,\n          DebuggerConstants.PREPACK_THREAD_ID\n        )\n      );\n    });\n  }\n\n  /**\n   * The 'initialize' request is the first request called by the UI\n   * to interrogate the features the debug adapter provides.\n   */\n  // Override\n  initializeRequest(response: DebugProtocol.InitializeResponse, args: DebugProtocol.InitializeRequestArguments): void {\n    this._clientID = args.clientID;\n    response.body = response.body || {};\n    response.body.supportsConfigurationDoneRequest = true;\n    // Respond back to the UI with the configurations. Will add more configurations gradually as needed.\n    // Adapter can respond immediately here because no message is sent to Prepack\n    this.sendResponse(response);\n  }\n\n  // Override\n  configurationDoneRequest(\n    response: DebugProtocol.ConfigurationDoneResponse,\n    args: DebugProtocol.ConfigurationDoneArguments\n  ): void {\n    // initial handshake with UI is complete\n    if (this._clientID !== DebuggerConstants.CLI_CLIENTID) {\n      this._ensureAdapterChannelCreated(\"configurationDoneRequest\");\n      invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n      // for all ui except the CLI, autosend the first run request\n      this._adapterChannel.run(DebuggerConstants.DEFAULT_REQUEST_ID, (runResponse: DebuggerResponse) => {});\n    }\n    this.sendResponse(response);\n  }\n\n  // Override\n  launchRequest(response: DebugProtocol.LaunchResponse, args: LaunchRequestArguments): void {\n    let inFilePath = this._generateDebugFilePath(\"in\");\n    let outFilePath = this._generateDebugFilePath(\"out\");\n    // Set up the communication channel to the debugger.\n    let adapterChannel = new AdapterChannel(inFilePath, outFilePath);\n    this._adapterChannel = adapterChannel;\n    this._registerMessageCallbacks();\n    let separatedSourceFiles = args.sourceFile.trim().split(/\\s+/g); // Split on all whitespace\n    let launchArgs: PrepackLaunchArguments = {\n      kind: \"launch\",\n      sourceFiles: separatedSourceFiles,\n      prepackRuntime: args.prepackRuntime,\n      prepackArguments: args.prepackArguments,\n      debugInFilePath: inFilePath,\n      debugOutFilePath: outFilePath,\n      outputCallback: (data: Buffer) => {\n        let outputEvent = new OutputEvent(data.toString(), \"stdout\");\n        this.sendEvent(outputEvent);\n      },\n      exitCallback: () => {\n        this.sendEvent(new TerminatedEvent());\n        process.exit();\n      },\n    };\n\n    adapterChannel.launch(response.request_seq, launchArgs, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n\n    // Important: InitializedEvent indicates to the protocol that further requests (e.g. breakpoints, execution control)\n    // are ready to be received. Prepack debugger is not ready to receive these requests until the Adapter Channel\n    // has been created and Prepack has been launched. Thus, the InitializedEvent is sent after Prepack launch and\n    // the creation of the Adapter Channel.\n    this.sendEvent(new InitializedEvent());\n  }\n\n  /**\n   * Request Prepack to continue running when it is stopped\n   */\n  // Override\n  continueRequest(response: DebugProtocol.ContinueResponse, args: DebugProtocol.ContinueArguments): void {\n    // send a Run request to Prepack and try to send the next request\n    this._ensureAdapterChannelCreated(\"continueRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.run(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  setBreakPointsRequest(\n    response: DebugProtocol.SetBreakpointsResponse,\n    args: DebugProtocol.SetBreakpointsArguments\n  ): void {\n    if (!args.source.path || !args.breakpoints) return;\n    let filePath = args.source.path;\n    let breakpointInfos = [];\n    for (const breakpoint of args.breakpoints) {\n      let line = breakpoint.line;\n      let column = 0;\n      if (breakpoint.column) {\n        column = breakpoint.column;\n      }\n      let breakpointInfo: Breakpoint = {\n        kind: \"breakpoint\",\n        requestID: response.request_seq,\n        filePath: filePath,\n        line: line,\n        column: column,\n      };\n      breakpointInfos.push(breakpointInfo);\n    }\n\n    this._ensureAdapterChannelCreated(\"setBreakPointsRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.setBreakpoints(response.request_seq, breakpointInfos, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"breakpoint-add\");\n      let breakpoints: Array<DebugProtocol.Breakpoint> = [];\n      for (const breakpointInfo of result.breakpoints) {\n        let source: DebugProtocol.Source = {\n          path: breakpointInfo.filePath,\n        };\n        let breakpoint: DebugProtocol.Breakpoint = {\n          verified: true,\n          source: source,\n          line: breakpointInfo.line,\n          column: breakpointInfo.column,\n        };\n        breakpoints.push(breakpoint);\n      }\n      response.body = {\n        breakpoints: breakpoints,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  stackTraceRequest(response: DebugProtocol.StackTraceResponse, args: DebugProtocol.StackTraceArguments): void {\n    this._ensureAdapterChannelCreated(\"stackTraceRequest\");\n    invariant(this._adapterChannel !== undefined);\n    this._adapterChannel.getStackFrames(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"stackframe\");\n      let frameInfos = result.stackframes;\n      let frames: Array<DebugProtocol.StackFrame> = [];\n      for (const frameInfo of frameInfos) {\n        let source: DebugProtocol.Source = {\n          path: frameInfo.fileName,\n        };\n        let frame: DebugProtocol.StackFrame = {\n          id: frameInfo.id,\n          name: frameInfo.functionName,\n          source: source,\n          line: frameInfo.line,\n          column: frameInfo.column,\n        };\n        frames.push(frame);\n      }\n      response.body = {\n        stackFrames: frames,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  threadsRequest(response: DebugProtocol.ThreadsResponse): void {\n    // There will only be 1 thread, so respond immediately\n    let thread: DebugProtocol.Thread = {\n      id: DebuggerConstants.PREPACK_THREAD_ID,\n      name: \"main\",\n    };\n    response.body = {\n      threads: [thread],\n    };\n    this.sendResponse(response);\n  }\n\n  // Override\n  scopesRequest(response: DebugProtocol.ScopesResponse, args: DebugProtocol.ScopesArguments): void {\n    this._ensureAdapterChannelCreated(\"scopesRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.getScopes(response.request_seq, args.frameId, (dbgResponse: DebuggerResponse) => {\n      let result = dbgResponse.result;\n      invariant(result.kind === \"scopes\");\n      let scopeInfos = result.scopes;\n      let scopes: Array<DebugProtocol.Scope> = [];\n      for (const scopeInfo of scopeInfos) {\n        let scope: DebugProtocol.Scope = {\n          name: scopeInfo.name,\n          variablesReference: scopeInfo.variablesReference,\n          expensive: scopeInfo.expensive,\n        };\n        scopes.push(scope);\n      }\n      response.body = {\n        scopes: scopes,\n      };\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void {\n    this._ensureAdapterChannelCreated(\"variablesRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.getVariables(\n      response.request_seq,\n      args.variablesReference,\n      (dbgResponse: DebuggerResponse) => {\n        let result = dbgResponse.result;\n        invariant(result.kind === \"variables\");\n        let variableInfos = result.variables;\n        let variables: Array<DebugProtocol.Variable> = [];\n        for (const varInfo of variableInfos) {\n          let variable: DebugProtocol.Variable = {\n            name: varInfo.name,\n            value: varInfo.value,\n            variablesReference: varInfo.variablesReference,\n          };\n          variables.push(variable);\n        }\n        response.body = {\n          variables: variables,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n\n  // Override\n  stepInRequest(response: DebugProtocol.StepInResponse, args: DebugProtocol.StepInArguments): void {\n    this._ensureAdapterChannelCreated(\"stepInRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.stepInto(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  nextRequest(response: DebugProtocol.NextResponse, args: DebugProtocol.NextArguments): void {\n    this._ensureAdapterChannelCreated(\"nextRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.stepOver(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  stepOutRequest(response: DebugProtocol.StepOutResponse, args: DebugProtocol.StepOutArguments): void {\n    this._ensureAdapterChannelCreated(\"stepOutRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.stepOut(response.request_seq, (dbgResponse: DebuggerResponse) => {\n      this.sendResponse(response);\n    });\n  }\n\n  // Override\n  evaluateRequest(response: DebugProtocol.EvaluateResponse, args: DebugProtocol.EvaluateArguments): void {\n    this._ensureAdapterChannelCreated(\"evaluateRequest\");\n    invariant(this._adapterChannel !== undefined, \"Adapter Channel used before it was created, in debugger.\");\n    this._adapterChannel.evaluate(\n      response.request_seq,\n      args.frameId,\n      args.expression,\n      (dbgResponse: DebuggerResponse) => {\n        let evalResult = dbgResponse.result;\n        invariant(evalResult.kind === \"evaluate\");\n        response.body = {\n          result: evalResult.displayValue,\n          type: evalResult.type,\n          variablesReference: evalResult.variablesReference,\n        };\n        this.sendResponse(response);\n      }\n    );\n  }\n\n  _ensureAdapterChannelCreated(callingRequest: string) {\n    // All responses that involve the Adapter Channel should only be invoked\n    // after the channel has been created. If this ordering is perturbed,\n    // there was likely a change in the protocol implementation by Nuclide.\n    if (this._adapterChannel === undefined) {\n      throw new DebuggerError(\n        \"Startup Error\",\n        `Adapter Channel in Debugger is being used before it has been created. Caused by ${callingRequest}.`\n      );\n    }\n  }\n}\n\nDebugSession.run(PrepackDebugSession);\n"]}