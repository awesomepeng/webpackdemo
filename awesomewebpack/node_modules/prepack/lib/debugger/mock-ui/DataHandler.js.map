{"version":3,"sources":["../../../src/debugger/mock-ui/DataHandler.js"],"names":["TWO_CRLF","DataHandler","constructor","_rawData","Buffer","_contentLength","handleData","data","messageProcessor","concat","length","byteLength","message","toString","slice","idx","indexOf","header","lines","split","i","pair","parseInt","isNaN"],"mappings":";;;;;AAAA;;;;;;;;;AASA;;AAEA;AACA,MAAMA,WAAW,UAAjB;;AAEO,MAAMC,WAAN,CAAkB;AACvBC,gBAAc;AACZ,SAAKC,QAAL,GAAgB,IAAIC,MAAJ,CAAW,CAAX,CAAhB;AACA,SAAKC,cAAL,GAAsB,CAAC,CAAvB;AACD;;;AAIDC,aAAWC,IAAX,EAAyBC,gBAAzB,EAA4E;AAC1E,SAAKL,QAAL,GAAgBC,OAAOK,MAAP,CAAc,CAAC,KAAKN,QAAN,EAAgBI,IAAhB,CAAd,CAAhB;AACA;AACA,WAAO,KAAKJ,QAAL,CAAcO,MAAd,GAAuB,CAA9B,EAAiC;AAC/B;AACA,UAAI,KAAKL,cAAL,IAAuB,CAA3B,EAA8B;AAC5B;AACA,YAAI,KAAKF,QAAL,CAAcQ,UAAd,IAA4B,KAAKN,cAArC,EAAqD;AACnD;AACA,cAAIO,UAAU,KAAKT,QAAL,CAAcU,QAAd,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,KAAKR,cAAvC,CAAd;AACA;AACA,eAAKF,QAAL,GAAgB,KAAKA,QAAL,CAAcW,KAAd,CAAoB,KAAKT,cAAzB,CAAhB;AACA;AACA,eAAKA,cAAL,GAAsB,CAAC,CAAvB;AACA;AACAG,2BAAiBI,OAAjB;AACA,mBATmD,CASzC;AACX;AACF,OAbD,MAaO;AACL;AACA,YAAIG,MAAM,KAAKZ,QAAL,CAAca,OAAd,CAAsBhB,QAAtB,CAAV;AACA,YAAIe,QAAQ,CAAC,CAAb,EAAgB;AACd,cAAIE,SAAS,KAAKd,QAAL,CAAcU,QAAd,CAAuB,MAAvB,EAA+B,CAA/B,EAAkCE,GAAlC,CAAb;AACA,cAAIG,QAAQD,OAAOE,KAAP,CAAa,MAAb,CAAZ;AACA,eAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,MAAMR,MAA1B,EAAkCU,GAAlC,EAAuC;AACrC,gBAAIC,OAAOH,MAAME,CAAN,EAASD,KAAT,CAAe,KAAf,CAAX;AACA,gBAAIE,KAAK,CAAL,MAAY,gBAAhB,EAAkC;AAChC,mBAAKhB,cAAL,GAAsBiB,SAASD,KAAK,CAAL,CAAT,EAAkB,EAAlB,CAAtB;AACA;AACA,kBAAIE,MAAM,KAAKlB,cAAX,CAAJ,EAAgC,KAAKA,cAAL,GAAsB,CAAC,CAAvB;AACjC;AACF;AACD,eAAKF,QAAL,GAAgB,KAAKA,QAAL,CAAcW,KAAd,CAAoBC,MAAMf,SAASU,MAAnC,CAAhB;AACA;AACD;AACD;AACD;AACD;AACD;AACF;AA/CsB;QAAZT,W,GAAAA,W","file":"DataHandler.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict */\n\n//separator for messages according to the protocol\nconst TWO_CRLF = \"\\r\\n\\r\\n\";\n\nexport class DataHandler {\n  constructor() {\n    this._rawData = new Buffer(0);\n    this._contentLength = -1;\n  }\n  _rawData: Buffer;\n  _contentLength: number;\n\n  handleData(data: Buffer, messageProcessor: (message: string) => void): void {\n    this._rawData = Buffer.concat([this._rawData, data]);\n    // the following code parses a message according to the protocol.\n    while (this._rawData.length > 0) {\n      // if we know what length we are expecting\n      if (this._contentLength >= 0) {\n        // we have enough data to check for the expected message\n        if (this._rawData.byteLength >= this._contentLength) {\n          // first get the expected message\n          let message = this._rawData.toString(\"utf8\", 0, this._contentLength);\n          // reduce the buffer by the message we got\n          this._rawData = this._rawData.slice(this._contentLength);\n          // reset the content length to ensure it is extracted for the next message\n          this._contentLength = -1;\n          // process the message\n          messageProcessor(message);\n          continue; // there may be more complete messages to process\n        }\n      } else {\n        // if we don't know the length to expect, we need to extract it first\n        let idx = this._rawData.indexOf(TWO_CRLF);\n        if (idx !== -1) {\n          let header = this._rawData.toString(\"utf8\", 0, idx);\n          let lines = header.split(\"\\r\\n\");\n          for (let i = 0; i < lines.length; i++) {\n            let pair = lines[i].split(/: +/);\n            if (pair[0] === \"Content-Length\") {\n              this._contentLength = parseInt(pair[1], 10);\n              // reset the contentlength if it is invalid\n              if (isNaN(this._contentLength)) this._contentLength = -1;\n            }\n          }\n          this._rawData = this._rawData.slice(idx + TWO_CRLF.length);\n          continue;\n        }\n        // if we don't find the length we fall through and break\n      }\n      break;\n    }\n  }\n}\n"]}