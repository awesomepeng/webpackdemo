{"version":3,"sources":["../src/realm.js"],"names":["construct_empty_effects","t","effects_uid","Effects","constructor","result","generator","bindings","propertyBindings","createdObjects","_result","modifiedBindings","modifiedProperties","canBeApplied","_id","effects","undefined","completion","Tracer","beginEvaluateForEffects","state","endEvaluateForEffects","detourCall","F","thisArgument","argumentsList","newTarget","performCall","beforeCall","afterCall","beginOptimizingFunction","optimizedFunctionId","functionValue","endOptimizingFunction","ExecutionContext","setCaller","context","caller","setFunction","isStrict","$Strict","function","setLocation","loc","setRealm","realm","setReadOnly","value","oldReadOnly","isReadOnly","variableEnvironment","environmentRecord","lexicalEnvironment","suspend","resume","intrinsics","c","empty","pathConditions","Map","Set","Realm","opts","statistics","contextStack","MOBILE_JSC_VERSION","suppressDiagnostics","objectCount","symbolCount","functionBodyUniqueTagSeed","nextGeneratorId","useAbstractInterpretation","serialize","residual","Array","isArray","check","ignoreLeakLogic","isInPureTryStatement","mathRandomSeed","mathRandomGenerator","strictlyMonotonicDateNow","abstractValueImpliesMax","abstractValueImpliesCounter","inSimplificationPath","timeout","timeoutCounter","timeoutCounterThreshold","start","Date","now","compatibility","maxStackDepth","invariantLevel","invariantMode","emitConcreteModel","$TemplateMap","preludeGenerator","debugNames","uniqueSuffix","setupTrackedPropertyAccessors","trackedPropertyNames","tracers","$GlobalObject","evaluators","Object","create","partialEvaluators","$GlobalEnv","derivedIds","temporalEntryArgToEntries","temporalEntryCounter","instantRender","enabled","react","abstractHints","WeakMap","activeReconciler","arrayHints","classComponentMetadata","currentOwner","defaultPropsHelper","emptyArray","emptyObject","reactEnabled","hoistableFunctions","hoistableReactElements","noopFunction","optimizedNestedClosuresToWrite","optimizeNestedFunctions","reactOptimizeNestedFunctions","output","reactOutput","propsWithNoPartialKeyOrRef","WeakSet","reactElements","reactElementStringTypeReferences","reactProps","symbols","usedReactElementKeys","verbose","reactVerbose","alreadyDescribedLocations","stripFlow","fbLibraries","other","reactDom","reactDomServer","reactNative","reactRelay","errorHandler","globalSymbolRegistry","activeLexicalEnvironments","_abstractValuesDefined","_checkedObjectIds","isCompatibleWith","getGlobalLetBinding","key","globrec","dclrec","$DeclarativeRecord","HasBinding","GetBindingValue","e","readOnlyValue","forEach","ctx","testTimeout","total","error","currentLocation","handleError","hasRunningContext","length","getRunningContext","clearBlockBindings","b","keys","mightHaveBeenCaptured","name","delete","clearBlockBindingsFromCompletion","alternateEffects","consequentEffects","savedEffects","alternate","consequent","onDestroyScope","has","savedCompletion","destroy","pushContext","push","markVisibleLocalBindingsAsPotentiallyCaptured","lexEnv","envRec","binding","parent","clearFunctionBindings","funcVal","environment","$FunctionObject","clearFunctionBindingsFromCompletion","popContext","pop","wrapInGlobalEnv","callback","assignToGlobal","deleteGlobalBinding","DeleteBinding","neverCheckProperty","object","P","startsWith","intrinsicName","_getCheckedBindings","globalObject","properties","get","checkedBindingsObject","descriptor","markPropertyAsChecked","objectId","set","size","id","checkedBindings","$Set","true","hasBindingBeenChecked","mightNotBeTrue","evaluatePure","f","reportSideEffectFunc","saved_createdObjectsTrackedForLeaks","createdObjectsTrackedForLeaks","saved_reportSideEffectCallback","reportSideEffectCallback","args","isInPureScope","evaluateWithoutLeakLogic","evaluateWithPossibleThrowCompletion","thrownTypes","thrownValues","diag","evaluateNodeForEffects","ast","strictCode","env","generatorName","evaluateForEffects","evaluateCompletionDeref","evaluateForEffectsInGlobalEnv","func","withEffectsAppliedInGlobalEnv","applyEffects","undoBindings","restoreProperties","evaluateNodeForEffectsInGlobalEnv","node","partiallyEvaluateNodeForEffects","nodeAst","nodeIO","partialEval","partiallyEvaluateCompletionDeref","savedBindings","savedProperties","getAndResetModifiedMaps","saved_generator","saved_createdObjects","saved_completion","t1","GetValue","incorporateSavedCompletion","subsequentEffects","getCapturedEffects","stopEffectCaptureAndUndoEffects","updatePossiblyNormalCompletionWithSubsequentEffects","astGenerator","astBindings","astProperties","astCreatedObjects","t2","evaluateWithUndo","defaultValue","oldErrorHandler","d","severity","evaluateWithUndoForDiagnostic","savedHandler","diagnostic","resultVal","composeWithSavedCompletion","evaluateForFixpointEffects","iteration","test","effects1","redoBindings","effects2","containsEffects","e2","_applyPropertiesToNewlyCreatedObjects","_emitPropertAssignments","_emitLocalAssignments","cond","deriveAbstract","types","values","n","skipInvariant","widenEffects","evaluateWithAbstractConditional","condValue","consequentEffectsFunc","alternateEffectsFunc","withCondition","withInverseCondition","joinedEffects","joinForkOrChoose","newlyCreatedObjects","desc","propertyBinding","m","gen","tvalFor","map","val","_buildNode","tval","phiNode","emitStatement","v","buildNode","expressionStatement","assignmentExpression","pbindings","isSelfReferential","pathNode","refuseSerialization","o","mightHaveBeenDeleted","inTest","binaryExpression","stringLiteral","addEmpty","conditionalExpression","logicalExpression","path","mightBeUndefined","keyKey","lh","identifier","r","emptyTest","undefinedTest","unaryExpression","guard","deleteIt","ifStatement","p","composeEffects","priorEffects","composeGenerators","ob","a","add","updateAbruptCompletions","wrapSavedCompletion","captureEffects","savedPathConditions","concat","composePossiblyNormalCompletions","pushPathConditionsLeadingToNormalCompletion","allPathsAreAbrupt","pushInverseAndRefine","joinCondition","pushAndRefine","allPathsAreNormal","alternatePC","getNormalPathConditionFor","disjunct","createFromLogicalOp","consequentPC","inverse","createFromUnaryOp","jc","ijc","incorporatePriorSavedCompletion","priorCompletion","leadingComment","appendGenerator","realmModifiedBindings","realmModifiedProperties","realmCreatedObjects","outputToConsole","method","emitConsoleLog","console","getString","res","next","shift","nextString","ToString","recordModifiedBinding","isDefinedInsidePureFn","root","expressionLocation","hasLeaked","previousHasLeaked","previousValue","callReportObjectGetOwnProperties","reportObjectGetOwnProperties","callReportPropertyAccess","reportPropertyAccess","recordModifiedProperty","isNewObject","recordNewObject","entry","setModifiedMaps","rebuildObjectProperty","propertyValue","kind","absVal","find","isIntrinsic","isValidIdentifier","memberExpression","rebuildNestedProperties","abstractValue","isTop","template","getTemplate","intrinsicNameGenerated","ThrowIfMightHaveBeenDeleted","reportIntrospectionError","createExecutionContext","nextContextLocation","setNextExecutionContextLocation","message","createErrorThrowCompletion","type","__IntrospectionError","realmGenerator","evaluateForEffectsWithPriorEffects","priorEffect","callStack","Error","stack","_SafeGetDataPropertyValue","debuggerInstance","shouldStopForSeverity","handlePrepackError","msg","errorCode","location","loc_start","loc_end","end","line","column","log","warn","saveNameString","nameString","isNameStringUnique","getTemporalBuildNodeEntryFromDerivedValue","temporalBuildNodeEntry","$Realm","getTemporalGeneratorEntriesReferencingArg","arg","saveTemporalGeneratorEntryArgs","temporalEntries"],"mappings":";;;;;;QA2MgBA,uB,GAAAA,uB;;AAvLhB;;AACA;;AAOA;;AAiBA;;AAQA;;AACA;;AASA;;;;AACA;;;;AACA;;AACA;;AACA;;AAGA;;IAAYC,C;;;;;;AAgBZ,IAAIC,cAAc,CAAlB,C,CAtFA;;;;;;;;;AAwFO,MAAMC,OAAN,CAAc;AACnBC,cACEC,MADF,EAEEC,SAFF,EAGEC,QAHF,EAIEC,gBAJF,EAKEC,cALF,EAME;AACA,SAAKC,OAAL,GAAeL,MAAf;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKK,gBAAL,GAAwBJ,QAAxB;AACA,SAAKK,kBAAL,GAA0BJ,gBAA1B;AACA,SAAKC,cAAL,GAAsBA,cAAtB;;AAEA,SAAKI,YAAL,GAAoB,IAApB;AACA,SAAKC,GAAL,GAAWZ,aAAX;AACA,QAAIG,OAAOU,OAAP,KAAmBC,SAAvB,EAAkCX,OAAOU,OAAP,GAAiB,IAAjB,CATlC,CASyD;AAC1D;;AAGD,MAAIV,MAAJ,GAAyB;AACvB,WAAO,KAAKK,OAAZ;AACD;AACD,MAAIL,MAAJ,CAAWY,UAAX,EAAyC;AACvC,QAAIA,WAAWF,OAAX,KAAuBC,SAA3B,EAAsCC,WAAWF,OAAX,GAAqB,IAArB,CADC,CAC0B;AACjE,SAAKL,OAAL,GAAeO,UAAf;AACD;;AA1BkB;;QAARd,O,GAAAA,O;AAoCN,MAAMe,MAAN,CAAa;AAClBC,0BAAwBC,KAAxB,EAA0C,CAAE;AAC5CC,wBAAsBD,KAAtB,EAAkCL,OAAlC,EAAiE,CAAE;AACnEO,aACEC,CADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,SAJF,EAKEC,WALF,EAMgB,CAAE;AAClBC,aACEL,CADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,SAJF,EAKQ,CAAE;AACVG,YACEN,CADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,SAJF,EAKErB,MALF,EAMQ,CAAE;AACVyB,0BAAwBC,mBAAxB,EAAqDC,aAArD,EAAyF,CAAE;AAC3FC,wBAAsBF,mBAAtB,EAAyD,CAAE;AAxBzC;;QAAPb,M,GAAAA,M;AA2BN,MAAMgB,gBAAN,CAAuB;;AAW5BC,YAAUC,OAAV,EAA2C;AACzC,SAAKC,MAAL,GAAcD,OAAd;AACD;;AAEDE,cAAYf,CAAZ,EAA2C;AACzC,QAAIA,iDAAJ,EAAgD,KAAKgB,QAAL,GAAgBhB,EAAEiB,OAAlB;AAChD,SAAKC,QAAL,GAAgBlB,CAAhB;AACD;;AAEDmB,cAAYC,GAAZ,EAAuD;AACrD,QAAI,CAACA,GAAL,EAAU;AACV,SAAKA,GAAL,GAAWA,GAAX;AACD;;AAEDC,WAASC,KAAT,EAA6B;AAC3B,SAAKA,KAAL,GAAaA,KAAb;AACD;;AAED;;;;;AAKAC,cAAYC,KAAZ,EAAqC;AACnC,QAAIC,cAAc,KAAKC,UAAvB;AACA,QAAI,KAAKC,mBAAT,EAA8B,KAAKA,mBAAL,CAAyBC,iBAAzB,CAA2CF,UAA3C,GAAwDF,KAAxD;AAC9B,QAAI,KAAKK,kBAAT,EAA6B,KAAKA,kBAAL,CAAwBD,iBAAxB,CAA0CF,UAA1C,GAAuDF,KAAvD;AAC7B,SAAKE,UAAL,GAAkBF,KAAlB;AACA,WAAOC,WAAP;AACD;;AAEDK,YAAgB;AACd;AACD;;AAEDC,WAAgB;AACd;AACA,WAAO,KAAKT,KAAL,CAAWU,UAAX,CAAsBvC,SAA7B;AACD;AAjD2B;;QAAjBkB,gB,GAAAA,gB;AAoDN,SAASlC,uBAAT,CACL6C,KADK,EAELW,IAAgB,wCAA2BX,MAAMU,UAAN,CAAiBE,KAA5C,EAAmDzC,SAAnD,CAFX,EAGI;AACT;AACA;AACA;AACA,SAAO,IAAIb,OAAJ,CACLqD,CADK,EAEL,yBAAcX,KAAd,EAAqB,yBAArB,EAAgDA,MAAMa,cAAtD,CAFK,EAGL,IAAIC,GAAJ,EAHK,EAIL,IAAIA,GAAJ,EAJK,EAKL,IAAIC,GAAJ,EALK,CAAP;AAOD;;AAEM,MAAMC,KAAN,CAAY;AACjBzD,cAAY0D,IAAZ,EAAgCC,UAAhC,EAA6D;AAAA,SA8I7DC,YA9I6D,GA8IrB,EA9IqB;AAAA,SAqO7DC,kBArO6D,GAqOxC,gBArOwC;AAAA,SAwO7DC,mBAxO6D,GAwOvC,KAxOuC;AAAA,SAyO7DC,WAzO6D,GAyO/C,CAzO+C;AAAA,SA0O7DC,WA1O6D,GA0O/C,eA1O+C;AAAA,SA8O7DC,yBA9O6D,GA8OjC,CA9OiC;AAAA,SAoP7DC,eApP6D,GAoPnC,CApPmC;;AAC3D,SAAKP,UAAL,GAAkBA,UAAlB;AACA,SAAKd,UAAL,GAAkB,KAAlB;AACA,SAAKsB,yBAAL,GAAiCT,KAAKU,SAAL,KAAmB,IAAnB,IAA2BV,KAAKW,QAAL,KAAkB,IAA7C,IAAqDC,MAAMC,OAAN,CAAcb,KAAKc,KAAnB,CAAtF;AACA,SAAKC,eAAL,GAAuB,KAAvB;AACA,SAAKC,oBAAL,GAA4B,KAA5B;AACA,QAAIhB,KAAKiB,cAAL,KAAwB/D,SAA5B,EAAuC;AACrC,WAAKgE,mBAAL,GAA2B,0BAAWlB,KAAKiB,cAAhB,CAA3B;AACD;AACD,SAAKE,wBAAL,GAAgC,CAAC,CAACnB,KAAKmB,wBAAvC;;AAEA;AACA,SAAKC,uBAAL,GAA+BpB,KAAKoB,uBAAL,KAAiClE,SAAjC,GAA6C8C,KAAKoB,uBAAlD,GAA4E,CAA3G;AACA,SAAKC,2BAAL,GAAmC,CAAnC;AACA,SAAKC,oBAAL,GAA4B,KAA5B;;AAEA,SAAKC,OAAL,GAAevB,KAAKuB,OAApB;AACA,QAAI,KAAKA,OAAL,KAAiBrE,SAArB,EAAgC;AAC9B;AACA;AACA,WAAKsE,cAAL,GAAsB,KAAKC,uBAAL,GAA+B,IAArD;AACD;;AAED,SAAKC,KAAL,GAAaC,KAAKC,GAAL,EAAb;AACA,SAAKC,aAAL,GAAqB7B,KAAK6B,aAAL,KAAuB3E,SAAvB,GAAmC8C,KAAK6B,aAAxC,GAAwD,SAA7E;AACA,SAAKC,aAAL,GAAqB9B,KAAK8B,aAAL,IAAsB,GAA3C;AACA,SAAKC,cAAL,GAAsB/B,KAAK+B,cAAL,IAAuB,CAA7C;AACA,SAAKC,aAAL,GAAqBhC,KAAKgC,aAAL,IAAsB,OAA3C;AACA,SAAKC,iBAAL,GAAyB,CAAC,CAACjC,KAAKiC,iBAAhC;;AAEA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKtC,cAAL,GAAsB,EAAtB;;AAEA,QAAI,KAAKa,yBAAT,EAAoC;AAClC,WAAK0B,gBAAL,GAAwB,gCAAqBnC,KAAKoC,UAA1B,EAAsCpC,KAAKqC,YAA3C,CAAxB;AACA,yBAAYC,6BAAZ,CAA0C,mBAAYC,oBAAtD;AACA,yBAAYD,6BAAZ,CAA0C,2BAAoBC,oBAA9D;AACA,yBAAYD,6BAAZ,CAA0C,kBAAWC,oBAArD;AACD;;AAED,SAAKC,OAAL,GAAe,EAAf;;AAEA;AACA,SAAK/C,UAAL,GAAmB,EAAnB;AACA,SAAKgD,aAAL,GAAuB,EAAvB;AACA,SAAKC,UAAL,GAAmBC,OAAOC,MAAP,CAAc,IAAd,CAAnB;AACA,SAAKC,iBAAL,GAA0BF,OAAOC,MAAP,CAAc,IAAd,CAA1B;AACA,SAAKE,UAAL,GAAoB5F,SAApB;;AAEA,SAAK6F,UAAL,GAAkB,IAAIlD,GAAJ,EAAlB;AACA,SAAKmD,yBAAL,GAAiC,IAAInD,GAAJ,EAAjC;AACA,SAAKoD,oBAAL,GAA4B,CAA5B;;AAEA,SAAKC,aAAL,GAAqB;AACnBC,eAASnD,KAAKkD,aAAL,IAAsB;AADZ,KAArB;;AAIA,SAAKE,KAAL,GAAa;AACXC,qBAAe,IAAIC,OAAJ,EADJ;AAEXC,wBAAkBrG,SAFP;AAGXsG,kBAAY,IAAIF,OAAJ,EAHD;AAIXG,8BAAwB,IAAI5D,GAAJ,EAJb;AAKX6D,oBAAcxG,SALH;AAMXyG,0BAAoBzG,SANT;AAOX0G,kBAAY1G,SAPD;AAQX2G,mBAAa3G,SARF;AASXiG,eAASnD,KAAK8D,YAAL,IAAqB,KATnB;AAUXC,0BAAoB,IAAIT,OAAJ,EAVT;AAWXU,8BAAwB,IAAIV,OAAJ,EAXb;AAYXW,oBAAc/G,SAZH;AAaXgH,sCAAgC,EAbrB;AAcXC,+BAAyBnE,KAAKoE,4BAAL,IAAqC,KAdnD;AAeXC,cAAQrE,KAAKsE,WAAL,IAAoB,gBAfjB;AAgBXC,kCAA4B,IAAIC,OAAJ,EAhBjB;AAiBXC,qBAAe,IAAInB,OAAJ,EAjBJ;AAkBXoB,wCAAkC,IAAI7E,GAAJ,EAlBvB;AAmBX8E,kBAAY,IAAIH,OAAJ,EAnBD;AAoBXI,eAAS,IAAI/E,GAAJ,EApBE;AAqBXgF,4BAAsB,IAAI/E,GAAJ,EArBX;AAsBXgF,eAAS9E,KAAK+E,YAAL,IAAqB;AAtBnB,KAAb;;AAyBA,SAAKC,yBAAL,GAAiC,IAAI1B,OAAJ,EAAjC;AACA,SAAK2B,SAAL,GAAiBjF,KAAKiF,SAAL,IAAkB,KAAnC;;AAEA,SAAKC,WAAL,GAAmB;AACjBC,aAAO,IAAItF,GAAJ,EADU;AAEjBuD,aAAOlG,SAFU;AAGjBkI,gBAAUlI,SAHO;AAIjBmI,sBAAgBnI,SAJC;AAKjBoI,mBAAapI,SALI;AAMjBqI,kBAAYrI;AANK,KAAnB;;AASA,SAAKsI,YAAL,GAAoBxF,KAAKwF,YAAzB;;AAEA,SAAKC,oBAAL,GAA4B,EAA5B;AACA,SAAKC,yBAAL,GAAiC,IAAI5F,GAAJ,EAAjC;AACA,SAAK6F,sBAAL,GAA8B,IAAI7F,GAAJ,EAA9B,CAlG2D,CAkGlB;AACzC,SAAKsC,UAAL,GAAkBpC,KAAKoC,UAAvB;AACA,SAAKwD,iBAAL,GAAyB,IAAI/F,GAAJ,EAAzB;AACD,GAtGgB,CA8Gc;;;AA2B/B;AACA;;AAkGA;AACA;AACA;;;AAWA;AACAgG,mBAAiBhE,aAAjB,EAAwD;AACtD,WAAOA,kBAAkB,KAAKA,aAA9B;AACD;;AAED;AACA;AACAiE,sBAAoBC,GAApB,EAA+C;AAC7C,QAAIC,UAAU,KAAKlD,UAAL,CAAgBzD,iBAA9B;AACA;AACA,6BAAU2G,uDAAV;AACA,QAAIC,SAASD,QAAQE,kBAArB;;AAEA,QAAI;AACF,aAAOD,OAAOE,UAAP,CAAkBJ,GAAlB,IAAyBE,OAAOG,eAAP,CAAuBL,GAAvB,EAA4B,KAA5B,CAAzB,GAA8D7I,SAArE;AACD,KAFD,CAEE,OAAOmJ,CAAP,EAAU;AACV,UAAIA,+BAAJ,EAA6B,OAAOnJ,SAAP;AAC7B,YAAMmJ,CAAN;AACD;AACF;;AAED;;;;;;;;AAQArH,cAAYsH,aAAZ,EAA6C;AAC3C,QAAIpH,cAAc,KAAKC,UAAvB;AACA,SAAKA,UAAL,GAAkBmH,aAAlB;AACA,SAAKxD,UAAL,CAAgBzD,iBAAhB,CAAkCF,UAAlC,GAA+CmH,aAA/C;AACA,SAAKpG,YAAL,CAAkBqG,OAAlB,CAA0BC,OAAO;AAC/BA,UAAIxH,WAAJ,CAAgBsH,aAAhB;AACD,KAFD;AAGA,WAAOpH,WAAP;AACD;;AAEDuH,gBAAoB;AAClB,QAAIlF,UAAU,KAAKA,OAAnB;AACA,QAAIA,YAAYrE,SAAZ,IAAyB,CAAC,GAAE,KAAKsE,cAArC,EAAqD;AACnD,WAAKA,cAAL,GAAsB,KAAKC,uBAA3B;AACA,UAAIiF,QAAQ/E,KAAKC,GAAL,KAAa,KAAKF,KAA9B;AACA,UAAIgF,QAAQnF,OAAZ,EAAqB;AACnB,YAAIoF,QAAQ,+BACT,6CAA4CpF,OAAQ,EAD3C,EAEV,KAAKqF,eAFK,EAGV,QAHU,EAIV,YAJU,CAAZ;AAMA,aAAKC,WAAL,CAAiBF,KAAjB;AACA,cAAM,uBAAe,WAAf,CAAN;AACD;AACF;AACF;;AAEDG,sBAA6B;AAC3B,WAAO,KAAK5G,YAAL,CAAkB6G,MAAlB,KAA6B,CAApC;AACD;;AAEDC,sBAAsC;AACpC,QAAI1I,UAAU,KAAK4B,YAAL,CAAkB,KAAKA,YAAL,CAAkB6G,MAAlB,GAA2B,CAA7C,CAAd;AACA,6BAAUzI,OAAV,EAAmB,sCAAnB;AACA,WAAOA,OAAP;AACD;;AAED2I,qBAAmBpK,gBAAnB,EAAsDwC,iBAAtD,EAA6G;AAC3G,QAAIxC,qBAAqBK,SAAzB,EAAoC;AACpC,SAAK,IAAIgK,CAAT,IAAcrK,iBAAiBsK,IAAjB,EAAd,EAAuC;AACrC,UAAID,EAAEE,qBAAN,EAA6B;AAC7B,UAAI/H,kBAAkB5C,QAAlB,CAA2ByK,EAAEG,IAA7B,KAAsChI,kBAAkB5C,QAAlB,CAA2ByK,EAAEG,IAA7B,MAAuCH,CAAjF,EAAoFrK,iBAAiByK,MAAjB,CAAwBJ,CAAxB;AACrF;AACF;;AAEDK,mCAAiCpK,UAAjC,EAAyDkC,iBAAzD,EAAgH;AAC9G,QAAIlC,2DAAJ,EAAoD;AAClD,WAAK8J,kBAAL,CAAwB9J,WAAWqK,gBAAX,CAA4B3K,gBAApD,EAAsEwC,iBAAtE;AACA,WAAK4H,kBAAL,CAAwB9J,WAAWsK,iBAAX,CAA6B5K,gBAArD,EAAuEwC,iBAAvE;AACA,UAAIlC,WAAWuK,YAAX,KAA4BxK,SAAhC,EACE,KAAK+J,kBAAL,CAAwB9J,WAAWuK,YAAX,CAAwB7K,gBAAhD,EAAkEwC,iBAAlE;AACF,UAAIlC,WAAWwK,SAAX,mCAAJ,EACE,KAAKJ,gCAAL,CAAsCpK,WAAWwK,SAAjD,EAA4DtI,iBAA5D;AACF,UAAIlC,WAAWyK,UAAX,mCAAJ,EACE,KAAKL,gCAAL,CAAsCpK,WAAWyK,UAAjD,EAA6DvI,iBAA7D;AACH,KATD,MASO,IAAIlC,yDAAJ,EAAkD;AACvD,WAAK8J,kBAAL,CAAwB9J,WAAWqK,gBAAX,CAA4B3K,gBAApD,EAAsEwC,iBAAtE;AACA,WAAK4H,kBAAL,CAAwB9J,WAAWsK,iBAAX,CAA6B5K,gBAArD,EAAuEwC,iBAAvE;AACA,UAAIlC,WAAWwK,SAAX,mCAAJ,EACE,KAAKJ,gCAAL,CAAsCpK,WAAWwK,SAAjD,EAA4DtI,iBAA5D;AACF,UAAIlC,WAAWyK,UAAX,mCAAJ,EACE,KAAKL,gCAAL,CAAsCpK,WAAWyK,UAAjD,EAA6DvI,iBAA7D;AACH;AACF;;AAED;AACA;AACAwI,iBAAevI,kBAAf,EAA6D;AAC3D,6BAAU,KAAKoG,yBAAL,CAA+BoC,GAA/B,CAAmCxI,kBAAnC,CAAV;AACA,QAAIzC,mBAAmB,KAAKA,gBAA5B;AACA,QAAIA,gBAAJ,EAAsB;AACpB;AACA,UAAIwC,oBAAoBC,mBAAmBD,iBAA3C;AACA,UAAIA,sEAAJ,EAA+D;AAC7D,aAAK4H,kBAAL,CAAwBpK,gBAAxB,EAA0CwC,iBAA1C;AACA,YAAI,KAAK0I,eAAL,KAAyB7K,SAA7B,EACE,KAAKqK,gCAAL,CAAsC,KAAKQ,eAA3C,EAA4D1I,iBAA5D;AACH;AACF;;AAED;AACA,SAAKqG,yBAAL,CAA+B4B,MAA/B,CAAsChI,kBAAtC;AACAA,uBAAmB0I,OAAnB;AACD;;AAEDC,cAAY3J,OAAZ,EAA6C;AAC3C,QAAI,KAAK4B,YAAL,CAAkB6G,MAAlB,IAA4B,KAAKjF,aAArC,EAAoD;AAClD,YAAM,uBAAe,8BAAf,CAAN;AACD;AACD,SAAK5B,YAAL,CAAkBgI,IAAlB,CAAuB5J,OAAvB;AACD;;AAED6J,kDAAsD;AACpD,QAAI7J,UAAU,KAAK0I,iBAAL,EAAd;AACA,QAAI1I,QAAQK,QAAR,KAAqBzB,SAAzB,EAAoC;AACpC,QAAIkL,SAAS9J,QAAQgB,kBAArB;AACA,WAAO8I,UAAU,IAAjB,EAAuB;AACrB,UAAIC,SAASD,OAAO/I,iBAApB;AACA,UAAIgJ,2DAAJ,EAAoD;AAClD,YAAI5L,WAAW4L,OAAO5L,QAAtB;AACA,aAAK,IAAI4K,IAAT,IAAiB5K,QAAjB,EAA2B;AACzB,cAAI6L,UAAU7L,SAAS4K,IAAT,CAAd;AACAiB,kBAAQlB,qBAAR,GAAgC,IAAhC;AACD;AACF;AACDgB,eAASA,OAAOG,MAAhB;AACD;AACF;;AAEDC,wBAAsB3L,gBAAtB,EAAyD4L,OAAzD,EAAuF;AACrF,QAAI5L,qBAAqBK,SAAzB,EAAoC;AACpC,SAAK,IAAIgK,CAAT,IAAcrK,iBAAiBsK,IAAjB,EAAd,EAAuC;AACrC,UAAID,EAAEE,qBAAN,EAA6B;AAC7B,UAAIF,EAAEwB,WAAF,sDAAsDxB,EAAEwB,WAAF,CAAcC,eAAd,KAAkCF,OAA5F,EACE5L,iBAAiByK,MAAjB,CAAwBJ,CAAxB;AACH;AACF;;AAED0B,sCAAoCzL,UAApC,EAA4DsL,OAA5D,EAA0F;AACxF,QAAItL,2DAAJ,EAAoD;AAClD,WAAKqL,qBAAL,CAA2BrL,WAAWqK,gBAAX,CAA4B3K,gBAAvD,EAAyE4L,OAAzE;AACA,WAAKD,qBAAL,CAA2BrL,WAAWsK,iBAAX,CAA6B5K,gBAAxD,EAA0E4L,OAA1E;AACA,UAAItL,WAAWuK,YAAX,KAA4BxK,SAAhC,EACE,KAAKsL,qBAAL,CAA2BrL,WAAWuK,YAAX,CAAwB7K,gBAAnD,EAAqE4L,OAArE;AACF,UAAItL,WAAWwK,SAAX,mCAAJ,EACE,KAAKiB,mCAAL,CAAyCzL,WAAWwK,SAApD,EAA+Dc,OAA/D;AACF,UAAItL,WAAWyK,UAAX,mCAAJ,EACE,KAAKgB,mCAAL,CAAyCzL,WAAWyK,UAApD,EAAgEa,OAAhE;AACH,KATD,MASO,IAAItL,yDAAJ,EAAkD;AACvD,WAAKqL,qBAAL,CAA2BrL,WAAWqK,gBAAX,CAA4B3K,gBAAvD,EAAyE4L,OAAzE;AACA,WAAKD,qBAAL,CAA2BrL,WAAWsK,iBAAX,CAA6B5K,gBAAxD,EAA0E4L,OAA1E;AACA,UAAItL,WAAWwK,SAAX,mCAAJ,EACE,KAAKiB,mCAAL,CAAyCzL,WAAWwK,SAApD,EAA+Dc,OAA/D;AACF,UAAItL,WAAWyK,UAAX,mCAAJ,EACE,KAAKgB,mCAAL,CAAyCzL,WAAWyK,UAApD,EAAgEa,OAAhE;AACH;AACF;;AAEDI,aAAWvK,OAAX,EAA4C;AAC1C,QAAImK,UAAUnK,QAAQK,QAAtB;AACA,QAAI8J,OAAJ,EAAa;AACX,WAAKD,qBAAL,CAA2B,KAAK3L,gBAAhC,EAAkD4L,OAAlD;AACA,UAAI,KAAKV,eAAL,KAAyB7K,SAA7B,EAAwC,KAAK0L,mCAAL,CAAyC,KAAKb,eAA9C,EAA+DU,OAA/D;AACzC;AACD,QAAI/I,IAAI,KAAKQ,YAAL,CAAkB4I,GAAlB,EAAR;AACA,6BAAUpJ,MAAMpB,OAAhB;AACD;;AAEDyK,kBAAmBC,QAAnB,EAAyC;AACvC,QAAI1K,UAAU,IAAIF,gBAAJ,EAAd;AACAE,YAAQG,QAAR,GAAmB,KAAKA,QAAxB;AACAH,YAAQgB,kBAAR,GAA6B,KAAKwD,UAAlC;AACAxE,YAAQc,mBAAR,GAA8B,KAAK0D,UAAnC;AACAxE,YAAQS,KAAR,GAAgB,IAAhB;;AAEA,SAAKkJ,WAAL,CAAiB3J,OAAjB;AACA,QAAI;AACF,aAAO0K,UAAP;AACD,KAFD,SAEU;AACR,WAAKH,UAAL,CAAgBvK,OAAhB;AACD;AACF;;AAED2K,iBAAe5B,IAAf,EAAoCpI,KAApC,EAAwD;AACtD,SAAK8J,eAAL,CAAqB,MAAM,KAAKjG,UAAL,CAAgBmG,cAAhB,CAA+B5B,IAA/B,EAAqCpI,KAArC,CAA3B;AACD;;AAEDiK,sBAAoB7B,IAApB,EAAwC;AACtC,SAAKvE,UAAL,CAAgBzD,iBAAhB,CAAkC8J,aAAlC,CAAgD9B,IAAhD;AACD;;AAED+B,qBAAmBC,MAAnB,EAA8DC,CAA9D,EAAkF;AAChF,WACEA,EAAEC,UAAF,CAAa,IAAb,KACCF,WAAW,KAAK5G,aAAhB,IAAiC6G,MAAM,QADxC,IAECD,OAAOG,aAAP,KAAyBtM,SAAzB,IAAsCmM,OAAOG,aAAP,CAAqBD,UAArB,CAAgC,IAAhC,CAHzC;AAKD;;AAEDE,wBAAmC;AACjC,QAAIC,eAAe,KAAKjH,aAAxB;AACA,6BAAUiH,0CAAV;AACA,QAAIpB,UAAUoB,aAAaC,UAAb,CAAwBC,GAAxB,CAA4B,mBAA5B,CAAd;AACA,6BAAUtB,YAAYpL,SAAtB;AACA,QAAI2M,wBAAwBvB,QAAQwB,UAAR,IAAsBxB,QAAQwB,UAAR,CAAmB7K,KAArE;AACA,6BAAU4K,mDAAV;AACA,WAAOA,qBAAP;AACD;;AAEDE,wBAAsBV,MAAtB,EAAiEC,CAAjE,EAAkF;AAChF,6BAAU,CAAC,KAAKF,kBAAL,CAAwBC,MAAxB,EAAgCC,CAAhC,CAAX;AACA,QAAIU,WAAW,KAAKpE,iBAAL,CAAuBgE,GAAvB,CAA2BP,MAA3B,CAAf;AACA,QAAIW,aAAa9M,SAAjB,EAA4B,KAAK0I,iBAAL,CAAuBqE,GAAvB,CAA2BZ,MAA3B,EAAoCW,WAAW,KAAKpE,iBAAL,CAAuBsE,IAAtE;AAC5B,QAAIC,KAAM,KAAIH,QAAS,IAAGV,CAAE,EAA5B;AACA,QAAIc,kBAAkB,KAAKX,mBAAL,EAAtB;AACAW,oBAAgBC,IAAhB,CAAqBF,EAArB,EAAyB,KAAK1K,UAAL,CAAgB6K,IAAzC,EAA+CF,eAA/C;AACD;;AAEDG,wBAAsBlB,MAAtB,EAAiEC,CAAjE,EAA4F;AAC1F,QAAI,KAAKF,kBAAL,CAAwBC,MAAxB,EAAgCC,CAAhC,CAAJ,EAAwC,OAAO,IAAP;AACxC,QAAIU,WAAW,KAAKpE,iBAAL,CAAuBgE,GAAvB,CAA2BP,MAA3B,CAAf;AACA,QAAIW,aAAa9M,SAAjB,EAA4B,OAAO,KAAP;AAC5B,QAAIiN,KAAM,KAAIH,QAAS,IAAGV,CAAE,EAA5B;AACA,QAAIhB,UAAU,KAAKmB,mBAAL,GAA2BE,UAA3B,CAAsCC,GAAtC,CAA0CO,EAA1C,CAAd;AACA,QAAI7B,YAAYpL,SAAhB,EAA2B,OAAO,KAAP;AAC3B,QAAI+B,QAAQqJ,QAAQwB,UAAR,IAAsBxB,QAAQwB,UAAR,CAAmB7K,KAArD;AACA,WAAOA,iCAA0B,CAACA,MAAMuL,cAAN,EAAlC;AACD;;AAED;AACA;AACA;AACA;AACAC,eACEC,CADF,EAEEC,oBAFF,EAKK;AACH,QAAIC,sCAAsC,KAAKC,6BAA/C;AACA,QAAIC,iCAAiC,KAAKC,wBAA1C;AACA;AACA;AACA;AACA;AACA,SAAKF,6BAAL,GAAqC,IAAI/K,GAAJ,EAArC;AACA,SAAKiL,wBAAL,GAAgC,CAAC,GAAGC,IAAJ,KAAa;AAC3C,UAAIL,wBAAwB,IAA5B,EAAkC;AAChCA,6BAAqB,GAAGK,IAAxB;AACD;AACD;AACA,UAAIF,kCAAkC,IAAtC,EAA4C;AAC1CA,uCAA+B,GAAGE,IAAlC;AACD;AACF,KARD;AASA,QAAI;AACF,aAAON,GAAP;AACD,KAFD,SAEU;AACR,WAAKG,6BAAL,GAAqCD,mCAArC;AACA,WAAKG,wBAAL,GAAgCD,8BAAhC;AACD;AACF;;AAEDG,kBAAyB;AACvB,WAAO,CAAC,CAAC,KAAKJ,6BAAd;AACD;;AAEDK,2BAAyBR,CAAzB,EAAgD;AAC9C,6BAAU,CAAC,KAAK3J,eAAhB,EAAiC,4DAAjC;AACA,SAAKA,eAAL,GAAuB,IAAvB;AACA,QAAI;AACF,aAAO2J,GAAP;AACD,KAFD,SAEU;AACR,WAAK3J,eAAL,GAAuB,KAAvB;AACD;AACF;;AAED;AACA;AACA;AACAoK,sCAAoCT,CAApC,EAAoDU,WAApD,EAA8EC,YAA9E,EAAiH;AAC/G;AACA;AACA;AACA;AACA,6BAAU,KAAKJ,aAAL,EAAV,EAAgC,mDAAhC;;AAEA;AACA;AACA;AACA;AACA,QAAIhM,QAAQyL,GAAZ;AACA,QAAI,KAAK1J,oBAAT,EAA+B;AAC7B,UAAIsK,OAAO,+BACT,sDADS,EAET,KAAK1E,eAFI,EAGT,QAHS,EAIT,kBAJS,CAAX;AAMA,UAAI,KAAKC,WAAL,CAAiByE,IAAjB,MAA2B,SAA/B,EAA0C,MAAM,wBAAN;AAC3C;AACD,WAAOrM,KAAP;AACD;;AAED;AACA;AACA;AACAsM,yBACEC,GADF,EAEEC,UAFF,EAGEC,GAHF,EAIEpO,KAJF,EAKEqO,gBAAyB,wBAL3B,EAMW;AACT,WAAO,KAAKC,kBAAL,CAAwB,MAAMF,IAAIG,uBAAJ,CAA4BL,GAA5B,EAAiCC,UAAjC,CAA9B,EAA4EnO,KAA5E,EAAmFqO,aAAnF,CAAP;AACD;;AAEDG,gCACEC,IADF,EAEEzO,KAFF,EAGEqO,gBAAyB,+BAH3B,EAIW;AACT,WAAO,KAAK5C,eAAL,CAAqB,MAAM,KAAK6C,kBAAL,CAAwBG,IAAxB,EAA8BzO,KAA9B,EAAqCqO,aAArC,CAA3B,CAAP;AACD;;AAED;AACA;AACAK,gCAAiCD,IAAjC,EAAqD9O,OAArD,EAA0E;AACxE,QAAIV,MAAJ;AACA,SAAKuP,6BAAL,CAAmC,MAAM;AACvC,UAAI;AACF,aAAKG,YAAL,CAAkBhP,OAAlB,EAA2B,EAA3B,EAA+B,KAA/B;AACAV,iBAASwP,KAAK9O,OAAL,CAAT;AACA,eAAO,KAAKwC,UAAL,CAAgBvC,SAAvB;AACD,OAJD,SAIU;AACR,aAAKgP,YAAL,CAAkBjP,QAAQJ,gBAA1B;AACA,aAAKsP,iBAAL,CAAuBlP,QAAQH,kBAA/B;AACA,iCAAU,CAACG,QAAQF,YAAnB;AACAE,gBAAQF,YAAR,GAAuB,IAAvB;AACD;AACF,KAXD;AAYA,6BAAUR,WAAWW,SAArB,EAAgC,oDAAhC;AACA,WAAOX,MAAP;AACD;;AAED6P,oCAAkCC,IAAlC,EAAmD/O,KAAnD,EAAgEqO,aAAhE,EAAiG;AAC/F,WAAO,KAAK5C,eAAL,CAAqB,MAAM,KAAKwC,sBAAL,CAA4Bc,IAA5B,EAAkC,KAAlC,EAAyC,KAAKvJ,UAA9C,EAA0DxF,KAA1D,EAAiEqO,aAAjE,CAA3B,CAAP;AACD;;AAEDW,kCACEd,GADF,EAEEC,UAFF,EAGEC,GAHF,EAImD;AACjD,QAAIa,OAAJ,EAAaC,MAAb;AACA,aAASC,WAAT,GAAuB;AACrB,UAAIlQ,MAAJ;AACA,OAACA,MAAD,EAASgQ,OAAT,EAAkBC,MAAlB,IAA4Bd,IAAIgB,gCAAJ,CAAqClB,GAArC,EAA0CC,UAA1C,CAA5B;AACA,aAAOlP,MAAP;AACD;AACD,QAAIU,UAAU,KAAK2O,kBAAL,CAAwBa,WAAxB,EAAqCvP,SAArC,EAAgD,iCAAhD,CAAd;AACA,6BAAUqP,YAAYrP,SAAZ,IAAyBsP,WAAWtP,SAA9C;AACA,WAAO,CAACD,OAAD,EAAUsP,OAAV,EAAmBC,MAAnB,CAAP;AACD;;AAEDZ,qBAAmBlB,CAAnB,EAAgDpN,KAAhD,EAA4DqO,aAA5D,EAA4F;AAC1F;AACA,QAAI,CAACgB,aAAD,EAAgBC,eAAhB,IAAmC,KAAKC,uBAAL,EAAvC;AACA,QAAIC,kBAAkB,KAAKtQ,SAA3B;AACA,QAAIuQ,uBAAuB,KAAKpQ,cAAhC;AACA,QAAIqQ,mBAAmB,KAAKjF,eAA5B;AACA,SAAKvL,SAAL,GAAiB,yBAAc,IAAd,EAAoBmP,aAApB,EAAmC,KAAK/L,cAAxC,CAAjB;AACA,SAAKjD,cAAL,GAAsB,IAAImD,GAAJ,EAAtB;AACA,SAAKiI,eAAL,GAAuB7K,SAAvB,CAR0F,CAQxD;;AAElC,QAAIX,MAAJ;AACA,QAAI;AACF,WAAK,IAAI0Q,EAAT,IAAe,KAAKzK,OAApB,EAA6ByK,GAAG5P,uBAAH,CAA2BC,KAA3B;;AAE7B,UAAIoC,CAAJ;AACA,UAAI;AACF,YAAI;AACFA,cAAIgL,GAAJ;AACA,cAAIhL,mCAAJ,EAA4BA,IAAI,wBAAYwN,QAAZ,CAAqB,IAArB,EAA2BxN,CAA3B,CAAJ,CAA5B,KACK,IAAIA,gDAAJ,EAAyCA,IAAIA,EAAET,KAAN;AAC/C,SAJD,CAIE,OAAOoH,CAAP,EAAU;AACV,cAAIA,0CAAJ,EAAmC3G,IAAI2G,CAAJ,CAAnC,KACK,MAAMA,CAAN;AACN;AACD;AACA,YAAI3G,6BAAsBA,0CAA1B,EAAyDA,IAAI,sBAAUyN,0BAAV,CAAqC,IAArC,EAA2CzN,CAA3C,CAAJ;AACzD,iCAAUA,MAAMxC,SAAhB;AACA,YAAIwC,kDAAJ,EAA2C;AACzC;AACA;AACA,cAAI0N,oBAAoB,KAAKC,kBAAL,CAAwB3N,EAAET,KAA1B,CAAxB;AACA,eAAKqO,+BAAL,CAAqC5N,CAArC;AACA,2BAAK6N,mDAAL,CAAyD,IAAzD,EAA+D7N,CAA/D,EAAkE0N,iBAAlE;AACA,eAAKrF,eAAL,GAAuB7K,SAAvB;AACD;;AAED,iCAAU,KAAKV,SAAL,KAAmBU,SAA7B;AACA,iCAAU,KAAKL,gBAAL,KAA0BK,SAApC;AACA,iCAAU,KAAKJ,kBAAL,KAA4BI,SAAtC;AACA,iCAAU,KAAKP,cAAL,KAAwBO,SAAlC;AACA,YAAIsQ,eAAe,KAAKhR,SAAxB;AACA,YAAIiR,cAAc,KAAK5Q,gBAAvB;AACA,YAAI6Q,gBAAgB,KAAK5Q,kBAAzB;AACA,YAAI6Q,oBAAoB,KAAKhR,cAA7B;;AAEA;;;;;;;;AASA;AACA,YAAI+C,yBAAJ,EAAwBA,IAAI,wCAA2BA,CAA3B,CAAJ;AACxBnD,iBAAS,IAAIF,OAAJ,CAAYqD,CAAZ,EAAe8N,YAAf,EAA6BC,WAA7B,EAA0CC,aAA1C,EAAyDC,iBAAzD,CAAT;AACA,eAAOpR,MAAP;AACD,OA3CD,SA2CU;AACR;AACA,YAAI,KAAKwL,eAAL,KAAyB7K,SAA7B,EAAwC,KAAKoQ,+BAAL,CAAqC,KAAKvF,eAA1C;AACxC,YAAIxL,WAAWW,SAAf,EAA0B;AACxB,eAAKgP,YAAL,CAAkB3P,OAAOM,gBAAzB;AACA,eAAKsP,iBAAL,CAAuB5P,OAAOO,kBAA9B;AACD,SAHD,MAGO;AACL,eAAKoP,YAAL,CAAkB,KAAKrP,gBAAvB;AACA,eAAKsP,iBAAL,CAAuB,KAAKrP,kBAA5B;AACD;AACD,aAAKN,SAAL,GAAiBsQ,eAAjB;AACA,aAAKjQ,gBAAL,GAAwB8P,aAAxB;AACA,aAAK7P,kBAAL,GAA0B8P,eAA1B;AACA,aAAKjQ,cAAL,GAAsBoQ,oBAAtB;AACA,aAAKhF,eAAL,GAAuBiF,gBAAvB;AACD;AACF,KA/DD,SA+DU;AACR,WAAK,IAAIY,EAAT,IAAe,KAAKpL,OAApB,EAA6BoL,GAAGrQ,qBAAH,CAAyBD,KAAzB,EAAgCf,MAAhC;AAC9B;AACF;;AAEDsR,mBAAiBnD,CAAjB,EAAiCoD,eAAsB,KAAKrO,UAAL,CAAgBvC,SAAvE,EAAyF;AACvF,QAAI,CAAC,KAAKuD,yBAAV,EAAqC,OAAOiK,GAAP;AACrC,QAAIqD,kBAAkB,KAAKvI,YAA3B;AACA,SAAKA,YAAL,GAAoBwI,KAAK;AACvB,UAAIA,EAAEC,QAAF,KAAe,aAAf,IAAgCD,EAAEC,QAAF,KAAe,SAAnD,EAA8D,OAAO,SAAP;AAC9D,aAAO,MAAP;AACD,KAHD;AAIA,QAAI;AACF,UAAIhR,UAAU,KAAK2O,kBAAL,CACZ,MAAM;AACJ,YAAI;AACF,iBAAOlB,GAAP;AACD,SAFD,CAEE,OAAOrE,CAAP,EAAU;AACV,cAAIA,oCAAJ,EAA6B;AAC3B,mBAAOyH,YAAP;AACD,WAFD,MAEO,IAAIzH,+BAAJ,EAA6B;AAClC,mBAAOyH,YAAP;AACD,WAFM,MAEA;AACL,kBAAMzH,CAAN;AACD;AACF;AACF,OAbW,EAcZnJ,SAdY,EAeZ,kBAfY,CAAd;AAiBA,aAAOD,QAAQV,MAAR,kDAAmDU,QAAQV,MAAR,CAAe0C,KAAlE,GAA0E6O,YAAjF;AACD,KAnBD,SAmBU;AACR,WAAKtI,YAAL,GAAoBuI,eAApB;AACD;AACF;;AAEDG,gCAA8BxD,CAA9B,EAA0E;AACxE,QAAI,CAAC,KAAKjK,yBAAV,EAAqC,OAAOiK,GAAP;AACrC,QAAIyD,eAAe,KAAK3I,YAAxB;AACA,QAAI4I,UAAJ;AACA,QAAI;AACF,WAAK5I,YAAL,GAAoBwI,KAAK;AACvBI,qBAAaJ,CAAb;AACA,eAAO,MAAP;AACD,OAHD;AAIA,UAAI/Q,UAAU,KAAK2O,kBAAL,CAAwBlB,CAAxB,EAA2BxN,SAA3B,EAAsC,+BAAtC,CAAd;AACA,WAAK+O,YAAL,CAAkBhP,OAAlB;AACA,UAAIoR,YAAYpR,QAAQV,MAAxB;AACA,UAAI8R,kDAAJ,EAA2C,MAAMA,SAAN;AAC3C,UAAIA,0DAAJ,EAAmD;AACjD;AACA;AACA;AACA;AACAA,oBAAY,KAAKC,0BAAL,CAAgCD,SAAhC,CAAZ;AACD;AACD,+BAAUA,wDAAV;AACA,aAAOA,UAAUpP,KAAjB;AACD,KAlBD,CAkBE,OAAOoH,CAAP,EAAU;AACV,UAAI+H,eAAelR,SAAnB,EAA8B,OAAOkR,UAAP;AAC9B,YAAM/H,CAAN;AACD,KArBD,SAqBU;AACR,WAAKb,YAAL,GAAoB2I,YAApB;AACD;AACF;;AAEDI,6BAA2BC,SAA3B,EAAiH;AAC/G,QAAI;AACF,UAAIC,IAAJ;AACA,UAAI/D,IAAI,MAAM;AACZ,YAAInO,MAAJ;AACA,SAACkS,IAAD,EAAOlS,MAAP,IAAiBiS,WAAjB;AACA,YAAI,EAAEC,oCAAF,CAAJ,EAAsC,MAAM,uBAAe,oCAAf,CAAN;AACtC,iCAAUlS,yCAAV;AACA,eAAOA,MAAP;AACD,OAND;AAOA,UAAImS,WAAW,KAAK9C,kBAAL,CAAwBlB,CAAxB,EAA2BxN,SAA3B,EAAsC,8BAAtC,CAAf;AACA,aAAO,IAAP,EAAa;AACX,aAAKyR,YAAL,CAAkBD,SAAS7R,gBAA3B;AACA,aAAKsP,iBAAL,CAAuBuC,SAAS5R,kBAAhC;AACA,YAAI8R,WAAW,KAAKhD,kBAAL,CAAwBlB,CAAxB,EAA2BxN,SAA3B,EAAsC,8BAAtC,CAAf;AACA,aAAKgP,YAAL,CAAkBwC,SAAS7R,gBAA3B;AACA,aAAKsP,iBAAL,CAAuBuC,SAAS5R,kBAAhC;AACA,YAAI,kBAAM+R,eAAN,CAAsBH,QAAtB,EAAgCE,QAAhC,CAAJ,EAA+C;AAC7C;AACA;AACA;AACA,gBAAME,KAAKF,QAAX;AACA,eAAKG,qCAAL,CAA2CD,GAAGhS,kBAA9C,EAAkEgS,GAAGnS,cAArE;AACA,eAAKqS,uBAAL,CAA6BF,GAAGtS,SAAhC,EAA2CsS,GAAGhS,kBAA9C,EAAkEgS,GAAGnS,cAArE;AACA,eAAKsS,qBAAL,CAA2BH,GAAGtS,SAA9B,EAAyCsS,GAAGjS,gBAA5C,EAA8DiS,GAAGnS,cAAjE;AACA,mCAAU8R,oCAAV;AACA,cAAIS,OAAOJ,GAAGtS,SAAH,CAAa2S,cAAb,CAA4BV,KAAKW,KAAjC,EAAwCX,KAAKY,MAA7C,EAAqD,CAACZ,IAAD,CAArD,EAA6D,CAAC,CAACa,CAAD,CAAD,KAASA,CAAtE,EAAyE;AAClFC,2BAAe;AADmE,WAAzE,CAAX;AAGA,iBAAO,CAACb,QAAD,EAAWE,QAAX,EAAqBM,IAArB,CAAP;AACD;AACDR,mBAAW,kBAAMc,YAAN,CAAmB,IAAnB,EAAyBd,QAAzB,EAAmCE,QAAnC,CAAX;AACD;AACF,KAhCD,CAgCE,OAAOvI,CAAP,EAAU;AACV,UAAIA,+BAAJ,EAA6B,OAAOnJ,SAAP;AAC7B,YAAMmJ,CAAN;AACD;AACF;;AAEDoJ,kCACEC,SADF,EAEEC,qBAFF,EAGEC,oBAHF,EAIS;AACP;AACA,QAAIlB,QAAJ;AACA,QAAI;AACFA,iBAAW,iBAAKmB,aAAL,CAAmBH,SAAnB,EAA8BC,qBAA9B,CAAX;AACD,KAFD,CAEE,OAAOtJ,CAAP,EAAU;AACV,UAAI,EAAEA,wCAAF,CAAJ,EAAyC,MAAMA,CAAN;AAC1C;;AAED,QAAIuI,QAAJ;AACA,QAAI;AACFA,iBAAW,iBAAKkB,oBAAL,CAA0BJ,SAA1B,EAAqCE,oBAArC,CAAX;AACD,KAFD,CAEE,OAAOvJ,CAAP,EAAU;AACV,UAAI,EAAEA,wCAAF,CAAJ,EAAyC,MAAMA,CAAN;AAC1C;;AAED,QAAI0J,aAAJ,EAAmB5S,UAAnB;AACA,QAAIuR,aAAaxR,SAAb,IAA0B0R,aAAa1R,SAA3C,EAAsD;AACpD,UAAIwR,aAAaxR,SAAb,IAA0B0R,aAAa1R,SAA3C,EAAsD,MAAM,iCAAN;AACtD6S,sBAAgBrB,YAAYE,QAA5B;AACA,+BAAUmB,kBAAkB7S,SAA5B;AACAC,mBAAa4S,cAAcxT,MAA3B;AACA,WAAK0P,YAAL,CAAkB8D,aAAlB,EAAiC,iCAAjC;AACD,KAND,MAMO;AACL;AACA;AACAA,sBAAgB,iBAAKC,gBAAL,CAAsB,IAAtB,EAA4BN,SAA5B,EAAuChB,QAAvC,EAAiDE,QAAjD,CAAhB;AACAzR,mBAAa4S,cAAcxT,MAA3B;AACA,UAAIY,yDAAJ,EAAkD;AAChD;AACA,cAAMA,UAAN;AACD;AACD,UAAIA,2DAAJ,EAAoD;AAClD;AACA;AACA;AACA;AACAA,qBAAa,KAAKmR,0BAAL,CAAgCnR,UAAhC,CAAb;AACA,aAAK8O,YAAL,CAAkB8D,aAAlB,EAAiC,iCAAjC,EAAoE,KAApE;AACD,OAPD,MAOO;AACL,aAAK9D,YAAL,CAAkB8D,aAAlB,EAAiC,iCAAjC;AACD;AACF;;AAED;AACA,QAAI5S,mDAAJ,EAA4C,MAAMA,UAAN;AAC5C,QAAIA,yDAAJ,EAAkDA,aAAaA,WAAW8B,KAAxB;AAClD,6BAAU9B,kCAAV;AACA,WAAOA,UAAP;AACD;;AAED4R,wCACEjS,kBADF,EAEEmT,mBAFF,EAGQ;AACN,QAAInT,uBAAuBI,SAA3B,EAAsC;AACtCJ,uBAAmByJ,OAAnB,CAA2B,CAAC2J,IAAD,EAAOC,eAAP,EAAwBC,CAAxB,KAA8B;AACvD,UAAIH,oBAAoBnI,GAApB,CAAwBqI,gBAAgB9G,MAAxC,CAAJ,EAAqD;AACnD8G,wBAAgBrG,UAAhB,GAA6BoG,IAA7B;AACD;AACF,KAJD;AAKD;;AAED;AACAjB,wBAAsBoB,GAAtB,EAAsC5T,QAAtC,EAA0DwT,mBAA1D,EAAqG;AACnG,QAAIK,UAAmC,IAAIzQ,GAAJ,EAAvC;AACApD,aAAS8J,OAAT,CAAiB,CAAC+B,OAAD,EAAUvC,GAAV,EAAewK,GAAf,KAAuB;AACtC,UAAIC,MAAMlI,QAAQrJ,KAAlB;AACA,UAAIuR,mCAAJ,EAAkC;AAChC,iCAAUA,IAAIC,UAAJ,KAAmBvT,SAA7B;AACA,YAAIwT,OAAOL,IAAIlB,cAAJ,CAAmBqB,IAAIpB,KAAvB,EAA8BoB,IAAInB,MAAlC,EAA0C,CAACmB,GAAD,CAA1C,EAAiD,CAAC,CAAClB,CAAD,CAAD,KAASA,CAA1D,EAA6D;AACtEC,yBAAe;AADuD,SAA7D,CAAX;AAGAe,gBAAQrG,GAAR,CAAYlE,GAAZ,EAAiB2K,IAAjB;AACD;AACF,KATD;AAUAjU,aAAS8J,OAAT,CAAiB,CAAC+B,OAAD,EAAUvC,GAAV,EAAewK,GAAf,KAAuB;AACtC,UAAIC,MAAMlI,QAAQrJ,KAAlB;AACA,UAAIuR,mCAAJ,EAAkC;AAChC,YAAIG,UAAU5K,IAAI4K,OAAlB;AACA,YAAID,OAAOJ,QAAQ1G,GAAR,CAAY7D,GAAZ,CAAX;AACA,iCAAU2K,SAASxT,SAAnB;AACAmT,YAAIO,aAAJ,CAAkB,CAACF,IAAD,CAAlB,EAA0B,CAAC,CAACG,CAAD,CAAD,KAAS;AACjC,mCAAUF,YAAYzT,SAAtB;AACA,cAAIiN,KAAKwG,QAAQG,SAAR,CAAkB,EAAlB,CAAT;AACA,iBAAO3U,EAAE4U,mBAAF,CAAsB5U,EAAE6U,oBAAF,CAAuB,GAAvB,EAA6B7G,EAA7B,EAAuC0G,CAAvC,CAAtB,CAAP;AACD,SAJD;AAKD;;AAED,UAAIL,qCAA8BP,oBAAoBnI,GAApB,CAAwB0I,GAAxB,CAAlC,EAAgE;AAC9D,YAAIG,UAAU5K,IAAI4K,OAAlB;AACAN,YAAIO,aAAJ,CAAkB,CAACJ,GAAD,CAAlB,EAAyB,CAAC,CAACK,CAAD,CAAD,KAAS;AAChC,mCAAUF,YAAYzT,SAAtB;AACA,cAAIiN,KAAKwG,QAAQG,SAAR,CAAkB,EAAlB,CAAT;AACA,iBAAO3U,EAAE4U,mBAAF,CAAsB5U,EAAE6U,oBAAF,CAAuB,GAAvB,EAA6B7G,EAA7B,EAAuC0G,CAAvC,CAAtB,CAAP;AACD,SAJD;AAKD;AACF,KArBD;AAsBD;;AAED;AACA7B,0BAAwBqB,GAAxB,EAAwCY,SAAxC,EAAqEhB,mBAArE,EAAgH;AAC9G,aAASiB,iBAAT,CAA2BjS,KAA3B,EAAyCkS,QAAzC,EAAkF;AAChF,UAAIlS,UAAUkS,QAAd,EAAwB,OAAO,IAAP;AACxB,UAAIlS,yCAAkCkS,aAAajU,SAAnD,EAA8D;AAC5D,aAAK,IAAI2T,CAAT,IAAc5R,MAAM+L,IAApB,EAA0B;AACxB,cAAIkG,kBAAkBL,CAAlB,EAAqBM,QAArB,CAAJ,EAAoC,OAAO,IAAP;AACrC;AACF;AACD,aAAO,KAAP;AACD;;AAED,QAAIb,UAAmC,IAAIzQ,GAAJ,EAAvC;AACAoR,cAAU1K,OAAV,CAAkB,CAACiK,GAAD,EAAMzK,GAAN,EAAWwK,GAAX,KAAmB;AACnC,UAAIN,oBAAoBnI,GAApB,CAAwB/B,IAAIsD,MAA5B,KAAuCtD,IAAIsD,MAAJ,CAAW+H,mBAAtD,EAA2E;AACzE;AACD;AACD,UAAInS,QAAQuR,OAAOA,IAAIvR,KAAvB;AACA,UAAIA,qCAAJ,EAAoC;AAClC,iCAAUA,MAAMwR,UAAN,KAAqBvT,SAA/B;AACA,YAAIwT,OAAOL,IAAIlB,cAAJ,CACTlQ,MAAMmQ,KADG,EAETnQ,MAAMoQ,MAFG,EAGT,CAACtJ,IAAIsD,MAAL,EAAapK,KAAb,CAHS,EAIT,CAAC,CAACoS,CAAD,EAAI/B,CAAJ,CAAD,KAAY;AACV,mCAAUrQ,6BAAV;AACA,cAAI,OAAO8G,IAAIA,GAAX,KAAmB,QAAnB,IAA+B9G,MAAMqS,oBAAN,EAA/B,IAA+DJ,kBAAkBjS,KAAlB,EAAyB8G,IAAIoL,QAA7B,CAAnE,EAA2G;AACzG,gBAAII,SAASpV,EAAEqV,gBAAF,CAAmB,IAAnB,EAAyBrV,EAAEsV,aAAF,CAAgB1L,IAAIA,GAApB,CAAzB,EAAmDsL,CAAnD,CAAb;AACA,gBAAIK,WAAWvV,EAAEwV,qBAAF,CAAwBJ,MAAxB,EAAgCjC,CAAhC,gCAAf;AACAA,gBAAInT,EAAEyV,iBAAF,CAAoB,IAApB,EAA0BtC,CAA1B,EAA6BoC,QAA7B,CAAJ;AACD;AACD,iBAAOpC,CAAP;AACD,SAZQ,EAaT;AACEC,yBAAe;AADjB,SAbS,CAAX;AAiBAe,gBAAQrG,GAAR,CAAYlE,GAAZ,EAAiB2K,IAAjB;AACD;AACF,KA1BD;AA2BAO,cAAU1K,OAAV,CAAkB,CAACiK,GAAD,EAAMzK,GAAN,EAAWwK,GAAX,KAAmB;AACnC,UAAIN,oBAAoBnI,GAApB,CAAwB/B,IAAIsD,MAA5B,KAAuCtD,IAAIsD,MAAJ,CAAW+H,mBAAtD,EAA2E;AACzE;AACD;AACD,UAAIS,OAAO9L,IAAIoL,QAAf;AACA,UAAIT,OAAOJ,QAAQ1G,GAAR,CAAY7D,GAAZ,CAAX;AACA,+BAAUyK,QAAQtT,SAAlB;AACA,UAAI+B,QAAQuR,IAAIvR,KAAhB;AACA,+BAAUA,6BAAV;AACA,UAAIqS,uBAAuBrS,MAAMqS,oBAAN,EAA3B;AACA,UAAIQ,mBAAmB7S,MAAM6S,gBAAN,EAAvB;AACA,UAAIC,SAAShM,IAAIA,GAAjB;AACA,UAAI,OAAOgM,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,YAAIF,SAAS3U,SAAb,EAAwB;AACtBmT,cAAIO,aAAJ,CAAkB,CAAC7K,IAAIsD,MAAL,EAAaqH,QAAQzR,KAArB,EAA4B,KAAKQ,UAAL,CAAgBE,KAA5C,CAAlB,EAAsE,CAAC,CAAC0R,CAAD,EAAIR,CAAJ,EAAOxK,CAAP,CAAD,KAAe;AACnF,qCAAUwL,SAAS3U,SAAnB;AACA,qCAAU,OAAO6U,MAAP,KAAkB,QAA5B;AACA,gBAAIC,KAAKH,KAAKf,SAAL,CAAe,CAACO,CAAD,EAAIlV,EAAE8V,UAAF,CAAaF,MAAb,CAAJ,CAAf,CAAT;AACA,gBAAIG,IAAI/V,EAAE4U,mBAAF,CAAsB5U,EAAE6U,oBAAF,CAAuB,GAAvB,EAA6BgB,EAA7B,EAAuCnB,CAAvC,CAAtB,CAAR;AACA,gBAAIS,oBAAJ,EAA0B;AACxB;AACA,kBAAIa,YAAYhW,EAAEqV,gBAAF,CAAmB,KAAnB,EAA0BX,CAA1B,EAA6BxK,CAA7B,CAAhB;AACA,kBAAI+L,gBAAgBjW,EAAEqV,gBAAF,CAAmB,KAAnB,EAA0BX,CAA1B,+BAApB;AACA,kBAAIU,SAASpV,EAAEkW,eAAF,CAAkB,GAAlB,EAAuBlW,EAAEqV,gBAAF,CAAmB,IAAnB,EAAyBrV,EAAEsV,aAAF,CAAgBM,MAAhB,CAAzB,EAAkDV,CAAlD,CAAvB,CAAb;AACA,kBAAIiB,QAAQnW,EAAEyV,iBAAF,CAAoB,IAApB,EAA0BO,SAA1B,EAAqChW,EAAEyV,iBAAF,CAAoB,IAApB,EAA0BQ,aAA1B,EAAyCb,MAAzC,CAArC,CAAZ;AACA,kBAAIgB,WAAWpW,EAAE4U,mBAAF,CAAsB5U,EAAEkW,eAAF,CAAkB,QAAlB,EAA6BL,EAA7B,CAAtB,CAAf;AACA,qBAAO7V,EAAEqW,WAAF,CAAcV,mBAAmBK,SAAnB,GAA+BG,KAA7C,EAAoDC,QAApD,EAA8DL,CAA9D,CAAP;AACD;AACD,mBAAOA,CAAP;AACD,WAfD;AAgBD,SAjBD,MAiBO;AACL;AACA;AACA;AACD;AACF,OAvBD,MAuBO;AACL;AACA,iCAAUH,8BAAV;AACA1B,YAAIO,aAAJ,CAAkB,CAAC7K,IAAIsD,MAAL,EAAa0I,MAAb,EAAqBrB,QAAQzR,KAA7B,EAAoC,KAAKQ,UAAL,CAAgBE,KAApD,CAAlB,EAA8E,CAAC,CAAC0R,CAAD,EAAIoB,CAAJ,EAAO5B,CAAP,EAAUxK,CAAV,CAAD,KAAkB;AAC9F,mCAAUwL,SAAS3U,SAAnB;AACA,cAAI8U,KAAKH,KAAKf,SAAL,CAAe,CAACO,CAAD,EAAIoB,CAAJ,CAAf,CAAT;AACA,iBAAOtW,EAAE4U,mBAAF,CAAsB5U,EAAE6U,oBAAF,CAAuB,GAAvB,EAA6BgB,EAA7B,EAAuCnB,CAAvC,CAAtB,CAAP;AACD,SAJD;AAKD;AACF,KA5CD;AA6CD;;AAED6B,iBAAeC,YAAf,EAAsCvF,iBAAtC,EAA2E;AACzE,QAAI7Q,SAASL,wBAAwB,IAAxB,EAA8BkR,kBAAkB7Q,MAAhD,CAAb;;AAEAA,WAAOC,SAAP,GAAmB,iBAAKoW,iBAAL,CACjB,IADiB,EAEjBD,aAAanW,SAAb,IAA0BD,OAAOC,SAFhB,EAGjB4Q,kBAAkB5Q,SAHD,CAAnB;;AAMA,QAAImW,aAAa9V,gBAAjB,EAAmC;AACjC8V,mBAAa9V,gBAAb,CAA8B0J,OAA9B,CAAsC,CAACiK,GAAD,EAAMzK,GAAN,EAAWqK,CAAX,KAAiB7T,OAAOM,gBAAP,CAAwBoN,GAAxB,CAA4BlE,GAA5B,EAAiCyK,GAAjC,CAAvD;AACD;AACDpD,sBAAkBvQ,gBAAlB,CAAmC0J,OAAnC,CAA2C,CAACiK,GAAD,EAAMzK,GAAN,EAAWqK,CAAX,KAAiB7T,OAAOM,gBAAP,CAAwBoN,GAAxB,CAA4BlE,GAA5B,EAAiCyK,GAAjC,CAA5D;;AAEA,QAAImC,aAAa7V,kBAAjB,EAAqC;AACnC6V,mBAAa7V,kBAAb,CAAgCyJ,OAAhC,CAAwC,CAAC2J,IAAD,EAAOC,eAAP,EAAwBC,CAAxB,KACtC7T,OAAOO,kBAAP,CAA0BmN,GAA1B,CAA8BkG,eAA9B,EAA+CD,IAA/C,CADF;AAGD;AACD9C,sBAAkBtQ,kBAAlB,CAAqCyJ,OAArC,CAA6C,CAACiK,GAAD,EAAMzK,GAAN,EAAWqK,CAAX,KAAiB7T,OAAOO,kBAAP,CAA0BmN,GAA1B,CAA8BlE,GAA9B,EAAmCyK,GAAnC,CAA9D;;AAEA,QAAImC,aAAahW,cAAjB,EAAiC;AAC/BgW,mBAAahW,cAAb,CAA4B4J,OAA5B,CAAoC,CAACsM,EAAD,EAAKC,CAAL,KAAWvW,OAAOI,cAAP,CAAsBoW,GAAtB,CAA0BF,EAA1B,CAA/C;AACD;AACDzF,sBAAkBzQ,cAAlB,CAAiC4J,OAAjC,CAAyC,CAACsM,EAAD,EAAKC,CAAL,KAAWvW,OAAOI,cAAP,CAAsBoW,GAAtB,CAA0BF,EAA1B,CAApD;;AAEA,WAAOtW,MAAP;AACD;;AAEDyW,0BAAwBL,YAAxB,EAA+CjT,CAA/C,EAAkF;AAChF,QAAIA,EAAEkI,UAAF,yCAAJ,EAA8C;AAC5ClI,QAAEkI,UAAF,CAAa3K,OAAb,GAAuB,KAAKyV,cAAL,CAAoBC,YAApB,EAAkCjT,EAAE+H,iBAApC,CAAvB;AACA,UAAIE,YAAYjI,EAAEiI,SAAlB;AACA,UAAIA,0DAAJ,EAAmD,KAAKqL,uBAAL,CAA6BL,YAA7B,EAA2ChL,SAA3C;AACpD,KAJD,MAIO;AACL,+BAAUjI,EAAEiI,SAAF,yCAAV;AACAjI,QAAEiI,SAAF,CAAY1K,OAAZ,GAAsB,KAAKyV,cAAL,CAAoBC,YAApB,EAAkCjT,EAAE8H,gBAApC,CAAtB;AACA,UAAII,aAAalI,EAAEkI,UAAnB;AACA,UAAIA,2DAAJ,EAAoD,KAAKoL,uBAAL,CAA6BL,YAA7B,EAA2C/K,UAA3C;AACrD;AACF;;AAEDqL,sBAAoB9V,UAApB,EAAgE;AAC9D,QAAI,KAAK4K,eAAL,KAAyB7K,SAA7B,EAAwC;AACtC,UAAIC,WAAWyK,UAAX,yCAAJ,EAAuD;AACrDzK,mBAAWwK,SAAX,GAAuB,KAAKI,eAA5B;AACD,OAFD,MAEO;AACL5K,mBAAWyK,UAAX,GAAwB,KAAKG,eAA7B;AACD;AACD5K,iBAAWuK,YAAX,GAA0B,KAAKK,eAAL,CAAqBL,YAA/C;AACD,KAPD,MAOO;AACL,WAAKwL,cAAL,CAAoB/V,UAApB;AACD;AACD,SAAK4K,eAAL,GAAuB5K,UAAvB;AACD;;AAEDmR,6BAA2BnR,UAA3B,EAAwE;AACtE,QAAI,KAAK4K,eAAL,KAAyB7K,SAA7B,EAAwC;AACtC,WAAK6K,eAAL,GAAuB5K,UAAvB;AACA,WAAK4K,eAAL,CAAqBoL,mBAArB,GAA2C,KAAKvT,cAAhD;AACA,WAAKA,cAAL,GAAsB,GAAGwT,MAAH,CAAU,KAAKxT,cAAf,CAAtB;AACA,WAAKsT,cAAL,CAAoB/V,UAApB;AACD,KALD,MAKO;AACL,UAAI4K,kBAAkB,KAAKA,eAA3B;AACA,UAAI1B,IAAI,KAAKgH,kBAAL,EAAR;AACA,WAAKC,+BAAL,CAAqCvF,eAArC;AACAA,wBAAkB,iBAAKsL,gCAAL,CAAsC,IAAtC,EAA4CtL,eAA5C,EAA6D5K,UAA7D,EAAyEkJ,CAAzE,CAAlB;AACA,WAAK4F,YAAL,CAAkB5F,CAAlB;AACA,WAAK6M,cAAL,CAAoBnL,eAApB;AACA,WAAKA,eAAL,GAAuBA,eAAvB;AACD;AACD,QAAIhJ,QAAQ,IAAZ;AACAuU,gDAA4CnW,UAA5C;AACA,WAAOA,WAAW8B,KAAlB;;AAEA,aAASqU,2CAAT,CAAqD5T,CAArD,EAA2G;AACzG,UAAI6T,kBAAkB7T,EAAEkI,UAApB,CAAJ,EAAqC;AACnC,yBAAK4L,oBAAL,CAA0B9T,EAAE+T,aAA5B;AACA,YAAI/T,EAAEiI,SAAF,qDAAmDjI,EAAEiI,SAAF,+CAAvD,EACE2L,4CAA4C5T,EAAEiI,SAA9C;AACH,OAJD,MAIO,IAAI4L,kBAAkB7T,EAAEiI,SAApB,CAAJ,EAAoC;AACzC,yBAAK+L,aAAL,CAAmBhU,EAAE+T,aAArB;AACA,YAAI/T,EAAEkI,UAAF,qDAAoDlI,EAAEkI,UAAF,+CAAxD,EACE0L,4CAA4C5T,EAAEkI,UAA9C;AACH,OAJM,MAIA,IAAI+L,kBAAkBjU,EAAEkI,UAApB,CAAJ,EAAqC;AAC1C,YAAI,CAAC+L,kBAAkBjU,EAAEiI,SAApB,CAAL,EAAqC;AACnC,cAAIiM,cAAcC,0BAA0BnU,EAAEiI,SAA5B,CAAlB;AACA,cAAImM,WAAW,qBAAcC,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CW,EAAE+T,aAAjD,EAAgEG,WAAhE,CAAf;AACA,2BAAKF,aAAL,CAAmBI,QAAnB;AACD;AACF,OANM,MAMA,IAAIH,kBAAkBjU,EAAEiI,SAApB,CAAJ,EAAoC;AACzC,YAAIqM,eAAeH,0BAA0BnU,EAAEkI,UAA5B,CAAnB;AACA,YAAIqM,UAAU,qBAAcC,iBAAd,CAAgCnV,KAAhC,EAAuC,GAAvC,EAA4CW,EAAE+T,aAA9C,CAAd;AACA,YAAIK,WAAW,qBAAcC,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CkV,OAA/C,EAAwDD,YAAxD,CAAf;AACA,yBAAKN,aAAL,CAAmBI,QAAnB;AACD,OALM,MAKA;AACL,YAAIK,KAAKzU,EAAE+T,aAAX;AACA,YAAIO,eAAe,qBAAcD,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CoV,EAA/C,EAAmDN,0BAA0BnU,EAAEkI,UAA5B,CAAnD,CAAnB;AACA,YAAIwM,MAAM,qBAAcF,iBAAd,CAAgCnV,KAAhC,EAAuC,GAAvC,EAA4CoV,EAA5C,CAAV;AACA,YAAIP,cAAc,qBAAcG,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CqV,GAA/C,EAAoDP,0BAA0BnU,EAAEiI,SAA5B,CAApD,CAAlB;AACA,YAAImM,WAAW,qBAAcC,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CiV,YAA/C,EAA6DJ,WAA7D,CAAf;AACA,yBAAKF,aAAL,CAAmBI,QAAnB;AACD;AACF;;AAED,aAASP,iBAAT,CAA2B7T,CAA3B,EAAmD;AACjD,UAAIA,gDAAJ,EAAyC,OAAO6T,kBAAkB7T,EAAEkI,UAApB,KAAmC2L,kBAAkB7T,EAAEiI,SAApB,CAA1C;AACzC,UAAIjI,0CAAJ,EAAmC,OAAO,IAAP;AACnC,aAAO,KAAP;AACD;;AAED,aAASiU,iBAAT,CAA2BjU,CAA3B,EAAmD;AACjD,UAAIA,sDAAyCA,gDAA7C,EACE,OAAOiU,kBAAkBjU,EAAEkI,UAApB,KAAmC+L,kBAAkBjU,EAAEiI,SAApB,CAA1C;AACF,UAAIjI,0CAAJ,EAAmC,OAAO,KAAP;AACnC,aAAO,IAAP;AACD;;AAED,aAASmU,yBAAT,CAAmCnU,CAAnC,EAAyD;AACvD,+BAAUA,sDAAyCA,gDAAnD;AACA,UAAI6T,kBAAkB7T,EAAEkI,UAApB,CAAJ,EAAqC;AACnC,iCAAU,CAAC2L,kBAAkB7T,EAAEiI,SAApB,CAAX;AACA,YAAIsM,UAAU,qBAAcC,iBAAd,CAAgCnV,KAAhC,EAAuC,GAAvC,EAA4CW,EAAE+T,aAA9C,CAAd;AACA,YAAIE,kBAAkBjU,EAAEiI,SAApB,CAAJ,EAAoC,OAAOsM,OAAP;AACpC,eAAO,qBAAcF,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CkV,OAA/C,EAAwDJ,0BAA0BnU,EAAEiI,SAA5B,CAAxD,CAAP;AACD,OALD,MAKO,IAAI4L,kBAAkB7T,EAAEiI,SAApB,CAAJ,EAAoC;AACzC,iCAAU,CAAC4L,kBAAkB7T,EAAEkI,UAApB,CAAX;AACA,YAAI+L,kBAAkBjU,EAAEkI,UAApB,CAAJ,EAAqC,OAAOlI,EAAE+T,aAAT;AACrC,eAAO,qBAAcM,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CW,EAAE+T,aAAjD,EAAgEI,0BAA0BnU,EAAEkI,UAA5B,CAAhE,CAAP;AACD,OAJM,MAIA,IAAI+L,kBAAkBjU,EAAEkI,UAApB,CAAJ,EAAqC;AAC1C;AACA,iCAAU,CAAC+L,kBAAkBjU,EAAEiI,SAApB,CAAX;AACA,iCAAU,CAAC4L,kBAAkB7T,EAAEiI,SAApB,CAAX;AACA,YAAIyM,MAAM,qBAAcF,iBAAd,CAAgCnV,KAAhC,EAAuC,GAAvC,EAA4CW,EAAE+T,aAA9C,CAAV;AACA,YAAIG,cAAc,qBAAcG,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CqV,GAA/C,EAAoDP,0BAA0BnU,EAAEiI,SAA5B,CAApD,CAAlB;AACA,eAAO,qBAAcoM,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CW,EAAE+T,aAAjD,EAAgEG,WAAhE,CAAP;AACD,OAPM,MAOA,IAAID,kBAAkBjU,EAAEiI,SAApB,CAAJ,EAAoC;AACzC;AACA,iCAAU,CAACgM,kBAAkBjU,EAAEkI,UAApB,CAAX;AACA,iCAAU,CAAC2L,kBAAkB7T,EAAEkI,UAApB,CAAX;AACA,YAAIuM,KAAKzU,EAAE+T,aAAX;AACA,YAAIO,eAAe,qBAAcD,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CoV,EAA/C,EAAmDN,0BAA0BnU,EAAEkI,UAA5B,CAAnD,CAAnB;AACA,YAAIwM,MAAM,qBAAcF,iBAAd,CAAgCnV,KAAhC,EAAuC,GAAvC,EAA4CoV,EAA5C,CAAV;AACA,eAAO,qBAAcJ,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CiV,YAA/C,EAA6DI,GAA7D,CAAP;AACD,OARM,MAQA;AACL,YAAID,KAAKzU,EAAE+T,aAAX;AACA,YAAIO,eAAe,qBAAcD,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CoV,EAA/C,EAAmDN,0BAA0BnU,EAAEkI,UAA5B,CAAnD,CAAnB;AACA,YAAIwM,MAAM,qBAAcF,iBAAd,CAAgCnV,KAAhC,EAAuC,GAAvC,EAA4CoV,EAA5C,CAAV;AACA,YAAIP,cAAc,qBAAcG,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CqV,GAA/C,EAAoDP,0BAA0BnU,EAAEiI,SAA5B,CAApD,CAAlB;AACA,eAAO,qBAAcoM,mBAAd,CAAkChV,KAAlC,EAAyC,IAAzC,EAA+CiV,YAA/C,EAA6DJ,WAA7D,CAAP;AACD;AACF;AACF;;AAEDS,kCAAgCC,eAAhC,EAAwF;AACtF,QAAIA,oBAAoBpX,SAAxB,EAAmC;AACnC;AACA,6BAAUoX,gBAAgB5M,YAAhB,KAAiCxK,SAA3C;AACA,QAAI,KAAK6K,eAAL,KAAyB7K,SAA7B,EAAwC;AACtC;AACA;AACA;AACA;AACA;AACA,+BAAU,KAAKL,gBAAL,KAA0BK,SAApC;AACA,WAAK6K,eAAL,GAAuBuM,eAAvB;AACD,KARD,MAQO;AACL,UAAI5M,eAAe,KAAKK,eAAL,CAAqBL,YAAxC;AACA,+BAAUA,iBAAiBxK,SAA3B;AACA,WAAKyR,YAAL,CAAkBjH,aAAa7K,gBAA/B;AACA,WAAKsP,iBAAL,CAAuBzE,aAAa5K,kBAApC;AACA,uBAAKyQ,mDAAL,CAAyD,IAAzD,EAA+D+G,eAA/D,EAAgF5M,YAAhF;AACA,WAAKwE,YAAL,CAAkBxE,aAAa7K,gBAA/B;AACA,WAAKsP,iBAAL,CAAuBzE,aAAa5K,kBAApC;AACA,+BAAU,KAAKiL,eAAL,KAAyB7K,SAAnC;AACA,WAAK6K,eAAL,CAAqBL,YAArB,GAAoCxK,SAApC;AACA,WAAK6K,eAAL,GAAuB,iBAAKsL,gCAAL,CAAsC,IAAtC,EAA4CiB,eAA5C,EAA6D,KAAKvM,eAAlE,CAAvB;AACD;AACF;;AAEDmL,iBAAe/V,UAAf,EAA2D;AACzD,6BAAUA,WAAWuK,YAAX,KAA4BxK,SAAtC;AACAC,eAAWuK,YAAX,GAA0B,IAAIrL,OAAJ,CACxB,wCAA2B,KAAKoD,UAAL,CAAgBvC,SAA3C,CADwB,EAEvB,KAAKV,SAFkB,EAGvB,KAAKK,gBAHkB,EAIvB,KAAKC,kBAJkB,EAKvB,KAAKH,cALkB,CAA1B;AAOA,SAAKH,SAAL,GAAiB,yBAAc,IAAd,EAAoB,UAApB,EAAgC,KAAKoD,cAArC,CAAjB;AACA,SAAK/C,gBAAL,GAAwB,IAAIgD,GAAJ,EAAxB;AACA,SAAK/C,kBAAL,GAA0B,IAAI+C,GAAJ,EAA1B;AACA,SAAKlD,cAAL,GAAsB,IAAImD,GAAJ,EAAtB;AACD;;AAEDuN,qBAAmBwD,IAAY,KAAKpR,UAAL,CAAgBvC,SAA/C,EAAmE;AACjE,6BAAU,KAAKV,SAAL,KAAmBU,SAA7B;AACA,6BAAU,KAAKL,gBAAL,KAA0BK,SAApC;AACA,6BAAU,KAAKJ,kBAAL,KAA4BI,SAAtC;AACA,6BAAU,KAAKP,cAAL,KAAwBO,SAAlC;AACA,WAAO,IAAIb,OAAJ,CACL,wCAA2BwU,CAA3B,CADK,EAEL,KAAKrU,SAFA,EAGL,KAAKK,gBAHA,EAIL,KAAKC,kBAJA,EAKL,KAAKH,cALA,CAAP;AAOD;;AAED2Q,kCAAgCnQ,UAAhC,EAA4E;AAC1E;AACA,SAAK+O,YAAL,CAAkB,KAAKrP,gBAAvB;AACA,SAAKsP,iBAAL,CAAuB,KAAKrP,kBAA5B;;AAEA;AACA,QAAIK,WAAWuK,YAAX,KAA4BxK,SAAhC,EAA2C;AACzC,YAAMwK,eAAevK,WAAWuK,YAAhC;AACAvK,iBAAWuK,YAAX,GAA0BxK,SAA1B;AACA,WAAKV,SAAL,GAAiBkL,aAAalL,SAA9B;AACA,WAAKK,gBAAL,GAAwB6K,aAAa7K,gBAArC;AACA,WAAKC,kBAAL,GAA0B4K,aAAa5K,kBAAvC;AACA,WAAKH,cAAL,GAAsB+K,aAAa/K,cAAnC;AACD,KAPD,MAOO;AACL,+BAAU,KAAV;AACD;AACF;;AAED;AACAsP,eAAahP,OAAb,EAA+BsX,iBAAyB,EAAxD,EAA4DC,kBAA2B,IAAvF,EAAmG;AACjG,6BACEvX,QAAQF,YADV,EAEE,kGAFF;AAIAE,YAAQF,YAAR,GAAuB,KAAvB;AACA,QAAI,EAAEP,SAAF,EAAaK,gBAAb,EAA+BC,kBAA/B,EAAmDH,cAAnD,KAAsEM,OAA1E;;AAEA;AACA,QAAIuX,eAAJ,EAAqB,KAAKA,eAAL,CAAqBhY,SAArB,EAAgC+X,cAAhC;;AAErB;AACA,SAAK5F,YAAL,CAAkB9R,gBAAlB;AACA,SAAKsP,iBAAL,CAAuBrP,kBAAvB;;AAEA;AACA,QAAI2X,wBAAwB,KAAK5X,gBAAjC;AACA,QAAI4X,0BAA0BvX,SAA9B,EAAyC;AACvCL,uBAAiB0J,OAAjB,CAAyB,CAACiK,GAAD,EAAMzK,GAAN,EAAWqK,CAAX,KAAiB;AACxC,iCAAUqE,0BAA0BvX,SAApC;AACA,YAAI,CAACuX,sBAAsB3M,GAAtB,CAA0B/B,GAA1B,CAAL,EAAqC;AACnC0O,gCAAsBxK,GAAtB,CAA0BlE,GAA1B,EAA+ByK,GAA/B;AACD;AACF,OALD;AAMD;AACD,QAAIkE,0BAA0B,KAAK5X,kBAAnC;AACA,QAAI4X,4BAA4BxX,SAAhC,EAA2C;AACzCJ,yBAAmByJ,OAAnB,CAA2B,CAAC2J,IAAD,EAAOC,eAAP,EAAwBC,CAAxB,KAA8B;AACvD,iCAAUsE,4BAA4BxX,SAAtC;AACA,YAAI,CAACwX,wBAAwB5M,GAAxB,CAA4BqI,eAA5B,CAAL,EAAmD;AACjDuE,kCAAwBzK,GAAxB,CAA4BkG,eAA5B,EAA6CD,IAA7C;AACD;AACF,OALD;AAMD;;AAED;AACA,QAAIvT,eAAeuN,IAAf,GAAsB,CAA1B,EAA6B;AAC3B,UAAIyK,sBAAsB,KAAKhY,cAA/B;AACA,UAAIgY,wBAAwBzX,SAA5B,EAAuC,KAAKP,cAAL,GAAsB,IAAImD,GAAJ,CAAQnD,cAAR,CAAtB,CAAvC,KACK;AACHA,uBAAe4J,OAAf,CAAuB,CAACsM,EAAD,EAAKC,CAAL,KAAW;AAChC,mCAAU6B,wBAAwBzX,SAAlC;AACAyX,8BAAoB5B,GAApB,CAAwBF,EAAxB;AACD,SAHD;AAID;AACF;AACF;;AAED+B,kBAAgBC,MAAhB,EAA4C7J,IAA5C,EAAuF;AACrF,QAAI,KAAK7L,UAAT,EAAqB;AACnB;AACA,YAAM,uBAAe,oDAAf,CAAN;AACD;AACD,QAAI,KAAKsB,yBAAT,EAAoC;AAClC,+BAAU,KAAKjE,SAAL,KAAmBU,SAA7B;AACA,WAAKV,SAAL,CAAesY,cAAf,CAA8BD,MAA9B,EAAsC7J,IAAtC;AACD,KAHD,MAGO;AACL;AACA+J,cAAQF,MAAR,EAAgBG,UAAU,IAAV,EAAgBhK,IAAhB,CAAhB;AACD;;AAED,aAASgK,SAAT,CAAmBjW,KAAnB,EAAiCsQ,MAAjC,EAAwE;AACtE,UAAI4F,MAAM,EAAV;AACA,aAAO5F,OAAOtI,MAAd,EAAsB;AACpB,YAAImO,OAAO7F,OAAO8F,KAAP,EAAX;AACA,YAAIC,aAAa,eAAGC,QAAH,CAAYtW,KAAZ,EAAmBmW,IAAnB,CAAjB;AACAD,eAAOG,UAAP;AACD;AACD,aAAOH,GAAP;AACD;AACF;;AAED;AACA;AACAK,wBAAsBhN,OAAtB,EAAwCrJ,KAAxC,EAAgE;AAC9D,UAAMsW,wBAAwBC,QAAQ;AACpC,UAAIlX,UAAU,KAAK0I,iBAAL,EAAd;AACA,UAAI,EAAE1H,oBAAoBoM,GAAtB,EAA2B/M,UAAUoN,IAArC,KAA8CzN,OAAlD;;AAEA,+BAAUyN,oCAAV;AACA,UAAIyJ,0DAA6CzJ,SAASyJ,KAAK7M,eAA/D,EAAgF;AAC9E,eAAO,IAAP;AACD;AACD,UAAI,KAAKkC,6BAAL,KAAuC3N,SAAvC,IAAoD,CAAC,KAAK2N,6BAAL,CAAmC/C,GAAnC,CAAuCiE,IAAvC,CAAzD,EAAuG;AACrG,eAAO,KAAP;AACD;AACDL,YAAMA,IAAInD,MAAV;AACA,aAAOmD,GAAP,EAAY;AACV,YAAIA,IAAIrM,iBAAJ,KAA0BmW,IAA9B,EAAoC;AAClC,iBAAO,IAAP;AACD;AACD9J,cAAMA,IAAInD,MAAV;AACD;AACD,aAAO,KAAP;AACD,KAnBD;;AAqBA,QACE,KAAK1L,gBAAL,KAA0BK,SAA1B,IACA,CAAC,KAAKL,gBAAL,CAAsBiL,GAAtB,CAA0BQ,OAA1B,CADD,IAEArJ,UAAU/B,SAFV,IAGA,KAAK+N,aAAL,EAHA,IAIA,KAAKF,wBAAL,KAAkC7N,SALpC,EAME;AACA,UAAIwO,MAAMpD,QAAQI,WAAlB;;AAEA,UACE,EAAEgD,wDAAF,KACCA,4DAA+C,CAAC6J,sBAAsB7J,GAAtB,CAFnD,EAGE;AACA,aAAKX,wBAAL,CAA8B,kBAA9B,EAAkDzC,OAAlD,EAA2DrJ,MAAMwW,kBAAjE;AACD;AACF;;AAED,QAAInN,QAAQI,WAAR,CAAoBvJ,UAAxB,EAAoC;AAClC;AACA,YAAM,uBAAe,+CAAf,CAAN;AACD;;AAED,QAAI,KAAKtC,gBAAL,KAA0BK,SAA1B,IAAuC,CAAC,KAAKL,gBAAL,CAAsBiL,GAAtB,CAA0BQ,OAA1B,CAA5C,EAAgF;AAC9E,WAAKzL,gBAAL,CAAsBoN,GAAtB,CAA0B3B,OAA1B,EAAmC;AACjCoN,mBAAWxY,SADsB;AAEjC+B,eAAO/B,SAF0B;AAGjCyY,2BAAmBrN,QAAQoN,SAHM;AAIjCE,uBAAetN,QAAQrJ;AAJU,OAAnC;AAMD;AACD,WAAOqJ,OAAP;AACD;;AAEDuN,mCAAiChD,EAAjC,EAAwD;AACtD,QAAI,KAAKiD,4BAAL,KAAsC5Y,SAA1C,EAAqD;AACnD,WAAK4Y,4BAAL,CAAkCjD,EAAlC;AACD;AACF;;AAEDkD,2BAAyBzN,OAAzB,EAAyD;AACvD,QAAI,KAAK0N,oBAAL,KAA8B9Y,SAAlC,EAA6C;AAC3C,WAAK8Y,oBAAL,CAA0B1N,OAA1B;AACD;AACF;;AAED;AACA;AACA2N,yBAAuB3N,OAAvB,EAA8D;AAC5D,QAAIA,YAAYpL,SAAhB,EAA2B;AAC3B,QAAI,KAAK+N,aAAL,EAAJ,EAA0B;AACxB,UAAI5B,SAASf,QAAQe,MAArB;AACA,+BAAUA,oCAAV;AACA,YAAMwB,gCAAgC,KAAKA,6BAA3C;;AAEA,UAAIA,kCAAkC3N,SAAlC,IAA+C,CAAC2N,8BAA8B/C,GAA9B,CAAkCuB,MAAlC,CAApD,EAA+F;AAC7F,YAAIf,QAAQe,MAAR,KAAmB,KAAK5G,aAA5B,EAA2C;AACzC,eAAKsI,wBAAL,IACE,KAAKA,wBAAL,CAA8B,iBAA9B,EAAiDzC,OAAjD,EAA0De,OAAOoM,kBAAjE,CADF;AAED,SAHD,MAGO;AACL,eAAK1K,wBAAL,IACE,KAAKA,wBAAL,CAA8B,mBAA9B,EAAmDzC,OAAnD,EAA4De,OAAOoM,kBAAnE,CADF;AAED;AACF;AACF;AACD,QAAI,KAAKtW,UAAL,KAAoB,KAAK6H,iBAAL,GAAyB7H,UAAzB,IAAuC,CAAC,KAAK+W,WAAL,CAAiB5N,QAAQe,MAAzB,CAA5D,CAAJ,EAAmG;AACjG;AACA,YAAM,uBAAe,gDAAf,CAAN;AACD;AACD,SAAK0M,wBAAL,CAA8BzN,OAA9B;AACA,QAAI,KAAKxL,kBAAL,KAA4BI,SAA5B,IAAyC,CAAC,KAAKJ,kBAAL,CAAwBgL,GAAxB,CAA4BQ,OAA5B,CAA9C,EAAoF;AAClF,WAAKxL,kBAAL,CAAwBmN,GAAxB,CAA4B3B,OAA5B,EAAqC,6BAAgBA,QAAQwB,UAAxB,CAArC;AACD;AACF;;AAEDoM,cAAY7M,MAAZ,EAAgE;AAC9D,QAAIA,4CAAJ,EAA2C,OAAO,KAAP;AAC3C,WAAO,KAAK1M,cAAL,KAAwBO,SAAxB,IAAqC,KAAKP,cAAL,CAAoBmL,GAApB,CAAwBuB,MAAxB,CAA5C;AACD;;AAED8M,kBAAgB9M,MAAhB,EAA2C;AACzC,QAAI,KAAK1M,cAAL,KAAwBO,SAA5B,EAAuC;AACrC,WAAKP,cAAL,CAAoBoW,GAApB,CAAwB1J,MAAxB;AACD;AACD,QAAI,KAAKwB,6BAAL,KAAuC3N,SAA3C,EAAsD;AACpD,WAAK2N,6BAAL,CAAmCkI,GAAnC,CAAuC1J,MAAvC;AACD;AACF;;AAED;AACA;AACAwD,4BAAsE;AACpE,QAAItQ,SAAS,CAAC,KAAKM,gBAAN,EAAwB,KAAKC,kBAA7B,CAAb;AACA,SAAKD,gBAAL,GAAwB,IAAIgD,GAAJ,EAAxB;AACA,SAAK/C,kBAAL,GAA0B,IAAI+C,GAAJ,EAA1B;AACA,WAAOtD,MAAP;AACD;;AAEDoS,eAAa9R,gBAAb,EAAsD;AACpD,QAAIA,qBAAqBK,SAAzB,EAAoC;AACpCL,qBAAiB0J,OAAjB,CAAyB,CAAC,EAAEmP,SAAF,EAAazW,KAAb,EAAD,EAAuBqJ,OAAvB,EAAgC8H,CAAhC,KAAsC;AAC7D9H,cAAQoN,SAAR,GAAoBA,aAAa,KAAjC;AACApN,cAAQrJ,KAAR,GAAgBA,KAAhB;AACD,KAHD;AAID;;AAEDiN,eAAarP,gBAAb,EAAsD;AACpD,QAAIA,qBAAqBK,SAAzB,EAAoC;AACpCL,qBAAiB0J,OAAjB,CAAyB,CAAC6P,KAAD,EAAQ9N,OAAR,EAAiB8H,CAAjB,KAAuB;AAC9C,UAAIgG,MAAMV,SAAN,KAAoBxY,SAAxB,EAAmCkZ,MAAMV,SAAN,GAAkBpN,QAAQoN,SAA1B;AACnC,UAAIU,MAAMnX,KAAN,KAAgB/B,SAApB,EAA+BkZ,MAAMnX,KAAN,GAAcqJ,QAAQrJ,KAAtB;AAC/BqJ,cAAQoN,SAAR,GAAoBU,MAAMT,iBAAN,IAA2B,KAA/C;AACArN,cAAQrJ,KAAR,GAAgBmX,MAAMR,aAAtB;AACD,KALD;AAMD;;AAED;AACA;AACA;AACAzJ,oBAAkBrP,kBAAlB,EAAqE;AACnE,QAAIA,uBAAuBI,SAA3B,EAAsC;AACtCJ,uBAAmByJ,OAAnB,CAA2B,CAAC2J,IAAD,EAAOC,eAAP,EAAwBC,CAAxB,KAA8B;AACvD,UAAIpC,IAAImC,gBAAgBrG,UAAxB;AACAqG,sBAAgBrG,UAAhB,GAA6BoG,IAA7B;AACAE,QAAEnG,GAAF,CAAMkG,eAAN,EAAuBnC,CAAvB;AACD,KAJD;AAKD;;AAED;AACA;AACAqI,kBAAgBxZ,gBAAhB,EAAmDC,kBAAnD,EAAsG;AACpG,SAAKD,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACD;;AAEDwZ,wBAAsBjN,MAAtB,EAAqCtD,GAArC,EAAkDwQ,aAAlD,EAAwE1E,IAAxE,EAA4F;AAC1F,QAAI,EAAE0E,6CAAF,CAAJ,EAA+C;AAC/C,QAAIA,cAAcC,IAAd,KAAuB,uBAA3B,EAAoD;AAClD,UAAIC,SAASF,cAAcvL,IAAd,CAAmB0L,IAAnB,CAAwBrQ,KAAKA,iCAA7B,CAAb;AACA,+BAAUoQ,sCAAV;AACAF,sBAAgBE,MAAhB;AACD;AACD,QAAI,CAACF,cAAcI,WAAd,EAAL,EAAkC;AAChCJ,oBAAc/M,aAAd,GAA+B,GAAEqI,IAAK,IAAG9L,GAAI,EAA7C;AACAwQ,oBAAcC,IAAd,GAAqB,iBAArB;AACAD,oBAAcvL,IAAd,GAAqB,CAAC3B,MAAD,CAArB;AACAkN,oBAAc9F,UAAd,GAA2B,CAAC,CAACpE,IAAD,CAAD,KACzBlQ,EAAEya,iBAAF,CAAoB7Q,GAApB,IACI5J,EAAE0a,gBAAF,CAAmBxK,IAAnB,EAAyBlQ,EAAE8V,UAAF,CAAalM,GAAb,CAAzB,EAA4C,KAA5C,CADJ,GAEI5J,EAAE0a,gBAAF,CAAmBxK,IAAnB,EAAyBlQ,EAAEsV,aAAF,CAAgB1L,GAAhB,CAAzB,EAA+C,IAA/C,CAHN;AAIA,WAAK+Q,uBAAL,CAA6BP,aAA7B,EAA4CA,cAAc/M,aAA1D;AACD;AACF;;AAEDsN,0BAAwBC,aAAxB,EAAuElF,IAAvE,EAA2F;AACzF,QAAI,EAAEkF,mDAAF,CAAJ,EAAqD;AACrD,QAAIA,cAAc1H,MAAd,CAAqB2H,KAArB,EAAJ,EAAkC;AAClC,QAAIC,WAAWF,cAAcG,WAAd,EAAf;AACA,6BAAU,CAACD,SAASzN,aAAV,IAA2ByN,SAASzN,aAAT,KAA2BqI,IAAhE;AACAoF,aAASzN,aAAT,GAAyBqI,IAAzB;AACAoF,aAASE,sBAAT,GAAkC,IAAlC;AACA,SAAK,IAAI,CAACpR,GAAD,EAAMuC,OAAN,CAAT,IAA2B2O,SAAStN,UAApC,EAAgD;AAC9C,UAAIrB,YAAYpL,SAAZ,IAAyBoL,QAAQwB,UAAR,KAAuB5M,SAApD,EAA+D,SADjB,CAC2B;AACzE,+BAAUoL,QAAQwB,UAAR,KAAuB5M,SAAjC;AACA,UAAI+B,QAAQqJ,QAAQwB,UAAR,CAAmB7K,KAA/B;AACA,6BAAWmY,2BAAX,CAAuCnY,KAAvC;AACA,UAAIA,UAAU/B,SAAd,EAAyB;AACvB,6BAAcma,wBAAd,CAAuCN,aAAvC,EAAsDhR,GAAtD;AACA,cAAM,wBAAN;AACD;AACD,+BAAU9G,6BAAV;AACA,WAAKqX,qBAAL,CAA2BS,aAA3B,EAA0ChR,GAA1C,EAA+C9G,KAA/C,EAAsD4S,IAAtD;AACD;AACF;;AAEDyF,2BAA2C;AACzC,QAAIhZ,UAAU,IAAIF,gBAAJ,EAAd;AACA,QAAIS,MAAM,KAAK0Y,mBAAf;AACA,QAAI1Y,GAAJ,EAAS;AACPP,cAAQM,WAAR,CAAoBC,GAApB;AACA,WAAK0Y,mBAAL,GAA2B,IAA3B;AACD;AACD,WAAOjZ,OAAP;AACD;;AAEDkZ,kCAAgC3Y,GAAhC,EAAyF;AACvF,QAAI+W,gBAAgB,KAAK2B,mBAAzB;AACA,SAAKA,mBAAL,GAA2B1Y,GAA3B;AACA,WAAO+W,aAAP;AACD;;AAEDyB,2BAAyBI,OAAzB,EAAsE;AACpE,QAAIA,YAAYva,SAAhB,EAA2Bua,UAAU,EAAV;AAC3B,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiCA,UAAU,uBAAgB,IAAhB,EAAsBA,OAAtB,CAAV;AACjC,6BAAUA,qCAAV;AACA,SAAKF,mBAAL,GAA2B,KAAK3Q,eAAhC;AACA,QAAID,QAAQ,+BAAuB8Q,QAAQxY,KAA/B,EAAsC,KAAK2H,eAA3C,EAA4D,QAA5D,EAAsE,YAAtE,CAAZ;AACA,SAAKC,WAAL,CAAiBF,KAAjB;AACD;;AAED+Q,6BAA2BC,IAA3B,EAAsDF,OAAtD,EAA8G;AAC5G,6BAAUE,SAAS,KAAKlY,UAAL,CAAgBmY,oBAAnC;AACA,QAAIH,YAAYva,SAAhB,EAA2Bua,UAAU,EAAV;AAC3B,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiCA,UAAU,uBAAgB,IAAhB,EAAsBA,OAAtB,CAAV;AACjC,6BAAUA,qCAAV;AACA,SAAKF,mBAAL,GAA2B,KAAK3Q,eAAhC;AACA,WAAO,iCAAoB,uBAAU,IAAV,EAAgB+Q,IAAhB,EAAsB,CAACF,OAAD,CAAtB,CAApB,EAAsDva,SAAtD,EAAiE,KAAK0J,eAAtE,CAAP;AACD;;AAED4N,kBAAgBhY,SAAhB,EAAsC+X,iBAAyB,EAA/D,EAAyE;AACvE,QAAIsD,iBAAiB,KAAKrb,SAA1B;AACA,QAAIqb,mBAAmB3a,SAAvB,EAAkC;AAChC,+BAAUV,UAAUmD,KAAV,EAAV;AACA;AACD;AACDkY,mBAAerD,eAAf,CAA+BhY,SAA/B,EAA0C+X,cAA1C;AACD;;AAED;AACA;AACA;AACA;AACAuD,qCACEnF,YADF,EAEEjI,CAFF,EAGEiB,aAHF,EAIW;AACT,WAAO,KAAKC,kBAAL,CACL,MAAM;AACJ,WAAK,IAAImM,WAAT,IAAwBpF,YAAxB,EAAsC,KAAK1G,YAAL,CAAkB8L,WAAlB;AACtC,UAAI;AACF,eAAOrN,GAAP;AACD,OAFD,SAEU;AACR,aAAK,IAAIqN,WAAT,IAAwBpF,YAAxB,EAAsC;AACpC,mCAAU,CAACoF,YAAYhb,YAAvB;AACAgb,sBAAYhb,YAAZ,GAA2B,IAA3B;AACD;AACF;AACF,KAXI,EAYLG,SAZK,EAaLyO,aAbK,CAAP;AAeD;;AAED;AACA;AACA9E,cAAYuH,UAAZ,EAAgE;AAC9D,QAAI,CAACA,WAAW4J,SAAZ,IAAyB,KAAK9X,YAAL,CAAkB6G,MAAlB,GAA2B,CAAxD,EAA2D;AACzD,UAAIJ,QAAQ,uBAAU,IAAV,EAAgB,KAAKlH,UAAL,CAAgBwY,KAAhC,CAAZ;AACA,UAAIC,QAAQvR,MAAMwR,yBAAN,CAAgC,OAAhC,CAAZ;AACA,UAAID,mCAAJ,EAAkC9J,WAAW4J,SAAX,GAAuBE,MAAMjZ,KAA7B;AACnC;;AAED;AACA;AACA,QAAI,KAAKmZ,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBC,qBAAtB,CAA4CjK,WAAWH,QAAvD,CAA7B,EAA+F;AAC7F,WAAKmK,gBAAL,CAAsBE,kBAAtB,CAAyClK,UAAzC;AACD;;AAED;AACA,QAAI5I,eAAe,KAAKA,YAAxB;AACA,QAAI,CAACA,YAAL,EAAmB;AACjB,UAAI+S,MAAO,GAAEnK,WAAWoK,SAAU,KAAIpK,WAAWqJ,OAAQ,EAAzD;AACA,UAAIrJ,WAAWqK,QAAf,EAAyB;AACvB,YAAIC,YAAYtK,WAAWqK,QAAX,CAAoB/W,KAApC;AACA,YAAIiX,UAAUvK,WAAWqK,QAAX,CAAoBG,GAAlC;AACAL,eAAQ,OAAMG,UAAUG,IAAK,IAAGH,UAAUI,MAAO,OAAMH,QAAQE,IAAK,IAAGF,QAAQG,MAAO,EAAtF;AACD;AACD,UAAI;AACF,gBAAQ1K,WAAWH,QAAnB;AACE,eAAK,aAAL;AACE8G,oBAAQgE,GAAR,CAAa,SAAQR,GAAI,EAAzB;AACA,mBAAO,SAAP;AACF,eAAK,SAAL;AACExD,oBAAQiE,IAAR,CAAc,SAAQT,GAAI,EAA1B;AACA,mBAAO,SAAP;AACF,eAAK,kBAAL;AACExD,oBAAQpO,KAAR,CAAe,UAAS4R,GAAI,EAA5B;AACA,mBAAO,MAAP;AACF,eAAK,YAAL;AACExD,oBAAQpO,KAAR,CAAe,gBAAe4R,GAAI,EAAlC;AACA,mBAAO,MAAP;AACF;AACE,qCAAU,KAAV,EAAiB,uBAAjB;AAdJ;AAgBD,OAjBD,SAiBU;AACRxD,gBAAQgE,GAAR,CAAY3K,WAAW4J,SAAvB;AACD;AACF;AACD,WAAOxS,aAAa4I,UAAb,EAAyB,KAAKhO,mBAA9B,CAAP;AACD;;AAED6Y,iBAAeC,UAAf,EAAyC;AACvC,SAAKvT,sBAAL,CAA4BoN,GAA5B,CAAgCmG,UAAhC;AACD;;AAEDC,qBAAmBD,UAAnB,EAAgD;AAC9C,WAAO,CAAC,KAAKvT,sBAAL,CAA4BmC,GAA5B,CAAgCoR,UAAhC,CAAR;AACD;;AAEDE,4CAA0Cna,KAA1C,EAAuF;AACrF,QAAIoI,OAAOpI,MAAMuK,aAAjB;AACA,QAAI,CAACnC,IAAL,EAAW;AACT,aAAOnK,SAAP;AACD;AACD,QAAImc,yBAAyBpa,MAAMqa,MAAN,CAAavW,UAAb,CAAwB6G,GAAxB,CAA4BvC,IAA5B,CAA7B;AACA,WAAOgS,sBAAP;AACD;;AAEDE,4CAA0CC,GAA1C,EAAgH;AAC9G,WAAO,KAAKxW,yBAAL,CAA+B4G,GAA/B,CAAmC4P,GAAnC,CAAP;AACD;;AAEDC,iCAA+BJ,sBAA/B,EAAqF;AACnF,QAAIrO,OAAOqO,uBAAuBrO,IAAlC;AACA,SAAK,IAAIwO,GAAT,IAAgBxO,IAAhB,EAAsB;AACpB,UAAI0O,kBAAkB,KAAK1W,yBAAL,CAA+B4G,GAA/B,CAAmC4P,GAAnC,CAAtB;;AAEA,UAAIE,oBAAoBxc,SAAxB,EAAmC;AACjCwc,0BAAkB,IAAI5Z,GAAJ,EAAlB;AACA,aAAKkD,yBAAL,CAA+BiH,GAA/B,CAAmCuP,GAAnC,EAAwCE,eAAxC;AACD;AACDA,sBAAgB3G,GAAhB,CAAoBsG,sBAApB;AACD;AACF;AAzmDgB;QAANtZ,K,GAAAA,K","file":"realm.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  ClassComponentMetadata,\n  ConsoleMethodTypes,\n  DebugServerType,\n  Descriptor,\n  Intrinsics,\n  PropertyBinding,\n  ReactHint,\n} from \"./types.js\";\nimport { RealmStatistics } from \"./statistics.js\";\nimport {\n  CompilerDiagnostic,\n  type ErrorHandlerResult,\n  type ErrorHandler,\n  FatalError,\n  InfeasiblePathError,\n} from \"./errors.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BoundFunctionValue,\n  ConcreteValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport type { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport {\n  LexicalEnvironment,\n  Reference,\n  GlobalEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n} from \"./environment.js\";\nimport type { Binding } from \"./environment.js\";\nimport { cloneDescriptor, Construct } from \"./methods/index.js\";\nimport {\n  AbruptCompletion,\n  Completion,\n  ForkedAbruptCompletion,\n  PossiblyNormalCompletion,\n  SimpleNormalCompletion,\n  ThrowCompletion,\n} from \"./completions.js\";\nimport type { Compatibility, RealmOptions, ReactOutputTypes, InvariantModeTypes } from \"./options.js\";\nimport invariant from \"./invariant.js\";\nimport seedrandom from \"seedrandom\";\nimport { Generator, PreludeGenerator, type TemporalBuildNodeEntry } from \"./utils/generator.js\";\nimport { emptyExpression, voidExpression } from \"./utils/babelhelpers.js\";\nimport { Environment, Functions, Join, Properties, To, Widen, Path } from \"./singletons.js\";\nimport type { ReactSymbolTypes } from \"./react/utils.js\";\nimport type { BabelNode, BabelNodeSourceLocation, BabelNodeLVal, BabelNodeStatement } from \"babel-types\";\nimport * as t from \"babel-types\";\n\nexport type BindingEntry = {\n  hasLeaked: void | boolean,\n  value: void | Value,\n  previousHasLeaked: void | boolean,\n  previousValue: void | Value,\n};\nexport type Bindings = Map<Binding, BindingEntry>;\nexport type EvaluationResult = Completion | Reference;\nexport type PropertyBindings = Map<PropertyBinding, void | Descriptor>;\n\nexport type CreatedObjects = Set<ObjectValue>;\n\nexport type SideEffectType = \"MODIFIED_BINDING\" | \"MODIFIED_PROPERTY\" | \"EXCEPTION_THROWN\" | \"MODIFIED_GLOBAL\";\n\nlet effects_uid = 0;\n\nexport class Effects {\n  constructor(\n    result: Completion,\n    generator: Generator,\n    bindings: Bindings,\n    propertyBindings: PropertyBindings,\n    createdObjects: CreatedObjects\n  ) {\n    this._result = result;\n    this.generator = generator;\n    this.modifiedBindings = bindings;\n    this.modifiedProperties = propertyBindings;\n    this.createdObjects = createdObjects;\n\n    this.canBeApplied = true;\n    this._id = effects_uid++;\n    if (result.effects === undefined) result.effects = this; //todo: require callers to ensure this\n  }\n\n  _result: Completion;\n  get result(): Completion {\n    return this._result;\n  }\n  set result(completion: Completion): void {\n    if (completion.effects === undefined) completion.effects = this; //todo: require callers to ensure this\n    this._result = completion;\n  }\n\n  generator: Generator;\n  modifiedBindings: Bindings;\n  modifiedProperties: PropertyBindings;\n  createdObjects: CreatedObjects;\n  canBeApplied: boolean;\n  _id: number;\n}\n\nexport class Tracer {\n  beginEvaluateForEffects(state: any): void {}\n  endEvaluateForEffects(state: any, effects: void | Effects): void {}\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {}\n  beforeCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue\n  ): void {}\n  afterCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    result: void | Reference | Value | AbruptCompletion\n  ): void {}\n  beginOptimizingFunction(optimizedFunctionId: number, functionValue: FunctionValue): void {}\n  endOptimizingFunction(optimizedFunctionId: number): void {}\n}\n\nexport class ExecutionContext {\n  function: ?FunctionValue;\n  caller: ?ExecutionContext;\n  loc: ?BabelNodeSourceLocation;\n  ScriptOrModule: any;\n  realm: Realm;\n  variableEnvironment: LexicalEnvironment;\n  lexicalEnvironment: LexicalEnvironment;\n  isReadOnly: boolean;\n  isStrict: boolean;\n\n  setCaller(context: ExecutionContext): void {\n    this.caller = context;\n  }\n\n  setFunction(F: null | FunctionValue): void {\n    if (F instanceof ECMAScriptSourceFunctionValue) this.isStrict = F.$Strict;\n    this.function = F;\n  }\n\n  setLocation(loc: null | BabelNodeSourceLocation): void {\n    if (!loc) return;\n    this.loc = loc;\n  }\n\n  setRealm(realm: Realm): void {\n    this.realm = realm;\n  }\n\n  /*\n   Read-only envs disallow:\n   - creating bindings in their scope\n   - creating or modifying objects when they are current running context\n  */\n  setReadOnly(value: boolean): boolean {\n    let oldReadOnly = this.isReadOnly;\n    if (this.variableEnvironment) this.variableEnvironment.environmentRecord.isReadOnly = value;\n    if (this.lexicalEnvironment) this.lexicalEnvironment.environmentRecord.isReadOnly = value;\n    this.isReadOnly = value;\n    return oldReadOnly;\n  }\n\n  suspend(): void {\n    // TODO #712: suspend\n  }\n\n  resume(): Value {\n    // TODO #712: resume\n    return this.realm.intrinsics.undefined;\n  }\n}\n\nexport function construct_empty_effects(\n  realm: Realm,\n  c: Completion = new SimpleNormalCompletion(realm.intrinsics.empty, undefined)\n): Effects {\n  // TODO #2222: Check if `realm.pathConditions` is always correct here.\n  // The path conditions here should probably be empty.\n  // Picking up the current path conditions from the Realm might be the reason why composition does not work.\n  return new Effects(\n    c,\n    new Generator(realm, \"construct_empty_effects\", realm.pathConditions),\n    new Map(),\n    new Map(),\n    new Set()\n  );\n}\n\nexport class Realm {\n  constructor(opts: RealmOptions, statistics: RealmStatistics) {\n    this.statistics = statistics;\n    this.isReadOnly = false;\n    this.useAbstractInterpretation = opts.serialize === true || opts.residual === true || Array.isArray(opts.check);\n    this.ignoreLeakLogic = false;\n    this.isInPureTryStatement = false;\n    if (opts.mathRandomSeed !== undefined) {\n      this.mathRandomGenerator = seedrandom(opts.mathRandomSeed);\n    }\n    this.strictlyMonotonicDateNow = !!opts.strictlyMonotonicDateNow;\n\n    // 0 = disabled\n    this.abstractValueImpliesMax = opts.abstractValueImpliesMax !== undefined ? opts.abstractValueImpliesMax : 0;\n    this.abstractValueImpliesCounter = 0;\n    this.inSimplificationPath = false;\n\n    this.timeout = opts.timeout;\n    if (this.timeout !== undefined) {\n      // We'll call Date.now for every this.timeoutCounterThreshold'th AST node.\n      // The threshold is there to reduce the cost of the surprisingly expensive Date.now call.\n      this.timeoutCounter = this.timeoutCounterThreshold = 1024;\n    }\n\n    this.start = Date.now();\n    this.compatibility = opts.compatibility !== undefined ? opts.compatibility : \"browser\";\n    this.maxStackDepth = opts.maxStackDepth || 225;\n    this.invariantLevel = opts.invariantLevel || 0;\n    this.invariantMode = opts.invariantMode || \"throw\";\n    this.emitConcreteModel = !!opts.emitConcreteModel;\n\n    this.$TemplateMap = [];\n    this.pathConditions = [];\n\n    if (this.useAbstractInterpretation) {\n      this.preludeGenerator = new PreludeGenerator(opts.debugNames, opts.uniqueSuffix);\n      ObjectValue.setupTrackedPropertyAccessors(ObjectValue.trackedPropertyNames);\n      ObjectValue.setupTrackedPropertyAccessors(NativeFunctionValue.trackedPropertyNames);\n      ObjectValue.setupTrackedPropertyAccessors(ProxyValue.trackedPropertyNames);\n    }\n\n    this.tracers = [];\n\n    // These get initialized in construct_realm to avoid the dependency\n    this.intrinsics = ({}: any);\n    this.$GlobalObject = (({}: any): ObjectValue);\n    this.evaluators = (Object.create(null): any);\n    this.partialEvaluators = (Object.create(null): any);\n    this.$GlobalEnv = ((undefined: any): LexicalEnvironment);\n\n    this.derivedIds = new Map();\n    this.temporalEntryArgToEntries = new Map();\n    this.temporalEntryCounter = 0;\n\n    this.instantRender = {\n      enabled: opts.instantRender || false,\n    };\n\n    this.react = {\n      abstractHints: new WeakMap(),\n      activeReconciler: undefined,\n      arrayHints: new WeakMap(),\n      classComponentMetadata: new Map(),\n      currentOwner: undefined,\n      defaultPropsHelper: undefined,\n      emptyArray: undefined,\n      emptyObject: undefined,\n      enabled: opts.reactEnabled || false,\n      hoistableFunctions: new WeakMap(),\n      hoistableReactElements: new WeakMap(),\n      noopFunction: undefined,\n      optimizedNestedClosuresToWrite: [],\n      optimizeNestedFunctions: opts.reactOptimizeNestedFunctions || false,\n      output: opts.reactOutput || \"create-element\",\n      propsWithNoPartialKeyOrRef: new WeakSet(),\n      reactElements: new WeakMap(),\n      reactElementStringTypeReferences: new Map(),\n      reactProps: new WeakSet(),\n      symbols: new Map(),\n      usedReactElementKeys: new Set(),\n      verbose: opts.reactVerbose || false,\n    };\n\n    this.alreadyDescribedLocations = new WeakMap();\n    this.stripFlow = opts.stripFlow || false;\n\n    this.fbLibraries = {\n      other: new Map(),\n      react: undefined,\n      reactDom: undefined,\n      reactDomServer: undefined,\n      reactNative: undefined,\n      reactRelay: undefined,\n    };\n\n    this.errorHandler = opts.errorHandler;\n\n    this.globalSymbolRegistry = [];\n    this.activeLexicalEnvironments = new Set();\n    this._abstractValuesDefined = new Set(); // A set of nameStrings to ensure abstract values have unique names\n    this.debugNames = opts.debugNames;\n    this._checkedObjectIds = new Map();\n  }\n\n  statistics: RealmStatistics;\n  start: number;\n  isReadOnly: boolean;\n  isStrict: boolean;\n  useAbstractInterpretation: boolean;\n  debugNames: void | boolean;\n  isInPureTryStatement: boolean; // TODO(1264): Remove this once we implement proper exception handling in abstract calls.\n  timeout: void | number;\n  mathRandomGenerator: void | (() => number);\n  strictlyMonotonicDateNow: boolean;\n  maxStackDepth: number;\n  invariantLevel: number;\n  invariantMode: InvariantModeTypes;\n  ignoreLeakLogic: boolean;\n  emitConcreteModel: boolean;\n\n  abstractValueImpliesMax: number;\n  abstractValueImpliesCounter: number;\n  inSimplificationPath: boolean;\n\n  modifiedBindings: void | Bindings;\n  modifiedProperties: void | PropertyBindings;\n  createdObjects: void | CreatedObjects;\n  createdObjectsTrackedForLeaks: void | CreatedObjects;\n  reportObjectGetOwnProperties: void | (ObjectValue => void);\n  reportSideEffectCallback:\n    | void\n    | ((sideEffectType: SideEffectType, binding: void | Binding | PropertyBinding, expressionLocation: any) => void);\n  reportPropertyAccess: void | (PropertyBinding => void);\n  savedCompletion: void | PossiblyNormalCompletion;\n\n  activeLexicalEnvironments: Set<LexicalEnvironment>;\n\n  // A list of abstract conditions that are known to be true in the current execution path.\n  // For example, the abstract condition of an if statement is known to be true inside its true branch.\n  pathConditions: Array<AbstractValue>;\n\n  currentLocation: ?BabelNodeSourceLocation;\n  nextContextLocation: ?BabelNodeSourceLocation;\n  contextStack: Array<ExecutionContext> = [];\n  $GlobalEnv: LexicalEnvironment;\n  intrinsics: Intrinsics;\n\n  derivedIds: Map<string, TemporalBuildNodeEntry>;\n  temporalEntryArgToEntries: Map<Value, Set<TemporalBuildNodeEntry>>;\n  temporalEntryCounter: number;\n\n  instantRender: {\n    enabled: boolean,\n  };\n  react: {\n    // reactHints are generated to help improve the effeciency of the React reconciler when\n    // operating on a tree of React components. We can use reactHint to mark AbstractValues\n    // with extra data that helps us traverse through the tree that would otherwise not be possible\n    // (for example, when we use Relay's React containers with \"fb-www\"  which are AbstractObjectValues,\n    // we need to know what React component was passed to this AbstractObjectValue so we can visit it next)\n    abstractHints: WeakMap<AbstractValue | ObjectValue, ReactHint>,\n    activeReconciler: any, // inentionally \"any\", importing the React reconciler class increases Flow's cylic count\n    arrayHints: WeakMap<ArrayValue, { func: Value, thisVal: Value }>,\n    classComponentMetadata: Map<ECMAScriptSourceFunctionValue, ClassComponentMetadata>,\n    currentOwner?: ObjectValue,\n    defaultPropsHelper?: ECMAScriptSourceFunctionValue,\n    emptyArray: void | ArrayValue,\n    emptyObject: void | ObjectValue,\n    enabled: boolean,\n    hoistableFunctions: WeakMap<FunctionValue, boolean>,\n    hoistableReactElements: WeakMap<ObjectValue, boolean>,\n    noopFunction: void | ECMAScriptSourceFunctionValue,\n    optimizedNestedClosuresToWrite: Array<{\n      effects: Effects,\n      func: ECMAScriptSourceFunctionValue | BoundFunctionValue,\n    }>,\n    optimizeNestedFunctions: boolean,\n    output?: ReactOutputTypes,\n    propsWithNoPartialKeyOrRef: WeakSet<ObjectValue | AbstractObjectValue>,\n    reactElements: WeakMap<ObjectValue, { createdDuringReconcilation: boolean, firstRenderOnly: boolean }>,\n    reactElementStringTypeReferences: Map<string, AbstractValue>,\n    reactProps: WeakSet<ObjectValue>,\n    symbols: Map<ReactSymbolTypes, SymbolValue>,\n    usedReactElementKeys: Set<string>,\n    verbose: boolean,\n  };\n  alreadyDescribedLocations: WeakMap<FunctionValue | BabelNodeSourceLocation, string | void>;\n  stripFlow: boolean;\n\n  fbLibraries: {\n    other: Map<string, AbstractValue>,\n    react: void | ObjectValue,\n    reactDom: void | ObjectValue,\n    reactDomServer: void | ObjectValue,\n    reactNative: void | ObjectValue,\n    reactRelay: void | ObjectValue,\n  };\n\n  $GlobalObject: ObjectValue | AbstractObjectValue;\n  compatibility: Compatibility;\n\n  $TemplateMap: Array<{ $Strings: Array<string>, $Array: ObjectValue }>;\n\n  generator: void | Generator;\n  preludeGenerator: void | PreludeGenerator;\n  timeoutCounter: number;\n  timeoutCounterThreshold: number;\n  evaluators: {\n    [key: string]: (\n      ast: BabelNode,\n      strictCode: boolean,\n      env: LexicalEnvironment,\n      realm: Realm,\n      metadata?: any\n    ) => Value | Reference,\n  };\n  partialEvaluators: {\n    [key: string]: (\n      ast: BabelNode,\n      strictCode: boolean,\n      env: LexicalEnvironment,\n      realm: Realm,\n      metadata?: any\n    ) => [Completion | Reference | Value, BabelNode, Array<BabelNodeStatement>],\n  };\n  simplifyAndRefineAbstractValue: AbstractValue => Value;\n  simplifyAndRefineAbstractCondition: AbstractValue => Value;\n\n  tracers: Array<Tracer>;\n\n  MOBILE_JSC_VERSION = \"jsc-600-1-4-17\";\n\n  errorHandler: ?ErrorHandler;\n  suppressDiagnostics = false;\n  objectCount = 0;\n  symbolCount = 867501803871088;\n  // Unique tag for identifying function body ast node. It is neeeded\n  // instead of ast node itself because we may perform ast tree deep clone\n  // during serialization which changes the ast identity.\n  functionBodyUniqueTagSeed = 1;\n\n  globalSymbolRegistry: Array<{ $Key: string, $Symbol: SymbolValue }>;\n\n  debuggerInstance: DebugServerType | void;\n\n  nextGeneratorId: number = 0;\n  _abstractValuesDefined: Set<string>;\n  _checkedObjectIds: Map<ObjectValue | AbstractObjectValue, number>;\n\n  // to force flow to type the annotations\n  isCompatibleWith(compatibility: Compatibility): boolean {\n    return compatibility === this.compatibility;\n  }\n\n  // Checks if there is a let binding at global scope with the given name\n  // returning it if so\n  getGlobalLetBinding(key: string): void | Value {\n    let globrec = this.$GlobalEnv.environmentRecord;\n    // GlobalEnv should have a GlobalEnvironmentRecord\n    invariant(globrec instanceof GlobalEnvironmentRecord);\n    let dclrec = globrec.$DeclarativeRecord;\n\n    try {\n      return dclrec.HasBinding(key) ? dclrec.GetBindingValue(key, false) : undefined;\n    } catch (e) {\n      if (e instanceof FatalError) return undefined;\n      throw e;\n    }\n  }\n\n  /*\n   Read only realms disallow:\n   - using console.log\n   - creating bindings in any existing scopes\n   - modifying object properties in any existing scopes\n   Setting a realm read-only sets all contained environments to read-only, but\n   all new environments (e.g. new ExecutionContexts) will be writeable.\n   */\n  setReadOnly(readOnlyValue: boolean): boolean {\n    let oldReadOnly = this.isReadOnly;\n    this.isReadOnly = readOnlyValue;\n    this.$GlobalEnv.environmentRecord.isReadOnly = readOnlyValue;\n    this.contextStack.forEach(ctx => {\n      ctx.setReadOnly(readOnlyValue);\n    });\n    return oldReadOnly;\n  }\n\n  testTimeout(): void {\n    let timeout = this.timeout;\n    if (timeout !== undefined && !--this.timeoutCounter) {\n      this.timeoutCounter = this.timeoutCounterThreshold;\n      let total = Date.now() - this.start;\n      if (total > timeout) {\n        let error = new CompilerDiagnostic(\n          `total time has exceeded the timeout time: ${timeout}`,\n          this.currentLocation,\n          \"PP0036\",\n          \"FatalError\"\n        );\n        this.handleError(error);\n        throw new FatalError(\"Timed out\");\n      }\n    }\n  }\n\n  hasRunningContext(): boolean {\n    return this.contextStack.length !== 0;\n  }\n\n  getRunningContext(): ExecutionContext {\n    let context = this.contextStack[this.contextStack.length - 1];\n    invariant(context, \"There's no running execution context\");\n    return context;\n  }\n\n  clearBlockBindings(modifiedBindings: void | Bindings, environmentRecord: DeclarativeEnvironmentRecord): void {\n    if (modifiedBindings === undefined) return;\n    for (let b of modifiedBindings.keys()) {\n      if (b.mightHaveBeenCaptured) continue;\n      if (environmentRecord.bindings[b.name] && environmentRecord.bindings[b.name] === b) modifiedBindings.delete(b);\n    }\n  }\n\n  clearBlockBindingsFromCompletion(completion: Completion, environmentRecord: DeclarativeEnvironmentRecord): void {\n    if (completion instanceof PossiblyNormalCompletion) {\n      this.clearBlockBindings(completion.alternateEffects.modifiedBindings, environmentRecord);\n      this.clearBlockBindings(completion.consequentEffects.modifiedBindings, environmentRecord);\n      if (completion.savedEffects !== undefined)\n        this.clearBlockBindings(completion.savedEffects.modifiedBindings, environmentRecord);\n      if (completion.alternate instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.alternate, environmentRecord);\n      if (completion.consequent instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.consequent, environmentRecord);\n    } else if (completion instanceof ForkedAbruptCompletion) {\n      this.clearBlockBindings(completion.alternateEffects.modifiedBindings, environmentRecord);\n      this.clearBlockBindings(completion.consequentEffects.modifiedBindings, environmentRecord);\n      if (completion.alternate instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.alternate, environmentRecord);\n      if (completion.consequent instanceof Completion)\n        this.clearBlockBindingsFromCompletion(completion.consequent, environmentRecord);\n    }\n  }\n\n  // Call when a scope falls out of scope and should be destroyed.\n  // Clears the Bindings corresponding to the disappearing Scope from ModifiedBindings\n  onDestroyScope(lexicalEnvironment: LexicalEnvironment): void {\n    invariant(this.activeLexicalEnvironments.has(lexicalEnvironment));\n    let modifiedBindings = this.modifiedBindings;\n    if (modifiedBindings) {\n      // Don't undo things to global scope because it's needed past its destruction point (for serialization)\n      let environmentRecord = lexicalEnvironment.environmentRecord;\n      if (environmentRecord instanceof DeclarativeEnvironmentRecord) {\n        this.clearBlockBindings(modifiedBindings, environmentRecord);\n        if (this.savedCompletion !== undefined)\n          this.clearBlockBindingsFromCompletion(this.savedCompletion, environmentRecord);\n      }\n    }\n\n    // Ensures if we call onDestroyScope too early, there will be a failure.\n    this.activeLexicalEnvironments.delete(lexicalEnvironment);\n    lexicalEnvironment.destroy();\n  }\n\n  pushContext(context: ExecutionContext): void {\n    if (this.contextStack.length >= this.maxStackDepth) {\n      throw new FatalError(\"Maximum stack depth exceeded\");\n    }\n    this.contextStack.push(context);\n  }\n\n  markVisibleLocalBindingsAsPotentiallyCaptured(): void {\n    let context = this.getRunningContext();\n    if (context.function === undefined) return;\n    let lexEnv = context.lexicalEnvironment;\n    while (lexEnv != null) {\n      let envRec = lexEnv.environmentRecord;\n      if (envRec instanceof DeclarativeEnvironmentRecord) {\n        let bindings = envRec.bindings;\n        for (let name in bindings) {\n          let binding = bindings[name];\n          binding.mightHaveBeenCaptured = true;\n        }\n      }\n      lexEnv = lexEnv.parent;\n    }\n  }\n\n  clearFunctionBindings(modifiedBindings: void | Bindings, funcVal: FunctionValue): void {\n    if (modifiedBindings === undefined) return;\n    for (let b of modifiedBindings.keys()) {\n      if (b.mightHaveBeenCaptured) continue;\n      if (b.environment instanceof FunctionEnvironmentRecord && b.environment.$FunctionObject === funcVal)\n        modifiedBindings.delete(b);\n    }\n  }\n\n  clearFunctionBindingsFromCompletion(completion: Completion, funcVal: FunctionValue): void {\n    if (completion instanceof PossiblyNormalCompletion) {\n      this.clearFunctionBindings(completion.alternateEffects.modifiedBindings, funcVal);\n      this.clearFunctionBindings(completion.consequentEffects.modifiedBindings, funcVal);\n      if (completion.savedEffects !== undefined)\n        this.clearFunctionBindings(completion.savedEffects.modifiedBindings, funcVal);\n      if (completion.alternate instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.alternate, funcVal);\n      if (completion.consequent instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.consequent, funcVal);\n    } else if (completion instanceof ForkedAbruptCompletion) {\n      this.clearFunctionBindings(completion.alternateEffects.modifiedBindings, funcVal);\n      this.clearFunctionBindings(completion.consequentEffects.modifiedBindings, funcVal);\n      if (completion.alternate instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.alternate, funcVal);\n      if (completion.consequent instanceof Completion)\n        this.clearFunctionBindingsFromCompletion(completion.consequent, funcVal);\n    }\n  }\n\n  popContext(context: ExecutionContext): void {\n    let funcVal = context.function;\n    if (funcVal) {\n      this.clearFunctionBindings(this.modifiedBindings, funcVal);\n      if (this.savedCompletion !== undefined) this.clearFunctionBindingsFromCompletion(this.savedCompletion, funcVal);\n    }\n    let c = this.contextStack.pop();\n    invariant(c === context);\n  }\n\n  wrapInGlobalEnv<T>(callback: () => T): T {\n    let context = new ExecutionContext();\n    context.isStrict = this.isStrict;\n    context.lexicalEnvironment = this.$GlobalEnv;\n    context.variableEnvironment = this.$GlobalEnv;\n    context.realm = this;\n\n    this.pushContext(context);\n    try {\n      return callback();\n    } finally {\n      this.popContext(context);\n    }\n  }\n\n  assignToGlobal(name: BabelNodeLVal, value: Value): void {\n    this.wrapInGlobalEnv(() => this.$GlobalEnv.assignToGlobal(name, value));\n  }\n\n  deleteGlobalBinding(name: string): void {\n    this.$GlobalEnv.environmentRecord.DeleteBinding(name);\n  }\n\n  neverCheckProperty(object: ObjectValue | AbstractObjectValue, P: string): boolean {\n    return (\n      P.startsWith(\"__\") ||\n      (object === this.$GlobalObject && P === \"global\") ||\n      (object.intrinsicName !== undefined && object.intrinsicName.startsWith(\"__\"))\n    );\n  }\n\n  _getCheckedBindings(): ObjectValue {\n    let globalObject = this.$GlobalObject;\n    invariant(globalObject instanceof ObjectValue);\n    let binding = globalObject.properties.get(\"__checkedBindings\");\n    invariant(binding !== undefined);\n    let checkedBindingsObject = binding.descriptor && binding.descriptor.value;\n    invariant(checkedBindingsObject instanceof ObjectValue);\n    return checkedBindingsObject;\n  }\n\n  markPropertyAsChecked(object: ObjectValue | AbstractObjectValue, P: string): void {\n    invariant(!this.neverCheckProperty(object, P));\n    let objectId = this._checkedObjectIds.get(object);\n    if (objectId === undefined) this._checkedObjectIds.set(object, (objectId = this._checkedObjectIds.size));\n    let id = `__${objectId}:${P}`;\n    let checkedBindings = this._getCheckedBindings();\n    checkedBindings.$Set(id, this.intrinsics.true, checkedBindings);\n  }\n\n  hasBindingBeenChecked(object: ObjectValue | AbstractObjectValue, P: string): void | boolean {\n    if (this.neverCheckProperty(object, P)) return true;\n    let objectId = this._checkedObjectIds.get(object);\n    if (objectId === undefined) return false;\n    let id = `__${objectId}:${P}`;\n    let binding = this._getCheckedBindings().properties.get(id);\n    if (binding === undefined) return false;\n    let value = binding.descriptor && binding.descriptor.value;\n    return value instanceof Value && !value.mightNotBeTrue();\n  }\n\n  // Evaluate a context as if it won't have any side-effects outside of any objects\n  // that it created itself. This promises that any abstract functions inside of it\n  // also won't have effects on any objects or bindings that weren't created in this\n  // call.\n  evaluatePure<T>(\n    f: () => T,\n    reportSideEffectFunc:\n      | null\n      | ((sideEffectType: SideEffectType, binding: void | Binding | PropertyBinding, value: void | Value) => void)\n  ): T {\n    let saved_createdObjectsTrackedForLeaks = this.createdObjectsTrackedForLeaks;\n    let saved_reportSideEffectCallback = this.reportSideEffectCallback;\n    // Track all objects (including function closures) created during\n    // this call. This will be used to make the assumption that every\n    // *other* object is unchanged (pure). These objects are marked\n    // as leaked if they're passed to abstract functions.\n    this.createdObjectsTrackedForLeaks = new Set();\n    this.reportSideEffectCallback = (...args) => {\n      if (reportSideEffectFunc != null) {\n        reportSideEffectFunc(...args);\n      }\n      // Ensure we call any previously nested side-effect callbacks\n      if (saved_reportSideEffectCallback != null) {\n        saved_reportSideEffectCallback(...args);\n      }\n    };\n    try {\n      return f();\n    } finally {\n      this.createdObjectsTrackedForLeaks = saved_createdObjectsTrackedForLeaks;\n      this.reportSideEffectCallback = saved_reportSideEffectCallback;\n    }\n  }\n\n  isInPureScope(): boolean {\n    return !!this.createdObjectsTrackedForLeaks;\n  }\n\n  evaluateWithoutLeakLogic(f: () => Value): Value {\n    invariant(!this.ignoreLeakLogic, \"Nesting evaluateWithoutLeakLogic() calls is not supported.\");\n    this.ignoreLeakLogic = true;\n    try {\n      return f();\n    } finally {\n      this.ignoreLeakLogic = false;\n    }\n  }\n\n  // Evaluate some code that might generate temporal values knowing that it might end in an abrupt\n  // completion. We only need to support ThrowCompletion for now but this can be expanded to support other\n  // abrupt completions.\n  evaluateWithPossibleThrowCompletion(f: () => Value, thrownTypes: TypesDomain, thrownValues: ValuesDomain): Value {\n    // The cases when we need this are only when we might invoke unknown code such as abstract\n    // funtions, getters, custom coercion etc. It is possible we can use this in other cases\n    // where something might throw a built-in error but can never issue arbitrary code such as\n    // calling something that might not be a function. For now we only use it in pure functions.\n    invariant(this.isInPureScope(), \"only abstract abrupt completion in pure functions\");\n\n    // TODO(1264): We should create a new generator for this scope and wrap it in a try/catch.\n    // We could use the outcome of that as the join condition for a PossiblyNormalCompletion.\n    // We should then compose that with the saved completion and move on to the normal route.\n    // Currently we just issue a recoverable error instead if this might matter.\n    let value = f();\n    if (this.isInPureTryStatement) {\n      let diag = new CompilerDiagnostic(\n        \"Possible throw inside try/catch is not yet supported\",\n        this.currentLocation,\n        \"PP0021\",\n        \"RecoverableError\"\n      );\n      if (this.handleError(diag) !== \"Recover\") throw new FatalError();\n    }\n    return value;\n  }\n\n  // Evaluate the given ast in a sandbox and return the evaluation results\n  // in the form of a completion, a code generator, a map of changed variable\n  // bindings and a map of changed property bindings.\n  evaluateNodeForEffects(\n    ast: BabelNode,\n    strictCode: boolean,\n    env: LexicalEnvironment,\n    state?: any,\n    generatorName?: string = \"evaluateNodeForEffects\"\n  ): Effects {\n    return this.evaluateForEffects(() => env.evaluateCompletionDeref(ast, strictCode), state, generatorName);\n  }\n\n  evaluateForEffectsInGlobalEnv(\n    func: () => Value,\n    state?: any,\n    generatorName?: string = \"evaluateForEffectsInGlobalEnv\"\n  ): Effects {\n    return this.wrapInGlobalEnv(() => this.evaluateForEffects(func, state, generatorName));\n  }\n\n  // NB: does not apply generators because there's no way to cleanly revert them.\n  // func should not return undefined\n  withEffectsAppliedInGlobalEnv<T>(func: Effects => T, effects: Effects): T {\n    let result: T;\n    this.evaluateForEffectsInGlobalEnv(() => {\n      try {\n        this.applyEffects(effects, \"\", false);\n        result = func(effects);\n        return this.intrinsics.undefined;\n      } finally {\n        this.undoBindings(effects.modifiedBindings);\n        this.restoreProperties(effects.modifiedProperties);\n        invariant(!effects.canBeApplied);\n        effects.canBeApplied = true;\n      }\n    });\n    invariant(result !== undefined, \"If we get here, func must have returned undefined.\");\n    return result;\n  }\n\n  evaluateNodeForEffectsInGlobalEnv(node: BabelNode, state?: any, generatorName?: string): Effects {\n    return this.wrapInGlobalEnv(() => this.evaluateNodeForEffects(node, false, this.$GlobalEnv, state, generatorName));\n  }\n\n  partiallyEvaluateNodeForEffects(\n    ast: BabelNode,\n    strictCode: boolean,\n    env: LexicalEnvironment\n  ): [Effects, BabelNode, Array<BabelNodeStatement>] {\n    let nodeAst, nodeIO;\n    function partialEval() {\n      let result;\n      [result, nodeAst, nodeIO] = env.partiallyEvaluateCompletionDeref(ast, strictCode);\n      return result;\n    }\n    let effects = this.evaluateForEffects(partialEval, undefined, \"partiallyEvaluateNodeForEffects\");\n    invariant(nodeAst !== undefined && nodeIO !== undefined);\n    return [effects, nodeAst, nodeIO];\n  }\n\n  evaluateForEffects(f: () => Completion | Value, state: any, generatorName: string): Effects {\n    // Save old state and set up empty state for ast\n    let [savedBindings, savedProperties] = this.getAndResetModifiedMaps();\n    let saved_generator = this.generator;\n    let saved_createdObjects = this.createdObjects;\n    let saved_completion = this.savedCompletion;\n    this.generator = new Generator(this, generatorName, this.pathConditions);\n    this.createdObjects = new Set();\n    this.savedCompletion = undefined; // while in this call, we only explore the normal path.\n\n    let result;\n    try {\n      for (let t1 of this.tracers) t1.beginEvaluateForEffects(state);\n\n      let c;\n      try {\n        try {\n          c = f();\n          if (c instanceof Reference) c = Environment.GetValue(this, c);\n          else if (c instanceof SimpleNormalCompletion) c = c.value;\n        } catch (e) {\n          if (e instanceof AbruptCompletion) c = e;\n          else throw e;\n        }\n        // This is a join point for the normal branch of a PossiblyNormalCompletion.\n        if (c instanceof Value || c instanceof AbruptCompletion) c = Functions.incorporateSavedCompletion(this, c);\n        invariant(c !== undefined);\n        if (c instanceof PossiblyNormalCompletion) {\n          // The current state may have advanced since the time control forked into the various paths recorded in c.\n          // Update the normal path and restore the global state to what it was at the time of the fork.\n          let subsequentEffects = this.getCapturedEffects(c.value);\n          this.stopEffectCaptureAndUndoEffects(c);\n          Join.updatePossiblyNormalCompletionWithSubsequentEffects(this, c, subsequentEffects);\n          this.savedCompletion = undefined;\n        }\n\n        invariant(this.generator !== undefined);\n        invariant(this.modifiedBindings !== undefined);\n        invariant(this.modifiedProperties !== undefined);\n        invariant(this.createdObjects !== undefined);\n        let astGenerator = this.generator;\n        let astBindings = this.modifiedBindings;\n        let astProperties = this.modifiedProperties;\n        let astCreatedObjects = this.createdObjects;\n\n        /* TODO #1615: The following invariant should hold.\n\n        // Check invariant that modified bindings to not refer to environment record belonging to\n        // newly created closure objects.\n        for (let binding of astBindings.keys())\n          if (binding.environment instanceof FunctionEnvironmentRecord)\n            invariant(!astCreatedObjects.has(binding.environment.$FunctionObject));\n        */\n\n        // Return the captured state changes and evaluation result\n        if (c instanceof Value) c = new SimpleNormalCompletion(c);\n        result = new Effects(c, astGenerator, astBindings, astProperties, astCreatedObjects);\n        return result;\n      } finally {\n        // Roll back the state changes\n        if (this.savedCompletion !== undefined) this.stopEffectCaptureAndUndoEffects(this.savedCompletion);\n        if (result !== undefined) {\n          this.undoBindings(result.modifiedBindings);\n          this.restoreProperties(result.modifiedProperties);\n        } else {\n          this.undoBindings(this.modifiedBindings);\n          this.restoreProperties(this.modifiedProperties);\n        }\n        this.generator = saved_generator;\n        this.modifiedBindings = savedBindings;\n        this.modifiedProperties = savedProperties;\n        this.createdObjects = saved_createdObjects;\n        this.savedCompletion = saved_completion;\n      }\n    } finally {\n      for (let t2 of this.tracers) t2.endEvaluateForEffects(state, result);\n    }\n  }\n\n  evaluateWithUndo(f: () => Value, defaultValue: Value = this.intrinsics.undefined): Value {\n    if (!this.useAbstractInterpretation) return f();\n    let oldErrorHandler = this.errorHandler;\n    this.errorHandler = d => {\n      if (d.severity === \"Information\" || d.severity === \"Warning\") return \"Recover\";\n      return \"Fail\";\n    };\n    try {\n      let effects = this.evaluateForEffects(\n        () => {\n          try {\n            return f();\n          } catch (e) {\n            if (e instanceof Completion) {\n              return defaultValue;\n            } else if (e instanceof FatalError) {\n              return defaultValue;\n            } else {\n              throw e;\n            }\n          }\n        },\n        undefined,\n        \"evaluateWithUndo\"\n      );\n      return effects.result instanceof SimpleNormalCompletion ? effects.result.value : defaultValue;\n    } finally {\n      this.errorHandler = oldErrorHandler;\n    }\n  }\n\n  evaluateWithUndoForDiagnostic(f: () => Value): CompilerDiagnostic | Value {\n    if (!this.useAbstractInterpretation) return f();\n    let savedHandler = this.errorHandler;\n    let diagnostic;\n    try {\n      this.errorHandler = d => {\n        diagnostic = d;\n        return \"Fail\";\n      };\n      let effects = this.evaluateForEffects(f, undefined, \"evaluateWithUndoForDiagnostic\");\n      this.applyEffects(effects);\n      let resultVal = effects.result;\n      if (resultVal instanceof AbruptCompletion) throw resultVal;\n      if (resultVal instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        resultVal = this.composeWithSavedCompletion(resultVal);\n      }\n      invariant(resultVal instanceof SimpleNormalCompletion);\n      return resultVal.value;\n    } catch (e) {\n      if (diagnostic !== undefined) return diagnostic;\n      throw e;\n    } finally {\n      this.errorHandler = savedHandler;\n    }\n  }\n\n  evaluateForFixpointEffects(iteration: () => [Value, EvaluationResult]): void | [Effects, Effects, AbstractValue] {\n    try {\n      let test;\n      let f = () => {\n        let result;\n        [test, result] = iteration();\n        if (!(test instanceof AbstractValue)) throw new FatalError(\"loop terminates before fixed point\");\n        invariant(result instanceof Completion);\n        return result;\n      };\n      let effects1 = this.evaluateForEffects(f, undefined, \"evaluateForFixpointEffects/1\");\n      while (true) {\n        this.redoBindings(effects1.modifiedBindings);\n        this.restoreProperties(effects1.modifiedProperties);\n        let effects2 = this.evaluateForEffects(f, undefined, \"evaluateForFixpointEffects/2\");\n        this.undoBindings(effects1.modifiedBindings);\n        this.restoreProperties(effects1.modifiedProperties);\n        if (Widen.containsEffects(effects1, effects2)) {\n          // effects1 includes every value present in effects2, so doing another iteration using effects2 will not\n          // result in any more values being added to abstract domains and hence a fixpoint has been reached.\n          // Generate code using effects2 because its expressions have not been widened away.\n          const e2 = effects2;\n          this._applyPropertiesToNewlyCreatedObjects(e2.modifiedProperties, e2.createdObjects);\n          this._emitPropertAssignments(e2.generator, e2.modifiedProperties, e2.createdObjects);\n          this._emitLocalAssignments(e2.generator, e2.modifiedBindings, e2.createdObjects);\n          invariant(test instanceof AbstractValue);\n          let cond = e2.generator.deriveAbstract(test.types, test.values, [test], ([n]) => n, {\n            skipInvariant: true,\n          });\n          return [effects1, effects2, cond];\n        }\n        effects1 = Widen.widenEffects(this, effects1, effects2);\n      }\n    } catch (e) {\n      if (e instanceof FatalError) return undefined;\n      throw e;\n    }\n  }\n\n  evaluateWithAbstractConditional(\n    condValue: AbstractValue,\n    consequentEffectsFunc: () => Effects,\n    alternateEffectsFunc: () => Effects\n  ): Value {\n    // Evaluate consequent and alternate in sandboxes and get their effects.\n    let effects1;\n    try {\n      effects1 = Path.withCondition(condValue, consequentEffectsFunc);\n    } catch (e) {\n      if (!(e instanceof InfeasiblePathError)) throw e;\n    }\n\n    let effects2;\n    try {\n      effects2 = Path.withInverseCondition(condValue, alternateEffectsFunc);\n    } catch (e) {\n      if (!(e instanceof InfeasiblePathError)) throw e;\n    }\n\n    let joinedEffects, completion;\n    if (effects1 === undefined || effects2 === undefined) {\n      if (effects1 === undefined && effects2 === undefined) throw new InfeasiblePathError();\n      joinedEffects = effects1 || effects2;\n      invariant(joinedEffects !== undefined);\n      completion = joinedEffects.result;\n      this.applyEffects(joinedEffects, \"evaluateWithAbstractConditional\");\n    } else {\n      // Join the effects, creating an abstract view of what happened, regardless\n      // of the actual value of condValue.\n      joinedEffects = Join.joinForkOrChoose(this, condValue, effects1, effects2);\n      completion = joinedEffects.result;\n      if (completion instanceof ForkedAbruptCompletion) {\n        // Note that the effects are tracked separately inside completion and will be applied later.\n        throw completion;\n      }\n      if (completion instanceof PossiblyNormalCompletion) {\n        // in this case one of the branches may complete abruptly, which means that\n        // not all control flow branches join into one flow at this point.\n        // Consequently we have to continue tracking changes until the point where\n        // all the branches come together into one.\n        completion = this.composeWithSavedCompletion(completion);\n        this.applyEffects(joinedEffects, \"evaluateWithAbstractConditional\", false);\n      } else {\n        this.applyEffects(joinedEffects, \"evaluateWithAbstractConditional\");\n      }\n    }\n\n    // return or throw completion\n    if (completion instanceof AbruptCompletion) throw completion;\n    if (completion instanceof SimpleNormalCompletion) completion = completion.value;\n    invariant(completion instanceof Value);\n    return completion;\n  }\n\n  _applyPropertiesToNewlyCreatedObjects(\n    modifiedProperties: void | PropertyBindings,\n    newlyCreatedObjects: CreatedObjects\n  ): void {\n    if (modifiedProperties === undefined) return;\n    modifiedProperties.forEach((desc, propertyBinding, m) => {\n      if (newlyCreatedObjects.has(propertyBinding.object)) {\n        propertyBinding.descriptor = desc;\n      }\n    });\n  }\n\n  // populate the loop body generator with assignments that will update the phiNodes\n  _emitLocalAssignments(gen: Generator, bindings: Bindings, newlyCreatedObjects: CreatedObjects): void {\n    let tvalFor: Map<any, AbstractValue> = new Map();\n    bindings.forEach((binding, key, map) => {\n      let val = binding.value;\n      if (val instanceof AbstractValue) {\n        invariant(val._buildNode !== undefined);\n        let tval = gen.deriveAbstract(val.types, val.values, [val], ([n]) => n, {\n          skipInvariant: true,\n        });\n        tvalFor.set(key, tval);\n      }\n    });\n    bindings.forEach((binding, key, map) => {\n      let val = binding.value;\n      if (val instanceof AbstractValue) {\n        let phiNode = key.phiNode;\n        let tval = tvalFor.get(key);\n        invariant(tval !== undefined);\n        gen.emitStatement([tval], ([v]) => {\n          invariant(phiNode !== undefined);\n          let id = phiNode.buildNode([]);\n          return t.expressionStatement(t.assignmentExpression(\"=\", (id: any), v));\n        });\n      }\n\n      if (val instanceof ObjectValue && newlyCreatedObjects.has(val)) {\n        let phiNode = key.phiNode;\n        gen.emitStatement([val], ([v]) => {\n          invariant(phiNode !== undefined);\n          let id = phiNode.buildNode([]);\n          return t.expressionStatement(t.assignmentExpression(\"=\", (id: any), v));\n        });\n      }\n    });\n  }\n\n  // populate the loop body generator with assignments that will update properties modified inside the loop\n  _emitPropertAssignments(gen: Generator, pbindings: PropertyBindings, newlyCreatedObjects: CreatedObjects): void {\n    function isSelfReferential(value: Value, pathNode: void | AbstractValue): boolean {\n      if (value === pathNode) return true;\n      if (value instanceof AbstractValue && pathNode !== undefined) {\n        for (let v of value.args) {\n          if (isSelfReferential(v, pathNode)) return true;\n        }\n      }\n      return false;\n    }\n\n    let tvalFor: Map<any, AbstractValue> = new Map();\n    pbindings.forEach((val, key, map) => {\n      if (newlyCreatedObjects.has(key.object) || key.object.refuseSerialization) {\n        return;\n      }\n      let value = val && val.value;\n      if (value instanceof AbstractValue) {\n        invariant(value._buildNode !== undefined);\n        let tval = gen.deriveAbstract(\n          value.types,\n          value.values,\n          [key.object, value],\n          ([o, n]) => {\n            invariant(value instanceof Value);\n            if (typeof key.key === \"string\" && value.mightHaveBeenDeleted() && isSelfReferential(value, key.pathNode)) {\n              let inTest = t.binaryExpression(\"in\", t.stringLiteral(key.key), o);\n              let addEmpty = t.conditionalExpression(inTest, n, emptyExpression);\n              n = t.logicalExpression(\"||\", n, addEmpty);\n            }\n            return n;\n          },\n          {\n            skipInvariant: true,\n          }\n        );\n        tvalFor.set(key, tval);\n      }\n    });\n    pbindings.forEach((val, key, map) => {\n      if (newlyCreatedObjects.has(key.object) || key.object.refuseSerialization) {\n        return;\n      }\n      let path = key.pathNode;\n      let tval = tvalFor.get(key);\n      invariant(val !== undefined);\n      let value = val.value;\n      invariant(value instanceof Value);\n      let mightHaveBeenDeleted = value.mightHaveBeenDeleted();\n      let mightBeUndefined = value.mightBeUndefined();\n      let keyKey = key.key;\n      if (typeof keyKey === \"string\") {\n        if (path !== undefined) {\n          gen.emitStatement([key.object, tval || value, this.intrinsics.empty], ([o, v, e]) => {\n            invariant(path !== undefined);\n            invariant(typeof keyKey === \"string\");\n            let lh = path.buildNode([o, t.identifier(keyKey)]);\n            let r = t.expressionStatement(t.assignmentExpression(\"=\", (lh: any), v));\n            if (mightHaveBeenDeleted) {\n              // If v === __empty || (v === undefined  && !(key.key in o))  then delete it\n              let emptyTest = t.binaryExpression(\"===\", v, e);\n              let undefinedTest = t.binaryExpression(\"===\", v, voidExpression);\n              let inTest = t.unaryExpression(\"!\", t.binaryExpression(\"in\", t.stringLiteral(keyKey), o));\n              let guard = t.logicalExpression(\"||\", emptyTest, t.logicalExpression(\"&&\", undefinedTest, inTest));\n              let deleteIt = t.expressionStatement(t.unaryExpression(\"delete\", (lh: any)));\n              return t.ifStatement(mightBeUndefined ? emptyTest : guard, deleteIt, r);\n            }\n            return r;\n          });\n        } else {\n          // RH value was not widened, so it must have been a constant. We don't need to assign that inside the loop.\n          // Note, however, that if the LH side is a property of an intrinsic object, then an assignment will\n          // have been emitted to the generator.\n        }\n      } else {\n        // TODO: What if keyKey is undefined?\n        invariant(keyKey instanceof Value);\n        gen.emitStatement([key.object, keyKey, tval || value, this.intrinsics.empty], ([o, p, v, e]) => {\n          invariant(path !== undefined);\n          let lh = path.buildNode([o, p]);\n          return t.expressionStatement(t.assignmentExpression(\"=\", (lh: any), v));\n        });\n      }\n    });\n  }\n\n  composeEffects(priorEffects: Effects, subsequentEffects: Effects): Effects {\n    let result = construct_empty_effects(this, subsequentEffects.result);\n\n    result.generator = Join.composeGenerators(\n      this,\n      priorEffects.generator || result.generator,\n      subsequentEffects.generator\n    );\n\n    if (priorEffects.modifiedBindings) {\n      priorEffects.modifiedBindings.forEach((val, key, m) => result.modifiedBindings.set(key, val));\n    }\n    subsequentEffects.modifiedBindings.forEach((val, key, m) => result.modifiedBindings.set(key, val));\n\n    if (priorEffects.modifiedProperties) {\n      priorEffects.modifiedProperties.forEach((desc, propertyBinding, m) =>\n        result.modifiedProperties.set(propertyBinding, desc)\n      );\n    }\n    subsequentEffects.modifiedProperties.forEach((val, key, m) => result.modifiedProperties.set(key, val));\n\n    if (priorEffects.createdObjects) {\n      priorEffects.createdObjects.forEach((ob, a) => result.createdObjects.add(ob));\n    }\n    subsequentEffects.createdObjects.forEach((ob, a) => result.createdObjects.add(ob));\n\n    return result;\n  }\n\n  updateAbruptCompletions(priorEffects: Effects, c: PossiblyNormalCompletion): void {\n    if (c.consequent instanceof AbruptCompletion) {\n      c.consequent.effects = this.composeEffects(priorEffects, c.consequentEffects);\n      let alternate = c.alternate;\n      if (alternate instanceof PossiblyNormalCompletion) this.updateAbruptCompletions(priorEffects, alternate);\n    } else {\n      invariant(c.alternate instanceof AbruptCompletion);\n      c.alternate.effects = this.composeEffects(priorEffects, c.alternateEffects);\n      let consequent = c.consequent;\n      if (consequent instanceof PossiblyNormalCompletion) this.updateAbruptCompletions(priorEffects, consequent);\n    }\n  }\n\n  wrapSavedCompletion(completion: PossiblyNormalCompletion): void {\n    if (this.savedCompletion !== undefined) {\n      if (completion.consequent instanceof AbruptCompletion) {\n        completion.alternate = this.savedCompletion;\n      } else {\n        completion.consequent = this.savedCompletion;\n      }\n      completion.savedEffects = this.savedCompletion.savedEffects;\n    } else {\n      this.captureEffects(completion);\n    }\n    this.savedCompletion = completion;\n  }\n\n  composeWithSavedCompletion(completion: PossiblyNormalCompletion): Value {\n    if (this.savedCompletion === undefined) {\n      this.savedCompletion = completion;\n      this.savedCompletion.savedPathConditions = this.pathConditions;\n      this.pathConditions = [].concat(this.pathConditions);\n      this.captureEffects(completion);\n    } else {\n      let savedCompletion = this.savedCompletion;\n      let e = this.getCapturedEffects();\n      this.stopEffectCaptureAndUndoEffects(savedCompletion);\n      savedCompletion = Join.composePossiblyNormalCompletions(this, savedCompletion, completion, e);\n      this.applyEffects(e);\n      this.captureEffects(savedCompletion);\n      this.savedCompletion = savedCompletion;\n    }\n    let realm = this;\n    pushPathConditionsLeadingToNormalCompletion(completion);\n    return completion.value;\n\n    function pushPathConditionsLeadingToNormalCompletion(c: ForkedAbruptCompletion | PossiblyNormalCompletion) {\n      if (allPathsAreAbrupt(c.consequent)) {\n        Path.pushInverseAndRefine(c.joinCondition);\n        if (c.alternate instanceof PossiblyNormalCompletion || c.alternate instanceof ForkedAbruptCompletion)\n          pushPathConditionsLeadingToNormalCompletion(c.alternate);\n      } else if (allPathsAreAbrupt(c.alternate)) {\n        Path.pushAndRefine(c.joinCondition);\n        if (c.consequent instanceof PossiblyNormalCompletion || c.consequent instanceof ForkedAbruptCompletion)\n          pushPathConditionsLeadingToNormalCompletion(c.consequent);\n      } else if (allPathsAreNormal(c.consequent)) {\n        if (!allPathsAreNormal(c.alternate)) {\n          let alternatePC = getNormalPathConditionFor(c.alternate);\n          let disjunct = AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, alternatePC);\n          Path.pushAndRefine(disjunct);\n        }\n      } else if (allPathsAreNormal(c.alternate)) {\n        let consequentPC = getNormalPathConditionFor(c.consequent);\n        let inverse = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n        let disjunct = AbstractValue.createFromLogicalOp(realm, \"||\", inverse, consequentPC);\n        Path.pushAndRefine(disjunct);\n      } else {\n        let jc = c.joinCondition;\n        let consequentPC = AbstractValue.createFromLogicalOp(realm, \"&&\", jc, getNormalPathConditionFor(c.consequent));\n        let ijc = AbstractValue.createFromUnaryOp(realm, \"!\", jc);\n        let alternatePC = AbstractValue.createFromLogicalOp(realm, \"&&\", ijc, getNormalPathConditionFor(c.alternate));\n        let disjunct = AbstractValue.createFromLogicalOp(realm, \"||\", consequentPC, alternatePC);\n        Path.pushAndRefine(disjunct);\n      }\n    }\n\n    function allPathsAreAbrupt(c: Completion): boolean {\n      if (c instanceof ForkedAbruptCompletion) return allPathsAreAbrupt(c.consequent) && allPathsAreAbrupt(c.alternate);\n      if (c instanceof AbruptCompletion) return true;\n      return false;\n    }\n\n    function allPathsAreNormal(c: Completion): boolean {\n      if (c instanceof PossiblyNormalCompletion || c instanceof ForkedAbruptCompletion)\n        return allPathsAreNormal(c.consequent) && allPathsAreNormal(c.alternate);\n      if (c instanceof AbruptCompletion) return false;\n      return true;\n    }\n\n    function getNormalPathConditionFor(c: Completion): Value {\n      invariant(c instanceof PossiblyNormalCompletion || c instanceof ForkedAbruptCompletion);\n      if (allPathsAreAbrupt(c.consequent)) {\n        invariant(!allPathsAreAbrupt(c.alternate));\n        let inverse = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n        if (allPathsAreNormal(c.alternate)) return inverse;\n        return AbstractValue.createFromLogicalOp(realm, \"&&\", inverse, getNormalPathConditionFor(c.alternate));\n      } else if (allPathsAreAbrupt(c.alternate)) {\n        invariant(!allPathsAreAbrupt(c.consequent));\n        if (allPathsAreNormal(c.consequent)) return c.joinCondition;\n        return AbstractValue.createFromLogicalOp(realm, \"&&\", c.joinCondition, getNormalPathConditionFor(c.consequent));\n      } else if (allPathsAreNormal(c.consequent)) {\n        // In principle the simplifier shoud reduce the result of the else clause to this case. This does less work.\n        invariant(!allPathsAreNormal(c.alternate));\n        invariant(!allPathsAreAbrupt(c.alternate));\n        let ijc = AbstractValue.createFromUnaryOp(realm, \"!\", c.joinCondition);\n        let alternatePC = AbstractValue.createFromLogicalOp(realm, \"&&\", ijc, getNormalPathConditionFor(c.alternate));\n        return AbstractValue.createFromLogicalOp(realm, \"||\", c.joinCondition, alternatePC);\n      } else if (allPathsAreNormal(c.alternate)) {\n        // In principle the simplifier shoud reduce the result of the else clause to this case. This does less work.\n        invariant(!allPathsAreNormal(c.consequent));\n        invariant(!allPathsAreAbrupt(c.consequent));\n        let jc = c.joinCondition;\n        let consequentPC = AbstractValue.createFromLogicalOp(realm, \"&&\", jc, getNormalPathConditionFor(c.consequent));\n        let ijc = AbstractValue.createFromUnaryOp(realm, \"!\", jc);\n        return AbstractValue.createFromLogicalOp(realm, \"||\", consequentPC, ijc);\n      } else {\n        let jc = c.joinCondition;\n        let consequentPC = AbstractValue.createFromLogicalOp(realm, \"&&\", jc, getNormalPathConditionFor(c.consequent));\n        let ijc = AbstractValue.createFromUnaryOp(realm, \"!\", jc);\n        let alternatePC = AbstractValue.createFromLogicalOp(realm, \"&&\", ijc, getNormalPathConditionFor(c.alternate));\n        return AbstractValue.createFromLogicalOp(realm, \"||\", consequentPC, alternatePC);\n      }\n    }\n  }\n\n  incorporatePriorSavedCompletion(priorCompletion: void | PossiblyNormalCompletion): void {\n    if (priorCompletion === undefined) return;\n    // A completion that has been saved and that is still active, will always have savedEffects.\n    invariant(priorCompletion.savedEffects !== undefined);\n    if (this.savedCompletion === undefined) {\n      // priorCompletion must be a previous savedCompletion, so the corresponding tracking maps would have been\n      // captured in priorCompletion.savedEffects and restored to the realm when clearing out this.savedCompletion.\n      // Since there is curently no savedCompletion, all the forks subsequent to the last normal fork in\n      // priorCompletion will have joined up again and their effects will have been applied to the current\n      // tracking maps.\n      invariant(this.modifiedBindings !== undefined);\n      this.savedCompletion = priorCompletion;\n    } else {\n      let savedEffects = this.savedCompletion.savedEffects;\n      invariant(savedEffects !== undefined);\n      this.redoBindings(savedEffects.modifiedBindings);\n      this.restoreProperties(savedEffects.modifiedProperties);\n      Join.updatePossiblyNormalCompletionWithSubsequentEffects(this, priorCompletion, savedEffects);\n      this.undoBindings(savedEffects.modifiedBindings);\n      this.restoreProperties(savedEffects.modifiedProperties);\n      invariant(this.savedCompletion !== undefined);\n      this.savedCompletion.savedEffects = undefined;\n      this.savedCompletion = Join.composePossiblyNormalCompletions(this, priorCompletion, this.savedCompletion);\n    }\n  }\n\n  captureEffects(completion: PossiblyNormalCompletion): void {\n    invariant(completion.savedEffects === undefined);\n    completion.savedEffects = new Effects(\n      new SimpleNormalCompletion(this.intrinsics.undefined),\n      (this.generator: any),\n      (this.modifiedBindings: any),\n      (this.modifiedProperties: any),\n      (this.createdObjects: any)\n    );\n    this.generator = new Generator(this, \"captured\", this.pathConditions);\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    this.createdObjects = new Set();\n  }\n\n  getCapturedEffects(v?: Value = this.intrinsics.undefined): Effects {\n    invariant(this.generator !== undefined);\n    invariant(this.modifiedBindings !== undefined);\n    invariant(this.modifiedProperties !== undefined);\n    invariant(this.createdObjects !== undefined);\n    return new Effects(\n      new SimpleNormalCompletion(v),\n      this.generator,\n      this.modifiedBindings,\n      this.modifiedProperties,\n      this.createdObjects\n    );\n  }\n\n  stopEffectCaptureAndUndoEffects(completion: PossiblyNormalCompletion): void {\n    // Roll back the state changes\n    this.undoBindings(this.modifiedBindings);\n    this.restoreProperties(this.modifiedProperties);\n\n    // Restore saved state\n    if (completion.savedEffects !== undefined) {\n      const savedEffects = completion.savedEffects;\n      completion.savedEffects = undefined;\n      this.generator = savedEffects.generator;\n      this.modifiedBindings = savedEffects.modifiedBindings;\n      this.modifiedProperties = savedEffects.modifiedProperties;\n      this.createdObjects = savedEffects.createdObjects;\n    } else {\n      invariant(false);\n    }\n  }\n\n  // Apply the given effects to the global state\n  applyEffects(effects: Effects, leadingComment: string = \"\", appendGenerator: boolean = true): void {\n    invariant(\n      effects.canBeApplied,\n      \"Effects have been applied and not properly reverted. It is not safe to apply them a second time.\"\n    );\n    effects.canBeApplied = false;\n    let { generator, modifiedBindings, modifiedProperties, createdObjects } = effects;\n\n    // Add generated code for property modifications\n    if (appendGenerator) this.appendGenerator(generator, leadingComment);\n\n    // Restore modifiedBindings\n    this.redoBindings(modifiedBindings);\n    this.restoreProperties(modifiedProperties);\n\n    // track modifiedBindings\n    let realmModifiedBindings = this.modifiedBindings;\n    if (realmModifiedBindings !== undefined) {\n      modifiedBindings.forEach((val, key, m) => {\n        invariant(realmModifiedBindings !== undefined);\n        if (!realmModifiedBindings.has(key)) {\n          realmModifiedBindings.set(key, val);\n        }\n      });\n    }\n    let realmModifiedProperties = this.modifiedProperties;\n    if (realmModifiedProperties !== undefined) {\n      modifiedProperties.forEach((desc, propertyBinding, m) => {\n        invariant(realmModifiedProperties !== undefined);\n        if (!realmModifiedProperties.has(propertyBinding)) {\n          realmModifiedProperties.set(propertyBinding, desc);\n        }\n      });\n    }\n\n    // add created objects\n    if (createdObjects.size > 0) {\n      let realmCreatedObjects = this.createdObjects;\n      if (realmCreatedObjects === undefined) this.createdObjects = new Set(createdObjects);\n      else {\n        createdObjects.forEach((ob, a) => {\n          invariant(realmCreatedObjects !== undefined);\n          realmCreatedObjects.add(ob);\n        });\n      }\n    }\n  }\n\n  outputToConsole(method: ConsoleMethodTypes, args: Array<string | ConcreteValue>): void {\n    if (this.isReadOnly) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to create console output in read-only realm\");\n    }\n    if (this.useAbstractInterpretation) {\n      invariant(this.generator !== undefined);\n      this.generator.emitConsoleLog(method, args);\n    } else {\n      // $FlowFixMe: Flow doesn't have type data for all the console methods yet\n      console[method](getString(this, args));\n    }\n\n    function getString(realm: Realm, values: Array<string | ConcreteValue>) {\n      let res = \"\";\n      while (values.length) {\n        let next = values.shift();\n        let nextString = To.ToString(realm, next);\n        res += nextString;\n      }\n      return res;\n    }\n  }\n\n  // Record the current value of binding in this.modifiedBindings unless\n  // there is already an entry for binding.\n  recordModifiedBinding(binding: Binding, value?: Value): Binding {\n    const isDefinedInsidePureFn = root => {\n      let context = this.getRunningContext();\n      let { lexicalEnvironment: env, function: func } = context;\n\n      invariant(func instanceof FunctionValue);\n      if (root instanceof FunctionEnvironmentRecord && func === root.$FunctionObject) {\n        return true;\n      }\n      if (this.createdObjectsTrackedForLeaks !== undefined && !this.createdObjectsTrackedForLeaks.has(func)) {\n        return false;\n      }\n      env = env.parent;\n      while (env) {\n        if (env.environmentRecord === root) {\n          return true;\n        }\n        env = env.parent;\n      }\n      return false;\n    };\n\n    if (\n      this.modifiedBindings !== undefined &&\n      !this.modifiedBindings.has(binding) &&\n      value !== undefined &&\n      this.isInPureScope() &&\n      this.reportSideEffectCallback !== undefined\n    ) {\n      let env = binding.environment;\n\n      if (\n        !(env instanceof DeclarativeEnvironmentRecord) ||\n        (env instanceof DeclarativeEnvironmentRecord && !isDefinedInsidePureFn(env))\n      ) {\n        this.reportSideEffectCallback(\"MODIFIED_BINDING\", binding, value.expressionLocation);\n      }\n    }\n\n    if (binding.environment.isReadOnly) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to modify a binding in read-only realm\");\n    }\n\n    if (this.modifiedBindings !== undefined && !this.modifiedBindings.has(binding)) {\n      this.modifiedBindings.set(binding, {\n        hasLeaked: undefined,\n        value: undefined,\n        previousHasLeaked: binding.hasLeaked,\n        previousValue: binding.value,\n      });\n    }\n    return binding;\n  }\n\n  callReportObjectGetOwnProperties(ob: ObjectValue): void {\n    if (this.reportObjectGetOwnProperties !== undefined) {\n      this.reportObjectGetOwnProperties(ob);\n    }\n  }\n\n  callReportPropertyAccess(binding: PropertyBinding): void {\n    if (this.reportPropertyAccess !== undefined) {\n      this.reportPropertyAccess(binding);\n    }\n  }\n\n  // Record the current value of binding in this.modifiedProperties unless\n  // there is already an entry for binding.\n  recordModifiedProperty(binding: void | PropertyBinding): void {\n    if (binding === undefined) return;\n    if (this.isInPureScope()) {\n      let object = binding.object;\n      invariant(object instanceof ObjectValue);\n      const createdObjectsTrackedForLeaks = this.createdObjectsTrackedForLeaks;\n\n      if (createdObjectsTrackedForLeaks !== undefined && !createdObjectsTrackedForLeaks.has(object)) {\n        if (binding.object === this.$GlobalObject) {\n          this.reportSideEffectCallback &&\n            this.reportSideEffectCallback(\"MODIFIED_GLOBAL\", binding, object.expressionLocation);\n        } else {\n          this.reportSideEffectCallback &&\n            this.reportSideEffectCallback(\"MODIFIED_PROPERTY\", binding, object.expressionLocation);\n        }\n      }\n    }\n    if (this.isReadOnly && (this.getRunningContext().isReadOnly || !this.isNewObject(binding.object))) {\n      // This only happens during speculative execution and is reported elsewhere\n      throw new FatalError(\"Trying to modify a property in read-only realm\");\n    }\n    this.callReportPropertyAccess(binding);\n    if (this.modifiedProperties !== undefined && !this.modifiedProperties.has(binding)) {\n      this.modifiedProperties.set(binding, cloneDescriptor(binding.descriptor));\n    }\n  }\n\n  isNewObject(object: AbstractObjectValue | ObjectValue): boolean {\n    if (object instanceof AbstractObjectValue) return false;\n    return this.createdObjects === undefined || this.createdObjects.has(object);\n  }\n\n  recordNewObject(object: ObjectValue): void {\n    if (this.createdObjects !== undefined) {\n      this.createdObjects.add(object);\n    }\n    if (this.createdObjectsTrackedForLeaks !== undefined) {\n      this.createdObjectsTrackedForLeaks.add(object);\n    }\n  }\n\n  // Returns the current values of modifiedBindings and modifiedProperties\n  // and then assigns new empty maps to them.\n  getAndResetModifiedMaps(): [void | Bindings, void | PropertyBindings] {\n    let result = [this.modifiedBindings, this.modifiedProperties];\n    this.modifiedBindings = new Map();\n    this.modifiedProperties = new Map();\n    return result;\n  }\n\n  redoBindings(modifiedBindings: void | Bindings): void {\n    if (modifiedBindings === undefined) return;\n    modifiedBindings.forEach(({ hasLeaked, value }, binding, m) => {\n      binding.hasLeaked = hasLeaked || false;\n      binding.value = value;\n    });\n  }\n\n  undoBindings(modifiedBindings: void | Bindings): void {\n    if (modifiedBindings === undefined) return;\n    modifiedBindings.forEach((entry, binding, m) => {\n      if (entry.hasLeaked === undefined) entry.hasLeaked = binding.hasLeaked;\n      if (entry.value === undefined) entry.value = binding.value;\n      binding.hasLeaked = entry.previousHasLeaked || false;\n      binding.value = entry.previousValue;\n    });\n  }\n\n  // Restores each PropertyBinding in the given map to the value it\n  // had when it was entered into the map and updates the map to record\n  // the value the Binding had just before the call to this method.\n  restoreProperties(modifiedProperties: void | PropertyBindings): void {\n    if (modifiedProperties === undefined) return;\n    modifiedProperties.forEach((desc, propertyBinding, m) => {\n      let d = propertyBinding.descriptor;\n      propertyBinding.descriptor = desc;\n      m.set(propertyBinding, d);\n    });\n  }\n\n  // Provide the realm with maps in which to track modifications.\n  // A map can be set to undefined if no tracking is required.\n  setModifiedMaps(modifiedBindings: void | Bindings, modifiedProperties: void | PropertyBindings): void {\n    this.modifiedBindings = modifiedBindings;\n    this.modifiedProperties = modifiedProperties;\n  }\n\n  rebuildObjectProperty(object: Value, key: string, propertyValue: Value, path: string): void {\n    if (!(propertyValue instanceof AbstractValue)) return;\n    if (propertyValue.kind === \"abstractConcreteUnion\") {\n      let absVal = propertyValue.args.find(e => e instanceof AbstractValue);\n      invariant(absVal instanceof AbstractValue);\n      propertyValue = absVal;\n    }\n    if (!propertyValue.isIntrinsic()) {\n      propertyValue.intrinsicName = `${path}.${key}`;\n      propertyValue.kind = \"rebuiltProperty\";\n      propertyValue.args = [object];\n      propertyValue._buildNode = ([node]) =>\n        t.isValidIdentifier(key)\n          ? t.memberExpression(node, t.identifier(key), false)\n          : t.memberExpression(node, t.stringLiteral(key), true);\n      this.rebuildNestedProperties(propertyValue, propertyValue.intrinsicName);\n    }\n  }\n\n  rebuildNestedProperties(abstractValue: AbstractValue | UndefinedValue, path: string): void {\n    if (!(abstractValue instanceof AbstractObjectValue)) return;\n    if (abstractValue.values.isTop()) return;\n    let template = abstractValue.getTemplate();\n    invariant(!template.intrinsicName || template.intrinsicName === path);\n    template.intrinsicName = path;\n    template.intrinsicNameGenerated = true;\n    for (let [key, binding] of template.properties) {\n      if (binding === undefined || binding.descriptor === undefined) continue; // deleted\n      invariant(binding.descriptor !== undefined);\n      let value = binding.descriptor.value;\n      Properties.ThrowIfMightHaveBeenDeleted(value);\n      if (value === undefined) {\n        AbstractValue.reportIntrospectionError(abstractValue, key);\n        throw new FatalError();\n      }\n      invariant(value instanceof Value);\n      this.rebuildObjectProperty(abstractValue, key, value, path);\n    }\n  }\n\n  createExecutionContext(): ExecutionContext {\n    let context = new ExecutionContext();\n    let loc = this.nextContextLocation;\n    if (loc) {\n      context.setLocation(loc);\n      this.nextContextLocation = null;\n    }\n    return context;\n  }\n\n  setNextExecutionContextLocation(loc: ?BabelNodeSourceLocation): ?BabelNodeSourceLocation {\n    let previousValue = this.nextContextLocation;\n    this.nextContextLocation = loc;\n    return previousValue;\n  }\n\n  reportIntrospectionError(message?: void | string | StringValue): void {\n    if (message === undefined) message = \"\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    let error = new CompilerDiagnostic(message.value, this.currentLocation, \"PP0001\", \"FatalError\");\n    this.handleError(error);\n  }\n\n  createErrorThrowCompletion(type: NativeFunctionValue, message?: void | string | StringValue): ThrowCompletion {\n    invariant(type !== this.intrinsics.__IntrospectionError);\n    if (message === undefined) message = \"\";\n    if (typeof message === \"string\") message = new StringValue(this, message);\n    invariant(message instanceof StringValue);\n    this.nextContextLocation = this.currentLocation;\n    return new ThrowCompletion(Construct(this, type, [message]), undefined, this.currentLocation);\n  }\n\n  appendGenerator(generator: Generator, leadingComment: string = \"\"): void {\n    let realmGenerator = this.generator;\n    if (realmGenerator === undefined) {\n      invariant(generator.empty());\n      return;\n    }\n    realmGenerator.appendGenerator(generator, leadingComment);\n  }\n\n  // This function gets the evaluated effects with a collection of\n  // prior nested affects applied (and their canBeApplied flag reset)\n  // We can safely do this as we've wrapped the effects in evaluated\n  // effects, meaning all the effects applied to Realm get restored\n  evaluateForEffectsWithPriorEffects(\n    priorEffects: Array<Effects>,\n    f: () => AbruptCompletion | Value,\n    generatorName: string\n  ): Effects {\n    return this.evaluateForEffects(\n      () => {\n        for (let priorEffect of priorEffects) this.applyEffects(priorEffect);\n        try {\n          return f();\n        } finally {\n          for (let priorEffect of priorEffects) {\n            invariant(!priorEffect.canBeApplied);\n            priorEffect.canBeApplied = true;\n          }\n        }\n      },\n      undefined,\n      generatorName\n    );\n  }\n\n  // Pass the error to the realm's error-handler\n  // Return value indicates whether the caller should try to recover from the error or not.\n  handleError(diagnostic: CompilerDiagnostic): ErrorHandlerResult {\n    if (!diagnostic.callStack && this.contextStack.length > 0) {\n      let error = Construct(this, this.intrinsics.Error);\n      let stack = error._SafeGetDataPropertyValue(\"stack\");\n      if (stack instanceof StringValue) diagnostic.callStack = stack.value;\n    }\n\n    // If debugger is attached, give it a first crack so that it can\n    // stop execution for debugging before PP exits.\n    if (this.debuggerInstance && this.debuggerInstance.shouldStopForSeverity(diagnostic.severity)) {\n      this.debuggerInstance.handlePrepackError(diagnostic);\n    }\n\n    // Default behaviour is to bail on the first error\n    let errorHandler = this.errorHandler;\n    if (!errorHandler) {\n      let msg = `${diagnostic.errorCode}: ${diagnostic.message}`;\n      if (diagnostic.location) {\n        let loc_start = diagnostic.location.start;\n        let loc_end = diagnostic.location.end;\n        msg += ` at ${loc_start.line}:${loc_start.column} to ${loc_end.line}:${loc_end.column}`;\n      }\n      try {\n        switch (diagnostic.severity) {\n          case \"Information\":\n            console.log(`Info: ${msg}`);\n            return \"Recover\";\n          case \"Warning\":\n            console.warn(`Warn: ${msg}`);\n            return \"Recover\";\n          case \"RecoverableError\":\n            console.error(`Error: ${msg}`);\n            return \"Fail\";\n          case \"FatalError\":\n            console.error(`Fatal Error: ${msg}`);\n            return \"Fail\";\n          default:\n            invariant(false, \"Unexpected error type\");\n        }\n      } finally {\n        console.log(diagnostic.callStack);\n      }\n    }\n    return errorHandler(diagnostic, this.suppressDiagnostics);\n  }\n\n  saveNameString(nameString: string): void {\n    this._abstractValuesDefined.add(nameString);\n  }\n\n  isNameStringUnique(nameString: string): boolean {\n    return !this._abstractValuesDefined.has(nameString);\n  }\n\n  getTemporalBuildNodeEntryFromDerivedValue(value: Value): void | TemporalBuildNodeEntry {\n    let name = value.intrinsicName;\n    if (!name) {\n      return undefined;\n    }\n    let temporalBuildNodeEntry = value.$Realm.derivedIds.get(name);\n    return temporalBuildNodeEntry;\n  }\n\n  getTemporalGeneratorEntriesReferencingArg(arg: AbstractValue | ObjectValue): void | Set<TemporalBuildNodeEntry> {\n    return this.temporalEntryArgToEntries.get(arg);\n  }\n\n  saveTemporalGeneratorEntryArgs(temporalBuildNodeEntry: TemporalBuildNodeEntry): void {\n    let args = temporalBuildNodeEntry.args;\n    for (let arg of args) {\n      let temporalEntries = this.temporalEntryArgToEntries.get(arg);\n\n      if (temporalEntries === undefined) {\n        temporalEntries = new Set();\n        this.temporalEntryArgToEntries.set(arg, temporalEntries);\n      }\n      temporalEntries.add(temporalBuildNodeEntry);\n    }\n  }\n}\n"]}