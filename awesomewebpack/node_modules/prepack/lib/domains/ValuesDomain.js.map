{"version":3,"sources":["../../src/domains/ValuesDomain.js"],"names":["ValuesDomain","constructor","_values","values","valueSet","Set","add","_elements","contains","x","elems","xelems","undefined","size","e","has","containsValue","isTop","getElements","binaryOp","realm","op","left","right","leftElements","rightElements","topVal","resultSet","savedHandler","errorHandler","savedIsReadOnly","isReadOnly","leftElem","rightElem","result","computeBinary","subResult","lval","rval","lprim","ToPrimitiveOrAbstract","rprim","createFromBinaryOp","lstr","ToString","rstr","lnum","ToNumber","rnum","r","intrinsics","false","value","true","ToUint32","createFromNumberValue","ToInt32","base","ToNumberOrAbstract","exponent","baseVal","exponentVal","Math","pow","lnumVal","rnumVal","isNaN","NaN","ToPropertyKey","logicalOp","computeLogical","lbool","ToBoolean","computeUnary","oldValue","val","typeString","typeToString","getType","unaryOp","operandValues","operandElements","operandElem","includesValueNotOfType","type","cval","includesValueOfType","mightBeFalse","mightNotBeFalse","joinValues","v1","v2","joinWith","union","y","forEach","v","meetValues","meetWith","intersection","elements","promoteEmptyToUndefined","newSet","$Realm"],"mappings":"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","file":"ValuesDomain.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { BabelBinaryOperator, BabelNodeLogicalOperator, BabelUnaryOperator } from \"babel-types\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  AbstractEqualityComparison,\n  AbstractRelationalComparison,\n  Add,\n  HasProperty,\n  InstanceofOperator,\n  StrictEqualityComparison,\n} from \"../methods/index.js\";\nimport type { Realm } from \"../realm.js\";\nimport { To } from \"../singletons.js\";\nimport {\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Utils } from \"../singletons.js\";\n\n/* An abstract domain that collects together a set of concrete values\n   that might be the value of a variable at runtime.\n   Initially, every variable has the value undefined.\n   A property that has been weakly deleted will have more than\n   one value, one of which will by the EmptyValue.  */\n\nexport default class ValuesDomain {\n  constructor(_values: void | Set<ConcreteValue> | ConcreteValue) {\n    let values = _values;\n    if (values instanceof ConcreteValue) {\n      let valueSet = new Set();\n      valueSet.add(values);\n      values = valueSet;\n    }\n    this._elements = values;\n  }\n\n  static topVal = new ValuesDomain(undefined);\n\n  _elements: void | Set<ConcreteValue>;\n\n  contains(x: ValuesDomain): boolean {\n    let elems = this._elements;\n    let xelems = x._elements;\n    if (elems === xelems) return true;\n    if (elems === undefined) return true;\n    if (xelems === undefined) return false;\n    if (elems.size < xelems.size) return false;\n    for (let e of xelems) {\n      if (!elems.has(e)) return false;\n    }\n    return true;\n  }\n\n  containsValue(x: Value): boolean {\n    let elems = this._elements;\n    if (elems === undefined) return true; // Top contains everything\n    if (x instanceof AbstractValue) return this.contains(x.values);\n    invariant(x instanceof ConcreteValue);\n    return elems.has(x);\n  }\n\n  isTop(): boolean {\n    return this._elements === undefined;\n  }\n\n  getElements(): Set<ConcreteValue> {\n    invariant(this._elements !== undefined);\n    return this._elements;\n  }\n\n  // return a set of values that may be result of performing the given operation on each pair in the\n  // Cartesian product of the value sets of the operands.\n  static binaryOp(realm: Realm, op: BabelBinaryOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet: Set<ConcreteValue> = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeBinary(realm, op, leftElem, rightElem);\n          if (result instanceof ConcreteValue) {\n            resultSet.add(result);\n          } else {\n            invariant(result instanceof AbstractValue);\n            if (result.values.isTop()) {\n              return ValuesDomain.topVal;\n            }\n            for (let subResult of result.values.getElements()) {\n              resultSet.add(subResult);\n            }\n          }\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeBinary(realm: Realm, op: BabelBinaryOperator, lval: ConcreteValue, rval: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.8.3 The Addition Operator\n      let lprim = To.ToPrimitiveOrAbstract(realm, lval);\n      let rprim = To.ToPrimitiveOrAbstract(realm, rval);\n\n      if (lprim instanceof AbstractValue || rprim instanceof AbstractValue) {\n        return AbstractValue.createFromBinaryOp(realm, op, lprim, rprim);\n      }\n\n      if (lprim instanceof StringValue || rprim instanceof StringValue) {\n        let lstr = To.ToString(realm, lprim);\n        let rstr = To.ToString(realm, rprim);\n        return new StringValue(realm, lstr + rstr);\n      }\n\n      let lnum = To.ToNumber(realm, lprim);\n      let rnum = To.ToNumber(realm, rprim);\n      return Add(realm, lnum, rnum);\n    } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n      // ECMA262 12.10.3\n      if (op === \"<\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true, op);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \"<=\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false, op);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else if (r instanceof AbstractValue) {\n          return r;\n        } else {\n          return realm.intrinsics.true;\n        }\n      } else if (op === \">\") {\n        let r = AbstractRelationalComparison(realm, rval, lval, false, op);\n        if (r instanceof UndefinedValue) {\n          return realm.intrinsics.false;\n        } else {\n          return r;\n        }\n      } else if (op === \">=\") {\n        let r = AbstractRelationalComparison(realm, lval, rval, true, op);\n        if (r instanceof UndefinedValue || (r instanceof BooleanValue && r.value)) {\n          return realm.intrinsics.false;\n        } else if (r instanceof AbstractValue) {\n          return r;\n        } else {\n          return realm.intrinsics.true;\n        }\n      }\n    } else if (op === \">>>\") {\n      // ECMA262 12.9.5.1\n      let lnum = To.ToUint32(realm, lval);\n      let rnum = To.ToUint32(realm, rval);\n\n      return IntegralValue.createFromNumberValue(realm, lnum >>> rnum);\n    } else if (op === \"<<\" || op === \">>\") {\n      let lnum = To.ToInt32(realm, lval);\n      let rnum = To.ToUint32(realm, rval);\n\n      if (op === \"<<\") {\n        // ECMA262 12.9.3.1\n        return IntegralValue.createFromNumberValue(realm, lnum << rnum);\n      } else if (op === \">>\") {\n        // ECMA262 12.9.4.1\n        return IntegralValue.createFromNumberValue(realm, lnum >> rnum);\n      }\n    } else if (op === \"**\") {\n      // ECMA262 12.6.3\n\n      // 5. Let base be ? ToNumber(leftValue).\n      let base = To.ToNumberOrAbstract(realm, lval);\n\n      // 6. Let exponent be ? ToNumber(rightValue).\n      let exponent = To.ToNumberOrAbstract(realm, rval);\n\n      if (base instanceof AbstractValue || exponent instanceof AbstractValue) {\n        const baseVal = base instanceof AbstractValue ? base : new NumberValue(realm, base);\n        const exponentVal = exponent instanceof AbstractValue ? exponent : new NumberValue(realm, exponent);\n        return AbstractValue.createFromBinaryOp(realm, op, baseVal, exponentVal);\n      }\n\n      // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.7.3.4.\n      return new NumberValue(realm, Math.pow(base, exponent));\n    } else if (op === \"%\" || op === \"/\" || op === \"*\" || op === \"-\") {\n      // ECMA262 12.7.3\n      let lnum = To.ToNumberOrAbstract(realm, lval);\n      let rnum = To.ToNumberOrAbstract(realm, rval);\n      if (lnum instanceof AbstractValue || rnum instanceof AbstractValue) {\n        const lnumVal = lnum instanceof AbstractValue ? lnum : new NumberValue(realm, lnum);\n        const rnumVal = rnum instanceof AbstractValue ? rnum : new NumberValue(realm, rnum);\n        return AbstractValue.createFromBinaryOp(realm, op, lnumVal, rnumVal);\n      }\n\n      if (isNaN(rnum)) return realm.intrinsics.NaN;\n      if (isNaN(lnum)) return realm.intrinsics.NaN;\n\n      if (op === \"-\") {\n        return Add(realm, lnum, rnum, true);\n      } else if (op === \"%\") {\n        // The sign of the result equals the sign of the dividend.\n        // If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\n        // If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n        // If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n        return new NumberValue(realm, lnum % rnum);\n      } else if (op === \"/\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Division of an infinity by an infinity results in NaN.\n        // Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n        // Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n        // Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n        // Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n        // Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum / rnum);\n      } else if (op === \"*\") {\n        // The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n        // Multiplication of an infinity by a zero results in NaN.\n        // Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n        // Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n        return new NumberValue(realm, lnum * rnum);\n      }\n    } else if (op === \"!==\") {\n      return new BooleanValue(realm, !StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"===\") {\n      return new BooleanValue(realm, StrictEqualityComparison(realm, lval, rval));\n    } else if (op === \"!=\" || op === \"==\") {\n      return AbstractEqualityComparison(realm, lval, rval, op);\n    } else if (op === \"&\" || op === \"|\" || op === \"^\") {\n      // ECMA262 12.12.3\n\n      // 5. Let lnum be ? ToInt32(lval).\n      let lnum: number = To.ToInt32(realm, lval);\n\n      // 6. Let rnum be ? ToInt32(rval).\n      let rnum: number = To.ToInt32(realm, rval);\n\n      // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32 bit integer.\n      if (op === \"&\") {\n        return IntegralValue.createFromNumberValue(realm, lnum & rnum);\n      } else if (op === \"|\") {\n        return IntegralValue.createFromNumberValue(realm, lnum | rnum);\n      } else if (op === \"^\") {\n        return IntegralValue.createFromNumberValue(realm, lnum ^ rnum);\n      }\n    } else if (op === \"in\") {\n      // ECMA262 12.10.3\n\n      // 5. If Type(rval) is not Object, throw a TypeError exception.\n      if (!(rval instanceof ObjectValue)) {\n        throw new FatalError();\n      }\n\n      // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n      return new BooleanValue(realm, HasProperty(realm, rval, To.ToPropertyKey(realm, lval)));\n    } else if (op === \"instanceof\") {\n      // ECMA262 12.10.3\n\n      // 5. Return ? InstanceofOperator(lval, rval).;\n      return new BooleanValue(realm, InstanceofOperator(realm, lval, rval));\n    }\n\n    invariant(false, \"unimplemented \" + op);\n  }\n\n  static logicalOp(realm: Realm, op: BabelNodeLogicalOperator, left: ValuesDomain, right: ValuesDomain): ValuesDomain {\n    let leftElements = left._elements;\n    let rightElements = right._elements;\n    // Return top if left and/or right are top or if the size of the value set would get to be quite large.\n    // Note: the larger the set of values, the less we know and therefore the less we get value from computing\n    // all of these values. TODO #1000: probably the upper bound can be quite a bit smaller.\n    if (!leftElements || !rightElements || leftElements.size > 100 || rightElements.size > 100)\n      return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let leftElem of leftElements) {\n        for (let rightElem of rightElements) {\n          let result = ValuesDomain.computeLogical(realm, op, leftElem, rightElem);\n          resultSet.add(result);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeLogical(\n    realm: Realm,\n    op: BabelNodeLogicalOperator,\n    lval: ConcreteValue,\n    rval: ConcreteValue\n  ): ConcreteValue {\n    let lbool = To.ToBoolean(realm, lval);\n\n    if (op === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else if (op === \"||\") {\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n    return rval;\n  }\n\n  // Note that calling this can result in user code running, which can side-effect the heap.\n  // If that is not the desired behavior, mark the realm as read-only for the duration of the call.\n  static computeUnary(realm: Realm, op: BabelUnaryOperator, value: ConcreteValue): Value {\n    if (op === \"+\") {\n      // ECMA262 12.5.6.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Return ? ToNumber(? GetValue(expr)).\n      return IntegralValue.createFromNumberValue(realm, To.ToNumber(realm, value));\n    } else if (op === \"-\") {\n      // ECMA262 12.5.7.1\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n      let oldValue = To.ToNumber(realm, value);\n\n      // 3. If oldValue is NaN, return NaN.\n      if (isNaN(oldValue)) {\n        return realm.intrinsics.NaN;\n      }\n\n      // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n      return IntegralValue.createFromNumberValue(realm, -oldValue);\n    } else if (op === \"~\") {\n      // ECMA262 12.5.8\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n      let oldValue = To.ToInt32(realm, value);\n\n      // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n      return IntegralValue.createFromNumberValue(realm, ~oldValue);\n    } else if (op === \"!\") {\n      // ECMA262 12.6.9\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n      let oldValue = To.ToBoolean(realm, value);\n\n      // 3. If oldValue is true, return false.\n      if (oldValue === true) return realm.intrinsics.false;\n\n      // 4. Return true.\n      return realm.intrinsics.true;\n    } else if (op === \"void\") {\n      // 1. Let expr be the result of evaluating UnaryExpression.\n      // 2. Perform ? GetValue(expr).\n      // 3. Return undefined.\n      return realm.intrinsics.undefined;\n    } else if (op === \"typeof\") {\n      // ECMA262 12.6.5\n      // 1. Let val be the result of evaluating UnaryExpression.\n      // 2. If Type(val) is Reference, then\n      // 3. Let val be ? GetValue(val).\n      let val = value;\n      // 4. Return a String according to Table 35.\n      let typeString = Utils.typeToString(val.getType());\n      invariant(typeString !== undefined);\n      return new StringValue(realm, typeString);\n    } else {\n      invariant(false, `${op} is a state update, not a pure operation, so we don't support it`);\n    }\n  }\n\n  static unaryOp(realm: Realm, op: BabelUnaryOperator, operandValues: ValuesDomain): ValuesDomain {\n    let operandElements = operandValues._elements;\n    if (operandElements === undefined) return ValuesDomain.topVal;\n    let resultSet = new Set();\n    let savedHandler = realm.errorHandler;\n    let savedIsReadOnly = realm.isReadOnly;\n    realm.isReadOnly = true;\n    try {\n      realm.errorHandler = () => {\n        throw new FatalError();\n      };\n      for (let operandElem of operandElements) {\n        let result = ValuesDomain.computeUnary(realm, op, operandElem);\n        if (result instanceof ConcreteValue) {\n          resultSet.add(result);\n        } else {\n          invariant(result instanceof AbstractValue);\n          if (result.values.isTop()) {\n            return ValuesDomain.topVal;\n          }\n          for (let subResult of result.values.getElements()) {\n            resultSet.add(subResult);\n          }\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) return ValuesDomain.topVal;\n    } finally {\n      realm.errorHandler = savedHandler;\n      realm.isReadOnly = savedIsReadOnly;\n    }\n    return new ValuesDomain(resultSet);\n  }\n\n  includesValueNotOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (!(cval instanceof type)) return true;\n    }\n    return false;\n  }\n\n  includesValueOfType(type: typeof Value): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval instanceof type) return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightBeFalse()) return true;\n    }\n    return false;\n  }\n\n  mightNotBeFalse(): boolean {\n    invariant(!this.isTop());\n    for (let cval of this.getElements()) {\n      if (cval.mightNotBeFalse()) return true;\n    }\n    return false;\n  }\n\n  static joinValues(\n    realm: Realm,\n    v1: Value = realm.intrinsics.undefined,\n    v2: Value = realm.intrinsics.undefined\n  ): ValuesDomain {\n    if (v1 instanceof AbstractValue) return v1.values.joinWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.joinWith(v1);\n    let union = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    union.add(v1);\n    invariant(v2 instanceof ConcreteValue);\n    union.add(v2);\n    return new ValuesDomain(union);\n  }\n\n  joinWith(y: Value): ValuesDomain {\n    if (this.isTop()) return this;\n    let union = new Set(this.getElements());\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return y.values;\n      y.values.getElements().forEach(v => union.add(v));\n    } else {\n      invariant(y instanceof ConcreteValue);\n      union.add(y);\n    }\n    return new ValuesDomain(union);\n  }\n\n  static meetValues(\n    realm: Realm,\n    v1: Value = realm.intrinsics.undefined,\n    v2: Value = realm.intrinsics.undefined\n  ): ValuesDomain {\n    if (v1 instanceof AbstractValue) return v1.values.meetWith(v2);\n    if (v2 instanceof AbstractValue) return v2.values.meetWith(v1);\n    let intersection = new Set();\n    invariant(v1 instanceof ConcreteValue);\n    invariant(v2 instanceof ConcreteValue);\n    if (v1 === v2) intersection.add(v1);\n    return new ValuesDomain(intersection);\n  }\n\n  meetWith(y: Value): ValuesDomain {\n    let intersection = new Set();\n    let elements = this._elements;\n    if (y instanceof AbstractValue) {\n      if (y.values.isTop()) return this;\n      y.values.getElements().forEach(v => {\n        if (elements === undefined || elements.has(v)) intersection.add(v);\n      });\n    } else {\n      invariant(y instanceof ConcreteValue);\n      if (elements === undefined || elements.has(y)) intersection.add(y);\n    }\n    return new ValuesDomain(intersection);\n  }\n\n  promoteEmptyToUndefined(): ValuesDomain {\n    if (this.isTop()) return this;\n    let newSet = new Set();\n    for (let cval of this.getElements()) {\n      if (cval instanceof EmptyValue) newSet.add(cval.$Realm.intrinsics.undefined);\n      else newSet.add(cval);\n    }\n    return new ValuesDomain(newSet);\n  }\n}\n"]}