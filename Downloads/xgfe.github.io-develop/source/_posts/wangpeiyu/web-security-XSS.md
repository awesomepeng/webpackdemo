title: Web 前端安全科普之 XSS
date: 2018-06-13 11:00:00
categories: wangpeiyu
tags:
- Web 安全
- 前端安全
- XSS
---
Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。

XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。

CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。

界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。

在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。


<!--more-->

## XSS 原理

跨站脚本的重点在脚本上，绝大多数的 XSS 会采用一段远程或者第三方域上的脚本资源，这样做的好处是攻击代码容易控制。script 标签可以嵌入第三方资源，这是浏览器允许的，对于嵌入的脚本内容，会与本域的脚本内容一样，在整个脚本上下文环境中存在，那么在这个场景中的各种功能都可以由嵌入的脚本实现，也就是说 JavaScript 能做到什么效果，XSS 的威力就有多大。

JavaScript 可以用用来获取的 Cookie、改变网页内容、URL 跳转，那么存在 XSS 漏洞的网站，就可以盗取用户 Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向 Web 页面中注入 JavaScript 代码。

XSS 攻击原理主要包括三个部分：

- 攻击者对某含有漏洞的服务器发起 XSS 攻击（注入 JS 代码）。

- 诱使受害者打开受到攻击的服务器 URL（邮件、留言等，此步骤可选项）。

- 受害者在 Web 浏览器中打开 URL，恶意脚本执行。

XSS 构造的例子：

    ```
           // 目标网站在服务端将用户输入内容直接拼接到返回 HTML 里
           res.body = '...<div>' + data.用户输入的内容 + '</div>...'

           // 攻击者在页面中提交了这样的内容：
           <script>alert(123)</script>
    ```

    ```
           // 目标网站在服务端将用户输入的内容直接拼接到了页面元素的属性中
           res.body = '...<img src=" + data.用户输入的图片地址 + ">...'

           // 攻击者在页面中提交了这样的内容：
           " /><script>alert(123)</script>
    ```

    ```
           // 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面中
           div.innerHTML = data.用户输入的内容

           // 不同于直接拼接，innerHTML 中的 script 标签不会被执行，但是攻击者可以这么写：
           <img src="x.png" onload="alert(123)">
    ```

    ```
           // 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面元素的属性中
           a.href = data.用户输入的链接

           // 不同于直接拼接，给元素的属性赋值时内容总会被当成字符串，但是攻击者可以这么写，如用户点了链接就会受到攻击：
           javascript:alert(123)
    ```

## XSS 类型

XSS 有三种类型，分别是反射型 XSS、存储型 XSS、DOM XSS，下面分别对这三种 XSS 进行介绍。

### 反射型 XSS

反射型 XSS 也被称为非持久性 XSS，是最容易出现的一种 XSS 漏洞，指的是发送请求时，XSS 代码出现在 URL 中，作为输入提交到服务端，服务端解析后响应，在响应内容中出现这段 XSS 代码，最后被浏览器解析执行。这个过程就像是一次反射，故称为反射型 XSS。它的数据流向是：浏览器 -> 后端 -> 浏览器。

```
    // 服务端代码
    <?php
        echo $_GET['x'];
    ?>

    // 在浏览器地址栏中输入
    http://xssdemo.wpy.com/domxss.html#alert(1)
```

![反射型XSS](http://vfile.meituan.net/xgfe/a7271f75b155dbab2e0c3fb758cbe111100565.png)

### 存储型 XSS

存储型 XSS 又被称为永久性 XSS，是最危险的一种跨站脚本，指的是发送请求时，提交的 XSS 代码会存储在服务端（不管是数据库、内存还是文件系统），下次请求目标页面时不用再提交 XSS 代码，存储型 XSS 的攻击是最隐蔽的，其危害性也更大。与反射型 XSS 和 DOM XSS 相比，存储型 XSS 的执行不需要手动触发。最典型的例子是留言板 XSS，用户提交一条包含 XSS 代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容就会从数据库查询出来并显示，浏览器发现有 XSS 代码，就当做正常的 HTML 与 JS 解析执行，于是就触发了 XSS 攻击。它的数据流向是：浏览器 -> 后端 -> 数据库 -> 后端 -> 浏览器。

### DOM XSS

DOM XSS 指的是 XSS 代码并不需要服务器解析响应的直接参与，触发 XSS 靠的就是浏览器端的 DOM 解析，可以认为完全是客户端的事情。它的数据流向是：URL->浏览器。

```
        // 客户端的脚本
        <script>eval(location.hash.substr(1));</script>

        // 用户点击这个 URL# 后的内容不会发送到服务端，仅在客户端被接收并解释执行。
        http://xssdemo.wpy.com/domxss.html#alert(1)
```

![DOM XSS](http://vfile.meituan.net/xgfe/919bcf853c27bbd16656cfa83b8b6ef887889.png)

#### DOM XSS 场景一：在前端实现页面跳转

在前端实现页面跳转，前端通常会通过 JavaScript 实现跳转，最常用到的方法有: location.href / location.replace() / location.assign()。 在该场景下，可以通过伪协议“javascript:”、“data:”在浏览器下执行脚本。但是这种通过伪协议进行攻击已经随着前端工程处理对相关跳转代码逻辑做了很好的完善，基本上不会再出现上述的这种情况。但是如下两种情况却为 Web 攻击打开了天窗：

- 使用 indexOf 判断 URL 参数是否合法，indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。所以如果 URL 中包含了伪代码及攻击代码，就会被攻击。

- 正则表达式判断 URL 是否合法，为了避免使用 indexOf 判断 URL 带来的缺陷，有些开发人员会想到用正则表达式，但忘了一个神奇的符号“^”，加上和不加上，过滤的效果具有天壤之别，如果没有加“^”，攻击者仍然可以绕过正则的过滤，在URL中植入伪代码和攻击代码。

- 修复方案：在前端实现页面跳转业务场景下，正确的过滤实现方法是，严格限制跳转范围。一方面要限制能够跳转页面的协议：只能是 http、https 或是其他指可控协议；另一方面，要严格限制跳转的范围，如果业务只要跳转到指定的几个页面，可以直接从数组中取值判断是否这几个页面，如果跳转范围稍大，正确使用正则表达式将跳转URL严格限制到可控范围内。 

#### DOM XSS 场景二：取值写入页面或动态执行 

除接收 URL 参数经后端处理最后在前端展示外，在 Web 前端通过 JavaScript 获取不同来源的参数值，不经后端处理即刻在 Web 页面进行展示或动态执行的业务场景也十分常见，想要在客户端实现接受参数并写入页面或动态执行，就不得不用到 innerHTML、document.write、eval。因为 JavaScript 取值的来源纷繁复杂，如果忘记做转义处理，或过分相信取值来源的数据，直接将分离出的参数值交给 JavaScriptinnerHTML、document.write、eval处理，就有可能招来 DOM-XSS。下面是三种常见的缺陷： 

- 从 URL 中的取参数值写入页面或动态执行，如直接从 URL 的锚参数（即位于#后面的参数）中取值，不经过任何处理直接 innerHTML 写入页面，导致攻击者只需要构造如下URL即可完成一次 DOM XSS 攻击。由于整个攻击过程在客户端侧完成，不需要向服务器发送任何请求数据，所以即便业务接入了对抗反射型 XSS 的 Web 应用防火墙（WAF），这类 DOM XSS 也无法被感知，攻击者便可畅通无阻的利用漏洞对用户开展攻击。 

- 从 Cookie 中的取参数值写入页面或动态执行，原理基本同从 URL 中的取参数值写入页面或动态执行，只是换了一个取值来源而已。

- 从 LocalStorage、Referer、Window name、SessionStorage中的取参数值写入页面或动态执行 ，如取 window.name 的值，最后直接 innerHTML 到页面中。一般情况下，页面的 window.name 攻击者不可控，故往往会被认为来源相对可信。但借助i frame 的 name 属性，攻击者可以将页面的 window.name 设置为攻击代码，仍然可以构造 DOM XSS。

- 修复方案：

    - 写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的 HTML 特殊字符进行转义处理能防止大部分 DOM-XSS 的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。 

    - 慎用危险的“eval”。需要强调的是，由于 JavaScript 中的 eval 函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用 eval
    函数处理不可控的外部数据。 

    - 编写安全的函数方法，从看似“可靠”的数据源获取参数值。无论是从 Cookie，还是从LocalStorage、Referer、Window name、SessionStorage 中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。 

## XSS 危害

- 盗取用户的 Cookie，Cookie 经常被用来存储用户的会话信息，比如用户登录认证后的 session，之后同域内发出的请求都会自动带上认证后的会话信息。如果 Cookie被盗取，攻击者就可以不用通过密码而直接登录用户的账户。Cookie 的重要字段：[name] [value] [domain] [path] [expires] [httponly] [secure]，其含义依次是：名称、值、所属域名、所属相对根路径、过期时间、是否有 HttpOnly 标志、是否有 Secure 标志。如果设置了 HttpOnly 标志，客户端脚本就无法通过document.cookie 获取该 Cookie，这样就能有效地防御 XSS 攻击获取 Cookie。

- 构建 GET 和 POST 请求，如果 Cookie 设置了 HttpOnly 标志，则无法直接劫持 Cookie 来使用了，但是 XSS 可以在 JavaScript 中构建 GET 或者 POST 请求，来实现自己的攻击。只要让用户执行下面这段脚本，就能发起 GET 请求，攻击者通过 XSS 诱导用户来执行。XSS 的攻击过程都是在浏览器通过执行 JavaScript 脚本自动进行，缺少与用户交互的过程。例如在 POST 的请求中，如果需要输入验证码，JS 代码无法解析验证码，攻击也就无法实现。但是针对验证码这种情况，如果 XSS 可以通过把验证码的图片发到远端攻击服务器，服务器解析验证码然后把结果返回给 JS 代码，JS 获取后继续进行攻击，不过就是成本有点高。

- XSS 钓鱼：上面模拟用户的 POST 请求貌似成本有点高，攻击者可以将 XSS 和钓鱼结合在一起，例如通过 JavaScript 代码模拟出网站的登录框，用户输入用户名和密码后，XSS 将这些信息发送到服务器端，用来进行攻击。

- 获取用户系统信息，此外 XSS 还可以识别用户的浏览器信息、用户安装的软件以及用户真实的 IP 等信息。

- XSS Worm：这是 XSS 的一种终极利用方式，破坏力和影响力是巨大的，与蠕虫病毒一样具有“传染性”，与系统病毒的唯一区别就是无法对系统底层操作。XSS 蠕虫是针对浏览器的攻击，网站规模越大，攻击效果就越大。一般来说，用户直接发生交互行为的页面，如果存在存储型 XSS，则比较容易发起 Worm 攻击。

## XSS 防御

- 任何由用户输出的数据都是不可信的。

- 不要在奇怪的地方插入不可信的数据。

  ![不可信数据](http://vfile.meituan.net/xgfe/0a853e1b33a7dfaeb4aa47f12453026b97763.png)

- 进行输入输出检查，将期望被当成字符串的不可信数据转义后再插入文档中，不同位置需要使用不同的转义逻辑。

  ![输入输出检查](http://vfile.meituan.net/xgfe/3df441ed85fa308c54a059924acd16e0248873.png)

- 将期望被当成 HTML 的不可信数据使用专业的库消毒后再插入文档中。

- 使用 HttpOnly 的 Cookie，给关键的 Cookie 设置 HttpOnly 属性，这样能够避免 JS 读取 Cookie信息，设置后有助于缓解 XSS，但是 XSS 除了劫持 Cookie 之外，还可以模拟用户的身份进行操作。

- 使用内容安全策略（CSP）是对抗 XSS 的深度防御策略，内容安全策略可以以白名单的方式限定哪些地方的内容可以被加载和执行，如果不存在可以通过本地文件放置恶意代码的其他漏洞，则该策略是有效的。

- 使用设计上就会自动编码来解决XSS问题的框架，如：React JS。了解每个框架的 XSS 保护的局限性，并适当地处理未覆盖的用例。

## 参考资料

- [XSS攻击手册](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)

- [XSS防御手册](https://www.owasp.org/index.php/XSS_Prevention_Cheat_Sheet)

- 《Web前端黑客技术揭秘》

- 《Web安全深度剖析》

- 《白帽子讲Web安全》

